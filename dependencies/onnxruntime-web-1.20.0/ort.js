/*!
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";
var ort = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // common/dist/esm/backend-impl.js
  var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
  var init_backend_impl = __esm({
    "common/dist/esm/backend-impl.js"() {
      "use strict";
      backends = /* @__PURE__ */ new Map();
      backendsSortedByPriority = [];
      registerBackend = (name2, backend2, priority) => {
        if (backend2 && typeof backend2.init === "function" && typeof backend2.createInferenceSessionHandler === "function") {
          const currentBackend = backends.get(name2);
          if (currentBackend === void 0) {
            backends.set(name2, { backend: backend2, priority });
          } else if (currentBackend.priority > priority) {
            return;
          } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend2) {
              throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
            }
          }
          if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name2);
            if (i !== -1) {
              backendsSortedByPriority.splice(i, 1);
            }
            for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
              if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
                backendsSortedByPriority.splice(i2, 0, name2);
                return;
              }
            }
            backendsSortedByPriority.push(name2);
          }
          return;
        }
        throw new TypeError("not a valid backend");
      };
      tryResolveAndInitializeBackend = async (backendName) => {
        const backendInfo = backends.get(backendName);
        if (!backendInfo) {
          return "backend not found.";
        }
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          return backendInfo.error;
        } else {
          const isInitializing = !!backendInfo.initPromise;
          try {
            if (!isInitializing) {
              backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
          } catch (e) {
            if (!isInitializing) {
              backendInfo.error = `${e}`;
              backendInfo.aborted = true;
            }
            return backendInfo.error;
          } finally {
            delete backendInfo.initPromise;
          }
        }
      };
      resolveBackendAndExecutionProviders = async (options) => {
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
        let backend2;
        const errors = [];
        const availableBackendNames = /* @__PURE__ */ new Set();
        for (const backendName of backendNames) {
          const resolveResult = await tryResolveAndInitializeBackend(backendName);
          if (typeof resolveResult === "string") {
            errors.push({ name: backendName, err: resolveResult });
          } else {
            if (!backend2) {
              backend2 = resolveResult;
            }
            if (backend2 === resolveResult) {
              availableBackendNames.add(backendName);
            }
          }
        }
        if (!backend2) {
          throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
        }
        for (const { name: name2, err } of errors) {
          if (backendHints.includes(name2)) {
            console.warn(`removing requested execution provider "${name2}" from session options because it is not available: ${err}`);
          }
        }
        const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
        return [
          backend2,
          new Proxy(options, {
            get: (target, prop) => {
              if (prop === "executionProviders") {
                return filteredEps;
              }
              return Reflect.get(target, prop);
            }
          })
        ];
      };
    }
  });

  // common/dist/esm/backend.js
  var init_backend = __esm({
    "common/dist/esm/backend.js"() {
      "use strict";
      init_backend_impl();
    }
  });

  // common/dist/esm/version.js
  var version;
  var init_version = __esm({
    "common/dist/esm/version.js"() {
      "use strict";
      version = "1.20.0";
    }
  });

  // common/dist/esm/env-impl.js
  var logLevelValue, env;
  var init_env_impl = __esm({
    "common/dist/esm/env-impl.js"() {
      "use strict";
      init_version();
      logLevelValue = "warning";
      env = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: version },
        set logLevel(value) {
          if (value === void 0) {
            return;
          }
          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
          }
          logLevelValue = value;
        },
        get logLevel() {
          return logLevelValue;
        }
      };
      Object.defineProperty(env, "logLevel", { enumerable: true });
    }
  });

  // common/dist/esm/env.js
  var env2;
  var init_env = __esm({
    "common/dist/esm/env.js"() {
      "use strict";
      init_env_impl();
      env2 = env;
    }
  });

  // common/dist/esm/tensor-conversion-impl.js
  var tensorToDataURL, tensorToImageData;
  var init_tensor_conversion_impl = __esm({
    "common/dist/esm/tensor-conversion-impl.js"() {
      "use strict";
      tensorToDataURL = (tensor, options) => {
        const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
        canvas.width = tensor.dims[3];
        canvas.height = tensor.dims[2];
        const pixels2DContext = canvas.getContext("2d");
        if (pixels2DContext != null) {
          let width;
          let height;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
          }
          const inputformat = options?.format !== void 0 ? options.format : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
              const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
              const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
              const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
              pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
              pixels2DContext.fillRect(j, i, 1, 1);
            }
          }
          if ("toDataURL" in canvas) {
            return canvas.toDataURL();
          } else {
            throw new Error("toDataURL is not supported");
          }
        } else {
          throw new Error("Can not access image data");
        }
      };
      tensorToImageData = (tensor, options) => {
        const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
        let image;
        if (pixels2DContext != null) {
          let width;
          let height;
          let channels;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
          }
          const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          if (options !== void 0) {
            if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
              throw new Error("Tensor format doesn't match input tensor dims");
            }
          }
          const step = 4;
          let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          image = pixels2DContext.createImageData(width, height);
          for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          }
        } else {
          throw new Error("Can not access image data");
        }
        return image;
      };
    }
  });

  // common/dist/esm/tensor-factory-impl.js
  var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
  var init_tensor_factory_impl = __esm({
    "common/dist/esm/tensor-factory-impl.js"() {
      "use strict";
      init_tensor_impl();
      bufferToTensor = (buffer, options) => {
        if (buffer === void 0) {
          throw new Error("Image buffer must be defined");
        }
        if (options.height === void 0 || options.width === void 0) {
          throw new Error("Image height and width must be defined");
        }
        if (options.tensorLayout === "NHWC") {
          throw new Error("NHWC Tensor layout is not supported yet");
        }
        const { height, width } = options;
        const norm = options.norm ?? { mean: 255, bias: 0 };
        let normMean;
        let normBias;
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
        }
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
        }
        const inputformat = options.format !== void 0 ? options.format : "RGBA";
        const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
        const stride = height * width;
        const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGB") {
          step = 3;
          rImagePointer = 0;
          gImagePointer = 1;
          bImagePointer = 2;
          aImagePointer = -1;
        }
        if (outputformat === "RGBA") {
          aTensorPointer = stride * 3;
        } else if (outputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        } else if (outputformat === "BGR") {
          bTensorPointer = 0;
          gTensorPointer = stride;
          rTensorPointer = stride * 2;
        }
        for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
          float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
          float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
          float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
          if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
          }
        }
        const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
        return outputTensor;
      };
      tensorFromImage = async (image, options) => {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isString = typeof image === "string";
        let data;
        let bufferToTensorOptions = options ?? {};
        const createCanvas2 = () => {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(1, 1);
          } else {
            throw new Error("Canvas is not supported");
          }
        };
        const createCanvasContext = (canvas) => {
          if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
            return canvas.getContext("2d");
          } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext("2d");
          } else {
            return null;
          }
        };
        if (isHTMLImageEle) {
          const canvas = createCanvas2();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              bufferToTensorOptions = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                bufferToTensorOptions.tensorFormat = "RGBA";
              }
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
          }
          bufferToTensorOptions.format = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          if (options !== void 0) {
            const tempCanvas = createCanvas2();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          const canvas = createCanvas2();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isString) {
          return new Promise((resolve, reject) => {
            const canvas = createCanvas2();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              bufferToTensorOptions.height = canvas.height;
              bufferToTensorOptions.width = canvas.width;
              resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      };
      tensorFromTexture = (texture, options) => {
        const { width, height, download, dispose } = options;
        const dims = [1, height, width, 4];
        return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
      };
      tensorFromGpuBuffer = (gpuBuffer, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
      };
      tensorFromMLTensor = (mlTensor, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
      };
      tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
    }
  });

  // common/dist/esm/tensor-impl-type-mapping.js
  var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
  var init_tensor_impl_type_mapping = __esm({
    "common/dist/esm/tensor-impl-type-mapping.js"() {
      "use strict";
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array],
        ["int4", Uint8Array],
        ["uint4", Uint8Array]
      ]);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"]
      ]);
      isTypedArrayChecked = false;
      checkTypedArray = () => {
        if (!isTypedArrayChecked) {
          isTypedArrayChecked = true;
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
          const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
          } else {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
          }
        }
      };
    }
  });

  // common/dist/esm/tensor-utils-impl.js
  var calculateSize, tensorReshape;
  var init_tensor_utils_impl = __esm({
    "common/dist/esm/tensor-utils-impl.js"() {
      "use strict";
      init_tensor_impl();
      calculateSize = (dims) => {
        let size = 1;
        for (let i = 0; i < dims.length; i++) {
          const dim = dims[i];
          if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
          }
          if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
          }
          size *= dim;
        }
        return size;
      };
      tensorReshape = (tensor, dims) => {
        switch (tensor.location) {
          case "cpu":
            return new Tensor(tensor.type, tensor.data, dims);
          case "cpu-pinned":
            return new Tensor({
              location: "cpu-pinned",
              data: tensor.data,
              type: tensor.type,
              dims
            });
          case "texture":
            return new Tensor({
              location: "texture",
              texture: tensor.texture,
              type: tensor.type,
              dims
            });
          case "gpu-buffer":
            return new Tensor({
              location: "gpu-buffer",
              gpuBuffer: tensor.gpuBuffer,
              type: tensor.type,
              dims
            });
          case "ml-tensor":
            return new Tensor({
              location: "ml-tensor",
              mlTensor: tensor.mlTensor,
              type: tensor.type,
              dims
            });
          default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
        }
      };
    }
  });

  // common/dist/esm/tensor-impl.js
  var Tensor;
  var init_tensor_impl = __esm({
    "common/dist/esm/tensor-impl.js"() {
      "use strict";
      init_tensor_conversion_impl();
      init_tensor_factory_impl();
      init_tensor_impl_type_mapping();
      init_tensor_utils_impl();
      Tensor = class {
        /**
         * implementation.
         */
        constructor(arg0, arg1, arg2) {
          checkTypedArray();
          let type;
          let dims;
          if (typeof arg0 === "object" && "location" in arg0) {
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch (arg0.location) {
              case "cpu-pinned": {
                const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
                if (!expectedTypedArrayConstructor) {
                  throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                }
                if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                  throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                }
                this.cpuData = arg0.data;
                break;
              }
              case "texture": {
                if (type !== "float32") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                }
                this.gpuTextureData = arg0.texture;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "gpu-buffer": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                }
                this.gpuBufferData = arg0.gpuBuffer;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "ml-tensor": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
                }
                this.mlTensorData = arg0.mlTensor;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              default:
                throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
          } else {
            let data;
            let maybeDims;
            if (typeof arg0 === "string") {
              type = arg0;
              maybeDims = arg2;
              if (arg0 === "string") {
                if (!Array.isArray(arg1)) {
                  throw new TypeError("A string tensor's data must be a string array.");
                }
                data = arg1;
              } else {
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === void 0) {
                  throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                  if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                    throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                  } else if (arg0 === "uint64" || arg0 === "int64") {
                    data = typedArrayConstructor.from(arg1, BigInt);
                  } else {
                    data = typedArrayConstructor.from(arg1);
                  }
                } else if (arg1 instanceof typedArrayConstructor) {
                  data = arg1;
                } else if (arg1 instanceof Uint8ClampedArray) {
                  if (arg0 === "uint8") {
                    data = Uint8Array.from(arg1);
                  } else {
                    throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                  }
                } else {
                  throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
              }
            } else {
              maybeDims = arg1;
              if (Array.isArray(arg0)) {
                if (arg0.length === 0) {
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === "string") {
                  type = "string";
                  data = arg0;
                } else if (firstElementType === "boolean") {
                  type = "bool";
                  data = Uint8Array.from(arg0);
                } else {
                  throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
              } else if (arg0 instanceof Uint8ClampedArray) {
                type = "uint8";
                data = Uint8Array.from(arg0);
              } else {
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === void 0) {
                  throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
              }
            }
            if (maybeDims === void 0) {
              maybeDims = [data.length];
            } else if (!Array.isArray(maybeDims)) {
              throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = "cpu";
          }
          const size = calculateSize(dims);
          if (this.cpuData && size !== this.cpuData.length) {
            if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
            } else {
              throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
            }
          }
          this.type = type;
          this.dims = dims;
          this.size = size;
        }
        // #endregion
        // #region factory
        static async fromImage(image, options) {
          return tensorFromImage(image, options);
        }
        static fromTexture(texture, options) {
          return tensorFromTexture(texture, options);
        }
        static fromGpuBuffer(gpuBuffer, options) {
          return tensorFromGpuBuffer(gpuBuffer, options);
        }
        static fromMLTensor(mlTensor, options) {
          return tensorFromMLTensor(mlTensor, options);
        }
        static fromPinnedBuffer(type, buffer, dims) {
          return tensorFromPinnedBuffer(type, buffer, dims);
        }
        // #endregion
        // #region conversions
        toDataURL(options) {
          return tensorToDataURL(this, options);
        }
        toImageData(options) {
          return tensorToImageData(this, options);
        }
        // #endregion
        // #region properties
        get data() {
          this.ensureValid();
          if (!this.cpuData) {
            throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
          }
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          this.ensureValid();
          if (!this.gpuTextureData) {
            throw new Error("The data is not stored as a WebGL texture.");
          }
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          this.ensureValid();
          if (!this.gpuBufferData) {
            throw new Error("The data is not stored as a WebGPU buffer.");
          }
          return this.gpuBufferData;
        }
        get mlTensor() {
          this.ensureValid();
          if (!this.mlTensorData) {
            throw new Error("The data is not stored as a WebNN MLTensor.");
          }
          return this.mlTensorData;
        }
        // #endregion
        // #region methods
        async getData(releaseData) {
          this.ensureValid();
          switch (this.dataLocation) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer":
            case "ml-tensor": {
              if (!this.downloader) {
                throw new Error("The current tensor is not created with a specified data downloader.");
              }
              if (this.isDownloading) {
                throw new Error("The current tensor is being downloaded.");
              }
              try {
                this.isDownloading = true;
                const data = await this.downloader();
                this.downloader = void 0;
                this.dataLocation = "cpu";
                this.cpuData = data;
                if (releaseData && this.disposer) {
                  this.disposer();
                  this.disposer = void 0;
                }
                return data;
              } finally {
                this.isDownloading = false;
              }
            }
            default:
              throw new Error(`cannot get data from location: ${this.dataLocation}`);
          }
        }
        dispose() {
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          if (this.disposer) {
            this.disposer();
            this.disposer = void 0;
          }
          this.cpuData = void 0;
          this.gpuTextureData = void 0;
          this.gpuBufferData = void 0;
          this.mlTensorData = void 0;
          this.downloader = void 0;
          this.isDownloading = void 0;
          this.dataLocation = "none";
        }
        // #endregion
        // #region tensor utilities
        ensureValid() {
          if (this.dataLocation === "none") {
            throw new Error("The tensor is disposed.");
          }
        }
        reshape(dims) {
          this.ensureValid();
          if (this.downloader || this.disposer) {
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          }
          return tensorReshape(this, dims);
        }
      };
    }
  });

  // common/dist/esm/tensor.js
  var Tensor2;
  var init_tensor = __esm({
    "common/dist/esm/tensor.js"() {
      "use strict";
      init_tensor_impl();
      Tensor2 = Tensor;
    }
  });

  // common/dist/esm/trace.js
  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
  var init_trace = __esm({
    "common/dist/esm/trace.js"() {
      "use strict";
      init_env_impl();
      TRACE = (deviceType, label) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeStamp(`${deviceType}::ORT::${label}`);
      };
      TRACE_FUNC = (msg, extraMsg) => {
        const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
        let hasTraceFunc = false;
        for (let i = 0; i < stack.length; i++) {
          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
            if (extraMsg) {
              label += `::${extraMsg}`;
            }
            TRACE("CPU", label);
            return;
          }
          if (stack[i].includes("TRACE_FUNC")) {
            hasTraceFunc = true;
          }
        }
      };
      TRACE_FUNC_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("BEGIN", extraMsg);
      };
      TRACE_FUNC_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("END", extraMsg);
      };
    }
  });

  // common/dist/esm/inference-session-impl.js
  var InferenceSession;
  var init_inference_session_impl = __esm({
    "common/dist/esm/inference-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      init_trace();
      InferenceSession = class _InferenceSession {
        constructor(handler) {
          this.handler = handler;
        }
        async run(feeds, arg1, arg2) {
          TRACE_FUNC_BEGIN();
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name2 of arg1) {
                if (typeof name2 !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (this.outputNames.indexOf(name2) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
                }
                fetches[name2] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name2 of this.outputNames) {
                if (arg1Keys.indexOf(name2) !== -1) {
                  const v = arg1[name2];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name2] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name2 of this.inputNames) {
            if (typeof feeds[name2] === "undefined") {
              throw new Error(`input '${name2}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name2 of this.outputNames) {
              fetches[name2] = null;
            }
          }
          const results = await this.handler.run(feeds, fetches, options);
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          TRACE_FUNC_END();
          return returnValue;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(arg0, arg1, arg2, arg3) {
          TRACE_FUNC_BEGIN();
          let filePathOrUint8Array;
          let options = {};
          if (typeof arg0 === "string") {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 === "number") {
              byteOffset = arg1;
              if (!Number.isSafeInteger(byteOffset)) {
                throw new RangeError("'byteOffset' must be an integer.");
              }
              if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
              }
              byteLength = arg0.byteLength - byteOffset;
              if (typeof arg2 === "number") {
                byteLength = arg2;
                if (!Number.isSafeInteger(byteLength)) {
                  throw new RangeError("'byteLength' must be an integer.");
                }
                if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                  throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                }
                if (typeof arg3 === "object" && arg3 !== null) {
                  options = arg3;
                } else if (typeof arg3 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'byteLength' must be a number.");
              }
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
          } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
          }
          const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          const handler = await backend2.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
          TRACE_FUNC_END();
          return new _InferenceSession(handler);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
      };
    }
  });

  // common/dist/esm/inference-session.js
  var InferenceSession2;
  var init_inference_session = __esm({
    "common/dist/esm/inference-session.js"() {
      "use strict";
      init_inference_session_impl();
      InferenceSession2 = InferenceSession;
    }
  });

  // common/dist/esm/tensor-conversion.js
  var init_tensor_conversion = __esm({
    "common/dist/esm/tensor-conversion.js"() {
      "use strict";
    }
  });

  // common/dist/esm/tensor-factory.js
  var init_tensor_factory = __esm({
    "common/dist/esm/tensor-factory.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-model.js
  var init_onnx_model = __esm({
    "common/dist/esm/onnx-model.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-value.js
  var init_onnx_value = __esm({
    "common/dist/esm/onnx-value.js"() {
      "use strict";
    }
  });

  // common/dist/esm/training-session-impl.js
  var noBackendErrMsg, TrainingSession;
  var init_training_session_impl = __esm({
    "common/dist/esm/training-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
      TrainingSession = class _TrainingSession {
        constructor(handler, hasOptimizerModel, hasEvalModel) {
          this.handler = handler;
          this.hasOptimizerModel = hasOptimizerModel;
          this.hasEvalModel = hasEvalModel;
        }
        get trainingInputNames() {
          return this.handler.inputNames;
        }
        get trainingOutputNames() {
          return this.handler.outputNames;
        }
        get evalInputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalInputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        get evalOutputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalOutputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        static async create(trainingOptions, sessionOptions) {
          const evalModel = trainingOptions.evalModel || "";
          const optimizerModel = trainingOptions.optimizerModel || "";
          const options = sessionOptions || {};
          const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          if (backend2.createTrainingSessionHandler) {
            const handler = await backend2.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
            return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
          } else {
            throw new Error(noBackendErrMsg);
          }
        }
        /**
         * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
         * the given parameters to SessionHandler.FetchesType and RunOptions.
         *
         * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
         * names.
         * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
         * names.
         * @param feeds the required input
         * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
         * @param arg2 optional RunOptions object.
         * @returns
         */
        typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name2 of arg1) {
                if (typeof name2 !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (outputNames.indexOf(name2) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
                }
                fetches[name2] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name2 of outputNames) {
                if (arg1Keys.indexOf(name2) !== -1) {
                  const v = arg1[name2];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name2] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name2 of inputNames) {
            if (typeof feeds[name2] === "undefined") {
              throw new Error(`input '${name2}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name2 of outputNames) {
              fetches[name2] = null;
            }
          }
          return [fetches, options];
        }
        /**
         * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
         * and changes it into a map of Tensors.
         *
         * @param results
         * @returns
         */
        convertHandlerReturnTypeToMapOfTensors(results) {
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          return returnValue;
        }
        async lazyResetGrad() {
          await this.handler.lazyResetGrad();
        }
        async runTrainStep(feeds, arg1, arg2) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runTrainStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        }
        async runOptimizerStep(options) {
          if (this.hasOptimizerModel) {
            await this.handler.runOptimizerStep(options || {});
          } else {
            throw new Error("This TrainingSession has no OptimizerModel loaded.");
          }
        }
        async runEvalStep(feeds, arg1, arg2) {
          if (this.hasEvalModel) {
            const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
            const results = await this.handler.runEvalStep(feeds, fetches, options);
            return this.convertHandlerReturnTypeToMapOfTensors(results);
          } else {
            throw new Error("This TrainingSession has no EvalModel loaded.");
          }
        }
        async getParametersSize(trainableOnly = true) {
          return this.handler.getParametersSize(trainableOnly);
        }
        async loadParametersBuffer(array, trainableOnly = true) {
          const paramsSize = await this.getParametersSize(trainableOnly);
          if (array.length !== 4 * paramsSize) {
            throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
          }
          return this.handler.loadParametersBuffer(array, trainableOnly);
        }
        async getContiguousParameters(trainableOnly = true) {
          return this.handler.getContiguousParameters(trainableOnly);
        }
        async release() {
          return this.handler.dispose();
        }
      };
    }
  });

  // common/dist/esm/training-session.js
  var TrainingSession2;
  var init_training_session = __esm({
    "common/dist/esm/training-session.js"() {
      "use strict";
      init_training_session_impl();
      TrainingSession2 = TrainingSession;
    }
  });

  // common/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  var init_esm = __esm({
    "common/dist/esm/index.js"() {
      "use strict";
      init_backend();
      init_env();
      init_inference_session();
      init_tensor();
      init_tensor_conversion();
      init_tensor_factory();
      init_trace();
      init_onnx_model();
      init_onnx_value();
      init_training_session();
    }
  });

  // web/lib/onnxjs/instrument.ts
  function log(arg0, arg1, arg2, arg3) {
    if (arg1 === void 0) {
      return createCategorizedLogger(arg0);
    } else if (arg2 === void 0) {
      logInternal(arg0, arg1, 1);
    } else if (typeof arg2 === "number" && arg3 === void 0) {
      logInternal(arg0, arg1, arg2);
    } else if (typeof arg2 === "string" && arg3 === void 0) {
      logInternal(arg0, arg2, 1, arg1);
    } else if (typeof arg2 === "string" && typeof arg3 === "number") {
      logInternal(arg0, arg2, arg3, arg1);
    } else {
      throw new TypeError("input is valid");
    }
  }
  function createCategorizedLogger(category) {
    return {
      verbose: log.verbose.bind(null, category),
      info: log.info.bind(null, category),
      warning: log.warning.bind(null, category),
      error: log.error.bind(null, category),
      fatal: log.fatal.bind(null, category)
    };
  }
  function logInternal(severity, content, _stack, category) {
    const config = LOGGER_CONFIG_MAP[category || ""] || LOGGER_CONFIG_MAP[""];
    if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {
      return;
    }
    if (config.logDateTime) {
      content = `${(/* @__PURE__ */ new Date()).toISOString()}|${content}`;
    }
    if (config.logSourceLocation) {
    }
    LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);
  }
  var NoOpLoggerProvider, ConsoleLoggerProvider, SEVERITY_VALUE, LOGGER_PROVIDER_MAP, LOGGER_DEFAULT_CONFIG, LOGGER_CONFIG_MAP, Logger, Event, EventRecord, Profiler, now;
  var init_instrument = __esm({
    "web/lib/onnxjs/instrument.ts"() {
      "use strict";
      NoOpLoggerProvider = class {
        log(_severity, _content, _category) {
        }
      };
      ConsoleLoggerProvider = class {
        log(severity, content, category) {
          console.log(`${this.color(severity)} ${category ? "\x1B[35m" + category + "\x1B[0m " : ""}${content}`);
        }
        color(severity) {
          switch (severity) {
            case "verbose":
              return "\x1B[34;40mv\x1B[0m";
            case "info":
              return "\x1B[32mi\x1B[0m";
            case "warning":
              return "\x1B[30;43mw\x1B[0m";
            case "error":
              return "\x1B[31;40me\x1B[0m";
            case "fatal":
              return "\x1B[101mf\x1B[0m";
            default:
              throw new Error(`unsupported severity: ${severity}`);
          }
        }
      };
      SEVERITY_VALUE = {
        verbose: 1e3,
        info: 2e3,
        warning: 4e3,
        error: 5e3,
        fatal: 6e3
      };
      LOGGER_PROVIDER_MAP = {
        ["none"]: new NoOpLoggerProvider(),
        ["console"]: new ConsoleLoggerProvider()
      };
      LOGGER_DEFAULT_CONFIG = {
        provider: "console",
        minimalSeverity: "warning",
        logDateTime: true,
        logSourceLocation: false
      };
      LOGGER_CONFIG_MAP = {
        [""]: LOGGER_DEFAULT_CONFIG
      };
      ((log3) => {
        function verbose(arg0, arg1) {
          log3("verbose", arg0, arg1);
        }
        log3.verbose = verbose;
        function info(arg0, arg1) {
          log3("info", arg0, arg1);
        }
        log3.info = info;
        function warning(arg0, arg1) {
          log3("warning", arg0, arg1);
        }
        log3.warning = warning;
        function error(arg0, arg1) {
          log3("error", arg0, arg1);
        }
        log3.error = error;
        function fatal(arg0, arg1) {
          log3("fatal", arg0, arg1);
        }
        log3.fatal = fatal;
        function reset(config) {
          LOGGER_CONFIG_MAP = {};
          set("", config || {});
        }
        log3.reset = reset;
        function set(category, config) {
          if (category === "*") {
            reset(config);
          } else {
            const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;
            LOGGER_CONFIG_MAP[category] = {
              provider: config.provider || previousConfig.provider,
              minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,
              logDateTime: config.logDateTime === void 0 ? previousConfig.logDateTime : config.logDateTime,
              logSourceLocation: config.logSourceLocation === void 0 ? previousConfig.logSourceLocation : config.logSourceLocation
            };
          }
        }
        log3.set = set;
        function setWithEnv(env3) {
          const config = {};
          if (env3.logLevel) {
            config.minimalSeverity = env3.logLevel;
          }
          set("", config);
        }
        log3.setWithEnv = setWithEnv;
      })(log || (log = {}));
      Logger = log;
      Event = class {
        constructor(category, name2, startTime, endCallback, timer, ctx) {
          this.category = category;
          this.name = name2;
          this.startTime = startTime;
          this.endCallback = endCallback;
          this.timer = timer;
          this.ctx = ctx;
        }
        async end() {
          return this.endCallback(this);
        }
        async checkTimer() {
          if (this.ctx === void 0 || this.timer === void 0) {
            throw new Error("No webgl timer found");
          } else {
            this.ctx.endTimer();
            return this.ctx.waitForQueryAndGetTime(this.timer);
          }
        }
      };
      EventRecord = class {
        constructor(category, name2, startTime, endTime) {
          this.category = category;
          this.name = name2;
          this.startTime = startTime;
          this.endTime = endTime;
        }
      };
      Profiler = class {
        constructor(maxNumberEvents, flushBatchSize, flushIntervalInMilliseconds) {
          this._started = false;
          this._flushPointer = 0;
          this._started = false;
          this._maxNumberEvents = maxNumberEvents === void 0 ? 1e4 : maxNumberEvents;
          this._flushBatchSize = flushBatchSize === void 0 ? 10 : flushBatchSize;
          this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === void 0 ? 5e3 : flushIntervalInMilliseconds;
        }
        static create(config) {
          if (config === void 0) {
            return new this();
          }
          return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);
        }
        // start profiling
        start() {
          this._started = true;
          this._timingEvents = [];
          this._flushTime = now();
          this._flushPointer = 0;
        }
        // stop profiling
        stop() {
          this._started = false;
          for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {
            this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
        }
        event(category, name2, func, ctx) {
          const event = this._started ? this.begin(category, name2, ctx) : void 0;
          let isPromise = false;
          const res = func();
          if (res && typeof res.then === "function") {
            isPromise = true;
            return new Promise((resolve, reject) => {
              res.then(
                async (value) => {
                  if (event) {
                    await event.end();
                  }
                  resolve(value);
                },
                async (reason) => {
                  if (event) {
                    await event.end();
                  }
                  reject(reason);
                }
              );
            });
          }
          if (!isPromise && event) {
            const eventRes = event.end();
            if (eventRes && typeof eventRes.then === "function") {
              return new Promise((resolve, reject) => {
                eventRes.then(
                  () => {
                    resolve(res);
                  },
                  (reason) => {
                    reject(reason);
                  }
                );
              });
            }
          }
          return res;
        }
        // begin an event
        begin(category, name2, ctx) {
          if (!this._started) {
            throw new Error("profiler is not started yet");
          }
          if (ctx === void 0) {
            const startTime = now();
            this.flush(startTime);
            return new Event(category, name2, startTime, (e) => this.endSync(e));
          } else {
            const timer = ctx.beginTimer();
            return new Event(category, name2, 0, async (e) => this.end(e), timer, ctx);
          }
        }
        // end the specific event
        async end(event) {
          const endTime = await event.checkTimer();
          if (this._timingEvents.length < this._maxNumberEvents) {
            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
            this.flush(endTime);
          }
        }
        endSync(event) {
          const endTime = now();
          if (this._timingEvents.length < this._maxNumberEvents) {
            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
            this.flush(endTime);
          }
        }
        logOneEvent(event) {
          Logger.verbose(
            `Profiler.${event.category}`,
            `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`
          );
        }
        flush(currentTime) {
          if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {
            for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) {
              this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            this._flushTime = now();
          }
        }
        get started() {
          return this._started;
        }
      };
      now = typeof performance !== "undefined" && performance.now ? () => performance.now() : Date.now;
    }
  });

  // web/lib/onnxjs/opset.ts
  function resolveOperator(node, opsets, rules) {
    for (const rule of rules) {
      const opType = rule[0];
      const domain = rule[1];
      const versionSelector = rule[2];
      const opImpl = rule[3];
      const opInit = rule[4];
      if (node.opType === opType) {
        for (const opset of opsets) {
          if (opset.domain === domain || opset.domain === "ai.onnx" && domain === "") {
            if (matchSelector(opset.version, versionSelector)) {
              return { opImpl, opInit };
            }
          }
        }
      }
    }
    throw new TypeError(
      `cannot resolve operator '${node.opType}' with opsets: ${opsets.map((set) => `${set.domain || "ai.onnx"} v${set.version}`).join(", ")}`
    );
  }
  function matchSelector(version3, selector) {
    if (selector.endsWith("+")) {
      const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);
      return !isNaN(rangeStart) && rangeStart <= version3;
    } else if (selector.split("-").length === 2) {
      const pair = selector.split("-");
      const rangeStart = Number.parseInt(pair[0], 10);
      const rangeEnd = Number.parseInt(pair[1], 10);
      return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version3 && version3 <= rangeEnd;
    } else {
      return Number.parseInt(selector, 10) === version3;
    }
  }
  var init_opset = __esm({
    "web/lib/onnxjs/opset.ts"() {
      "use strict";
    }
  });

  // web/node_modules/guid-typescript/dist/guid.js
  var require_guid = __commonJS({
    "web/node_modules/guid-typescript/dist/guid.js"(exports2) {
      "use strict";
      exports2.__esModule = true;
      var Guid2 = (
        /** @class */
        function() {
          function Guid3(guid) {
            if (!guid) {
              throw new TypeError("Invalid argument; `value` has no value.");
            }
            this.value = Guid3.EMPTY;
            if (guid && Guid3.isGuid(guid)) {
              this.value = guid;
            }
          }
          Guid3.isGuid = function(guid) {
            var value = guid.toString();
            return guid && (guid instanceof Guid3 || Guid3.validator.test(value));
          };
          Guid3.create = function() {
            return new Guid3([Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-"));
          };
          Guid3.createEmpty = function() {
            return new Guid3("emptyguid");
          };
          Guid3.parse = function(guid) {
            return new Guid3(guid);
          };
          Guid3.raw = function() {
            return [Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-");
          };
          Guid3.gen = function(count) {
            var out = "";
            for (var i = 0; i < count; i++) {
              out += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
            }
            return out;
          };
          Guid3.prototype.equals = function(other) {
            return Guid3.isGuid(other) && this.value === other.toString();
          };
          Guid3.prototype.isEmpty = function() {
            return this.value === Guid3.EMPTY;
          };
          Guid3.prototype.toString = function() {
            return this.value;
          };
          Guid3.prototype.toJSON = function() {
            return {
              value: this.value
            };
          };
          Guid3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
          Guid3.EMPTY = "00000000-0000-0000-0000-000000000000";
          return Guid3;
        }()
      );
      exports2.Guid = Guid2;
    }
  });

  // web/node_modules/long/index.js
  function Long(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache2;
    if (unsigned) {
      value >>>= 0;
      if (cache2 = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache2)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache2 = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache2)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  var wasm, INT_CACHE, UINT_CACHE, pow_dbl, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, TWO_PWR_24, ZERO, UZERO, ONE, UONE, NEG_ONE, MAX_VALUE, MAX_UNSIGNED_VALUE, MIN_VALUE, LongPrototype, long_default;
  var init_long = __esm({
    "web/node_modules/long/index.js"() {
      wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e) {
      }
      Long.prototype.__isLong__;
      Object.defineProperty(Long.prototype, "__isLong__", { value: true });
      Long.isLong = isLong;
      INT_CACHE = {};
      UINT_CACHE = {};
      Long.fromInt = fromInt;
      Long.fromNumber = fromNumber;
      Long.fromBits = fromBits;
      pow_dbl = Math.pow;
      Long.fromString = fromString;
      Long.fromValue = fromValue;
      TWO_PWR_16_DBL = 1 << 16;
      TWO_PWR_24_DBL = 1 << 24;
      TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      ZERO = fromInt(0);
      Long.ZERO = ZERO;
      UZERO = fromInt(0, true);
      Long.UZERO = UZERO;
      ONE = fromInt(1);
      Long.ONE = ONE;
      UONE = fromInt(1, true);
      Long.UONE = UONE;
      NEG_ONE = fromInt(-1);
      Long.NEG_ONE = NEG_ONE;
      MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long.MAX_VALUE = MAX_VALUE;
      MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long.MIN_VALUE = MIN_VALUE;
      LongPrototype = Long.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
            return div2.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return this;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](
            this.low,
            this.high,
            multiplier.low,
            multiplier.high
          );
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero())
          return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32)
          return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
      };
      Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long(
          bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
          bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
          unsigned
        );
      };
      Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long(
          bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
          bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
          unsigned
        );
      };
      long_default = Long;
    }
  });

  // web/node_modules/flatbuffers/js/flatbuffers.mjs
  var flatbuffers;
  var init_flatbuffers = __esm({
    "web/node_modules/flatbuffers/js/flatbuffers.mjs"() {
      flatbuffers = {};
      flatbuffers.Offset;
      flatbuffers.Table;
      flatbuffers.SIZEOF_SHORT = 2;
      flatbuffers.SIZEOF_INT = 4;
      flatbuffers.FILE_IDENTIFIER_LENGTH = 4;
      flatbuffers.SIZE_PREFIX_LENGTH = 4;
      flatbuffers.Encoding = {
        UTF8_BYTES: 1,
        UTF16_STRING: 2
      };
      flatbuffers.int32 = new Int32Array(2);
      flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);
      flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);
      flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
      flatbuffers.Long = function(low, high) {
        this.low = low | 0;
        this.high = high | 0;
      };
      flatbuffers.Long.create = function(low, high) {
        return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
      };
      flatbuffers.Long.prototype.toFloat64 = function() {
        return (this.low >>> 0) + this.high * 4294967296;
      };
      flatbuffers.Long.prototype.equals = function(other) {
        return this.low == other.low && this.high == other.high;
      };
      flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);
      flatbuffers.Builder = function(opt_initial_size) {
        if (!opt_initial_size) {
          var initial_size = 1024;
        } else {
          var initial_size = opt_initial_size;
        }
        this.bb = flatbuffers.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
      };
      flatbuffers.Builder.prototype.clear = function() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
      };
      flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
        this.force_defaults = forceDefaults;
      };
      flatbuffers.Builder.prototype.dataBuffer = function() {
        return this.bb;
      };
      flatbuffers.Builder.prototype.asUint8Array = function() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
      };
      flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
        if (size > this.minalign) {
          this.minalign = size;
        }
        var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
        while (this.space < align_size + size + additional_bytes) {
          var old_buf_size = this.bb.capacity();
          this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
          this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
      };
      flatbuffers.Builder.prototype.pad = function(byte_size) {
        for (var i = 0; i < byte_size; i++) {
          this.bb.writeInt8(--this.space, 0);
        }
      };
      flatbuffers.Builder.prototype.writeInt8 = function(value) {
        this.bb.writeInt8(this.space -= 1, value);
      };
      flatbuffers.Builder.prototype.writeInt16 = function(value) {
        this.bb.writeInt16(this.space -= 2, value);
      };
      flatbuffers.Builder.prototype.writeInt32 = function(value) {
        this.bb.writeInt32(this.space -= 4, value);
      };
      flatbuffers.Builder.prototype.writeInt64 = function(value) {
        this.bb.writeInt64(this.space -= 8, value);
      };
      flatbuffers.Builder.prototype.writeFloat32 = function(value) {
        this.bb.writeFloat32(this.space -= 4, value);
      };
      flatbuffers.Builder.prototype.writeFloat64 = function(value) {
        this.bb.writeFloat64(this.space -= 8, value);
      };
      flatbuffers.Builder.prototype.addInt8 = function(value) {
        this.prep(1, 0);
        this.writeInt8(value);
      };
      flatbuffers.Builder.prototype.addInt16 = function(value) {
        this.prep(2, 0);
        this.writeInt16(value);
      };
      flatbuffers.Builder.prototype.addInt32 = function(value) {
        this.prep(4, 0);
        this.writeInt32(value);
      };
      flatbuffers.Builder.prototype.addInt64 = function(value) {
        this.prep(8, 0);
        this.writeInt64(value);
      };
      flatbuffers.Builder.prototype.addFloat32 = function(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
      };
      flatbuffers.Builder.prototype.addFloat64 = function(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
      };
      flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt8(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt16(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt32(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
        if (this.force_defaults || !value.equals(defaultValue)) {
          this.addInt64(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addFloat32(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addFloat64(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addOffset(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
        if (value != defaultValue) {
          this.nested(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.nested = function(obj) {
        if (obj != this.offset()) {
          throw new Error("FlatBuffers: struct must be serialized inline.");
        }
      };
      flatbuffers.Builder.prototype.notNested = function() {
        if (this.isNested) {
          throw new Error("FlatBuffers: object serialization must not be nested.");
        }
      };
      flatbuffers.Builder.prototype.slot = function(voffset) {
        this.vtable[voffset] = this.offset();
      };
      flatbuffers.Builder.prototype.offset = function() {
        return this.bb.capacity() - this.space;
      };
      flatbuffers.Builder.growByteBuffer = function(bb) {
        var old_buf_size = bb.capacity();
        if (old_buf_size & 3221225472) {
          throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
        }
        var new_buf_size = old_buf_size << 1;
        var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
      };
      flatbuffers.Builder.prototype.addOffset = function(offset) {
        this.prep(flatbuffers.SIZEOF_INT, 0);
        this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
      };
      flatbuffers.Builder.prototype.startObject = function(numfields) {
        this.notNested();
        if (this.vtable == null) {
          this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (var i = 0; i < numfields; i++) {
          this.vtable[i] = 0;
        }
        this.isNested = true;
        this.object_start = this.offset();
      };
      flatbuffers.Builder.prototype.endObject = function() {
        if (this.vtable == null || !this.isNested) {
          throw new Error("FlatBuffers: endObject called without startObject");
        }
        this.addInt32(0);
        var vtableloc = this.offset();
        var i = this.vtable_in_use - 1;
        for (; i >= 0 && this.vtable[i] == 0; i--) {
        }
        var trimmed_size = i + 1;
        for (; i >= 0; i--) {
          this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        var standard_fields = 2;
        this.addInt16(vtableloc - this.object_start);
        var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
        this.addInt16(len);
        var existing_vtable = 0;
        var vt1 = this.space;
        outer_loop:
          for (i = 0; i < this.vtables.length; i++) {
            var vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
              for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
                if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                  continue outer_loop;
                }
              }
              existing_vtable = this.vtables[i];
              break;
            }
          }
        if (existing_vtable) {
          this.space = this.bb.capacity() - vtableloc;
          this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        } else {
          this.vtables.push(this.offset());
          this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
      };
      flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {
        var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
          var file_identifier = opt_file_identifier;
          this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
          if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
            throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
          }
          for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
            this.writeInt8(file_identifier.charCodeAt(i));
          }
        }
        this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
          this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
      };
      flatbuffers.Builder.prototype.finishSizePrefixed = function(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
      };
      flatbuffers.Builder.prototype.requiredField = function(table, field) {
        var table_start = this.bb.capacity() - table;
        var vtable_start = table_start - this.bb.readInt32(table_start);
        var ok = this.bb.readInt16(vtable_start + field) != 0;
        if (!ok) {
          throw new Error("FlatBuffers: field " + field + " must be set");
        }
      };
      flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems);
      };
      flatbuffers.Builder.prototype.endVector = function() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
      };
      flatbuffers.Builder.prototype.createString = function(s) {
        if (s instanceof Uint8Array) {
          var utf8 = s;
        } else {
          var utf8 = [];
          var i = 0;
          while (i < s.length) {
            var codePoint;
            var a = s.charCodeAt(i++);
            if (a < 55296 || a >= 56320) {
              codePoint = a;
            } else {
              var b = s.charCodeAt(i++);
              codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
            }
            if (codePoint < 128) {
              utf8.push(codePoint);
            } else {
              if (codePoint < 2048) {
                utf8.push(codePoint >> 6 & 31 | 192);
              } else {
                if (codePoint < 65536) {
                  utf8.push(codePoint >> 12 & 15 | 224);
                } else {
                  utf8.push(
                    codePoint >> 18 & 7 | 240,
                    codePoint >> 12 & 63 | 128
                  );
                }
                utf8.push(codePoint >> 6 & 63 | 128);
              }
              utf8.push(codePoint & 63 | 128);
            }
          }
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
          bytes[offset++] = utf8[i];
        }
        return this.endVector();
      };
      flatbuffers.Builder.prototype.createLong = function(low, high) {
        return flatbuffers.Long.create(low, high);
      };
      flatbuffers.ByteBuffer = function(bytes) {
        this.bytes_ = bytes;
        this.position_ = 0;
      };
      flatbuffers.ByteBuffer.allocate = function(byte_size) {
        return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
      };
      flatbuffers.ByteBuffer.prototype.clear = function() {
        this.position_ = 0;
      };
      flatbuffers.ByteBuffer.prototype.bytes = function() {
        return this.bytes_;
      };
      flatbuffers.ByteBuffer.prototype.position = function() {
        return this.position_;
      };
      flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
        this.position_ = position;
      };
      flatbuffers.ByteBuffer.prototype.capacity = function() {
        return this.bytes_.length;
      };
      flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
        return this.readUint8(offset) << 24 >> 24;
      };
      flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
        return this.bytes_[offset];
      };
      flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
        return this.readUint16(offset) << 16 >> 16;
      };
      flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
      };
      flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
      };
      flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
        return this.readInt32(offset) >>> 0;
      };
      flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
        return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
      };
      flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
        return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
      };
      flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
        flatbuffers.int32[0] = this.readInt32(offset);
        return flatbuffers.float32[0];
      };
      flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
        flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return flatbuffers.float64[0];
      };
      flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
        this.bytes_[offset] = /** @type {number} */
        value;
      };
      flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
        this.bytes_[offset] = value;
      };
      flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
      };
      flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
      };
      flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
      };
      flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
      };
      flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
        this.writeInt32(offset, value.low);
        this.writeInt32(offset + 4, value.high);
      };
      flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
        this.writeUint32(offset, value.low);
        this.writeUint32(offset + 4, value.high);
      };
      flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
        flatbuffers.float32[0] = value;
        this.writeInt32(offset, flatbuffers.int32[0]);
      };
      flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
        flatbuffers.float64[0] = value;
        this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
      };
      flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
        if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error(
            "FlatBuffers: ByteBuffer is too short to contain an identifier."
          );
        }
        var result = "";
        for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
          result += String.fromCharCode(
            this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)
          );
        }
        return result;
      };
      flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
        var vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
      };
      flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
      };
      flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
        offset += this.readInt32(offset);
        var length = this.readInt32(offset);
        var result = "";
        var i = 0;
        offset += flatbuffers.SIZEOF_INT;
        if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
          return this.bytes_.subarray(offset, offset + length);
        }
        while (i < length) {
          var codePoint;
          var a = this.readUint8(offset + i++);
          if (a < 192) {
            codePoint = a;
          } else {
            var b = this.readUint8(offset + i++);
            if (a < 224) {
              codePoint = (a & 31) << 6 | b & 63;
            } else {
              var c = this.readUint8(offset + i++);
              if (a < 240) {
                codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
              } else {
                var d = this.readUint8(offset + i++);
                codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
              }
            }
          }
          if (codePoint < 65536) {
            result += String.fromCharCode(codePoint);
          } else {
            codePoint -= 65536;
            result += String.fromCharCode(
              (codePoint >> 10) + 55296,
              (codePoint & (1 << 10) - 1) + 56320
            );
          }
        }
        return result;
      };
      flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
        return offset + this.readInt32(offset);
      };
      flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
        return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
      };
      flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
        return this.readInt32(offset + this.readInt32(offset));
      };
      flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
        if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
          if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
            return false;
          }
        }
        return true;
      };
      flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
        return flatbuffers.Long.create(low, high);
      };
    }
  });

  // web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts
  var onnxruntime;
  var init_ort_generated = __esm({
    "web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"() {
      "use strict";
      init_flatbuffers();
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let AttributeType;
            ((AttributeType2) => {
              AttributeType2[AttributeType2["UNDEFINED"] = 0] = "UNDEFINED";
              AttributeType2[AttributeType2["FLOAT"] = 1] = "FLOAT";
              AttributeType2[AttributeType2["INT"] = 2] = "INT";
              AttributeType2[AttributeType2["STRING"] = 3] = "STRING";
              AttributeType2[AttributeType2["TENSOR"] = 4] = "TENSOR";
              AttributeType2[AttributeType2["GRAPH"] = 5] = "GRAPH";
              AttributeType2[AttributeType2["FLOATS"] = 6] = "FLOATS";
              AttributeType2[AttributeType2["INTS"] = 7] = "INTS";
              AttributeType2[AttributeType2["STRINGS"] = 8] = "STRINGS";
              AttributeType2[AttributeType2["TENSORS"] = 9] = "TENSORS";
              AttributeType2[AttributeType2["GRAPHS"] = 10] = "GRAPHS";
              AttributeType2[AttributeType2["SPARSE_TENSOR"] = 11] = "SPARSE_TENSOR";
              AttributeType2[AttributeType2["SPARSE_TENSORS"] = 12] = "SPARSE_TENSORS";
            })(AttributeType = fbs2.AttributeType || (fbs2.AttributeType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let DimensionValueType;
            ((DimensionValueType2) => {
              DimensionValueType2[DimensionValueType2["UNKNOWN"] = 0] = "UNKNOWN";
              DimensionValueType2[DimensionValueType2["VALUE"] = 1] = "VALUE";
              DimensionValueType2[DimensionValueType2["PARAM"] = 2] = "PARAM";
            })(DimensionValueType = fbs2.DimensionValueType || (fbs2.DimensionValueType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let TensorDataType;
            ((TensorDataType2) => {
              TensorDataType2[TensorDataType2["UNDEFINED"] = 0] = "UNDEFINED";
              TensorDataType2[TensorDataType2["FLOAT"] = 1] = "FLOAT";
              TensorDataType2[TensorDataType2["UINT8"] = 2] = "UINT8";
              TensorDataType2[TensorDataType2["INT8"] = 3] = "INT8";
              TensorDataType2[TensorDataType2["UINT16"] = 4] = "UINT16";
              TensorDataType2[TensorDataType2["INT16"] = 5] = "INT16";
              TensorDataType2[TensorDataType2["INT32"] = 6] = "INT32";
              TensorDataType2[TensorDataType2["INT64"] = 7] = "INT64";
              TensorDataType2[TensorDataType2["STRING"] = 8] = "STRING";
              TensorDataType2[TensorDataType2["BOOL"] = 9] = "BOOL";
              TensorDataType2[TensorDataType2["FLOAT16"] = 10] = "FLOAT16";
              TensorDataType2[TensorDataType2["DOUBLE"] = 11] = "DOUBLE";
              TensorDataType2[TensorDataType2["UINT32"] = 12] = "UINT32";
              TensorDataType2[TensorDataType2["UINT64"] = 13] = "UINT64";
              TensorDataType2[TensorDataType2["COMPLEX64"] = 14] = "COMPLEX64";
              TensorDataType2[TensorDataType2["COMPLEX128"] = 15] = "COMPLEX128";
              TensorDataType2[TensorDataType2["BFLOAT16"] = 16] = "BFLOAT16";
              TensorDataType2[TensorDataType2["FLOAT8E4M3FN"] = 17] = "FLOAT8E4M3FN";
              TensorDataType2[TensorDataType2["FLOAT8E4M3FNUZ"] = 18] = "FLOAT8E4M3FNUZ";
              TensorDataType2[TensorDataType2["FLOAT8E5M2"] = 19] = "FLOAT8E5M2";
              TensorDataType2[TensorDataType2["FLOAT8E5M2FNUZ"] = 20] = "FLOAT8E5M2FNUZ";
            })(TensorDataType = fbs2.TensorDataType || (fbs2.TensorDataType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let NodeType;
            ((NodeType2) => {
              NodeType2[NodeType2["Primitive"] = 0] = "Primitive";
              NodeType2[NodeType2["Fused"] = 1] = "Fused";
            })(NodeType = fbs2.NodeType || (fbs2.NodeType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let TypeInfoValue;
            ((TypeInfoValue2) => {
              TypeInfoValue2[TypeInfoValue2["NONE"] = 0] = "NONE";
              TypeInfoValue2[TypeInfoValue2["tensor_type"] = 1] = "tensor_type";
              TypeInfoValue2[TypeInfoValue2["sequence_type"] = 2] = "sequence_type";
              TypeInfoValue2[TypeInfoValue2["map_type"] = 3] = "map_type";
            })(TypeInfoValue = fbs2.TypeInfoValue || (fbs2.TypeInfoValue = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Shape {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Shape
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Shape= obj
               * @returns Shape
               */
              static getRootAsShape(bb, obj) {
                return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Shape= obj
               * @returns Shape
               */
              static getSizePrefixedRootAsShape(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Dimension= obj
               * @returns onnxruntime.experimental.fbs.Dimension
               */
              dim(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Dimension()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              dimLength() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startShape(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimOffset
               */
              static addDim(builder, dimOffset) {
                builder.addFieldOffset(0, dimOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createDimVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDimVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endShape(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createShape(builder, dimOffset) {
                Shape.startShape(builder);
                Shape.addDim(builder, dimOffset);
                return Shape.endShape(builder);
              }
            }
            fbs2.Shape = Shape;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Dimension {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Dimension
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Dimension= obj
               * @returns Dimension
               */
              static getRootAsDimension(bb, obj) {
                return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Dimension= obj
               * @returns Dimension
               */
              static getSizePrefixedRootAsDimension(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.DimensionValue= obj
               * @returns onnxruntime.experimental.fbs.DimensionValue|null
               */
              value(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.DimensionValue()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              denotation(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDimension(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueOffset
               */
              static addValue(builder, valueOffset) {
                builder.addFieldOffset(0, valueOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset denotationOffset
               */
              static addDenotation(builder, denotationOffset) {
                builder.addFieldOffset(1, denotationOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDimension(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDimension(builder, valueOffset, denotationOffset) {
                Dimension.startDimension(builder);
                Dimension.addValue(builder, valueOffset);
                Dimension.addDenotation(builder, denotationOffset);
                return Dimension.endDimension(builder);
              }
            }
            fbs2.Dimension = Dimension;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class DimensionValue {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns DimensionValue
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param DimensionValue= obj
               * @returns DimensionValue
               */
              static getRootAsDimensionValue(bb, obj) {
                return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param DimensionValue= obj
               * @returns DimensionValue
               */
              static getSizePrefixedRootAsDimensionValue(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns onnxruntime.experimental.fbs.DimensionValueType
               */
              dimType() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt8(this.bb_pos + offset)
                ) : 0 /* UNKNOWN */;
              }
              /**
               * @returns flatbuffers.Long
               */
              dimValue() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              dimParam(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDimensionValue(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.DimensionValueType dimType
               */
              static addDimType(builder, dimType) {
                builder.addFieldInt8(0, dimType, 0 /* UNKNOWN */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long dimValue
               */
              static addDimValue(builder, dimValue) {
                builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimParamOffset
               */
              static addDimParam(builder, dimParamOffset) {
                builder.addFieldOffset(2, dimParamOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDimensionValue(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDimensionValue(builder, dimType, dimValue, dimParamOffset) {
                DimensionValue.startDimensionValue(builder);
                DimensionValue.addDimType(builder, dimType);
                DimensionValue.addDimValue(builder, dimValue);
                DimensionValue.addDimParam(builder, dimParamOffset);
                return DimensionValue.endDimensionValue(builder);
              }
            }
            fbs2.DimensionValue = DimensionValue;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class TensorTypeAndShape {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns TensorTypeAndShape
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TensorTypeAndShape= obj
               * @returns TensorTypeAndShape
               */
              static getRootAsTensorTypeAndShape(bb, obj) {
                return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TensorTypeAndShape= obj
               * @returns TensorTypeAndShape
               */
              static getSizePrefixedRootAsTensorTypeAndShape(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns onnxruntime.experimental.fbs.TensorDataType
               */
              elemType() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @param onnxruntime.experimental.fbs.Shape= obj
               * @returns onnxruntime.experimental.fbs.Shape|null
               */
              shape(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTensorTypeAndShape(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TensorDataType elemType
               */
              static addElemType(builder, elemType) {
                builder.addFieldInt32(0, elemType, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset shapeOffset
               */
              static addShape(builder, shapeOffset) {
                builder.addFieldOffset(1, shapeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTensorTypeAndShape(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTensorTypeAndShape(builder, elemType, shapeOffset) {
                TensorTypeAndShape.startTensorTypeAndShape(builder);
                TensorTypeAndShape.addElemType(builder, elemType);
                TensorTypeAndShape.addShape(builder, shapeOffset);
                return TensorTypeAndShape.endTensorTypeAndShape(builder);
              }
            }
            fbs2.TensorTypeAndShape = TensorTypeAndShape;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class MapType {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns MapType
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param MapType= obj
               * @returns MapType
               */
              static getRootAsMapType(bb, obj) {
                return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param MapType= obj
               * @returns MapType
               */
              static getSizePrefixedRootAsMapType(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns onnxruntime.experimental.fbs.TensorDataType
               */
              keyType() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @param onnxruntime.experimental.fbs.TypeInfo= obj
               * @returns onnxruntime.experimental.fbs.TypeInfo|null
               */
              valueType(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startMapType(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TensorDataType keyType
               */
              static addKeyType(builder, keyType) {
                builder.addFieldInt32(0, keyType, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueTypeOffset
               */
              static addValueType(builder, valueTypeOffset) {
                builder.addFieldOffset(1, valueTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endMapType(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createMapType(builder, keyType, valueTypeOffset) {
                MapType.startMapType(builder);
                MapType.addKeyType(builder, keyType);
                MapType.addValueType(builder, valueTypeOffset);
                return MapType.endMapType(builder);
              }
            }
            fbs2.MapType = MapType;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SequenceType {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SequenceType
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SequenceType= obj
               * @returns SequenceType
               */
              static getRootAsSequenceType(bb, obj) {
                return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SequenceType= obj
               * @returns SequenceType
               */
              static getSizePrefixedRootAsSequenceType(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.TypeInfo= obj
               * @returns onnxruntime.experimental.fbs.TypeInfo|null
               */
              elemType(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSequenceType(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset elemTypeOffset
               */
              static addElemType(builder, elemTypeOffset) {
                builder.addFieldOffset(0, elemTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSequenceType(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createSequenceType(builder, elemTypeOffset) {
                SequenceType.startSequenceType(builder);
                SequenceType.addElemType(builder, elemTypeOffset);
                return SequenceType.endSequenceType(builder);
              }
            }
            fbs2.SequenceType = SequenceType;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class EdgeEnd {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns EdgeEnd
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @returns number
               */
              nodeIndex() {
                return this.bb.readUint32(this.bb_pos);
              }
              /**
               * @returns number
               */
              srcArgIndex() {
                return this.bb.readInt32(this.bb_pos + 4);
              }
              /**
               * @returns number
               */
              dstArgIndex() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number node_index
               * @param number src_arg_index
               * @param number dst_arg_index
               * @returns flatbuffers.Offset
               */
              static createEdgeEnd(builder, node_index, src_arg_index, dst_arg_index) {
                builder.prep(4, 12);
                builder.writeInt32(dst_arg_index);
                builder.writeInt32(src_arg_index);
                builder.writeInt32(node_index);
                return builder.offset();
              }
            }
            fbs2.EdgeEnd = EdgeEnd;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class NodeEdge {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns NodeEdge
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param NodeEdge= obj
               * @returns NodeEdge
               */
              static getRootAsNodeEdge(bb, obj) {
                return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param NodeEdge= obj
               * @returns NodeEdge
               */
              static getSizePrefixedRootAsNodeEdge(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns number
               */
              nodeIndex() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.EdgeEnd= obj
               * @returns onnxruntime.experimental.fbs.EdgeEnd
               */
              inputEdges(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(
                  this.bb.__vector(this.bb_pos + offset) + index * 12,
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              inputEdgesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.EdgeEnd= obj
               * @returns onnxruntime.experimental.fbs.EdgeEnd
               */
              outputEdges(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(
                  this.bb.__vector(this.bb_pos + offset) + index * 12,
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              outputEdgesLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startNodeEdge(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number nodeIndex
               */
              static addNodeIndex(builder, nodeIndex) {
                builder.addFieldInt32(0, nodeIndex, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputEdgesOffset
               */
              static addInputEdges(builder, inputEdgesOffset) {
                builder.addFieldOffset(1, inputEdgesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputEdgesVector(builder, numElems) {
                builder.startVector(12, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset outputEdgesOffset
               */
              static addOutputEdges(builder, outputEdgesOffset) {
                builder.addFieldOffset(2, outputEdgesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOutputEdgesVector(builder, numElems) {
                builder.startVector(12, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endNodeEdge(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createNodeEdge(builder, nodeIndex, inputEdgesOffset, outputEdgesOffset) {
                NodeEdge.startNodeEdge(builder);
                NodeEdge.addNodeIndex(builder, nodeIndex);
                NodeEdge.addInputEdges(builder, inputEdgesOffset);
                NodeEdge.addOutputEdges(builder, outputEdgesOffset);
                return NodeEdge.endNodeEdge(builder);
              }
            }
            fbs2.NodeEdge = NodeEdge;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Node2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Node
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Node= obj
               * @returns Node
               */
              static getRootAsNode(bb, obj) {
                return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Node= obj
               * @returns Node
               */
              static getSizePrefixedRootAsNode(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              domain(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              sinceVersion() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * @returns number
               */
              index() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
              }
              opType(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns onnxruntime.experimental.fbs.NodeType
               */
              type() {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* Primitive */;
              }
              executionProviderType(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              inputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              inputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              outputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              outputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Attribute= obj
               * @returns onnxruntime.experimental.fbs.Attribute
               */
              attributes(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Attribute()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              attributesLength() {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @returns number
               */
              inputArgCounts(index) {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              inputArgCountsLength() {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Int32Array
               */
              inputArgCountsArray() {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? new Int32Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              implicitInputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              implicitInputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startNode(builder) {
                builder.startObject(13);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset domainOffset
               */
              static addDomain(builder, domainOffset) {
                builder.addFieldOffset(2, domainOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number sinceVersion
               */
              static addSinceVersion(builder, sinceVersion) {
                builder.addFieldInt32(3, sinceVersion, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number index
               */
              static addIndex(builder, index) {
                builder.addFieldInt32(4, index, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset opTypeOffset
               */
              static addOpType(builder, opTypeOffset) {
                builder.addFieldOffset(5, opTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.NodeType type
               */
              static addType(builder, type) {
                builder.addFieldInt32(6, type, 0 /* Primitive */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset executionProviderTypeOffset
               */
              static addExecutionProviderType(builder, executionProviderTypeOffset) {
                builder.addFieldOffset(7, executionProviderTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputsOffset
               */
              static addInputs(builder, inputsOffset) {
                builder.addFieldOffset(8, inputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createInputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset outputsOffset
               */
              static addOutputs(builder, outputsOffset) {
                builder.addFieldOffset(9, outputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createOutputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOutputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset attributesOffset
               */
              static addAttributes(builder, attributesOffset) {
                builder.addFieldOffset(10, attributesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createAttributesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startAttributesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputArgCountsOffset
               */
              static addInputArgCounts(builder, inputArgCountsOffset) {
                builder.addFieldOffset(11, inputArgCountsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createInputArgCountsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputArgCountsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset implicitInputsOffset
               */
              static addImplicitInputs(builder, implicitInputsOffset) {
                builder.addFieldOffset(12, implicitInputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createImplicitInputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startImplicitInputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endNode(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createNode(builder, nameOffset, docStringOffset, domainOffset, sinceVersion, index, opTypeOffset, type, executionProviderTypeOffset, inputsOffset, outputsOffset, attributesOffset, inputArgCountsOffset, implicitInputsOffset) {
                Node2.startNode(builder);
                Node2.addName(builder, nameOffset);
                Node2.addDocString(builder, docStringOffset);
                Node2.addDomain(builder, domainOffset);
                Node2.addSinceVersion(builder, sinceVersion);
                Node2.addIndex(builder, index);
                Node2.addOpType(builder, opTypeOffset);
                Node2.addType(builder, type);
                Node2.addExecutionProviderType(builder, executionProviderTypeOffset);
                Node2.addInputs(builder, inputsOffset);
                Node2.addOutputs(builder, outputsOffset);
                Node2.addAttributes(builder, attributesOffset);
                Node2.addInputArgCounts(builder, inputArgCountsOffset);
                Node2.addImplicitInputs(builder, implicitInputsOffset);
                return Node2.endNode(builder);
              }
            }
            fbs2.Node = Node2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class ValueInfo {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns ValueInfo
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param ValueInfo= obj
               * @returns ValueInfo
               */
              static getRootAsValueInfo(bb, obj) {
                return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param ValueInfo= obj
               * @returns ValueInfo
               */
              static getSizePrefixedRootAsValueInfo(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.TypeInfo= obj
               * @returns onnxruntime.experimental.fbs.TypeInfo|null
               */
              type(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startValueInfo(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset typeOffset
               */
              static addType(builder, typeOffset) {
                builder.addFieldOffset(2, typeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endValueInfo(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createValueInfo(builder, nameOffset, docStringOffset, typeOffset) {
                ValueInfo.startValueInfo(builder);
                ValueInfo.addName(builder, nameOffset);
                ValueInfo.addDocString(builder, docStringOffset);
                ValueInfo.addType(builder, typeOffset);
                return ValueInfo.endValueInfo(builder);
              }
            }
            fbs2.ValueInfo = ValueInfo;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class TypeInfo {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns TypeInfo
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TypeInfo= obj
               * @returns TypeInfo
               */
              static getRootAsTypeInfo(bb, obj) {
                return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TypeInfo= obj
               * @returns TypeInfo
               */
              static getSizePrefixedRootAsTypeInfo(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              denotation(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns onnxruntime.experimental.fbs.TypeInfoValue
               */
              valueType() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (
                  /**  */
                  this.bb.readUint8(this.bb_pos + offset)
                ) : 0 /* NONE */;
              }
              /**
               * @param flatbuffers.Table obj
               * @returns ?flatbuffers.Table
               */
              value(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTypeInfo(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset denotationOffset
               */
              static addDenotation(builder, denotationOffset) {
                builder.addFieldOffset(0, denotationOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TypeInfoValue valueType
               */
              static addValueType(builder, valueType) {
                builder.addFieldInt8(1, valueType, 0 /* NONE */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueOffset
               */
              static addValue(builder, valueOffset) {
                builder.addFieldOffset(2, valueOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTypeInfo(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTypeInfo(builder, denotationOffset, valueType, valueOffset) {
                TypeInfo.startTypeInfo(builder);
                TypeInfo.addDenotation(builder, denotationOffset);
                TypeInfo.addValueType(builder, valueType);
                TypeInfo.addValue(builder, valueOffset);
                return TypeInfo.endTypeInfo(builder);
              }
            }
            fbs2.TypeInfo = TypeInfo;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class OperatorSetId {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns OperatorSetId
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param OperatorSetId= obj
               * @returns OperatorSetId
               */
              static getRootAsOperatorSetId(bb, obj) {
                return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param OperatorSetId= obj
               * @returns OperatorSetId
               */
              static getSizePrefixedRootAsOperatorSetId(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              domain(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns flatbuffers.Long
               */
              version() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startOperatorSetId(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset domainOffset
               */
              static addDomain(builder, domainOffset) {
                builder.addFieldOffset(0, domainOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long version
               */
              static addVersion(builder, version3) {
                builder.addFieldInt64(1, version3, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endOperatorSetId(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createOperatorSetId(builder, domainOffset, version3) {
                OperatorSetId.startOperatorSetId(builder);
                OperatorSetId.addDomain(builder, domainOffset);
                OperatorSetId.addVersion(builder, version3);
                return OperatorSetId.endOperatorSetId(builder);
              }
            }
            fbs2.OperatorSetId = OperatorSetId;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Tensor4 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Tensor
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Tensor= obj
               * @returns Tensor
               */
              static getRootAsTensor(bb, obj) {
                return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Tensor= obj
               * @returns Tensor
               */
              static getSizePrefixedRootAsTensor(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              dims(index) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              dimsLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns onnxruntime.experimental.fbs.TensorDataType
               */
              dataType() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @param number index
               * @returns number
               */
              rawData(index) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
              }
              /**
               * @returns number
               */
              rawDataLength() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Uint8Array
               */
              rawDataArray() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? new Uint8Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              stringData(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              stringDataLength() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTensor(builder) {
                builder.startObject(6);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimsOffset
               */
              static addDims(builder, dimsOffset) {
                builder.addFieldOffset(2, dimsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createDimsVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDimsVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TensorDataType dataType
               */
              static addDataType(builder, dataType) {
                builder.addFieldInt32(3, dataType, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset rawDataOffset
               */
              static addRawData(builder, rawDataOffset) {
                builder.addFieldOffset(4, rawDataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createRawDataVector(builder, data) {
                builder.startVector(1, data.length, 1);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt8(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startRawDataVector(builder, numElems) {
                builder.startVector(1, numElems, 1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset stringDataOffset
               */
              static addStringData(builder, stringDataOffset) {
                builder.addFieldOffset(5, stringDataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createStringDataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startStringDataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTensor(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTensor(builder, nameOffset, docStringOffset, dimsOffset, dataType, rawDataOffset, stringDataOffset) {
                Tensor4.startTensor(builder);
                Tensor4.addName(builder, nameOffset);
                Tensor4.addDocString(builder, docStringOffset);
                Tensor4.addDims(builder, dimsOffset);
                Tensor4.addDataType(builder, dataType);
                Tensor4.addRawData(builder, rawDataOffset);
                Tensor4.addStringData(builder, stringDataOffset);
                return Tensor4.endTensor(builder);
              }
            }
            fbs2.Tensor = Tensor4;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SparseTensor {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SparseTensor
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SparseTensor= obj
               * @returns SparseTensor
               */
              static getRootAsSparseTensor(bb, obj) {
                return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SparseTensor= obj
               * @returns SparseTensor
               */
              static getSizePrefixedRootAsSparseTensor(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor|null
               */
              values(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor|null
               */
              indices(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              dims(index) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              dimsLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSparseTensor(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valuesOffset
               */
              static addValues(builder, valuesOffset) {
                builder.addFieldOffset(0, valuesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset indicesOffset
               */
              static addIndices(builder, indicesOffset) {
                builder.addFieldOffset(1, indicesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimsOffset
               */
              static addDims(builder, dimsOffset) {
                builder.addFieldOffset(2, dimsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createDimsVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDimsVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSparseTensor(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createSparseTensor(builder, valuesOffset, indicesOffset, dimsOffset) {
                SparseTensor.startSparseTensor(builder);
                SparseTensor.addValues(builder, valuesOffset);
                SparseTensor.addIndices(builder, indicesOffset);
                SparseTensor.addDims(builder, dimsOffset);
                return SparseTensor.endSparseTensor(builder);
              }
            }
            fbs2.SparseTensor = SparseTensor;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Attribute2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Attribute
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Attribute= obj
               * @returns Attribute
               */
              static getRootAsAttribute(bb, obj) {
                return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Attribute= obj
               * @returns Attribute
               */
              static getSizePrefixedRootAsAttribute(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns onnxruntime.experimental.fbs.AttributeType
               */
              type() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @returns number
               */
              f() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0;
              }
              /**
               * @returns flatbuffers.Long
               */
              i() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              s(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor|null
               */
              t(obj) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Graph= obj
               * @returns onnxruntime.experimental.fbs.Graph|null
               */
              g(obj) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param number index
               * @returns number
               */
              floats(index) {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              floatsLength() {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Float32Array
               */
              floatsArray() {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? new Float32Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              ints(index) {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              intsLength() {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              strings(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              stringsLength() {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor
               */
              tensors(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              tensorsLength() {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Graph= obj
               * @returns onnxruntime.experimental.fbs.Graph
               */
              graphs(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              graphsLength() {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startAttribute(builder) {
                builder.startObject(13);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.AttributeType type
               */
              static addType(builder, type) {
                builder.addFieldInt32(2, type, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number f
               */
              static addF(builder, f) {
                builder.addFieldFloat32(3, f, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long i
               */
              static addI(builder, i) {
                builder.addFieldInt64(4, i, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sOffset
               */
              static addS(builder, sOffset) {
                builder.addFieldOffset(5, sOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset tOffset
               */
              static addT(builder, tOffset) {
                builder.addFieldOffset(6, tOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset gOffset
               */
              static addG(builder, gOffset) {
                builder.addFieldOffset(7, gOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset floatsOffset
               */
              static addFloats(builder, floatsOffset) {
                builder.addFieldOffset(8, floatsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createFloatsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addFloat32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startFloatsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset intsOffset
               */
              static addInts(builder, intsOffset) {
                builder.addFieldOffset(9, intsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createIntsVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startIntsVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset stringsOffset
               */
              static addStrings(builder, stringsOffset) {
                builder.addFieldOffset(10, stringsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createStringsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startStringsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset tensorsOffset
               */
              static addTensors(builder, tensorsOffset) {
                builder.addFieldOffset(11, tensorsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createTensorsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startTensorsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphsOffset
               */
              static addGraphs(builder, graphsOffset) {
                builder.addFieldOffset(12, graphsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createGraphsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startGraphsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endAttribute(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createAttribute(builder, nameOffset, docStringOffset, type, f, i, sOffset, tOffset, gOffset, floatsOffset, intsOffset, stringsOffset, tensorsOffset, graphsOffset) {
                Attribute2.startAttribute(builder);
                Attribute2.addName(builder, nameOffset);
                Attribute2.addDocString(builder, docStringOffset);
                Attribute2.addType(builder, type);
                Attribute2.addF(builder, f);
                Attribute2.addI(builder, i);
                Attribute2.addS(builder, sOffset);
                Attribute2.addT(builder, tOffset);
                Attribute2.addG(builder, gOffset);
                Attribute2.addFloats(builder, floatsOffset);
                Attribute2.addInts(builder, intsOffset);
                Attribute2.addStrings(builder, stringsOffset);
                Attribute2.addTensors(builder, tensorsOffset);
                Attribute2.addGraphs(builder, graphsOffset);
                return Attribute2.endAttribute(builder);
              }
            }
            fbs2.Attribute = Attribute2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Graph2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Graph
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Graph= obj
               * @returns Graph
               */
              static getRootAsGraph(bb, obj) {
                return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Graph= obj
               * @returns Graph
               */
              static getSizePrefixedRootAsGraph(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor
               */
              initializers(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              initializersLength() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.ValueInfo= obj
               * @returns onnxruntime.experimental.fbs.ValueInfo
               */
              nodeArgs(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.ValueInfo()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              nodeArgsLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Node= obj
               * @returns onnxruntime.experimental.fbs.Node
               */
              nodes(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Node()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              nodesLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns number
               */
              maxNodeIndex() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.NodeEdge= obj
               * @returns onnxruntime.experimental.fbs.NodeEdge
               */
              nodeEdges(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? (obj || new onnxruntime2.experimental.fbs.NodeEdge()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              nodeEdgesLength() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              inputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              inputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              outputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              outputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.SparseTensor= obj
               * @returns onnxruntime.experimental.fbs.SparseTensor
               */
              sparseInitializers(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SparseTensor()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              sparseInitializersLength() {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startGraph(builder) {
                builder.startObject(8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset initializersOffset
               */
              static addInitializers(builder, initializersOffset) {
                builder.addFieldOffset(0, initializersOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createInitializersVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInitializersVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodeArgsOffset
               */
              static addNodeArgs(builder, nodeArgsOffset) {
                builder.addFieldOffset(1, nodeArgsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createNodeArgsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodeArgsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodesOffset
               */
              static addNodes(builder, nodesOffset) {
                builder.addFieldOffset(2, nodesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createNodesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number maxNodeIndex
               */
              static addMaxNodeIndex(builder, maxNodeIndex) {
                builder.addFieldInt32(3, maxNodeIndex, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodeEdgesOffset
               */
              static addNodeEdges(builder, nodeEdgesOffset) {
                builder.addFieldOffset(4, nodeEdgesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createNodeEdgesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodeEdgesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputsOffset
               */
              static addInputs(builder, inputsOffset) {
                builder.addFieldOffset(5, inputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createInputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset outputsOffset
               */
              static addOutputs(builder, outputsOffset) {
                builder.addFieldOffset(6, outputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createOutputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOutputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sparseInitializersOffset
               */
              static addSparseInitializers(builder, sparseInitializersOffset) {
                builder.addFieldOffset(7, sparseInitializersOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createSparseInitializersVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startSparseInitializersVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endGraph(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createGraph(builder, initializersOffset, nodeArgsOffset, nodesOffset, maxNodeIndex, nodeEdgesOffset, inputsOffset, outputsOffset, sparseInitializersOffset) {
                Graph2.startGraph(builder);
                Graph2.addInitializers(builder, initializersOffset);
                Graph2.addNodeArgs(builder, nodeArgsOffset);
                Graph2.addNodes(builder, nodesOffset);
                Graph2.addMaxNodeIndex(builder, maxNodeIndex);
                Graph2.addNodeEdges(builder, nodeEdgesOffset);
                Graph2.addInputs(builder, inputsOffset);
                Graph2.addOutputs(builder, outputsOffset);
                Graph2.addSparseInitializers(builder, sparseInitializersOffset);
                return Graph2.endGraph(builder);
              }
            }
            fbs2.Graph = Graph2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Model2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Model
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Model= obj
               * @returns Model
               */
              static getRootAsModel(bb, obj) {
                return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Model= obj
               * @returns Model
               */
              static getSizePrefixedRootAsModel(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns flatbuffers.Long
               */
              irVersion() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.OperatorSetId= obj
               * @returns onnxruntime.experimental.fbs.OperatorSetId
               */
              opsetImport(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.OperatorSetId()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              opsetImportLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              producerName(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              producerVersion(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              domain(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns flatbuffers.Long
               */
              modelVersion() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Graph= obj
               * @returns onnxruntime.experimental.fbs.Graph|null
               */
              graph(obj) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              graphDocString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startModel(builder) {
                builder.startObject(9);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long irVersion
               */
              static addIrVersion(builder, irVersion) {
                builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset opsetImportOffset
               */
              static addOpsetImport(builder, opsetImportOffset) {
                builder.addFieldOffset(1, opsetImportOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createOpsetImportVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOpsetImportVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset producerNameOffset
               */
              static addProducerName(builder, producerNameOffset) {
                builder.addFieldOffset(2, producerNameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset producerVersionOffset
               */
              static addProducerVersion(builder, producerVersionOffset) {
                builder.addFieldOffset(3, producerVersionOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset domainOffset
               */
              static addDomain(builder, domainOffset) {
                builder.addFieldOffset(4, domainOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long modelVersion
               */
              static addModelVersion(builder, modelVersion) {
                builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(6, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphOffset
               */
              static addGraph(builder, graphOffset) {
                builder.addFieldOffset(7, graphOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphDocStringOffset
               */
              static addGraphDocString(builder, graphDocStringOffset) {
                builder.addFieldOffset(8, graphDocStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endModel(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createModel(builder, irVersion, opsetImportOffset, producerNameOffset, producerVersionOffset, domainOffset, modelVersion, docStringOffset, graphOffset, graphDocStringOffset) {
                Model2.startModel(builder);
                Model2.addIrVersion(builder, irVersion);
                Model2.addOpsetImport(builder, opsetImportOffset);
                Model2.addProducerName(builder, producerNameOffset);
                Model2.addProducerVersion(builder, producerVersionOffset);
                Model2.addDomain(builder, domainOffset);
                Model2.addModelVersion(builder, modelVersion);
                Model2.addDocString(builder, docStringOffset);
                Model2.addGraph(builder, graphOffset);
                Model2.addGraphDocString(builder, graphDocStringOffset);
                return Model2.endModel(builder);
              }
            }
            fbs2.Model = Model2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class KernelCreateInfos {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns KernelCreateInfos
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param KernelCreateInfos= obj
               * @returns KernelCreateInfos
               */
              static getRootAsKernelCreateInfos(bb, obj) {
                return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param KernelCreateInfos= obj
               * @returns KernelCreateInfos
               */
              static getSizePrefixedRootAsKernelCreateInfos(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param number index
               * @returns number
               */
              nodeIndices(index) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              nodeIndicesLength() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Uint32Array
               */
              nodeIndicesArray() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? new Uint32Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              kernelDefHashes(index) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              kernelDefHashesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startKernelCreateInfos(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodeIndicesOffset
               */
              static addNodeIndices(builder, nodeIndicesOffset) {
                builder.addFieldOffset(0, nodeIndicesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createNodeIndicesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodeIndicesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset kernelDefHashesOffset
               */
              static addKernelDefHashes(builder, kernelDefHashesOffset) {
                builder.addFieldOffset(1, kernelDefHashesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createKernelDefHashesVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startKernelDefHashesVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endKernelCreateInfos(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createKernelCreateInfos(builder, nodeIndicesOffset, kernelDefHashesOffset) {
                KernelCreateInfos.startKernelCreateInfos(builder);
                KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);
                KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);
                return KernelCreateInfos.endKernelCreateInfos(builder);
              }
            }
            fbs2.KernelCreateInfos = KernelCreateInfos;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SubGraphSessionState {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SubGraphSessionState
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SubGraphSessionState= obj
               * @returns SubGraphSessionState
               */
              static getRootAsSubGraphSessionState(bb, obj) {
                return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SubGraphSessionState= obj
               * @returns SubGraphSessionState
               */
              static getSizePrefixedRootAsSubGraphSessionState(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              graphId(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.SessionState= obj
               * @returns onnxruntime.experimental.fbs.SessionState|null
               */
              sessionState(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSubGraphSessionState(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphIdOffset
               */
              static addGraphId(builder, graphIdOffset) {
                builder.addFieldOffset(0, graphIdOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sessionStateOffset
               */
              static addSessionState(builder, sessionStateOffset) {
                builder.addFieldOffset(1, sessionStateOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSubGraphSessionState(builder) {
                let offset = builder.endObject();
                builder.requiredField(offset, 4);
                return offset;
              }
              static createSubGraphSessionState(builder, graphIdOffset, sessionStateOffset) {
                SubGraphSessionState.startSubGraphSessionState(builder);
                SubGraphSessionState.addGraphId(builder, graphIdOffset);
                SubGraphSessionState.addSessionState(builder, sessionStateOffset);
                return SubGraphSessionState.endSubGraphSessionState(builder);
              }
            }
            fbs2.SubGraphSessionState = SubGraphSessionState;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SessionState {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SessionState
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SessionState= obj
               * @returns SessionState
               */
              static getRootAsSessionState(bb, obj) {
                return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SessionState= obj
               * @returns SessionState
               */
              static getSizePrefixedRootAsSessionState(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj
               * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null
               */
              kernels(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.KernelCreateInfos()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj
               * @returns onnxruntime.experimental.fbs.SubGraphSessionState
               */
              subGraphSessionStates(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SubGraphSessionState()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              subGraphSessionStatesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSessionState(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset kernelsOffset
               */
              static addKernels(builder, kernelsOffset) {
                builder.addFieldOffset(0, kernelsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset subGraphSessionStatesOffset
               */
              static addSubGraphSessionStates(builder, subGraphSessionStatesOffset) {
                builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createSubGraphSessionStatesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startSubGraphSessionStatesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSessionState(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createSessionState(builder, kernelsOffset, subGraphSessionStatesOffset) {
                SessionState.startSessionState(builder);
                SessionState.addKernels(builder, kernelsOffset);
                SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);
                return SessionState.endSessionState(builder);
              }
            }
            fbs2.SessionState = SessionState;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class InferenceSession7 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns InferenceSession
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param InferenceSession= obj
               * @returns InferenceSession
               */
              static getRootAsInferenceSession(bb, obj) {
                return (obj || new InferenceSession7()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param InferenceSession= obj
               * @returns InferenceSession
               */
              static getSizePrefixedRootAsInferenceSession(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new InferenceSession7()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @returns boolean
               */
              static bufferHasIdentifier(bb) {
                return bb.__has_identifier("ORTM");
              }
              ortVersion(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Model= obj
               * @returns onnxruntime.experimental.fbs.Model|null
               */
              model(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.SessionState= obj
               * @returns onnxruntime.experimental.fbs.SessionState|null
               */
              sessionState(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startInferenceSession(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset ortVersionOffset
               */
              static addOrtVersion(builder, ortVersionOffset) {
                builder.addFieldOffset(0, ortVersionOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset modelOffset
               */
              static addModel(builder, modelOffset) {
                builder.addFieldOffset(1, modelOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sessionStateOffset
               */
              static addSessionState(builder, sessionStateOffset) {
                builder.addFieldOffset(2, sessionStateOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endInferenceSession(builder) {
                let offset = builder.endObject();
                return offset;
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishInferenceSessionBuffer(builder, offset) {
                builder.finish(offset, "ORTM");
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishSizePrefixedInferenceSessionBuffer(builder, offset) {
                builder.finish(offset, "ORTM", true);
              }
              static createInferenceSession(builder, ortVersionOffset, modelOffset, sessionStateOffset) {
                InferenceSession7.startInferenceSession(builder);
                InferenceSession7.addOrtVersion(builder, ortVersionOffset);
                InferenceSession7.addModel(builder, modelOffset);
                InferenceSession7.addSessionState(builder, sessionStateOffset);
                return InferenceSession7.endInferenceSession(builder);
              }
            }
            fbs2.InferenceSession = InferenceSession7;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
    }
  });

  // web/node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "web/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
        while (index < arguments.length)
          params[offset++] = arguments[index++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // web/node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "web/node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      var base64 = exports2;
      base64.length = function length(string) {
        var p = string.length;
        if (!p)
          return 0;
        var n = 0;
        while (--p % 4 > 1 && string.charAt(p) === "=")
          ++n;
        return Math.ceil(string.length * 3) / 4 - n;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i = 0; i < 64; )
        s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
      var i;
      base64.encode = function encode(buffer, start, end) {
        var parts = null, chunk = [];
        var i2 = 0, j = 0, t;
        while (start < end) {
          var b = buffer[start++];
          switch (j) {
            case 0:
              chunk[i2++] = b64[b >> 2];
              t = (b & 3) << 4;
              j = 1;
              break;
            case 1:
              chunk[i2++] = b64[t | b >> 4];
              t = (b & 15) << 2;
              j = 2;
              break;
            case 2:
              chunk[i2++] = b64[t | b >> 6];
              chunk[i2++] = b64[b & 63];
              j = 0;
              break;
          }
          if (i2 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i2 = 0;
          }
        }
        if (j) {
          chunk[i2++] = b64[t];
          chunk[i2++] = 61;
          if (j === 1)
            chunk[i2++] = 61;
        }
        if (parts) {
          if (i2)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i2));
      };
      var invalidEncoding = "invalid encoding";
      base64.decode = function decode(string, buffer, offset) {
        var start = offset;
        var j = 0, t;
        for (var i2 = 0; i2 < string.length; ) {
          var c = string.charCodeAt(i2++);
          if (c === 61 && j > 1)
            break;
          if ((c = s64[c]) === void 0)
            throw Error(invalidEncoding);
          switch (j) {
            case 0:
              t = c;
              j = 1;
              break;
            case 1:
              buffer[offset++] = t << 2 | (c & 48) >> 4;
              t = c;
              j = 2;
              break;
            case 2:
              buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
              t = c;
              j = 3;
              break;
            case 3:
              buffer[offset++] = (t & 3) << 6 | c;
              j = 0;
              break;
          }
        }
        if (j === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base64.test = function test(string) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
      };
    }
  });

  // web/node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "web/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      module2.exports = EventEmitter;
      function EventEmitter() {
        this._listeners = {};
      }
      EventEmitter.prototype.on = function on(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter.prototype.off = function off(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length; )
              if (listeners[i].fn === fn)
                listeners.splice(i, 1);
              else
                ++i;
          }
        }
        return this;
      };
      EventEmitter.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [], i = 1;
          for (; i < arguments.length; )
            args.push(arguments[i++]);
          for (i = 0; i < listeners.length; )
            listeners[i].fn.apply(listeners[i++].ctx, args);
        }
        return this;
      };
    }
  });

  // web/node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "web/node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined")
          (function() {
            var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
            function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
            }
            function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
            }
            exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
            exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
            function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
            }
            function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
            }
            exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
            exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
          })();
        else
          (function() {
            function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0)
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf, pos);
              else if (isNaN(val))
                writeUint(2143289344, buf, pos);
              else if (val > 34028234663852886e22)
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 11754943508222875e-54)
                writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
            }
            exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
            function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }
            exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();
        if (typeof Float64Array !== "undefined")
          (function() {
            var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
            function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
            }
            function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
            }
            exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
            exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
            function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
            }
            function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
            }
            exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
            exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
          })();
        else
          (function() {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
              } else if (val > 17976931348623157e292) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                var mantissa;
                if (val < 22250738585072014e-324) {
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024)
                    exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
              }
            }
            exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
            function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }
            exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
        return exports3;
      }
      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = val >>> 16 & 255;
        buf[pos + 2] = val >>> 8 & 255;
        buf[pos + 3] = val & 255;
      }
      function readUintLE(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf, pos) {
        return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
      }
    }
  });

  // web/node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "web/node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e) {
        }
        return null;
      }
    }
  });

  // web/node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "web/node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      var utf8 = exports2;
      utf8.length = function utf8_length(string) {
        var len = 0, c = 0;
        for (var i = 0; i < string.length; ++i) {
          c = string.charCodeAt(i);
          if (c < 128)
            len += 1;
          else if (c < 2048)
            len += 2;
          else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
            ++i;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf8.read = function utf8_read(buffer, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i = 0, t;
        while (start < end) {
          t = buffer[start++];
          if (t < 128)
            chunk[i++] = t;
          else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
          else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
            chunk[i++] = 55296 + (t >> 10);
            chunk[i++] = 56320 + (t & 1023);
          } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
          }
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };
      utf8.write = function utf8_write(string, buffer, offset) {
        var start = offset, c1, c2;
        for (var i = 0; i < string.length; ++i) {
          c1 = string.charCodeAt(i);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // web/node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "web/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      module2.exports = pool;
      function pool(alloc, slice2, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX)
            return alloc(size2);
          if (offset + size2 > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
          }
          var buf = slice2.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf;
        };
      }
    }
  });

  // web/node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "web/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      module2.exports = LongBits;
      var util = require_minimal();
      function LongBits(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero = LongBits.zero = new LongBits(0, 0);
      zero.toNumber = function() {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function() {
        return this;
      };
      zero.length = function() {
        return 1;
      };
      var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits.fromNumber = function fromNumber2(value) {
        if (value === 0)
          return zero;
        var sign = value < 0;
        if (sign)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };
      LongBits.from = function from(value) {
        if (typeof value === "number")
          return LongBits.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
      };
      LongBits.prototype.toNumber = function toNumber2(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits.fromHash = function fromHash(hash) {
        if (hash === zeroHash)
          return zero;
        return new LongBits(
          (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
          (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
        );
      };
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.length = function length() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // web/node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "web/node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      var util = exports2;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util.emptyArray = Object.freeze ? Object.freeze([]) : (
        /* istanbul ignore next */
        []
      );
      util.emptyObject = Object.freeze ? Object.freeze({}) : (
        /* istanbul ignore next */
        {}
      );
      util.isInteger = Number.isInteger || /* istanbul ignore next */
      function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject(value) {
        return value && typeof value === "object";
      };
      util.isset = /**
       * Checks if a property on a message is considered to be present.
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = function() {
        try {
          var Buffer2 = util.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : (
            /* istanbul ignore next */
            null
          );
        } catch (e) {
          return null;
        }
      }();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash, unsigned) {
        var bits = util.LongBits.fromHash(hash);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge(dst, src, ifNotSet) {
        for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === void 0 || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
        return dst;
      }
      util.merge = merge;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name2) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get() {
              return name2;
            },
            set: void 0,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i = 0; i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;
        return function() {
          for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
            if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
              return keys[i2];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name2) {
          for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name2)
              delete this[fieldNames[i]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer2 = util.Buffer;
        if (!Buffer2) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
        function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    }
  });

  // web/node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "web/node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits = util.LongBits;
      var base64 = util.base64;
      var utf8 = util.utf8;
      function Op(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop() {
      }
      function State(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op(noop, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create = function create2() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create();
      Writer.alloc = function alloc(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte(val, buf, pos) {
        buf[pos] = val & 255;
      }
      function writeVarint32(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }
      function VarintOp(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint64(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };
      function writeFixed32(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
          buf[pos + i] = val[i];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte, 1, 0);
        if (util.isString(value)) {
          var buf = Writer.alloc(len = base64.length(value));
          base64.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create();
        BufferWriter._configure();
      };
    }
  });

  // web/node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "web/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy)
            val.copy(buf, pos, 0, val.length);
          else
            for (var i = 0; i < val.length; )
              buf[pos++] = val[i++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer(val, buf, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf, pos);
        else if (buf.utf8Write)
          buf.utf8Write(val, pos);
        else
          buf.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // web/node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "web/node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits = util.LongBits;
      var utf8 = util.utf8;
      function indexOutOfRange(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer) {
        this.buf = buffer;
        this.pos = 0;
        this.len = buffer.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      } : function create_array2(buffer) {
        if (Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      };
      var create = function create2() {
        return util.Buffer ? function create_buffer_setup(buffer) {
          return (Reader.create = function create_buffer(buffer2) {
            return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
          })(buffer);
        } : create_array;
      };
      Reader.create = create();
      Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
      util.Array.prototype.slice;
      Reader.prototype.uint32 = function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits(0, 0);
        var i = 0;
        if (this.len - this.pos > 4) {
          for (; i < 4; ++i) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i = 0;
        } else {
          for (; i < 3; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i < 5; ++i) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i < 5; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf, end) {
        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length = this.uint32(), start = this.pos, end = this.pos + length;
        if (end > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        if (start === end) {
          var nativeBuffer = util.Buffer;
          return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf8.read(bytes, 0, bytes.length);
      };
      Reader.prototype.skip = function skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : (
          /* istanbul ignore next */
          "toNumber"
        );
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // web/node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "web/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer) {
        Reader.call(this, buffer);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // web/node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "web/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(
                  /* endedByRPC */
                  true
                );
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // web/node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "web/node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      var rpc = exports2;
      rpc.Service = require_service();
    }
  });

  // web/node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "web/node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      module2.exports = {};
    }
  });

  // web/node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "web/node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      var protobuf = exports2;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure;
      function configure() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure();
    }
  });

  // web/node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "web/node_modules/protobufjs/minimal.js"(exports2, module2) {
      "use strict";
      module2.exports = require_index_minimal();
    }
  });

  // web/lib/onnxjs/ort-schema/protobuf/onnx.js
  var require_onnx = __commonJS({
    "web/lib/onnxjs/ort-schema/protobuf/onnx.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.onnx = function() {
        var onnx6 = {};
        onnx6.Version = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "_START_VERSION"] = 0;
          values[valuesById[1] = "IR_VERSION_2017_10_10"] = 1;
          values[valuesById[2] = "IR_VERSION_2017_10_30"] = 2;
          values[valuesById[3] = "IR_VERSION_2017_11_3"] = 3;
          values[valuesById[4] = "IR_VERSION_2019_1_22"] = 4;
          values[valuesById[5] = "IR_VERSION_2019_3_18"] = 5;
          values[valuesById[6] = "IR_VERSION_2019_9_19"] = 6;
          values[valuesById[7] = "IR_VERSION_2020_5_8"] = 7;
          values[valuesById[8] = "IR_VERSION_2021_7_30"] = 8;
          values[valuesById[9] = "IR_VERSION"] = 9;
          return values;
        }();
        onnx6.AttributeProto = function() {
          function AttributeProto(properties) {
            this.floats = [];
            this.ints = [];
            this.strings = [];
            this.tensors = [];
            this.graphs = [];
            this.sparseTensors = [];
            this.typeProtos = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          AttributeProto.prototype.name = "";
          AttributeProto.prototype.refAttrName = "";
          AttributeProto.prototype.docString = "";
          AttributeProto.prototype.type = 0;
          AttributeProto.prototype.f = 0;
          AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AttributeProto.prototype.s = $util.newBuffer([]);
          AttributeProto.prototype.t = null;
          AttributeProto.prototype.g = null;
          AttributeProto.prototype.sparseTensor = null;
          AttributeProto.prototype.tp = null;
          AttributeProto.prototype.floats = $util.emptyArray;
          AttributeProto.prototype.ints = $util.emptyArray;
          AttributeProto.prototype.strings = $util.emptyArray;
          AttributeProto.prototype.tensors = $util.emptyArray;
          AttributeProto.prototype.graphs = $util.emptyArray;
          AttributeProto.prototype.sparseTensors = $util.emptyArray;
          AttributeProto.prototype.typeProtos = $util.emptyArray;
          AttributeProto.create = function create(properties) {
            return new AttributeProto(properties);
          };
          AttributeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.name);
            if (message.f != null && Object.hasOwnProperty.call(message, "f"))
              writer.uint32(
                /* id 2, wireType 5 =*/
                21
              ).float(message.f);
            if (message.i != null && Object.hasOwnProperty.call(message, "i"))
              writer.uint32(
                /* id 3, wireType 0 =*/
                24
              ).int64(message.i);
            if (message.s != null && Object.hasOwnProperty.call(message, "s"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).bytes(message.s);
            if (message.t != null && Object.hasOwnProperty.call(message, "t"))
              $root.onnx.TensorProto.encode(message.t, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
              $root.onnx.GraphProto.encode(message.g, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            if (message.floats != null && message.floats.length) {
              writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork();
              for (var i = 0; i < message.floats.length; ++i)
                writer.float(message.floats[i]);
              writer.ldelim();
            }
            if (message.ints != null && message.ints.length) {
              writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).fork();
              for (var i = 0; i < message.ints.length; ++i)
                writer.int64(message.ints[i]);
              writer.ldelim();
            }
            if (message.strings != null && message.strings.length)
              for (var i = 0; i < message.strings.length; ++i)
                writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).bytes(message.strings[i]);
            if (message.tensors != null && message.tensors.length)
              for (var i = 0; i < message.tensors.length; ++i)
                $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).fork()).ldelim();
            if (message.graphs != null && message.graphs.length)
              for (var i = 0; i < message.graphs.length; ++i)
                $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(
                  /* id 11, wireType 2 =*/
                  90
                ).fork()).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).string(message.docString);
            if (message.tp != null && Object.hasOwnProperty.call(message, "tp"))
              $root.onnx.TypeProto.encode(message.tp, writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).fork()).ldelim();
            if (message.typeProtos != null && message.typeProtos.length)
              for (var i = 0; i < message.typeProtos.length; ++i)
                $root.onnx.TypeProto.encode(
                  message.typeProtos[i],
                  writer.uint32(
                    /* id 15, wireType 2 =*/
                    122
                  ).fork()
                ).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
              writer.uint32(
                /* id 20, wireType 0 =*/
                160
              ).int32(message.type);
            if (message.refAttrName != null && Object.hasOwnProperty.call(message, "refAttrName"))
              writer.uint32(
                /* id 21, wireType 2 =*/
                170
              ).string(message.refAttrName);
            if (message.sparseTensor != null && Object.hasOwnProperty.call(message, "sparseTensor"))
              $root.onnx.SparseTensorProto.encode(
                message.sparseTensor,
                writer.uint32(
                  /* id 22, wireType 2 =*/
                  178
                ).fork()
              ).ldelim();
            if (message.sparseTensors != null && message.sparseTensors.length)
              for (var i = 0; i < message.sparseTensors.length; ++i)
                $root.onnx.SparseTensorProto.encode(
                  message.sparseTensors[i],
                  writer.uint32(
                    /* id 23, wireType 2 =*/
                    186
                  ).fork()
                ).ldelim();
            return writer;
          };
          AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          AttributeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 21: {
                  message.refAttrName = reader.string();
                  break;
                }
                case 13: {
                  message.docString = reader.string();
                  break;
                }
                case 20: {
                  message.type = reader.int32();
                  break;
                }
                case 2: {
                  message.f = reader.float();
                  break;
                }
                case 3: {
                  message.i = reader.int64();
                  break;
                }
                case 4: {
                  message.s = reader.bytes();
                  break;
                }
                case 5: {
                  message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 6: {
                  message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 22: {
                  message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 14: {
                  message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                case 7: {
                  if (!(message.floats && message.floats.length))
                    message.floats = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.floats.push(reader.float());
                  } else
                    message.floats.push(reader.float());
                  break;
                }
                case 8: {
                  if (!(message.ints && message.ints.length))
                    message.ints = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.ints.push(reader.int64());
                  } else
                    message.ints.push(reader.int64());
                  break;
                }
                case 9: {
                  if (!(message.strings && message.strings.length))
                    message.strings = [];
                  message.strings.push(reader.bytes());
                  break;
                }
                case 10: {
                  if (!(message.tensors && message.tensors.length))
                    message.tensors = [];
                  message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 11: {
                  if (!(message.graphs && message.graphs.length))
                    message.graphs = [];
                  message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));
                  break;
                }
                case 23: {
                  if (!(message.sparseTensors && message.sparseTensors.length))
                    message.sparseTensors = [];
                  message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 15: {
                  if (!(message.typeProtos && message.typeProtos.length))
                    message.typeProtos = [];
                  message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          AttributeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          AttributeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName")) {
              if (!$util.isString(message.refAttrName))
                return "refAttrName: string expected";
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.type != null && message.hasOwnProperty("type"))
              switch (message.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 11:
                case 13:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 14:
                  break;
              }
            if (message.f != null && message.hasOwnProperty("f")) {
              if (typeof message.f !== "number")
                return "f: number expected";
            }
            if (message.i != null && message.hasOwnProperty("i")) {
              if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
                return "i: integer|Long expected";
            }
            if (message.s != null && message.hasOwnProperty("s")) {
              if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                return "s: buffer expected";
            }
            if (message.t != null && message.hasOwnProperty("t")) {
              var error = $root.onnx.TensorProto.verify(message.t);
              if (error)
                return "t." + error;
            }
            if (message.g != null && message.hasOwnProperty("g")) {
              var error = $root.onnx.GraphProto.verify(message.g);
              if (error)
                return "g." + error;
            }
            if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor")) {
              var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);
              if (error)
                return "sparseTensor." + error;
            }
            if (message.tp != null && message.hasOwnProperty("tp")) {
              var error = $root.onnx.TypeProto.verify(message.tp);
              if (error)
                return "tp." + error;
            }
            if (message.floats != null && message.hasOwnProperty("floats")) {
              if (!Array.isArray(message.floats))
                return "floats: array expected";
              for (var i = 0; i < message.floats.length; ++i)
                if (typeof message.floats[i] !== "number")
                  return "floats: number[] expected";
            }
            if (message.ints != null && message.hasOwnProperty("ints")) {
              if (!Array.isArray(message.ints))
                return "ints: array expected";
              for (var i = 0; i < message.ints.length; ++i)
                if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))
                  return "ints: integer|Long[] expected";
            }
            if (message.strings != null && message.hasOwnProperty("strings")) {
              if (!Array.isArray(message.strings))
                return "strings: array expected";
              for (var i = 0; i < message.strings.length; ++i)
                if (!(message.strings[i] && typeof message.strings[i].length === "number" || $util.isString(message.strings[i])))
                  return "strings: buffer[] expected";
            }
            if (message.tensors != null && message.hasOwnProperty("tensors")) {
              if (!Array.isArray(message.tensors))
                return "tensors: array expected";
              for (var i = 0; i < message.tensors.length; ++i) {
                var error = $root.onnx.TensorProto.verify(message.tensors[i]);
                if (error)
                  return "tensors." + error;
              }
            }
            if (message.graphs != null && message.hasOwnProperty("graphs")) {
              if (!Array.isArray(message.graphs))
                return "graphs: array expected";
              for (var i = 0; i < message.graphs.length; ++i) {
                var error = $root.onnx.GraphProto.verify(message.graphs[i]);
                if (error)
                  return "graphs." + error;
              }
            }
            if (message.sparseTensors != null && message.hasOwnProperty("sparseTensors")) {
              if (!Array.isArray(message.sparseTensors))
                return "sparseTensors: array expected";
              for (var i = 0; i < message.sparseTensors.length; ++i) {
                var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);
                if (error)
                  return "sparseTensors." + error;
              }
            }
            if (message.typeProtos != null && message.hasOwnProperty("typeProtos")) {
              if (!Array.isArray(message.typeProtos))
                return "typeProtos: array expected";
              for (var i = 0; i < message.typeProtos.length; ++i) {
                var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);
                if (error)
                  return "typeProtos." + error;
              }
            }
            return null;
          };
          AttributeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.AttributeProto)
              return object;
            var message = new $root.onnx.AttributeProto();
            if (object.name != null)
              message.name = String(object.name);
            if (object.refAttrName != null)
              message.refAttrName = String(object.refAttrName);
            if (object.docString != null)
              message.docString = String(object.docString);
            switch (object.type) {
              default:
                if (typeof object.type === "number") {
                  message.type = object.type;
                  break;
                }
                break;
              case "UNDEFINED":
              case 0:
                message.type = 0;
                break;
              case "FLOAT":
              case 1:
                message.type = 1;
                break;
              case "INT":
              case 2:
                message.type = 2;
                break;
              case "STRING":
              case 3:
                message.type = 3;
                break;
              case "TENSOR":
              case 4:
                message.type = 4;
                break;
              case "GRAPH":
              case 5:
                message.type = 5;
                break;
              case "SPARSE_TENSOR":
              case 11:
                message.type = 11;
                break;
              case "TYPE_PROTO":
              case 13:
                message.type = 13;
                break;
              case "FLOATS":
              case 6:
                message.type = 6;
                break;
              case "INTS":
              case 7:
                message.type = 7;
                break;
              case "STRINGS":
              case 8:
                message.type = 8;
                break;
              case "TENSORS":
              case 9:
                message.type = 9;
                break;
              case "GRAPHS":
              case 10:
                message.type = 10;
                break;
              case "SPARSE_TENSORS":
              case 12:
                message.type = 12;
                break;
              case "TYPE_PROTOS":
              case 14:
                message.type = 14;
                break;
            }
            if (object.f != null)
              message.f = Number(object.f);
            if (object.i != null) {
              if ($util.Long)
                (message.i = $util.Long.fromValue(object.i)).unsigned = false;
              else if (typeof object.i === "string")
                message.i = parseInt(object.i, 10);
              else if (typeof object.i === "number")
                message.i = object.i;
              else if (typeof object.i === "object")
                message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
            }
            if (object.s != null) {
              if (typeof object.s === "string")
                $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
              else if (object.s.length >= 0)
                message.s = object.s;
            }
            if (object.t != null) {
              if (typeof object.t !== "object")
                throw TypeError(".onnx.AttributeProto.t: object expected");
              message.t = $root.onnx.TensorProto.fromObject(object.t);
            }
            if (object.g != null) {
              if (typeof object.g !== "object")
                throw TypeError(".onnx.AttributeProto.g: object expected");
              message.g = $root.onnx.GraphProto.fromObject(object.g);
            }
            if (object.sparseTensor != null) {
              if (typeof object.sparseTensor !== "object")
                throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
              message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);
            }
            if (object.tp != null) {
              if (typeof object.tp !== "object")
                throw TypeError(".onnx.AttributeProto.tp: object expected");
              message.tp = $root.onnx.TypeProto.fromObject(object.tp);
            }
            if (object.floats) {
              if (!Array.isArray(object.floats))
                throw TypeError(".onnx.AttributeProto.floats: array expected");
              message.floats = [];
              for (var i = 0; i < object.floats.length; ++i)
                message.floats[i] = Number(object.floats[i]);
            }
            if (object.ints) {
              if (!Array.isArray(object.ints))
                throw TypeError(".onnx.AttributeProto.ints: array expected");
              message.ints = [];
              for (var i = 0; i < object.ints.length; ++i)
                if ($util.Long)
                  (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;
                else if (typeof object.ints[i] === "string")
                  message.ints[i] = parseInt(object.ints[i], 10);
                else if (typeof object.ints[i] === "number")
                  message.ints[i] = object.ints[i];
                else if (typeof object.ints[i] === "object")
                  message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();
            }
            if (object.strings) {
              if (!Array.isArray(object.strings))
                throw TypeError(".onnx.AttributeProto.strings: array expected");
              message.strings = [];
              for (var i = 0; i < object.strings.length; ++i)
                if (typeof object.strings[i] === "string")
                  $util.base64.decode(
                    object.strings[i],
                    message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])),
                    0
                  );
                else if (object.strings[i].length >= 0)
                  message.strings[i] = object.strings[i];
            }
            if (object.tensors) {
              if (!Array.isArray(object.tensors))
                throw TypeError(".onnx.AttributeProto.tensors: array expected");
              message.tensors = [];
              for (var i = 0; i < object.tensors.length; ++i) {
                if (typeof object.tensors[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.tensors: object expected");
                message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);
              }
            }
            if (object.graphs) {
              if (!Array.isArray(object.graphs))
                throw TypeError(".onnx.AttributeProto.graphs: array expected");
              message.graphs = [];
              for (var i = 0; i < object.graphs.length; ++i) {
                if (typeof object.graphs[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.graphs: object expected");
                message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);
              }
            }
            if (object.sparseTensors) {
              if (!Array.isArray(object.sparseTensors))
                throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
              message.sparseTensors = [];
              for (var i = 0; i < object.sparseTensors.length; ++i) {
                if (typeof object.sparseTensors[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
                message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);
              }
            }
            if (object.typeProtos) {
              if (!Array.isArray(object.typeProtos))
                throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
              message.typeProtos = [];
              for (var i = 0; i < object.typeProtos.length; ++i) {
                if (typeof object.typeProtos[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
                message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);
              }
            }
            return message;
          };
          AttributeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.floats = [];
              object.ints = [];
              object.strings = [];
              object.tensors = [];
              object.graphs = [];
              object.typeProtos = [];
              object.sparseTensors = [];
            }
            if (options.defaults) {
              object.name = "";
              object.f = 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.i = options.longs === String ? "0" : 0;
              if (options.bytes === String)
                object.s = "";
              else {
                object.s = [];
                if (options.bytes !== Array)
                  object.s = $util.newBuffer(object.s);
              }
              object.t = null;
              object.g = null;
              object.docString = "";
              object.tp = null;
              object.type = options.enums === String ? "UNDEFINED" : 0;
              object.refAttrName = "";
              object.sparseTensor = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.f != null && message.hasOwnProperty("f"))
              object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
            if (message.i != null && message.hasOwnProperty("i"))
              if (typeof message.i === "number")
                object.i = options.longs === String ? String(message.i) : message.i;
              else
                object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
            if (message.s != null && message.hasOwnProperty("s"))
              object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
            if (message.t != null && message.hasOwnProperty("t"))
              object.t = $root.onnx.TensorProto.toObject(message.t, options);
            if (message.g != null && message.hasOwnProperty("g"))
              object.g = $root.onnx.GraphProto.toObject(message.g, options);
            if (message.floats && message.floats.length) {
              object.floats = [];
              for (var j = 0; j < message.floats.length; ++j)
                object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];
            }
            if (message.ints && message.ints.length) {
              object.ints = [];
              for (var j = 0; j < message.ints.length; ++j)
                if (typeof message.ints[j] === "number")
                  object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];
                else
                  object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];
            }
            if (message.strings && message.strings.length) {
              object.strings = [];
              for (var j = 0; j < message.strings.length; ++j)
                object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];
            }
            if (message.tensors && message.tensors.length) {
              object.tensors = [];
              for (var j = 0; j < message.tensors.length; ++j)
                object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);
            }
            if (message.graphs && message.graphs.length) {
              object.graphs = [];
              for (var j = 0; j < message.graphs.length; ++j)
                object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.tp != null && message.hasOwnProperty("tp"))
              object.tp = $root.onnx.TypeProto.toObject(message.tp, options);
            if (message.typeProtos && message.typeProtos.length) {
              object.typeProtos = [];
              for (var j = 0; j < message.typeProtos.length; ++j)
                object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
              object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] === void 0 ? message.type : $root.onnx.AttributeProto.AttributeType[message.type] : message.type;
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
              object.refAttrName = message.refAttrName;
            if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor"))
              object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);
            if (message.sparseTensors && message.sparseTensors.length) {
              object.sparseTensors = [];
              for (var j = 0; j < message.sparseTensors.length; ++j)
                object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);
            }
            return object;
          };
          AttributeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.AttributeProto";
          };
          AttributeProto.AttributeType = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "INT"] = 2;
            values[valuesById[3] = "STRING"] = 3;
            values[valuesById[4] = "TENSOR"] = 4;
            values[valuesById[5] = "GRAPH"] = 5;
            values[valuesById[11] = "SPARSE_TENSOR"] = 11;
            values[valuesById[13] = "TYPE_PROTO"] = 13;
            values[valuesById[6] = "FLOATS"] = 6;
            values[valuesById[7] = "INTS"] = 7;
            values[valuesById[8] = "STRINGS"] = 8;
            values[valuesById[9] = "TENSORS"] = 9;
            values[valuesById[10] = "GRAPHS"] = 10;
            values[valuesById[12] = "SPARSE_TENSORS"] = 12;
            values[valuesById[14] = "TYPE_PROTOS"] = 14;
            return values;
          }();
          return AttributeProto;
        }();
        onnx6.ValueInfoProto = function() {
          function ValueInfoProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ValueInfoProto.prototype.name = "";
          ValueInfoProto.prototype.type = null;
          ValueInfoProto.prototype.docString = "";
          ValueInfoProto.create = function create(properties) {
            return new ValueInfoProto(properties);
          };
          ValueInfoProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
              $root.onnx.TypeProto.encode(message.type, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.docString);
            return writer;
          };
          ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ValueInfoProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 2: {
                  message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  message.docString = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ValueInfoProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.type != null && message.hasOwnProperty("type")) {
              var error = $root.onnx.TypeProto.verify(message.type);
              if (error)
                return "type." + error;
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            return null;
          };
          ValueInfoProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ValueInfoProto)
              return object;
            var message = new $root.onnx.ValueInfoProto();
            if (object.name != null)
              message.name = String(object.name);
            if (object.type != null) {
              if (typeof object.type !== "object")
                throw TypeError(".onnx.ValueInfoProto.type: object expected");
              message.type = $root.onnx.TypeProto.fromObject(object.type);
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            return message;
          };
          ValueInfoProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.name = "";
              object.type = null;
              object.docString = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
              object.type = $root.onnx.TypeProto.toObject(message.type, options);
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            return object;
          };
          ValueInfoProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.ValueInfoProto";
          };
          return ValueInfoProto;
        }();
        onnx6.NodeProto = function() {
          function NodeProto(properties) {
            this.input = [];
            this.output = [];
            this.attribute = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          NodeProto.prototype.input = $util.emptyArray;
          NodeProto.prototype.output = $util.emptyArray;
          NodeProto.prototype.name = "";
          NodeProto.prototype.opType = "";
          NodeProto.prototype.domain = "";
          NodeProto.prototype.attribute = $util.emptyArray;
          NodeProto.prototype.docString = "";
          NodeProto.create = function create(properties) {
            return new NodeProto(properties);
          };
          NodeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.input != null && message.input.length)
              for (var i = 0; i < message.input.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.input[i]);
            if (message.output != null && message.output.length)
              for (var i = 0; i < message.output.length; ++i)
                writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.output[i]);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.name);
            if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.opType);
            if (message.attribute != null && message.attribute.length)
              for (var i = 0; i < message.attribute.length; ++i)
                $root.onnx.AttributeProto.encode(
                  message.attribute[i],
                  writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()
                ).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.docString);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).string(message.domain);
            return writer;
          };
          NodeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          NodeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.input && message.input.length))
                    message.input = [];
                  message.input.push(reader.string());
                  break;
                }
                case 2: {
                  if (!(message.output && message.output.length))
                    message.output = [];
                  message.output.push(reader.string());
                  break;
                }
                case 3: {
                  message.name = reader.string();
                  break;
                }
                case 4: {
                  message.opType = reader.string();
                  break;
                }
                case 7: {
                  message.domain = reader.string();
                  break;
                }
                case 5: {
                  if (!(message.attribute && message.attribute.length))
                    message.attribute = [];
                  message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 6: {
                  message.docString = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          NodeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          NodeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.input != null && message.hasOwnProperty("input")) {
              if (!Array.isArray(message.input))
                return "input: array expected";
              for (var i = 0; i < message.input.length; ++i)
                if (!$util.isString(message.input[i]))
                  return "input: string[] expected";
            }
            if (message.output != null && message.hasOwnProperty("output")) {
              if (!Array.isArray(message.output))
                return "output: array expected";
              for (var i = 0; i < message.output.length; ++i)
                if (!$util.isString(message.output[i]))
                  return "output: string[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.opType != null && message.hasOwnProperty("opType")) {
              if (!$util.isString(message.opType))
                return "opType: string expected";
            }
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            if (message.attribute != null && message.hasOwnProperty("attribute")) {
              if (!Array.isArray(message.attribute))
                return "attribute: array expected";
              for (var i = 0; i < message.attribute.length; ++i) {
                var error = $root.onnx.AttributeProto.verify(message.attribute[i]);
                if (error)
                  return "attribute." + error;
              }
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            return null;
          };
          NodeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.NodeProto)
              return object;
            var message = new $root.onnx.NodeProto();
            if (object.input) {
              if (!Array.isArray(object.input))
                throw TypeError(".onnx.NodeProto.input: array expected");
              message.input = [];
              for (var i = 0; i < object.input.length; ++i)
                message.input[i] = String(object.input[i]);
            }
            if (object.output) {
              if (!Array.isArray(object.output))
                throw TypeError(".onnx.NodeProto.output: array expected");
              message.output = [];
              for (var i = 0; i < object.output.length; ++i)
                message.output[i] = String(object.output[i]);
            }
            if (object.name != null)
              message.name = String(object.name);
            if (object.opType != null)
              message.opType = String(object.opType);
            if (object.domain != null)
              message.domain = String(object.domain);
            if (object.attribute) {
              if (!Array.isArray(object.attribute))
                throw TypeError(".onnx.NodeProto.attribute: array expected");
              message.attribute = [];
              for (var i = 0; i < object.attribute.length; ++i) {
                if (typeof object.attribute[i] !== "object")
                  throw TypeError(".onnx.NodeProto.attribute: object expected");
                message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);
              }
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            return message;
          };
          NodeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.input = [];
              object.output = [];
              object.attribute = [];
            }
            if (options.defaults) {
              object.name = "";
              object.opType = "";
              object.docString = "";
              object.domain = "";
            }
            if (message.input && message.input.length) {
              object.input = [];
              for (var j = 0; j < message.input.length; ++j)
                object.input[j] = message.input[j];
            }
            if (message.output && message.output.length) {
              object.output = [];
              for (var j = 0; j < message.output.length; ++j)
                object.output[j] = message.output[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.opType != null && message.hasOwnProperty("opType"))
              object.opType = message.opType;
            if (message.attribute && message.attribute.length) {
              object.attribute = [];
              for (var j = 0; j < message.attribute.length; ++j)
                object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            return object;
          };
          NodeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.NodeProto";
          };
          return NodeProto;
        }();
        onnx6.TrainingInfoProto = function() {
          function TrainingInfoProto(properties) {
            this.initializationBinding = [];
            this.updateBinding = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TrainingInfoProto.prototype.initialization = null;
          TrainingInfoProto.prototype.algorithm = null;
          TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;
          TrainingInfoProto.prototype.updateBinding = $util.emptyArray;
          TrainingInfoProto.create = function create(properties) {
            return new TrainingInfoProto(properties);
          };
          TrainingInfoProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.initialization != null && Object.hasOwnProperty.call(message, "initialization"))
              $root.onnx.GraphProto.encode(message.initialization, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
              $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.initializationBinding != null && message.initializationBinding.length)
              for (var i = 0; i < message.initializationBinding.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.initializationBinding[i],
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).fork()
                ).ldelim();
            if (message.updateBinding != null && message.updateBinding.length)
              for (var i = 0; i < message.updateBinding.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.updateBinding[i],
                  writer.uint32(
                    /* id 4, wireType 2 =*/
                    34
                  ).fork()
                ).ldelim();
            return writer;
          };
          TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TrainingInfoProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TrainingInfoProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 2: {
                  message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  if (!(message.initializationBinding && message.initializationBinding.length))
                    message.initializationBinding = [];
                  message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                case 4: {
                  if (!(message.updateBinding && message.updateBinding.length))
                    message.updateBinding = [];
                  message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TrainingInfoProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.initialization != null && message.hasOwnProperty("initialization")) {
              var error = $root.onnx.GraphProto.verify(message.initialization);
              if (error)
                return "initialization." + error;
            }
            if (message.algorithm != null && message.hasOwnProperty("algorithm")) {
              var error = $root.onnx.GraphProto.verify(message.algorithm);
              if (error)
                return "algorithm." + error;
            }
            if (message.initializationBinding != null && message.hasOwnProperty("initializationBinding")) {
              if (!Array.isArray(message.initializationBinding))
                return "initializationBinding: array expected";
              for (var i = 0; i < message.initializationBinding.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);
                if (error)
                  return "initializationBinding." + error;
              }
            }
            if (message.updateBinding != null && message.hasOwnProperty("updateBinding")) {
              if (!Array.isArray(message.updateBinding))
                return "updateBinding: array expected";
              for (var i = 0; i < message.updateBinding.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);
                if (error)
                  return "updateBinding." + error;
              }
            }
            return null;
          };
          TrainingInfoProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TrainingInfoProto)
              return object;
            var message = new $root.onnx.TrainingInfoProto();
            if (object.initialization != null) {
              if (typeof object.initialization !== "object")
                throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
              message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);
            }
            if (object.algorithm != null) {
              if (typeof object.algorithm !== "object")
                throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
              message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);
            }
            if (object.initializationBinding) {
              if (!Array.isArray(object.initializationBinding))
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
              message.initializationBinding = [];
              for (var i = 0; i < object.initializationBinding.length; ++i) {
                if (typeof object.initializationBinding[i] !== "object")
                  throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
                message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(
                  object.initializationBinding[i]
                );
              }
            }
            if (object.updateBinding) {
              if (!Array.isArray(object.updateBinding))
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
              message.updateBinding = [];
              for (var i = 0; i < object.updateBinding.length; ++i) {
                if (typeof object.updateBinding[i] !== "object")
                  throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
                message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);
              }
            }
            return message;
          };
          TrainingInfoProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.initializationBinding = [];
              object.updateBinding = [];
            }
            if (options.defaults) {
              object.initialization = null;
              object.algorithm = null;
            }
            if (message.initialization != null && message.hasOwnProperty("initialization"))
              object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
              object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);
            if (message.initializationBinding && message.initializationBinding.length) {
              object.initializationBinding = [];
              for (var j = 0; j < message.initializationBinding.length; ++j)
                object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(
                  message.initializationBinding[j],
                  options
                );
            }
            if (message.updateBinding && message.updateBinding.length) {
              object.updateBinding = [];
              for (var j = 0; j < message.updateBinding.length; ++j)
                object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);
            }
            return object;
          };
          TrainingInfoProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TrainingInfoProto";
          };
          return TrainingInfoProto;
        }();
        onnx6.ModelProto = function() {
          function ModelProto(properties) {
            this.opsetImport = [];
            this.metadataProps = [];
            this.trainingInfo = [];
            this.functions = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ModelProto.prototype.opsetImport = $util.emptyArray;
          ModelProto.prototype.producerName = "";
          ModelProto.prototype.producerVersion = "";
          ModelProto.prototype.domain = "";
          ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ModelProto.prototype.docString = "";
          ModelProto.prototype.graph = null;
          ModelProto.prototype.metadataProps = $util.emptyArray;
          ModelProto.prototype.trainingInfo = $util.emptyArray;
          ModelProto.prototype.functions = $util.emptyArray;
          ModelProto.create = function create(properties) {
            return new ModelProto(properties);
          };
          ModelProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.irVersion != null && Object.hasOwnProperty.call(message, "irVersion"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.irVersion);
            if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.producerName);
            if (message.producerVersion != null && Object.hasOwnProperty.call(message, "producerVersion"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.producerVersion);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.domain);
            if (message.modelVersion != null && Object.hasOwnProperty.call(message, "modelVersion"))
              writer.uint32(
                /* id 5, wireType 0 =*/
                40
              ).int64(message.modelVersion);
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.docString);
            if (message.graph != null && Object.hasOwnProperty.call(message, "graph"))
              $root.onnx.GraphProto.encode(message.graph, writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork()).ldelim();
            if (message.opsetImport != null && message.opsetImport.length)
              for (var i = 0; i < message.opsetImport.length; ++i)
                $root.onnx.OperatorSetIdProto.encode(
                  message.opsetImport[i],
                  writer.uint32(
                    /* id 8, wireType 2 =*/
                    66
                  ).fork()
                ).ldelim();
            if (message.metadataProps != null && message.metadataProps.length)
              for (var i = 0; i < message.metadataProps.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.metadataProps[i],
                  writer.uint32(
                    /* id 14, wireType 2 =*/
                    114
                  ).fork()
                ).ldelim();
            if (message.trainingInfo != null && message.trainingInfo.length)
              for (var i = 0; i < message.trainingInfo.length; ++i)
                $root.onnx.TrainingInfoProto.encode(
                  message.trainingInfo[i],
                  writer.uint32(
                    /* id 20, wireType 2 =*/
                    162
                  ).fork()
                ).ldelim();
            if (message.functions != null && message.functions.length)
              for (var i = 0; i < message.functions.length; ++i)
                $root.onnx.FunctionProto.encode(
                  message.functions[i],
                  writer.uint32(
                    /* id 25, wireType 2 =*/
                    202
                  ).fork()
                ).ldelim();
            return writer;
          };
          ModelProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ModelProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.irVersion = reader.int64();
                  break;
                }
                case 8: {
                  if (!(message.opsetImport && message.opsetImport.length))
                    message.opsetImport = [];
                  message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                  break;
                }
                case 2: {
                  message.producerName = reader.string();
                  break;
                }
                case 3: {
                  message.producerVersion = reader.string();
                  break;
                }
                case 4: {
                  message.domain = reader.string();
                  break;
                }
                case 5: {
                  message.modelVersion = reader.int64();
                  break;
                }
                case 6: {
                  message.docString = reader.string();
                  break;
                }
                case 7: {
                  message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 14: {
                  if (!(message.metadataProps && message.metadataProps.length))
                    message.metadataProps = [];
                  message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                case 20: {
                  if (!(message.trainingInfo && message.trainingInfo.length))
                    message.trainingInfo = [];
                  message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 25: {
                  if (!(message.functions && message.functions.length))
                    message.functions = [];
                  message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ModelProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ModelProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.irVersion != null && message.hasOwnProperty("irVersion")) {
              if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))
                return "irVersion: integer|Long expected";
            }
            if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(message.opsetImport))
                return "opsetImport: array expected";
              for (var i = 0; i < message.opsetImport.length; ++i) {
                var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
                if (error)
                  return "opsetImport." + error;
              }
            }
            if (message.producerName != null && message.hasOwnProperty("producerName")) {
              if (!$util.isString(message.producerName))
                return "producerName: string expected";
            }
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion")) {
              if (!$util.isString(message.producerVersion))
                return "producerVersion: string expected";
            }
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion")) {
              if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))
                return "modelVersion: integer|Long expected";
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.graph != null && message.hasOwnProperty("graph")) {
              var error = $root.onnx.GraphProto.verify(message.graph);
              if (error)
                return "graph." + error;
            }
            if (message.metadataProps != null && message.hasOwnProperty("metadataProps")) {
              if (!Array.isArray(message.metadataProps))
                return "metadataProps: array expected";
              for (var i = 0; i < message.metadataProps.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);
                if (error)
                  return "metadataProps." + error;
              }
            }
            if (message.trainingInfo != null && message.hasOwnProperty("trainingInfo")) {
              if (!Array.isArray(message.trainingInfo))
                return "trainingInfo: array expected";
              for (var i = 0; i < message.trainingInfo.length; ++i) {
                var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);
                if (error)
                  return "trainingInfo." + error;
              }
            }
            if (message.functions != null && message.hasOwnProperty("functions")) {
              if (!Array.isArray(message.functions))
                return "functions: array expected";
              for (var i = 0; i < message.functions.length; ++i) {
                var error = $root.onnx.FunctionProto.verify(message.functions[i]);
                if (error)
                  return "functions." + error;
              }
            }
            return null;
          };
          ModelProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ModelProto)
              return object;
            var message = new $root.onnx.ModelProto();
            if (object.irVersion != null) {
              if ($util.Long)
                (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;
              else if (typeof object.irVersion === "string")
                message.irVersion = parseInt(object.irVersion, 10);
              else if (typeof object.irVersion === "number")
                message.irVersion = object.irVersion;
              else if (typeof object.irVersion === "object")
                message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();
            }
            if (object.opsetImport) {
              if (!Array.isArray(object.opsetImport))
                throw TypeError(".onnx.ModelProto.opsetImport: array expected");
              message.opsetImport = [];
              for (var i = 0; i < object.opsetImport.length; ++i) {
                if (typeof object.opsetImport[i] !== "object")
                  throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
              }
            }
            if (object.producerName != null)
              message.producerName = String(object.producerName);
            if (object.producerVersion != null)
              message.producerVersion = String(object.producerVersion);
            if (object.domain != null)
              message.domain = String(object.domain);
            if (object.modelVersion != null) {
              if ($util.Long)
                (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;
              else if (typeof object.modelVersion === "string")
                message.modelVersion = parseInt(object.modelVersion, 10);
              else if (typeof object.modelVersion === "number")
                message.modelVersion = object.modelVersion;
              else if (typeof object.modelVersion === "object")
                message.modelVersion = new $util.LongBits(
                  object.modelVersion.low >>> 0,
                  object.modelVersion.high >>> 0
                ).toNumber();
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.graph != null) {
              if (typeof object.graph !== "object")
                throw TypeError(".onnx.ModelProto.graph: object expected");
              message.graph = $root.onnx.GraphProto.fromObject(object.graph);
            }
            if (object.metadataProps) {
              if (!Array.isArray(object.metadataProps))
                throw TypeError(".onnx.ModelProto.metadataProps: array expected");
              message.metadataProps = [];
              for (var i = 0; i < object.metadataProps.length; ++i) {
                if (typeof object.metadataProps[i] !== "object")
                  throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);
              }
            }
            if (object.trainingInfo) {
              if (!Array.isArray(object.trainingInfo))
                throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
              message.trainingInfo = [];
              for (var i = 0; i < object.trainingInfo.length; ++i) {
                if (typeof object.trainingInfo[i] !== "object")
                  throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
                message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);
              }
            }
            if (object.functions) {
              if (!Array.isArray(object.functions))
                throw TypeError(".onnx.ModelProto.functions: array expected");
              message.functions = [];
              for (var i = 0; i < object.functions.length; ++i) {
                if (typeof object.functions[i] !== "object")
                  throw TypeError(".onnx.ModelProto.functions: object expected");
                message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);
              }
            }
            return message;
          };
          ModelProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.opsetImport = [];
              object.metadataProps = [];
              object.trainingInfo = [];
              object.functions = [];
            }
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.irVersion = options.longs === String ? "0" : 0;
              object.producerName = "";
              object.producerVersion = "";
              object.domain = "";
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.modelVersion = options.longs === String ? "0" : 0;
              object.docString = "";
              object.graph = null;
            }
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
              if (typeof message.irVersion === "number")
                object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;
              else
                object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;
            if (message.producerName != null && message.hasOwnProperty("producerName"))
              object.producerName = message.producerName;
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
              object.producerVersion = message.producerVersion;
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
              if (typeof message.modelVersion === "number")
                object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;
              else
                object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.graph != null && message.hasOwnProperty("graph"))
              object.graph = $root.onnx.GraphProto.toObject(message.graph, options);
            if (message.opsetImport && message.opsetImport.length) {
              object.opsetImport = [];
              for (var j = 0; j < message.opsetImport.length; ++j)
                object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
            }
            if (message.metadataProps && message.metadataProps.length) {
              object.metadataProps = [];
              for (var j = 0; j < message.metadataProps.length; ++j)
                object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);
            }
            if (message.trainingInfo && message.trainingInfo.length) {
              object.trainingInfo = [];
              for (var j = 0; j < message.trainingInfo.length; ++j)
                object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);
            }
            if (message.functions && message.functions.length) {
              object.functions = [];
              for (var j = 0; j < message.functions.length; ++j)
                object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);
            }
            return object;
          };
          ModelProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.ModelProto";
          };
          return ModelProto;
        }();
        onnx6.StringStringEntryProto = function() {
          function StringStringEntryProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          StringStringEntryProto.prototype.key = "";
          StringStringEntryProto.prototype.value = "";
          StringStringEntryProto.create = function create(properties) {
            return new StringStringEntryProto(properties);
          };
          StringStringEntryProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.key);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.value);
            return writer;
          };
          StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          StringStringEntryProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.key = reader.string();
                  break;
                }
                case 2: {
                  message.value = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          StringStringEntryProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
              if (!$util.isString(message.key))
                return "key: string expected";
            }
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!$util.isString(message.value))
                return "value: string expected";
            }
            return null;
          };
          StringStringEntryProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.StringStringEntryProto)
              return object;
            var message = new $root.onnx.StringStringEntryProto();
            if (object.key != null)
              message.key = String(object.key);
            if (object.value != null)
              message.value = String(object.value);
            return message;
          };
          StringStringEntryProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.key = "";
              object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
              object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
              object.value = message.value;
            return object;
          };
          StringStringEntryProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.StringStringEntryProto";
          };
          return StringStringEntryProto;
        }();
        onnx6.TensorAnnotation = function() {
          function TensorAnnotation(properties) {
            this.quantParameterTensorNames = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TensorAnnotation.prototype.tensorName = "";
          TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;
          TensorAnnotation.create = function create(properties) {
            return new TensorAnnotation(properties);
          };
          TensorAnnotation.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.tensorName != null && Object.hasOwnProperty.call(message, "tensorName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.tensorName);
            if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)
              for (var i = 0; i < message.quantParameterTensorNames.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.quantParameterTensorNames[i],
                  writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).fork()
                ).ldelim();
            return writer;
          };
          TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TensorAnnotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.tensorName = reader.string();
                  break;
                }
                case 2: {
                  if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))
                    message.quantParameterTensorNames = [];
                  message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TensorAnnotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.tensorName != null && message.hasOwnProperty("tensorName")) {
              if (!$util.isString(message.tensorName))
                return "tensorName: string expected";
            }
            if (message.quantParameterTensorNames != null && message.hasOwnProperty("quantParameterTensorNames")) {
              if (!Array.isArray(message.quantParameterTensorNames))
                return "quantParameterTensorNames: array expected";
              for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);
                if (error)
                  return "quantParameterTensorNames." + error;
              }
            }
            return null;
          };
          TensorAnnotation.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorAnnotation)
              return object;
            var message = new $root.onnx.TensorAnnotation();
            if (object.tensorName != null)
              message.tensorName = String(object.tensorName);
            if (object.quantParameterTensorNames) {
              if (!Array.isArray(object.quantParameterTensorNames))
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
              message.quantParameterTensorNames = [];
              for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {
                if (typeof object.quantParameterTensorNames[i] !== "object")
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(
                  object.quantParameterTensorNames[i]
                );
              }
            }
            return message;
          };
          TensorAnnotation.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.quantParameterTensorNames = [];
            if (options.defaults)
              object.tensorName = "";
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
              object.tensorName = message.tensorName;
            if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {
              object.quantParameterTensorNames = [];
              for (var j = 0; j < message.quantParameterTensorNames.length; ++j)
                object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(
                  message.quantParameterTensorNames[j],
                  options
                );
            }
            return object;
          };
          TensorAnnotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorAnnotation";
          };
          return TensorAnnotation;
        }();
        onnx6.GraphProto = function() {
          function GraphProto(properties) {
            this.node = [];
            this.initializer = [];
            this.sparseInitializer = [];
            this.input = [];
            this.output = [];
            this.valueInfo = [];
            this.quantizationAnnotation = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          GraphProto.prototype.node = $util.emptyArray;
          GraphProto.prototype.name = "";
          GraphProto.prototype.initializer = $util.emptyArray;
          GraphProto.prototype.sparseInitializer = $util.emptyArray;
          GraphProto.prototype.docString = "";
          GraphProto.prototype.input = $util.emptyArray;
          GraphProto.prototype.output = $util.emptyArray;
          GraphProto.prototype.valueInfo = $util.emptyArray;
          GraphProto.prototype.quantizationAnnotation = $util.emptyArray;
          GraphProto.create = function create(properties) {
            return new GraphProto(properties);
          };
          GraphProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && message.node.length)
              for (var i = 0; i < message.node.length; ++i)
                $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.name);
            if (message.initializer != null && message.initializer.length)
              for (var i = 0; i < message.initializer.length; ++i)
                $root.onnx.TensorProto.encode(
                  message.initializer[i],
                  writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()
                ).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).string(message.docString);
            if (message.input != null && message.input.length)
              for (var i = 0; i < message.input.length; ++i)
                $root.onnx.ValueInfoProto.encode(
                  message.input[i],
                  writer.uint32(
                    /* id 11, wireType 2 =*/
                    90
                  ).fork()
                ).ldelim();
            if (message.output != null && message.output.length)
              for (var i = 0; i < message.output.length; ++i)
                $root.onnx.ValueInfoProto.encode(
                  message.output[i],
                  writer.uint32(
                    /* id 12, wireType 2 =*/
                    98
                  ).fork()
                ).ldelim();
            if (message.valueInfo != null && message.valueInfo.length)
              for (var i = 0; i < message.valueInfo.length; ++i)
                $root.onnx.ValueInfoProto.encode(
                  message.valueInfo[i],
                  writer.uint32(
                    /* id 13, wireType 2 =*/
                    106
                  ).fork()
                ).ldelim();
            if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)
              for (var i = 0; i < message.quantizationAnnotation.length; ++i)
                $root.onnx.TensorAnnotation.encode(
                  message.quantizationAnnotation[i],
                  writer.uint32(
                    /* id 14, wireType 2 =*/
                    114
                  ).fork()
                ).ldelim();
            if (message.sparseInitializer != null && message.sparseInitializer.length)
              for (var i = 0; i < message.sparseInitializer.length; ++i)
                $root.onnx.SparseTensorProto.encode(
                  message.sparseInitializer[i],
                  writer.uint32(
                    /* id 15, wireType 2 =*/
                    122
                  ).fork()
                ).ldelim();
            return writer;
          };
          GraphProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          GraphProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.node && message.node.length))
                    message.node = [];
                  message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 2: {
                  message.name = reader.string();
                  break;
                }
                case 5: {
                  if (!(message.initializer && message.initializer.length))
                    message.initializer = [];
                  message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 15: {
                  if (!(message.sparseInitializer && message.sparseInitializer.length))
                    message.sparseInitializer = [];
                  message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 10: {
                  message.docString = reader.string();
                  break;
                }
                case 11: {
                  if (!(message.input && message.input.length))
                    message.input = [];
                  message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 12: {
                  if (!(message.output && message.output.length))
                    message.output = [];
                  message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 13: {
                  if (!(message.valueInfo && message.valueInfo.length))
                    message.valueInfo = [];
                  message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 14: {
                  if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))
                    message.quantizationAnnotation = [];
                  message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          GraphProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          GraphProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              if (!Array.isArray(message.node))
                return "node: array expected";
              for (var i = 0; i < message.node.length; ++i) {
                var error = $root.onnx.NodeProto.verify(message.node[i]);
                if (error)
                  return "node." + error;
              }
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.initializer != null && message.hasOwnProperty("initializer")) {
              if (!Array.isArray(message.initializer))
                return "initializer: array expected";
              for (var i = 0; i < message.initializer.length; ++i) {
                var error = $root.onnx.TensorProto.verify(message.initializer[i]);
                if (error)
                  return "initializer." + error;
              }
            }
            if (message.sparseInitializer != null && message.hasOwnProperty("sparseInitializer")) {
              if (!Array.isArray(message.sparseInitializer))
                return "sparseInitializer: array expected";
              for (var i = 0; i < message.sparseInitializer.length; ++i) {
                var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);
                if (error)
                  return "sparseInitializer." + error;
              }
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.input != null && message.hasOwnProperty("input")) {
              if (!Array.isArray(message.input))
                return "input: array expected";
              for (var i = 0; i < message.input.length; ++i) {
                var error = $root.onnx.ValueInfoProto.verify(message.input[i]);
                if (error)
                  return "input." + error;
              }
            }
            if (message.output != null && message.hasOwnProperty("output")) {
              if (!Array.isArray(message.output))
                return "output: array expected";
              for (var i = 0; i < message.output.length; ++i) {
                var error = $root.onnx.ValueInfoProto.verify(message.output[i]);
                if (error)
                  return "output." + error;
              }
            }
            if (message.valueInfo != null && message.hasOwnProperty("valueInfo")) {
              if (!Array.isArray(message.valueInfo))
                return "valueInfo: array expected";
              for (var i = 0; i < message.valueInfo.length; ++i) {
                var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);
                if (error)
                  return "valueInfo." + error;
              }
            }
            if (message.quantizationAnnotation != null && message.hasOwnProperty("quantizationAnnotation")) {
              if (!Array.isArray(message.quantizationAnnotation))
                return "quantizationAnnotation: array expected";
              for (var i = 0; i < message.quantizationAnnotation.length; ++i) {
                var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);
                if (error)
                  return "quantizationAnnotation." + error;
              }
            }
            return null;
          };
          GraphProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.GraphProto)
              return object;
            var message = new $root.onnx.GraphProto();
            if (object.node) {
              if (!Array.isArray(object.node))
                throw TypeError(".onnx.GraphProto.node: array expected");
              message.node = [];
              for (var i = 0; i < object.node.length; ++i) {
                if (typeof object.node[i] !== "object")
                  throw TypeError(".onnx.GraphProto.node: object expected");
                message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
              }
            }
            if (object.name != null)
              message.name = String(object.name);
            if (object.initializer) {
              if (!Array.isArray(object.initializer))
                throw TypeError(".onnx.GraphProto.initializer: array expected");
              message.initializer = [];
              for (var i = 0; i < object.initializer.length; ++i) {
                if (typeof object.initializer[i] !== "object")
                  throw TypeError(".onnx.GraphProto.initializer: object expected");
                message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);
              }
            }
            if (object.sparseInitializer) {
              if (!Array.isArray(object.sparseInitializer))
                throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
              message.sparseInitializer = [];
              for (var i = 0; i < object.sparseInitializer.length; ++i) {
                if (typeof object.sparseInitializer[i] !== "object")
                  throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
                message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);
              }
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.input) {
              if (!Array.isArray(object.input))
                throw TypeError(".onnx.GraphProto.input: array expected");
              message.input = [];
              for (var i = 0; i < object.input.length; ++i) {
                if (typeof object.input[i] !== "object")
                  throw TypeError(".onnx.GraphProto.input: object expected");
                message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);
              }
            }
            if (object.output) {
              if (!Array.isArray(object.output))
                throw TypeError(".onnx.GraphProto.output: array expected");
              message.output = [];
              for (var i = 0; i < object.output.length; ++i) {
                if (typeof object.output[i] !== "object")
                  throw TypeError(".onnx.GraphProto.output: object expected");
                message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);
              }
            }
            if (object.valueInfo) {
              if (!Array.isArray(object.valueInfo))
                throw TypeError(".onnx.GraphProto.valueInfo: array expected");
              message.valueInfo = [];
              for (var i = 0; i < object.valueInfo.length; ++i) {
                if (typeof object.valueInfo[i] !== "object")
                  throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);
              }
            }
            if (object.quantizationAnnotation) {
              if (!Array.isArray(object.quantizationAnnotation))
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
              message.quantizationAnnotation = [];
              for (var i = 0; i < object.quantizationAnnotation.length; ++i) {
                if (typeof object.quantizationAnnotation[i] !== "object")
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);
              }
            }
            return message;
          };
          GraphProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.node = [];
              object.initializer = [];
              object.input = [];
              object.output = [];
              object.valueInfo = [];
              object.quantizationAnnotation = [];
              object.sparseInitializer = [];
            }
            if (options.defaults) {
              object.name = "";
              object.docString = "";
            }
            if (message.node && message.node.length) {
              object.node = [];
              for (var j = 0; j < message.node.length; ++j)
                object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.initializer && message.initializer.length) {
              object.initializer = [];
              for (var j = 0; j < message.initializer.length; ++j)
                object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.input && message.input.length) {
              object.input = [];
              for (var j = 0; j < message.input.length; ++j)
                object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);
            }
            if (message.output && message.output.length) {
              object.output = [];
              for (var j = 0; j < message.output.length; ++j)
                object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);
            }
            if (message.valueInfo && message.valueInfo.length) {
              object.valueInfo = [];
              for (var j = 0; j < message.valueInfo.length; ++j)
                object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);
            }
            if (message.quantizationAnnotation && message.quantizationAnnotation.length) {
              object.quantizationAnnotation = [];
              for (var j = 0; j < message.quantizationAnnotation.length; ++j)
                object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(
                  message.quantizationAnnotation[j],
                  options
                );
            }
            if (message.sparseInitializer && message.sparseInitializer.length) {
              object.sparseInitializer = [];
              for (var j = 0; j < message.sparseInitializer.length; ++j)
                object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);
            }
            return object;
          };
          GraphProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.GraphProto";
          };
          return GraphProto;
        }();
        onnx6.TensorProto = function() {
          function TensorProto(properties) {
            this.dims = [];
            this.floatData = [];
            this.int32Data = [];
            this.stringData = [];
            this.int64Data = [];
            this.externalData = [];
            this.doubleData = [];
            this.uint64Data = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TensorProto.prototype.dims = $util.emptyArray;
          TensorProto.prototype.dataType = 0;
          TensorProto.prototype.segment = null;
          TensorProto.prototype.floatData = $util.emptyArray;
          TensorProto.prototype.int32Data = $util.emptyArray;
          TensorProto.prototype.stringData = $util.emptyArray;
          TensorProto.prototype.int64Data = $util.emptyArray;
          TensorProto.prototype.name = "";
          TensorProto.prototype.docString = "";
          TensorProto.prototype.rawData = $util.newBuffer([]);
          TensorProto.prototype.externalData = $util.emptyArray;
          TensorProto.prototype.dataLocation = 0;
          TensorProto.prototype.doubleData = $util.emptyArray;
          TensorProto.prototype.uint64Data = $util.emptyArray;
          TensorProto.create = function create(properties) {
            return new TensorProto(properties);
          };
          TensorProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.dims != null && message.dims.length) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork();
              for (var i = 0; i < message.dims.length; ++i)
                writer.int64(message.dims[i]);
              writer.ldelim();
            }
            if (message.dataType != null && Object.hasOwnProperty.call(message, "dataType"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.dataType);
            if (message.segment != null && Object.hasOwnProperty.call(message, "segment"))
              $root.onnx.TensorProto.Segment.encode(
                message.segment,
                writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()
              ).ldelim();
            if (message.floatData != null && message.floatData.length) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork();
              for (var i = 0; i < message.floatData.length; ++i)
                writer.float(message.floatData[i]);
              writer.ldelim();
            }
            if (message.int32Data != null && message.int32Data.length) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork();
              for (var i = 0; i < message.int32Data.length; ++i)
                writer.int32(message.int32Data[i]);
              writer.ldelim();
            }
            if (message.stringData != null && message.stringData.length)
              for (var i = 0; i < message.stringData.length; ++i)
                writer.uint32(
                  /* id 6, wireType 2 =*/
                  50
                ).bytes(message.stringData[i]);
            if (message.int64Data != null && message.int64Data.length) {
              writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork();
              for (var i = 0; i < message.int64Data.length; ++i)
                writer.int64(message.int64Data[i]);
              writer.ldelim();
            }
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).string(message.name);
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
              writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).bytes(message.rawData);
            if (message.doubleData != null && message.doubleData.length) {
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).fork();
              for (var i = 0; i < message.doubleData.length; ++i)
                writer.double(message.doubleData[i]);
              writer.ldelim();
            }
            if (message.uint64Data != null && message.uint64Data.length) {
              writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork();
              for (var i = 0; i < message.uint64Data.length; ++i)
                writer.uint64(message.uint64Data[i]);
              writer.ldelim();
            }
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).string(message.docString);
            if (message.externalData != null && message.externalData.length)
              for (var i = 0; i < message.externalData.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.externalData[i],
                  writer.uint32(
                    /* id 13, wireType 2 =*/
                    106
                  ).fork()
                ).ldelim();
            if (message.dataLocation != null && Object.hasOwnProperty.call(message, "dataLocation"))
              writer.uint32(
                /* id 14, wireType 0 =*/
                112
              ).int32(message.dataLocation);
            return writer;
          };
          TensorProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TensorProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.dims && message.dims.length))
                    message.dims = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.dims.push(reader.int64());
                  } else
                    message.dims.push(reader.int64());
                  break;
                }
                case 2: {
                  message.dataType = reader.int32();
                  break;
                }
                case 3: {
                  message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());
                  break;
                }
                case 4: {
                  if (!(message.floatData && message.floatData.length))
                    message.floatData = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.floatData.push(reader.float());
                  } else
                    message.floatData.push(reader.float());
                  break;
                }
                case 5: {
                  if (!(message.int32Data && message.int32Data.length))
                    message.int32Data = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.int32Data.push(reader.int32());
                  } else
                    message.int32Data.push(reader.int32());
                  break;
                }
                case 6: {
                  if (!(message.stringData && message.stringData.length))
                    message.stringData = [];
                  message.stringData.push(reader.bytes());
                  break;
                }
                case 7: {
                  if (!(message.int64Data && message.int64Data.length))
                    message.int64Data = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.int64Data.push(reader.int64());
                  } else
                    message.int64Data.push(reader.int64());
                  break;
                }
                case 8: {
                  message.name = reader.string();
                  break;
                }
                case 12: {
                  message.docString = reader.string();
                  break;
                }
                case 9: {
                  message.rawData = reader.bytes();
                  break;
                }
                case 13: {
                  if (!(message.externalData && message.externalData.length))
                    message.externalData = [];
                  message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                case 14: {
                  message.dataLocation = reader.int32();
                  break;
                }
                case 10: {
                  if (!(message.doubleData && message.doubleData.length))
                    message.doubleData = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.doubleData.push(reader.double());
                  } else
                    message.doubleData.push(reader.double());
                  break;
                }
                case 11: {
                  if (!(message.uint64Data && message.uint64Data.length))
                    message.uint64Data = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.uint64Data.push(reader.uint64());
                  } else
                    message.uint64Data.push(reader.uint64());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TensorProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TensorProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.dims != null && message.hasOwnProperty("dims")) {
              if (!Array.isArray(message.dims))
                return "dims: array expected";
              for (var i = 0; i < message.dims.length; ++i)
                if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                  return "dims: integer|Long[] expected";
            }
            if (message.dataType != null && message.hasOwnProperty("dataType")) {
              if (!$util.isInteger(message.dataType))
                return "dataType: integer expected";
            }
            if (message.segment != null && message.hasOwnProperty("segment")) {
              var error = $root.onnx.TensorProto.Segment.verify(message.segment);
              if (error)
                return "segment." + error;
            }
            if (message.floatData != null && message.hasOwnProperty("floatData")) {
              if (!Array.isArray(message.floatData))
                return "floatData: array expected";
              for (var i = 0; i < message.floatData.length; ++i)
                if (typeof message.floatData[i] !== "number")
                  return "floatData: number[] expected";
            }
            if (message.int32Data != null && message.hasOwnProperty("int32Data")) {
              if (!Array.isArray(message.int32Data))
                return "int32Data: array expected";
              for (var i = 0; i < message.int32Data.length; ++i)
                if (!$util.isInteger(message.int32Data[i]))
                  return "int32Data: integer[] expected";
            }
            if (message.stringData != null && message.hasOwnProperty("stringData")) {
              if (!Array.isArray(message.stringData))
                return "stringData: array expected";
              for (var i = 0; i < message.stringData.length; ++i)
                if (!(message.stringData[i] && typeof message.stringData[i].length === "number" || $util.isString(message.stringData[i])))
                  return "stringData: buffer[] expected";
            }
            if (message.int64Data != null && message.hasOwnProperty("int64Data")) {
              if (!Array.isArray(message.int64Data))
                return "int64Data: array expected";
              for (var i = 0; i < message.int64Data.length; ++i)
                if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))
                  return "int64Data: integer|Long[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
              if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
                return "rawData: buffer expected";
            }
            if (message.externalData != null && message.hasOwnProperty("externalData")) {
              if (!Array.isArray(message.externalData))
                return "externalData: array expected";
              for (var i = 0; i < message.externalData.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);
                if (error)
                  return "externalData." + error;
              }
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
              switch (message.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
                  break;
              }
            if (message.doubleData != null && message.hasOwnProperty("doubleData")) {
              if (!Array.isArray(message.doubleData))
                return "doubleData: array expected";
              for (var i = 0; i < message.doubleData.length; ++i)
                if (typeof message.doubleData[i] !== "number")
                  return "doubleData: number[] expected";
            }
            if (message.uint64Data != null && message.hasOwnProperty("uint64Data")) {
              if (!Array.isArray(message.uint64Data))
                return "uint64Data: array expected";
              for (var i = 0; i < message.uint64Data.length; ++i)
                if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))
                  return "uint64Data: integer|Long[] expected";
            }
            return null;
          };
          TensorProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorProto)
              return object;
            var message = new $root.onnx.TensorProto();
            if (object.dims) {
              if (!Array.isArray(object.dims))
                throw TypeError(".onnx.TensorProto.dims: array expected");
              message.dims = [];
              for (var i = 0; i < object.dims.length; ++i)
                if ($util.Long)
                  (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
                else if (typeof object.dims[i] === "string")
                  message.dims[i] = parseInt(object.dims[i], 10);
                else if (typeof object.dims[i] === "number")
                  message.dims[i] = object.dims[i];
                else if (typeof object.dims[i] === "object")
                  message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
            }
            if (object.dataType != null)
              message.dataType = object.dataType | 0;
            if (object.segment != null) {
              if (typeof object.segment !== "object")
                throw TypeError(".onnx.TensorProto.segment: object expected");
              message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);
            }
            if (object.floatData) {
              if (!Array.isArray(object.floatData))
                throw TypeError(".onnx.TensorProto.floatData: array expected");
              message.floatData = [];
              for (var i = 0; i < object.floatData.length; ++i)
                message.floatData[i] = Number(object.floatData[i]);
            }
            if (object.int32Data) {
              if (!Array.isArray(object.int32Data))
                throw TypeError(".onnx.TensorProto.int32Data: array expected");
              message.int32Data = [];
              for (var i = 0; i < object.int32Data.length; ++i)
                message.int32Data[i] = object.int32Data[i] | 0;
            }
            if (object.stringData) {
              if (!Array.isArray(object.stringData))
                throw TypeError(".onnx.TensorProto.stringData: array expected");
              message.stringData = [];
              for (var i = 0; i < object.stringData.length; ++i)
                if (typeof object.stringData[i] === "string")
                  $util.base64.decode(
                    object.stringData[i],
                    message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])),
                    0
                  );
                else if (object.stringData[i].length >= 0)
                  message.stringData[i] = object.stringData[i];
            }
            if (object.int64Data) {
              if (!Array.isArray(object.int64Data))
                throw TypeError(".onnx.TensorProto.int64Data: array expected");
              message.int64Data = [];
              for (var i = 0; i < object.int64Data.length; ++i)
                if ($util.Long)
                  (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;
                else if (typeof object.int64Data[i] === "string")
                  message.int64Data[i] = parseInt(object.int64Data[i], 10);
                else if (typeof object.int64Data[i] === "number")
                  message.int64Data[i] = object.int64Data[i];
                else if (typeof object.int64Data[i] === "object")
                  message.int64Data[i] = new $util.LongBits(
                    object.int64Data[i].low >>> 0,
                    object.int64Data[i].high >>> 0
                  ).toNumber();
            }
            if (object.name != null)
              message.name = String(object.name);
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.rawData != null) {
              if (typeof object.rawData === "string")
                $util.base64.decode(
                  object.rawData,
                  message.rawData = $util.newBuffer($util.base64.length(object.rawData)),
                  0
                );
              else if (object.rawData.length >= 0)
                message.rawData = object.rawData;
            }
            if (object.externalData) {
              if (!Array.isArray(object.externalData))
                throw TypeError(".onnx.TensorProto.externalData: array expected");
              message.externalData = [];
              for (var i = 0; i < object.externalData.length; ++i) {
                if (typeof object.externalData[i] !== "object")
                  throw TypeError(".onnx.TensorProto.externalData: object expected");
                message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);
              }
            }
            switch (object.dataLocation) {
              default:
                if (typeof object.dataLocation === "number") {
                  message.dataLocation = object.dataLocation;
                  break;
                }
                break;
              case "DEFAULT":
              case 0:
                message.dataLocation = 0;
                break;
              case "EXTERNAL":
              case 1:
                message.dataLocation = 1;
                break;
            }
            if (object.doubleData) {
              if (!Array.isArray(object.doubleData))
                throw TypeError(".onnx.TensorProto.doubleData: array expected");
              message.doubleData = [];
              for (var i = 0; i < object.doubleData.length; ++i)
                message.doubleData[i] = Number(object.doubleData[i]);
            }
            if (object.uint64Data) {
              if (!Array.isArray(object.uint64Data))
                throw TypeError(".onnx.TensorProto.uint64Data: array expected");
              message.uint64Data = [];
              for (var i = 0; i < object.uint64Data.length; ++i)
                if ($util.Long)
                  (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;
                else if (typeof object.uint64Data[i] === "string")
                  message.uint64Data[i] = parseInt(object.uint64Data[i], 10);
                else if (typeof object.uint64Data[i] === "number")
                  message.uint64Data[i] = object.uint64Data[i];
                else if (typeof object.uint64Data[i] === "object")
                  message.uint64Data[i] = new $util.LongBits(
                    object.uint64Data[i].low >>> 0,
                    object.uint64Data[i].high >>> 0
                  ).toNumber(true);
            }
            return message;
          };
          TensorProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.dims = [];
              object.floatData = [];
              object.int32Data = [];
              object.stringData = [];
              object.int64Data = [];
              object.doubleData = [];
              object.uint64Data = [];
              object.externalData = [];
            }
            if (options.defaults) {
              object.dataType = 0;
              object.segment = null;
              object.name = "";
              if (options.bytes === String)
                object.rawData = "";
              else {
                object.rawData = [];
                if (options.bytes !== Array)
                  object.rawData = $util.newBuffer(object.rawData);
              }
              object.docString = "";
              object.dataLocation = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.dims && message.dims.length) {
              object.dims = [];
              for (var j = 0; j < message.dims.length; ++j)
                if (typeof message.dims[j] === "number")
                  object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
                else
                  object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
              object.dataType = message.dataType;
            if (message.segment != null && message.hasOwnProperty("segment"))
              object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);
            if (message.floatData && message.floatData.length) {
              object.floatData = [];
              for (var j = 0; j < message.floatData.length; ++j)
                object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];
            }
            if (message.int32Data && message.int32Data.length) {
              object.int32Data = [];
              for (var j = 0; j < message.int32Data.length; ++j)
                object.int32Data[j] = message.int32Data[j];
            }
            if (message.stringData && message.stringData.length) {
              object.stringData = [];
              for (var j = 0; j < message.stringData.length; ++j)
                object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];
            }
            if (message.int64Data && message.int64Data.length) {
              object.int64Data = [];
              for (var j = 0; j < message.int64Data.length; ++j)
                if (typeof message.int64Data[j] === "number")
                  object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];
                else
                  object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.rawData != null && message.hasOwnProperty("rawData"))
              object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
            if (message.doubleData && message.doubleData.length) {
              object.doubleData = [];
              for (var j = 0; j < message.doubleData.length; ++j)
                object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];
            }
            if (message.uint64Data && message.uint64Data.length) {
              object.uint64Data = [];
              for (var j = 0; j < message.uint64Data.length; ++j)
                if (typeof message.uint64Data[j] === "number")
                  object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];
                else
                  object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.externalData && message.externalData.length) {
              object.externalData = [];
              for (var j = 0; j < message.externalData.length; ++j)
                object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
              object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === void 0 ? message.dataLocation : $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;
            return object;
          };
          TensorProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorProto";
          };
          TensorProto.DataType = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "UINT8"] = 2;
            values[valuesById[3] = "INT8"] = 3;
            values[valuesById[4] = "UINT16"] = 4;
            values[valuesById[5] = "INT16"] = 5;
            values[valuesById[6] = "INT32"] = 6;
            values[valuesById[7] = "INT64"] = 7;
            values[valuesById[8] = "STRING"] = 8;
            values[valuesById[9] = "BOOL"] = 9;
            values[valuesById[10] = "FLOAT16"] = 10;
            values[valuesById[11] = "DOUBLE"] = 11;
            values[valuesById[12] = "UINT32"] = 12;
            values[valuesById[13] = "UINT64"] = 13;
            values[valuesById[14] = "COMPLEX64"] = 14;
            values[valuesById[15] = "COMPLEX128"] = 15;
            values[valuesById[16] = "BFLOAT16"] = 16;
            values[valuesById[17] = "FLOAT8E4M3FN"] = 17;
            values[valuesById[18] = "FLOAT8E4M3FNUZ"] = 18;
            values[valuesById[19] = "FLOAT8E5M2"] = 19;
            values[valuesById[20] = "FLOAT8E5M2FNUZ"] = 20;
            return values;
          }();
          TensorProto.Segment = function() {
            function Segment(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Segment.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Segment.create = function create(properties) {
              return new Segment(properties);
            };
            Segment.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int64(message.begin);
              if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int64(message.end);
              return writer;
            };
            Segment.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Segment.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.begin = reader.int64();
                    break;
                  }
                  case 2: {
                    message.end = reader.int64();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Segment.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Segment.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.begin != null && message.hasOwnProperty("begin")) {
                if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))
                  return "begin: integer|Long expected";
              }
              if (message.end != null && message.hasOwnProperty("end")) {
                if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                  return "end: integer|Long expected";
              }
              return null;
            };
            Segment.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TensorProto.Segment)
                return object;
              var message = new $root.onnx.TensorProto.Segment();
              if (object.begin != null) {
                if ($util.Long)
                  (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;
                else if (typeof object.begin === "string")
                  message.begin = parseInt(object.begin, 10);
                else if (typeof object.begin === "number")
                  message.begin = object.begin;
                else if (typeof object.begin === "object")
                  message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();
              }
              if (object.end != null) {
                if ($util.Long)
                  (message.end = $util.Long.fromValue(object.end)).unsigned = false;
                else if (typeof object.end === "string")
                  message.end = parseInt(object.end, 10);
                else if (typeof object.end === "number")
                  message.end = object.end;
                else if (typeof object.end === "object")
                  message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
              }
              return message;
            };
            Segment.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.begin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.end = options.longs === String ? "0" : 0;
              }
              if (message.begin != null && message.hasOwnProperty("begin"))
                if (typeof message.begin === "number")
                  object.begin = options.longs === String ? String(message.begin) : message.begin;
                else
                  object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;
              if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end === "number")
                  object.end = options.longs === String ? String(message.end) : message.end;
                else
                  object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
              return object;
            };
            Segment.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TensorProto.Segment";
            };
            return Segment;
          }();
          TensorProto.DataLocation = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "EXTERNAL"] = 1;
            return values;
          }();
          return TensorProto;
        }();
        onnx6.SparseTensorProto = function() {
          function SparseTensorProto(properties) {
            this.dims = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SparseTensorProto.prototype.values = null;
          SparseTensorProto.prototype.indices = null;
          SparseTensorProto.prototype.dims = $util.emptyArray;
          SparseTensorProto.create = function create(properties) {
            return new SparseTensorProto(properties);
          };
          SparseTensorProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.values != null && Object.hasOwnProperty.call(message, "values"))
              $root.onnx.TensorProto.encode(message.values, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.indices != null && Object.hasOwnProperty.call(message, "indices"))
              $root.onnx.TensorProto.encode(message.indices, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.dims != null && message.dims.length) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork();
              for (var i = 0; i < message.dims.length; ++i)
                writer.int64(message.dims[i]);
              writer.ldelim();
            }
            return writer;
          };
          SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SparseTensorProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.SparseTensorProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 2: {
                  message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  if (!(message.dims && message.dims.length))
                    message.dims = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.dims.push(reader.int64());
                  } else
                    message.dims.push(reader.int64());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SparseTensorProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.values != null && message.hasOwnProperty("values")) {
              var error = $root.onnx.TensorProto.verify(message.values);
              if (error)
                return "values." + error;
            }
            if (message.indices != null && message.hasOwnProperty("indices")) {
              var error = $root.onnx.TensorProto.verify(message.indices);
              if (error)
                return "indices." + error;
            }
            if (message.dims != null && message.hasOwnProperty("dims")) {
              if (!Array.isArray(message.dims))
                return "dims: array expected";
              for (var i = 0; i < message.dims.length; ++i)
                if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                  return "dims: integer|Long[] expected";
            }
            return null;
          };
          SparseTensorProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.SparseTensorProto)
              return object;
            var message = new $root.onnx.SparseTensorProto();
            if (object.values != null) {
              if (typeof object.values !== "object")
                throw TypeError(".onnx.SparseTensorProto.values: object expected");
              message.values = $root.onnx.TensorProto.fromObject(object.values);
            }
            if (object.indices != null) {
              if (typeof object.indices !== "object")
                throw TypeError(".onnx.SparseTensorProto.indices: object expected");
              message.indices = $root.onnx.TensorProto.fromObject(object.indices);
            }
            if (object.dims) {
              if (!Array.isArray(object.dims))
                throw TypeError(".onnx.SparseTensorProto.dims: array expected");
              message.dims = [];
              for (var i = 0; i < object.dims.length; ++i)
                if ($util.Long)
                  (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
                else if (typeof object.dims[i] === "string")
                  message.dims[i] = parseInt(object.dims[i], 10);
                else if (typeof object.dims[i] === "number")
                  message.dims[i] = object.dims[i];
                else if (typeof object.dims[i] === "object")
                  message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
            }
            return message;
          };
          SparseTensorProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.dims = [];
            if (options.defaults) {
              object.values = null;
              object.indices = null;
            }
            if (message.values != null && message.hasOwnProperty("values"))
              object.values = $root.onnx.TensorProto.toObject(message.values, options);
            if (message.indices != null && message.hasOwnProperty("indices"))
              object.indices = $root.onnx.TensorProto.toObject(message.indices, options);
            if (message.dims && message.dims.length) {
              object.dims = [];
              for (var j = 0; j < message.dims.length; ++j)
                if (typeof message.dims[j] === "number")
                  object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
                else
                  object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
            }
            return object;
          };
          SparseTensorProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.SparseTensorProto";
          };
          return SparseTensorProto;
        }();
        onnx6.TensorShapeProto = function() {
          function TensorShapeProto(properties) {
            this.dim = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TensorShapeProto.prototype.dim = $util.emptyArray;
          TensorShapeProto.create = function create(properties) {
            return new TensorShapeProto(properties);
          };
          TensorShapeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.dim != null && message.dim.length)
              for (var i = 0; i < message.dim.length; ++i)
                $root.onnx.TensorShapeProto.Dimension.encode(
                  message.dim[i],
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()
                ).ldelim();
            return writer;
          };
          TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TensorShapeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.dim && message.dim.length))
                    message.dim = [];
                  message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TensorShapeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.dim != null && message.hasOwnProperty("dim")) {
              if (!Array.isArray(message.dim))
                return "dim: array expected";
              for (var i = 0; i < message.dim.length; ++i) {
                var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);
                if (error)
                  return "dim." + error;
              }
            }
            return null;
          };
          TensorShapeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorShapeProto)
              return object;
            var message = new $root.onnx.TensorShapeProto();
            if (object.dim) {
              if (!Array.isArray(object.dim))
                throw TypeError(".onnx.TensorShapeProto.dim: array expected");
              message.dim = [];
              for (var i = 0; i < object.dim.length; ++i) {
                if (typeof object.dim[i] !== "object")
                  throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);
              }
            }
            return message;
          };
          TensorShapeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.dim = [];
            if (message.dim && message.dim.length) {
              object.dim = [];
              for (var j = 0; j < message.dim.length; ++j)
                object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);
            }
            return object;
          };
          TensorShapeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorShapeProto";
          };
          TensorShapeProto.Dimension = function() {
            function Dimension(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Dimension.prototype.dimValue = null;
            Dimension.prototype.dimParam = null;
            Dimension.prototype.denotation = "";
            var $oneOfFields;
            Object.defineProperty(Dimension.prototype, "value", {
              get: $util.oneOfGetter($oneOfFields = ["dimValue", "dimParam"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Dimension.create = function create(properties) {
              return new Dimension(properties);
            };
            Dimension.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dimValue != null && Object.hasOwnProperty.call(message, "dimValue"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int64(message.dimValue);
              if (message.dimParam != null && Object.hasOwnProperty.call(message, "dimParam"))
                writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.dimParam);
              if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
                writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.denotation);
              return writer;
            };
            Dimension.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Dimension.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.dimValue = reader.int64();
                    break;
                  }
                  case 2: {
                    message.dimParam = reader.string();
                    break;
                  }
                  case 3: {
                    message.denotation = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Dimension.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Dimension.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                properties.value = 1;
                if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))
                  return "dimValue: integer|Long expected";
              }
              if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.dimParam))
                  return "dimParam: string expected";
              }
              if (message.denotation != null && message.hasOwnProperty("denotation")) {
                if (!$util.isString(message.denotation))
                  return "denotation: string expected";
              }
              return null;
            };
            Dimension.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TensorShapeProto.Dimension)
                return object;
              var message = new $root.onnx.TensorShapeProto.Dimension();
              if (object.dimValue != null) {
                if ($util.Long)
                  (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;
                else if (typeof object.dimValue === "string")
                  message.dimValue = parseInt(object.dimValue, 10);
                else if (typeof object.dimValue === "number")
                  message.dimValue = object.dimValue;
                else if (typeof object.dimValue === "object")
                  message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();
              }
              if (object.dimParam != null)
                message.dimParam = String(object.dimParam);
              if (object.denotation != null)
                message.denotation = String(object.denotation);
              return message;
            };
            Dimension.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.denotation = "";
              if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                if (typeof message.dimValue === "number")
                  object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;
                else
                  object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;
                if (options.oneofs)
                  object.value = "dimValue";
              }
              if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                object.dimParam = message.dimParam;
                if (options.oneofs)
                  object.value = "dimParam";
              }
              if (message.denotation != null && message.hasOwnProperty("denotation"))
                object.denotation = message.denotation;
              return object;
            };
            Dimension.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TensorShapeProto.Dimension";
            };
            return Dimension;
          }();
          return TensorShapeProto;
        }();
        onnx6.TypeProto = function() {
          function TypeProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TypeProto.prototype.tensorType = null;
          TypeProto.prototype.sequenceType = null;
          TypeProto.prototype.mapType = null;
          TypeProto.prototype.optionalType = null;
          TypeProto.prototype.sparseTensorType = null;
          TypeProto.prototype.denotation = "";
          var $oneOfFields;
          Object.defineProperty(TypeProto.prototype, "value", {
            get: $util.oneOfGetter(
              $oneOfFields = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]
            ),
            set: $util.oneOfSetter($oneOfFields)
          });
          TypeProto.create = function create(properties) {
            return new TypeProto(properties);
          };
          TypeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.tensorType != null && Object.hasOwnProperty.call(message, "tensorType"))
              $root.onnx.TypeProto.Tensor.encode(
                message.tensorType,
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()
              ).ldelim();
            if (message.sequenceType != null && Object.hasOwnProperty.call(message, "sequenceType"))
              $root.onnx.TypeProto.Sequence.encode(
                message.sequenceType,
                writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).fork()
              ).ldelim();
            if (message.mapType != null && Object.hasOwnProperty.call(message, "mapType"))
              $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.denotation);
            if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, "sparseTensorType"))
              $root.onnx.TypeProto.SparseTensor.encode(
                message.sparseTensorType,
                writer.uint32(
                  /* id 8, wireType 2 =*/
                  66
                ).fork()
              ).ldelim();
            if (message.optionalType != null && Object.hasOwnProperty.call(message, "optionalType"))
              $root.onnx.TypeProto.Optional.encode(
                message.optionalType,
                writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).fork()
              ).ldelim();
            return writer;
          };
          TypeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TypeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());
                  break;
                }
                case 4: {
                  message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());
                  break;
                }
                case 5: {
                  message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());
                  break;
                }
                case 9: {
                  message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());
                  break;
                }
                case 8: {
                  message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());
                  break;
                }
                case 6: {
                  message.denotation = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TypeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TypeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);
                if (error)
                  return "tensorType." + error;
              }
            }
            if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);
                if (error)
                  return "sequenceType." + error;
              }
            }
            if (message.mapType != null && message.hasOwnProperty("mapType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Map.verify(message.mapType);
                if (error)
                  return "mapType." + error;
              }
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);
                if (error)
                  return "optionalType." + error;
              }
            }
            if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);
                if (error)
                  return "sparseTensorType." + error;
              }
            }
            if (message.denotation != null && message.hasOwnProperty("denotation")) {
              if (!$util.isString(message.denotation))
                return "denotation: string expected";
            }
            return null;
          };
          TypeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto)
              return object;
            var message = new $root.onnx.TypeProto();
            if (object.tensorType != null) {
              if (typeof object.tensorType !== "object")
                throw TypeError(".onnx.TypeProto.tensorType: object expected");
              message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);
            }
            if (object.sequenceType != null) {
              if (typeof object.sequenceType !== "object")
                throw TypeError(".onnx.TypeProto.sequenceType: object expected");
              message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);
            }
            if (object.mapType != null) {
              if (typeof object.mapType !== "object")
                throw TypeError(".onnx.TypeProto.mapType: object expected");
              message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);
            }
            if (object.optionalType != null) {
              if (typeof object.optionalType !== "object")
                throw TypeError(".onnx.TypeProto.optionalType: object expected");
              message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);
            }
            if (object.sparseTensorType != null) {
              if (typeof object.sparseTensorType !== "object")
                throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
              message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);
            }
            if (object.denotation != null)
              message.denotation = String(object.denotation);
            return message;
          };
          TypeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.denotation = "";
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
              object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);
              if (options.oneofs)
                object.value = "tensorType";
            }
            if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
              object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);
              if (options.oneofs)
                object.value = "sequenceType";
            }
            if (message.mapType != null && message.hasOwnProperty("mapType")) {
              object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);
              if (options.oneofs)
                object.value = "mapType";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
              object.denotation = message.denotation;
            if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
              object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);
              if (options.oneofs)
                object.value = "sparseTensorType";
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
              object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);
              if (options.oneofs)
                object.value = "optionalType";
            }
            return object;
          };
          TypeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto";
          };
          TypeProto.Tensor = function() {
            function Tensor4(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Tensor4.prototype.elemType = 0;
            Tensor4.prototype.shape = null;
            Tensor4.create = function create(properties) {
              return new Tensor4(properties);
            };
            Tensor4.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.elemType);
              if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            Tensor4.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Tensor4.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = reader.int32();
                    break;
                  }
                  case 2: {
                    message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Tensor4.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Tensor4.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                if (!$util.isInteger(message.elemType))
                  return "elemType: integer expected";
              }
              if (message.shape != null && message.hasOwnProperty("shape")) {
                var error = $root.onnx.TensorShapeProto.verify(message.shape);
                if (error)
                  return "shape." + error;
              }
              return null;
            };
            Tensor4.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Tensor)
                return object;
              var message = new $root.onnx.TypeProto.Tensor();
              if (object.elemType != null)
                message.elemType = object.elemType | 0;
              if (object.shape != null) {
                if (typeof object.shape !== "object")
                  throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
              }
              return message;
            };
            Tensor4.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.elemType = 0;
                object.shape = null;
              }
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = message.elemType;
              if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
              return object;
            };
            Tensor4.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Tensor4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Tensor";
            };
            return Tensor4;
          }();
          TypeProto.Sequence = function() {
            function Sequence(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Sequence.prototype.elemType = null;
            Sequence.create = function create(properties) {
              return new Sequence(properties);
            };
            Sequence.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
              return writer;
            };
            Sequence.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Sequence.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Sequence();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Sequence.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Sequence.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                var error = $root.onnx.TypeProto.verify(message.elemType);
                if (error)
                  return "elemType." + error;
              }
              return null;
            };
            Sequence.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Sequence)
                return object;
              var message = new $root.onnx.TypeProto.Sequence();
              if (object.elemType != null) {
                if (typeof object.elemType !== "object")
                  throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
                message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
              }
              return message;
            };
            Sequence.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.elemType = null;
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
              return object;
            };
            Sequence.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Sequence";
            };
            return Sequence;
          }();
          TypeProto.Map = function() {
            function Map2(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Map2.prototype.keyType = 0;
            Map2.prototype.valueType = null;
            Map2.create = function create(properties) {
              return new Map2(properties);
            };
            Map2.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.keyType);
              if (message.valueType != null && Object.hasOwnProperty.call(message, "valueType"))
                $root.onnx.TypeProto.encode(message.valueType, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            Map2.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Map2.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Map();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.keyType = reader.int32();
                    break;
                  }
                  case 2: {
                    message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Map2.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Map2.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.keyType != null && message.hasOwnProperty("keyType")) {
                if (!$util.isInteger(message.keyType))
                  return "keyType: integer expected";
              }
              if (message.valueType != null && message.hasOwnProperty("valueType")) {
                var error = $root.onnx.TypeProto.verify(message.valueType);
                if (error)
                  return "valueType." + error;
              }
              return null;
            };
            Map2.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Map)
                return object;
              var message = new $root.onnx.TypeProto.Map();
              if (object.keyType != null)
                message.keyType = object.keyType | 0;
              if (object.valueType != null) {
                if (typeof object.valueType !== "object")
                  throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
                message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);
              }
              return message;
            };
            Map2.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.keyType = 0;
                object.valueType = null;
              }
              if (message.keyType != null && message.hasOwnProperty("keyType"))
                object.keyType = message.keyType;
              if (message.valueType != null && message.hasOwnProperty("valueType"))
                object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);
              return object;
            };
            Map2.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Map2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Map";
            };
            return Map2;
          }();
          TypeProto.Optional = function() {
            function Optional(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Optional.prototype.elemType = null;
            Optional.create = function create(properties) {
              return new Optional(properties);
            };
            Optional.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
              return writer;
            };
            Optional.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Optional.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Optional();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Optional.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Optional.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                var error = $root.onnx.TypeProto.verify(message.elemType);
                if (error)
                  return "elemType." + error;
              }
              return null;
            };
            Optional.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Optional)
                return object;
              var message = new $root.onnx.TypeProto.Optional();
              if (object.elemType != null) {
                if (typeof object.elemType !== "object")
                  throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
                message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
              }
              return message;
            };
            Optional.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.elemType = null;
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
              return object;
            };
            Optional.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Optional";
            };
            return Optional;
          }();
          TypeProto.SparseTensor = function() {
            function SparseTensor(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SparseTensor.prototype.elemType = 0;
            SparseTensor.prototype.shape = null;
            SparseTensor.create = function create(properties) {
              return new SparseTensor(properties);
            };
            SparseTensor.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.elemType);
              if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SparseTensor.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.SparseTensor();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = reader.int32();
                    break;
                  }
                  case 2: {
                    message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SparseTensor.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SparseTensor.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                if (!$util.isInteger(message.elemType))
                  return "elemType: integer expected";
              }
              if (message.shape != null && message.hasOwnProperty("shape")) {
                var error = $root.onnx.TensorShapeProto.verify(message.shape);
                if (error)
                  return "shape." + error;
              }
              return null;
            };
            SparseTensor.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.SparseTensor)
                return object;
              var message = new $root.onnx.TypeProto.SparseTensor();
              if (object.elemType != null)
                message.elemType = object.elemType | 0;
              if (object.shape != null) {
                if (typeof object.shape !== "object")
                  throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
                message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
              }
              return message;
            };
            SparseTensor.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.elemType = 0;
                object.shape = null;
              }
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = message.elemType;
              if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
              return object;
            };
            SparseTensor.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.SparseTensor";
            };
            return SparseTensor;
          }();
          return TypeProto;
        }();
        onnx6.OperatorSetIdProto = function() {
          function OperatorSetIdProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          OperatorSetIdProto.prototype.domain = "";
          OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          OperatorSetIdProto.create = function create(properties) {
            return new OperatorSetIdProto(properties);
          };
          OperatorSetIdProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.domain);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int64(message.version);
            return writer;
          };
          OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          OperatorSetIdProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.domain = reader.string();
                  break;
                }
                case 2: {
                  message.version = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          OperatorSetIdProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            if (message.version != null && message.hasOwnProperty("version")) {
              if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                return "version: integer|Long expected";
            }
            return null;
          };
          OperatorSetIdProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.OperatorSetIdProto)
              return object;
            var message = new $root.onnx.OperatorSetIdProto();
            if (object.domain != null)
              message.domain = String(object.domain);
            if (object.version != null) {
              if ($util.Long)
                (message.version = $util.Long.fromValue(object.version)).unsigned = false;
              else if (typeof object.version === "string")
                message.version = parseInt(object.version, 10);
              else if (typeof object.version === "number")
                message.version = object.version;
              else if (typeof object.version === "object")
                message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            }
            return message;
          };
          OperatorSetIdProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.domain = "";
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.version = options.longs === String ? "0" : 0;
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            if (message.version != null && message.hasOwnProperty("version"))
              if (typeof message.version === "number")
                object.version = options.longs === String ? String(message.version) : message.version;
              else
                object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            return object;
          };
          OperatorSetIdProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.OperatorSetIdProto";
          };
          return OperatorSetIdProto;
        }();
        onnx6.OperatorStatus = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "EXPERIMENTAL"] = 0;
          values[valuesById[1] = "STABLE"] = 1;
          return values;
        }();
        onnx6.FunctionProto = function() {
          function FunctionProto(properties) {
            this.input = [];
            this.output = [];
            this.attribute = [];
            this.attributeProto = [];
            this.node = [];
            this.opsetImport = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FunctionProto.prototype.name = "";
          FunctionProto.prototype.input = $util.emptyArray;
          FunctionProto.prototype.output = $util.emptyArray;
          FunctionProto.prototype.attribute = $util.emptyArray;
          FunctionProto.prototype.attributeProto = $util.emptyArray;
          FunctionProto.prototype.node = $util.emptyArray;
          FunctionProto.prototype.docString = "";
          FunctionProto.prototype.opsetImport = $util.emptyArray;
          FunctionProto.prototype.domain = "";
          FunctionProto.create = function create(properties) {
            return new FunctionProto(properties);
          };
          FunctionProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.name);
            if (message.input != null && message.input.length)
              for (var i = 0; i < message.input.length; ++i)
                writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).string(message.input[i]);
            if (message.output != null && message.output.length)
              for (var i = 0; i < message.output.length; ++i)
                writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).string(message.output[i]);
            if (message.attribute != null && message.attribute.length)
              for (var i = 0; i < message.attribute.length; ++i)
                writer.uint32(
                  /* id 6, wireType 2 =*/
                  50
                ).string(message.attribute[i]);
            if (message.node != null && message.node.length)
              for (var i = 0; i < message.node.length; ++i)
                $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).fork()).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).string(message.docString);
            if (message.opsetImport != null && message.opsetImport.length)
              for (var i = 0; i < message.opsetImport.length; ++i)
                $root.onnx.OperatorSetIdProto.encode(
                  message.opsetImport[i],
                  writer.uint32(
                    /* id 9, wireType 2 =*/
                    74
                  ).fork()
                ).ldelim();
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).string(message.domain);
            if (message.attributeProto != null && message.attributeProto.length)
              for (var i = 0; i < message.attributeProto.length; ++i)
                $root.onnx.AttributeProto.encode(
                  message.attributeProto[i],
                  writer.uint32(
                    /* id 11, wireType 2 =*/
                    90
                  ).fork()
                ).ldelim();
            return writer;
          };
          FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FunctionProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.FunctionProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 4: {
                  if (!(message.input && message.input.length))
                    message.input = [];
                  message.input.push(reader.string());
                  break;
                }
                case 5: {
                  if (!(message.output && message.output.length))
                    message.output = [];
                  message.output.push(reader.string());
                  break;
                }
                case 6: {
                  if (!(message.attribute && message.attribute.length))
                    message.attribute = [];
                  message.attribute.push(reader.string());
                  break;
                }
                case 11: {
                  if (!(message.attributeProto && message.attributeProto.length))
                    message.attributeProto = [];
                  message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 7: {
                  if (!(message.node && message.node.length))
                    message.node = [];
                  message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 8: {
                  message.docString = reader.string();
                  break;
                }
                case 9: {
                  if (!(message.opsetImport && message.opsetImport.length))
                    message.opsetImport = [];
                  message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                  break;
                }
                case 10: {
                  message.domain = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FunctionProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FunctionProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.input != null && message.hasOwnProperty("input")) {
              if (!Array.isArray(message.input))
                return "input: array expected";
              for (var i = 0; i < message.input.length; ++i)
                if (!$util.isString(message.input[i]))
                  return "input: string[] expected";
            }
            if (message.output != null && message.hasOwnProperty("output")) {
              if (!Array.isArray(message.output))
                return "output: array expected";
              for (var i = 0; i < message.output.length; ++i)
                if (!$util.isString(message.output[i]))
                  return "output: string[] expected";
            }
            if (message.attribute != null && message.hasOwnProperty("attribute")) {
              if (!Array.isArray(message.attribute))
                return "attribute: array expected";
              for (var i = 0; i < message.attribute.length; ++i)
                if (!$util.isString(message.attribute[i]))
                  return "attribute: string[] expected";
            }
            if (message.attributeProto != null && message.hasOwnProperty("attributeProto")) {
              if (!Array.isArray(message.attributeProto))
                return "attributeProto: array expected";
              for (var i = 0; i < message.attributeProto.length; ++i) {
                var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);
                if (error)
                  return "attributeProto." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              if (!Array.isArray(message.node))
                return "node: array expected";
              for (var i = 0; i < message.node.length; ++i) {
                var error = $root.onnx.NodeProto.verify(message.node[i]);
                if (error)
                  return "node." + error;
              }
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(message.opsetImport))
                return "opsetImport: array expected";
              for (var i = 0; i < message.opsetImport.length; ++i) {
                var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
                if (error)
                  return "opsetImport." + error;
              }
            }
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            return null;
          };
          FunctionProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.FunctionProto)
              return object;
            var message = new $root.onnx.FunctionProto();
            if (object.name != null)
              message.name = String(object.name);
            if (object.input) {
              if (!Array.isArray(object.input))
                throw TypeError(".onnx.FunctionProto.input: array expected");
              message.input = [];
              for (var i = 0; i < object.input.length; ++i)
                message.input[i] = String(object.input[i]);
            }
            if (object.output) {
              if (!Array.isArray(object.output))
                throw TypeError(".onnx.FunctionProto.output: array expected");
              message.output = [];
              for (var i = 0; i < object.output.length; ++i)
                message.output[i] = String(object.output[i]);
            }
            if (object.attribute) {
              if (!Array.isArray(object.attribute))
                throw TypeError(".onnx.FunctionProto.attribute: array expected");
              message.attribute = [];
              for (var i = 0; i < object.attribute.length; ++i)
                message.attribute[i] = String(object.attribute[i]);
            }
            if (object.attributeProto) {
              if (!Array.isArray(object.attributeProto))
                throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
              message.attributeProto = [];
              for (var i = 0; i < object.attributeProto.length; ++i) {
                if (typeof object.attributeProto[i] !== "object")
                  throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
                message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);
              }
            }
            if (object.node) {
              if (!Array.isArray(object.node))
                throw TypeError(".onnx.FunctionProto.node: array expected");
              message.node = [];
              for (var i = 0; i < object.node.length; ++i) {
                if (typeof object.node[i] !== "object")
                  throw TypeError(".onnx.FunctionProto.node: object expected");
                message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
              }
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.opsetImport) {
              if (!Array.isArray(object.opsetImport))
                throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
              message.opsetImport = [];
              for (var i = 0; i < object.opsetImport.length; ++i) {
                if (typeof object.opsetImport[i] !== "object")
                  throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
                message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
              }
            }
            if (object.domain != null)
              message.domain = String(object.domain);
            return message;
          };
          FunctionProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.input = [];
              object.output = [];
              object.attribute = [];
              object.node = [];
              object.opsetImport = [];
              object.attributeProto = [];
            }
            if (options.defaults) {
              object.name = "";
              object.docString = "";
              object.domain = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.input && message.input.length) {
              object.input = [];
              for (var j = 0; j < message.input.length; ++j)
                object.input[j] = message.input[j];
            }
            if (message.output && message.output.length) {
              object.output = [];
              for (var j = 0; j < message.output.length; ++j)
                object.output[j] = message.output[j];
            }
            if (message.attribute && message.attribute.length) {
              object.attribute = [];
              for (var j = 0; j < message.attribute.length; ++j)
                object.attribute[j] = message.attribute[j];
            }
            if (message.node && message.node.length) {
              object.node = [];
              for (var j = 0; j < message.node.length; ++j)
                object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.opsetImport && message.opsetImport.length) {
              object.opsetImport = [];
              for (var j = 0; j < message.opsetImport.length; ++j)
                object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            if (message.attributeProto && message.attributeProto.length) {
              object.attributeProto = [];
              for (var j = 0; j < message.attributeProto.length; ++j)
                object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);
            }
            return object;
          };
          FunctionProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.FunctionProto";
          };
          return FunctionProto;
        }();
        return onnx6;
      }();
      module2.exports = $root;
    }
  });

  // web/lib/onnxjs/util.ts
  function assert(expr, msg) {
    if (!expr) {
      throw new Error(typeof msg === "string" ? msg : msg());
    }
  }
  function decodeUtf8String(buffer) {
    return new TextDecoder().decode(buffer);
  }
  var import_onnx, ArrayUtil, MatMulUtil, BroadcastUtil, GemmUtil, ProtoUtil, LongUtil, ShapeUtil, SplitUtil, PoolConvUtil, MIN_CLIP, MAX_CLIP;
  var init_util = __esm({
    "web/lib/onnxjs/util.ts"() {
      "use strict";
      init_flatbuffers();
      init_long();
      import_onnx = __toESM(require_onnx());
      init_tensor2();
      ArrayUtil = class {
        /**
         * Verifies if 2 input arrays contain the same elements.
         * @param n1 Array 1
         * @param n2 Array 2
         * @returns Whether these 2 are equal
         */
        static arraysEqual(n1, n2) {
          if (n1.length !== n2.length) {
            return false;
          }
          for (let i = 0; i < n1.length; i++) {
            if (n1[i] !== n2[i]) {
              return false;
            }
          }
          return true;
        }
      };
      MatMulUtil = class {
        /**
         * Fix the input shapes for MatMul operation if they need fixing
         * @param dimsA The shape of tensor A. Should be an array of positive integers
         * @param dimsB The shape of tensor B. Should be an array of positive integers
         * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications
         */
        static preprocessInputShapes(dimsA, dimsB) {
          const a = dimsA.length === 1 ? [1, dimsA[0]] : dimsA;
          const b = dimsB.length === 1 ? [dimsB[0], 1] : dimsB;
          return [a, b];
        }
        /**
         * Fix the output shape computed for MatMul operation if it needs fixing
         * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.
         * This will be mutated.
         * @param aRank The rank of tensor A.
         * @param bRank The rank of tensor B.
         */
        static postprocessOutputShape(outputShape, aRank, bRank) {
          if (aRank === 1) {
            outputShape.splice(outputShape.length - 2, 1);
          }
          if (bRank === 1) {
            outputShape.pop();
          }
        }
        /**
         * Calculate the expected shape when matrix multiplication
         * @param a The shape of tensor A. Should be a tuple of 2 positive integers
         * @param b The shape of tensor B. Should be a tuple of 2 positive integers
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcMatMulShape(a, b) {
          return a[1] !== b[0] ? void 0 : [a[0], b[1]];
        }
      };
      BroadcastUtil = class _BroadcastUtil {
        /**
         * Calculate the expected shape when broadcasting 2 tensors
         * @param a The shape of tensor A. Should be an array of positive integers
         * @param b The shape of tensor B. Should be an array of positive integers
         * @param isMatMul Whether the operation is MatMul
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcShape(adims, bdims, isMatMul = false) {
          const arank = adims.length;
          const brank = bdims.length;
          if (arank === 0) {
            return bdims;
          }
          if (brank === 0) {
            return adims;
          }
          const crank = Math.max(adims.length, bdims.length);
          const cdims = new Array(crank);
          if (isMatMul) {
            if (arank < 2 || brank < 2) {
              return void 0;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape(
              [adims[arank - 2], adims[arank - 1]],
              [bdims[brank - 2], bdims[brank - 1]]
            );
            if (cShapeMatMul === void 0) {
              return void 0;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
          }
          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
              return void 0;
            }
            cdims[crank - i] = Math.max(aLen, bLen);
          }
          return cdims;
        }
        /**
         * Given the indices of a broadcasted tensor, calculate the original indices
         * @param broadcastedIndices The given indices of the broadcasted tensor.
         * @param originalShape The original shape of the tensor before broadcas
         * @returns The calculated indices that maps to the original tensor.
         */
        static index(broadcastedIndices, originalShape) {
          const originalIndices = new Array(originalShape.length);
          _BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);
          return originalIndices;
        }
        /**
         * Given the indices of a broadcasted tensor, calculate the original indices
         * @param broadcastedIndices The given indices of the broadcasted tensor.
         * @param originalShape The original shape of the tensor before broadcast
         * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be
         *     mutated).
         */
        static fillIndex(broadcastedIndices, originalShape, originalIndices) {
          const dimOffset = broadcastedIndices.length - originalShape.length;
          for (let i = 0; i < originalShape.length; i++) {
            originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];
          }
        }
        /**
         * Perform the broadcasting operation on the specific operator
         * @param a The input tensor A
         * @param b The input tensor B
         * @param op The operator lambda function
         * @param inplace Whether to write the result back to A.
         * @returns The result tensor, or undefined if input not broadcastable.
         */
        static calc(a, b, op, inplace, resultType) {
          const outputShape = _BroadcastUtil.calcShape(a.dims, b.dims);
          if (outputShape) {
            if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {
              return void 0;
            }
            const size = ShapeUtil.size(outputShape);
            const c = inplace ? a : new Tensor3(outputShape, resultType || a.type);
            if (outputShape.length === 0) {
              c.set([], op(a.get([]), b.get([])));
            } else {
              const outputIndices = new Array(outputShape.length);
              const originalIndicesA = new Array(a.dims.length);
              const originalIndicesB = new Array(b.dims.length);
              let valA = 0;
              let valB = 0;
              let isAScalar = false;
              let isBScalar = false;
              if (a.dims.length === 0) {
                valA = a.get([]);
                isAScalar = true;
              }
              if (b.dims.length === 0) {
                valB = b.get([]);
                isBScalar = true;
              }
              let rest;
              for (let i = 0; i < size; i++) {
                rest = i;
                for (let j = outputShape.length - 1; j >= 0; j--) {
                  outputIndices[j] = rest % outputShape[j];
                  rest = Math.floor(rest / outputShape[j]);
                }
                if (!isAScalar) {
                  _BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);
                  valA = a.get(originalIndicesA);
                }
                if (!isBScalar) {
                  _BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);
                  valB = b.get(originalIndicesB);
                }
                c.set(outputIndices, op(valA, valB));
              }
            }
            return c;
          }
          return void 0;
        }
        /**
         * Determine if a shape is unidirectional broadcastable to another shape
         * @param shape The input shape
         * @param finalShape The desired shape after broadcasting
         */
        static isValidBroadcast(shape2, finalShape) {
          const inputRank = shape2.length;
          const finalRank = finalShape.length;
          if (inputRank > finalRank) {
            return false;
          }
          for (let i = 1; i <= inputRank; i++) {
            if (shape2[inputRank - i] !== 1 && shape2[inputRank - i] !== finalShape[finalRank - i]) {
              return false;
            }
          }
          return true;
        }
        /**
         * Determine the broadcasted dims in input shape based on the given output shape.
         * Note that this function only returns the broadcasted dims.
         * @param inputShape The input shape
         * @param outputShape The output shape
         * @returns The broadcasted dims in input shape.
         */
        static getBroadcastDims(inputShape, outputShape) {
          const inRank = inputShape.length;
          const dims = [];
          for (let i = 0; i < inRank; i++) {
            const dim = inRank - 1 - i;
            const a = inputShape[dim] || 1;
            const b = outputShape[outputShape.length - 1 - i] || 1;
            if (b > 1 && a === 1) {
              dims.unshift(dim);
            }
          }
          return dims;
        }
      };
      GemmUtil = class {
        // will make sure input shapes are compatible for this op
        // and return back the shape of the output in the form of a tuple
        // will throw exception if the input shapes are not compatible
        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
          if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error("shape need to be of size 2");
          }
          let M;
          let K;
          let N;
          if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
          } else {
            M = leftShape[0];
            K = leftShape[1];
          }
          let kDim = -1;
          if (transRight) {
            N = rightShape[0];
            kDim = 1;
          } else {
            N = rightShape[1];
            kDim = 0;
          }
          if (rightShape[kDim] !== K) {
            throw new Error("dimension mismatch");
          }
          if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error("invalid shape specified");
          }
          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error("gemm: invalid bias shape for broadcast");
          }
          return [M, N, K];
        }
      };
      ProtoUtil = class _ProtoUtil {
        static tensorDataTypeFromProto(typeProto) {
          switch (typeProto) {
            case import_onnx.onnx.TensorProto.DataType.INT8:
              return "int8";
            case import_onnx.onnx.TensorProto.DataType.UINT8:
              return "uint8";
            case import_onnx.onnx.TensorProto.DataType.BOOL:
              return "bool";
            case import_onnx.onnx.TensorProto.DataType.INT16:
              return "int16";
            case import_onnx.onnx.TensorProto.DataType.UINT16:
              return "uint16";
            case import_onnx.onnx.TensorProto.DataType.INT32:
              return "int32";
            case import_onnx.onnx.TensorProto.DataType.UINT32:
              return "uint32";
            case import_onnx.onnx.TensorProto.DataType.FLOAT:
              return "float32";
            case import_onnx.onnx.TensorProto.DataType.DOUBLE:
              return "float64";
            case import_onnx.onnx.TensorProto.DataType.STRING:
              return "string";
            case import_onnx.onnx.TensorProto.DataType.INT64:
              return "int32";
            case import_onnx.onnx.TensorProto.DataType.UINT64:
              return "uint32";
            default:
              throw new Error(`unsupported data type: ${import_onnx.onnx.TensorProto.DataType[typeProto]}`);
          }
        }
        static tensorDataTypeStringToEnum(type) {
          switch (type) {
            case "int8":
              return import_onnx.onnx.TensorProto.DataType.INT8;
            case "uint8":
              return import_onnx.onnx.TensorProto.DataType.UINT8;
            case "bool":
              return import_onnx.onnx.TensorProto.DataType.BOOL;
            case "int16":
              return import_onnx.onnx.TensorProto.DataType.INT16;
            case "uint16":
              return import_onnx.onnx.TensorProto.DataType.UINT16;
            case "int32":
              return import_onnx.onnx.TensorProto.DataType.INT32;
            case "uint32":
              return import_onnx.onnx.TensorProto.DataType.UINT32;
            case "float32":
              return import_onnx.onnx.TensorProto.DataType.FLOAT;
            case "float64":
              return import_onnx.onnx.TensorProto.DataType.DOUBLE;
            case "string":
              return import_onnx.onnx.TensorProto.DataType.STRING;
            case "int64":
              return import_onnx.onnx.TensorProto.DataType.INT64;
            case "uint64":
              return import_onnx.onnx.TensorProto.DataType.UINT64;
            default:
              throw new Error(`unsupported data type: ${type}`);
          }
        }
        static tensorDimsFromProto(dims) {
          return dims.map((d) => long_default.isLong(d) ? d.toNumber() : d);
        }
        static tensorValueTypeFromProto(valueType) {
          return {
            tensorType: _ProtoUtil.tensorDataTypeFromProto(valueType.elemType),
            shape: { dims: _ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map((d) => d.dimValue)) }
          };
        }
        static tensorDimsFromORTFormat(tensor) {
          const dims = [];
          for (let i = 0; i < tensor.dimsLength(); i++) {
            dims.push(LongUtil.longToNumber(tensor.dims(i)));
          }
          return dims;
        }
        static tensorAttributesFromORTFormat(node) {
          const attributes = [];
          for (let i = 0; i < node.attributesLength(); i++) {
            attributes.push(node.attributes(i));
          }
          return attributes;
        }
      };
      LongUtil = class {
        // This function is called to get a number from long type of data for attribute, dim, and ir version,
        // which values are signed integers.
        // To make it more generic, add an optional parameter to convert to a unsigned number.
        static longToNumber(n, unsigned) {
          if (long_default.isLong(n)) {
            return n.toNumber();
          } else if (n instanceof flatbuffers.Long) {
            return long_default.fromValue({ low: n.low, high: n.high, unsigned: unsigned ?? false }).toNumber();
          }
          return n;
        }
        static isLong(n) {
          return long_default.isLong(n) || n instanceof flatbuffers.Long;
        }
      };
      ShapeUtil = class _ShapeUtil {
        static size(dims) {
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
        }
        // `axis` inclusive
        static sizeFromDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
        }
        // `axis` exclusive
        static sizeToDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
        }
        static getSizeFromDimensionRange(dims, start, end) {
          let size = 1;
          for (let i = start; i < end; i++) {
            if (dims[i] <= 0) {
              throw new Error(
                // eslint-disable-next-line max-len
                "cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them."
              );
            }
            size *= dims[i];
          }
          return size;
        }
        static computeStrides(dims) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [1];
          }
          const strides = new Array(rank);
          strides[rank - 1] = 1;
          strides[rank - 2] = dims[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
          }
          return strides;
        }
        static transpose(dims) {
          const copy = dims.slice();
          return copy.reverse();
        }
        static indicesToOffset(indices, strides, axis) {
          if (axis === void 0) {
            axis = indices.length;
          }
          let offset = 0;
          for (let i = 0; i < axis; ++i) {
            offset += strides[i] * indices[i];
          }
          return offset;
        }
        static offsetToIndices(offset, strides) {
          const rank = strides.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [offset * strides[0]];
          }
          const indices = new Array(strides.length);
          for (let i = 0; i < indices.length - 1; ++i) {
            indices[i] = Math.floor(offset / strides[i]);
            offset -= indices[i] * strides[i];
          }
          indices[indices.length - 1] = offset;
          return indices;
        }
        /**
         * normailze axis of range [-r, r) into [0, r).
         */
        static normalizeAxis(axis, tensorRank) {
          if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error("unsupported axis for this operation.");
          }
          return axis < 0 ? axis + tensorRank : axis;
        }
        static normalizeAxes(axes, tensorRank) {
          return axes.map((x) => this.normalizeAxis(x, tensorRank));
        }
        // Increment an index into a tensor (in lexicographic
        // ordering), wrapping around the specified upper_bound.
        /**
         * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.
         * @param index Given index to increment (Will be mutated)
         * @param dims The dimensions of the tensor for which the given index corresponds to
         * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank
         */
        static incrementIndex(index, dims, axisToIncrementOn) {
          if (dims.length === 0 || index.length === 0) {
            throw new Error("Index incrementing unsupported for scalar Tensor");
          }
          if (axisToIncrementOn === void 0) {
            axisToIncrementOn = dims.length;
          } else {
            if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {
              throw new Error("Incorrect axis to increment on");
            }
          }
          for (let k = axisToIncrementOn - 1; k >= 0; --k) {
            index[k]++;
            if (index[k] < dims[k]) {
              break;
            }
            index[k] = 0;
          }
        }
        /**
         * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array
         * Used in Reshape
         * @param originalDims Original Shape array
         * @param shapeHints array containing values to compute the new dimensions
         * For example:
         * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]
         * originalDims = [2,2] and shapeHints = [4] will return [4]
         * originalDims = [2,2] and shapeHints = [5] will throw an exception
         * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape
         */
        static calculateReshapedDims(originalDims, shapeHints) {
          if (shapeHints.length === 0) {
            if (originalDims.length === 0 || _ShapeUtil.size(originalDims) === 1) {
              return [];
            } else {
              throw new Error("cannot reshape to a scalar Tensor");
            }
          }
          const nDims = shapeHints.length;
          const reshapedDims = new Array(nDims);
          let unknownDimension = -1;
          let newTensorSize = 1;
          for (let i = 0; i < nDims; i++) {
            if (shapeHints[i] < -1) {
              throw new Error("a dimension in shape hints cannot be less than -1");
            }
            if (shapeHints[i] === -1) {
              if (unknownDimension !== -1) {
                throw new Error("at most one dimension in shape hints can be -1");
              }
              unknownDimension = i;
            } else {
              if (shapeHints[i] === 0) {
                if (i >= originalDims.length) {
                  throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                }
                reshapedDims[i] = originalDims[i];
              } else {
                reshapedDims[i] = shapeHints[i];
              }
              newTensorSize *= reshapedDims[i];
            }
          }
          const oldTensorSize = _ShapeUtil.size(originalDims);
          if (unknownDimension !== -1) {
            if (oldTensorSize % newTensorSize !== 0) {
              throw new Error(
                `the input tensor cannot be reshaped to the requested shape. Input shape: [${originalDims}] Output shape: [${shapeHints}]`
              );
            }
            reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;
          } else {
            if (newTensorSize !== oldTensorSize) {
              throw new Error("reshapedDims and originalDims don't have matching sizes");
            }
          }
          return reshapedDims;
        }
        /**
         * Sorts a given array based on the indices in the Perm array
         * Used in Transpose
         * @param a Array to be sorted such as dims or strides
         * @param perm Perm given; if null a will be reversed
         */
        static sortBasedOnPerm(a, perm) {
          if (perm) {
            return perm.map((v) => a[v]);
          } else {
            return a.slice().reverse();
          }
        }
        /**
         * Pads a given shape according to the padding values
         * @param dims shape of the Tensor to be padded
         * @param pad pad values
         */
        static padShape(dims, pad) {
          const rank = dims.length;
          return dims.map((v, i) => v + pad[i] + pad[i + rank]);
        }
        /**
         * Determines if the two shapes are identical
         * @param shape1
         * @param shape2
         */
        static areEqual(shape1, shape2) {
          if (shape1.length !== shape2.length) {
            return false;
          }
          return shape1.every((v, i) => v === shape2[i]);
        }
        /**
         * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size
         * @param dims - input `dims` that needs to be checked
         */
        static validateDimsAndCalcSize(dims) {
          if (dims.length > 6) {
            throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
          }
          let size = 1;
          for (const n of dims) {
            if (!Number.isInteger(n)) {
              throw new TypeError(`Invalid shape: ${n} is not an integer`);
            }
            if (n < 0 || n > 2147483647) {
              throw new TypeError(`Invalid shape: length ${n} is not allowed`);
            }
            size *= n;
          }
          return size;
        }
        /**
         * Determines the shape of output tensor y = flatten(x, axis)
         * @param dims - shape of input tensor
         * @param axis - flatten axis, in the range [-r, r]
         */
        static flattenShape(dims, axis) {
          if (axis < 0) {
            axis += dims.length;
          }
          const total = dims.reduce((x, y) => x * y, 1);
          const right = dims.slice(axis).reduce((x, y) => x * y, 1);
          const outputDims = [total / right, right];
          return outputDims;
        }
        /**
         * Determines the shape of output tensor y = squeeze(x, axes)
         * @param dims - shape of input tensor
         * @param axes - squeeze axes
         */
        static squeezeShape(dims, axes) {
          const outputDims = new Array();
          axes = _ShapeUtil.normalizeAxes(axes, dims.length);
          for (let i = 0; i < dims.length; i++) {
            const inSqueezeList = axes.indexOf(i) >= 0;
            if (inSqueezeList && dims[i] !== 1) {
              throw new Error("squeeze an axis of size different than 1");
            }
            if (axes.length === 0 && dims[i] > 1 || axes.length > 0 && !inSqueezeList) {
              outputDims.push(dims[i]);
            }
          }
          return outputDims;
        }
        /**
         * Determines the shape of output tensor y = unsqueeze(x, axes)
         * @param dims - shape of input tensor
         * @param axes - unsqueeze axes
         */
        static unsqueezeShape(dims, axes) {
          const outputDims = new Array(dims.length + axes.length);
          outputDims.fill(0);
          for (let i = 0; i < axes.length; i++) {
            const axis = _ShapeUtil.normalizeAxis(axes[i], outputDims.length);
            if (axis >= outputDims.length) {
              throw new Error("'axes' has an out of range axis");
            }
            if (outputDims[axis] !== 0) {
              throw new Error("'axes' has a duplicate axis");
            }
            outputDims[axis] = 1;
          }
          let inputDimsIterator = 0;
          for (let i = 0; i < outputDims.length; i++) {
            if (outputDims[i] === 0) {
              outputDims[i] = dims[inputDimsIterator++];
            }
          }
          if (inputDimsIterator !== dims.length) {
            throw new Error("the unsqueezed dimension could not be established");
          }
          return outputDims;
        }
      };
      SplitUtil = class _SplitUtil {
        /**
         * Calculates new Shapes from existing one and the splits given along the axis provides
         * @param dims Shape of the Tensor to be splitted into two or more Shapes
         * @param axis The dimension along which the Tensor will be split
         * @param splits Offsets for the start of each split
         */
        static splitShape(dims, axis, split2, numOutputs) {
          if (split2.length === 0) {
            if (!numOutputs) {
              throw new Error("need to know number of outputs when the 'split' attribute is not specified");
            }
            _SplitUtil.determineSplit(dims[axis], numOutputs, split2);
          }
          const shapes = [];
          const offsets = [0];
          for (let i = 0; i < split2.length; ++i) {
            if (i !== 0) {
              offsets.push(offsets[i - 1] + split2[i - 1]);
            }
            const shape2 = dims.slice();
            shape2[axis] = split2[i];
            shapes.push(shape2);
          }
          return [shapes, offsets];
        }
        static determineSplit(numElementsAlongAxis, numOutputs, split2) {
          if (numElementsAlongAxis % numOutputs !== 0) {
            throw new Error("cannot split tensor to equal sized parts");
          }
          for (let i = 0; i < numOutputs; ++i) {
            split2.push(numElementsAlongAxis / numOutputs);
          }
        }
      };
      PoolConvUtil = class _PoolConvUtil {
        /**
         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension.
         * @param kernelShape The size of the kernel along each axis.
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         */
        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          }
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              if (dim >= kernelShape.length) {
                kernelShape.push(inputDims[dim + 2]);
              } else {
                kernelShape[dim] = inputDims[dim + 2];
              }
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
              if (strides[dim] < 0) {
                throw new Error("strides should be greater than or equal to 1");
              }
            } else {
              strides.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < dilations.length) {
              if (dilations[dim] < 0) {
                throw new Error("dilations should be greater than or equal to 1");
              }
            } else {
              dilations.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
              if (pads[dim] < 0) {
                throw new Error("pad should be greater than or equal to 1");
              }
            } else {
              pads.push(0);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
              throw new Error("kernel shapes need to be greater than 0");
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
              throw new Error("pads should be smaller than kernel");
            }
          }
        }
        // adjust pad values based on 'autoPad' attribute
        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (!autoPad) {
            return;
          }
          if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error("length of pads should be twice the length of data dimensions");
          }
          if (strides.length !== inputDims.length - 2) {
            throw new Error("length of strides should be the length of data dimensions");
          }
          if (kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of kernel shapes should be the length of data dimensions");
          }
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            _PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + 2],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            );
          }
        }
        /**
         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0) {
            throw new Error("input shape must be of size greater than 0");
          }
          const outputDims = [inputDims[0], inputDims[1]];
          _PoolConvUtil.computeShapeHelper(
            isGlobalOperator,
            inputDims,
            outputDims,
            strides,
            dilations,
            kernelShape,
            pads,
            autoPad
          );
          return outputDims;
        }
        /**
         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param filterDims The filter tensor dimension. (inputs[1].dims)
         * @param strides Stride along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error("invalid input tensor dims or invalid filter tensor dims");
          }
          const outputDims = [inputDims[0], filterDims[0]];
          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
          return outputDims;
        }
        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
        // called by computePoolOutputShape() and computeConvOutputShape()
        // adjust pads based on 'autoPad' attribute prior to shape computation
        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(1);
            }
          } else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(
                _PoolConvUtil.adjustPadAndReturnShape(
                  inputDims[dim + 2],
                  strides[dim],
                  dilations[dim],
                  kernelShape[dim],
                  pads,
                  dim,
                  dim + inputDims.length - 2,
                  autoPad
                )
              );
            }
          }
        }
        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
        // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
          const dkernel = dilation * (kernel - 1) + 1;
          if (autoPad && autoPad !== "NOTSET") {
            switch (autoPad) {
              case "VALID":
                pads[padHeadIndex] = 0;
                pads[padTailIndex] = 0;
                return Math.floor((inSize - dkernel) / stride + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (dilation !== 1) {
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                } else {
                  const legacyTargetSize = (inSize + stride - 1) / stride;
                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          } else {
            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
          }
        }
      };
      MIN_CLIP = -34028234663852886e22;
      MAX_CLIP = 34028234663852886e22;
    }
  });

  // web/lib/onnxjs/tensor.ts
  function sizeof(type) {
    switch (type) {
      case "bool":
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      case "float64":
        return 8;
      default:
        throw new Error(`cannot calculate sizeof() on type ${type}`);
    }
  }
  function sizeofProto(type) {
    switch (type) {
      case import_onnx2.onnx.TensorProto.DataType.UINT8:
      case import_onnx2.onnx.TensorProto.DataType.INT8:
      case import_onnx2.onnx.TensorProto.DataType.BOOL:
        return 1;
      case import_onnx2.onnx.TensorProto.DataType.UINT16:
      case import_onnx2.onnx.TensorProto.DataType.INT16:
        return 2;
      case import_onnx2.onnx.TensorProto.DataType.FLOAT:
      case import_onnx2.onnx.TensorProto.DataType.INT32:
      case import_onnx2.onnx.TensorProto.DataType.UINT32:
        return 4;
      case import_onnx2.onnx.TensorProto.DataType.INT64:
      case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
      case import_onnx2.onnx.TensorProto.DataType.UINT64:
        return 8;
      default:
        throw new Error(`cannot calculate sizeof() on type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
    }
  }
  function createView(dataBuffer, type) {
    return new (dataviewConstructor(type))(dataBuffer);
  }
  function dataviewConstructor(type) {
    switch (type) {
      case "bool":
      case "uint8":
        return Uint8Array;
      case "int8":
        return Int8Array;
      case "int16":
        return Int16Array;
      case "uint16":
        return Uint16Array;
      case "int32":
        return Int32Array;
      case "uint32":
        return Uint32Array;
      case "int64":
        return BigInt64Array;
      case "float32":
        return Float32Array;
      case "float64":
        return Float64Array;
      default:
        throw new Error("unspecified error");
    }
  }
  function longToNumber(i, type) {
    if (type === import_onnx2.onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {
      if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {
        throw new TypeError("int64 is not supported");
      }
    } else if (type === import_onnx2.onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 || type === import_onnx2.onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {
      if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {
        throw new TypeError("uint64 is not supported");
      }
    } else {
      throw new TypeError(`not a LONG type: ${import_onnx2.onnx.TensorProto.DataType[type]}`);
    }
    return i.toNumber();
  }
  function readProto(view, type, byteOffset) {
    switch (type) {
      case import_onnx2.onnx.TensorProto.DataType.BOOL:
      case import_onnx2.onnx.TensorProto.DataType.UINT8:
        return view.getUint8(byteOffset);
      case import_onnx2.onnx.TensorProto.DataType.INT8:
        return view.getInt8(byteOffset);
      case import_onnx2.onnx.TensorProto.DataType.UINT16:
        return view.getUint16(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.INT16:
        return view.getInt16(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.FLOAT:
        return view.getFloat32(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.INT32:
        return view.getInt32(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.UINT32:
        return view.getUint32(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.INT64:
        return longToNumber(
          long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false),
          type
        );
      case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
        return view.getFloat64(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.UINT64:
        return longToNumber(
          long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true),
          type
        );
      default:
        throw new Error(`cannot read from DataView for type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
    }
  }
  var import_guid_typescript, import_onnx2, ortFbs, Tensor3;
  var init_tensor2 = __esm({
    "web/lib/onnxjs/tensor.ts"() {
      "use strict";
      import_guid_typescript = __toESM(require_guid());
      init_long();
      init_ort_generated();
      import_onnx2 = __toESM(require_onnx());
      init_util();
      ortFbs = onnxruntime.experimental.fbs;
      Tensor3 = class _Tensor {
        constructor(dims, type, dataProvider, asyncDataProvider, cache2, dataId = import_guid_typescript.Guid.create()) {
          this.dims = dims;
          this.type = type;
          this.dataProvider = dataProvider;
          this.asyncDataProvider = asyncDataProvider;
          this.cache = cache2;
          this.dataId = dataId;
          this.size = ShapeUtil.validateDimsAndCalcSize(dims);
          const size = this.size;
          const empty = dataProvider === void 0 && asyncDataProvider === void 0 && cache2 === void 0;
          if (cache2 !== void 0) {
            if (cache2.length !== size) {
              throw new RangeError("Input dims doesn't match data length.");
            }
          }
          if (type === "string") {
            if (cache2 !== void 0 && (!Array.isArray(cache2) || !cache2.every((i) => typeof i === "string"))) {
              throw new TypeError("cache should be a string array");
            }
            if (empty) {
              this.cache = new Array(size);
            }
          } else {
            if (cache2 !== void 0) {
              const constructor = dataviewConstructor(type);
              if (!(cache2 instanceof constructor)) {
                throw new TypeError(`cache should be type ${constructor.name}`);
              }
            }
            if (empty) {
              const buf = new ArrayBuffer(size * sizeof(type));
              this.cache = createView(buf, type);
            }
          }
        }
        /**
         * get the underlying tensor data
         */
        get data() {
          if (this.cache === void 0) {
            const data = this.dataProvider(this.dataId);
            if (data.length !== this.size) {
              throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
            }
            this.cache = data;
          }
          return this.cache;
        }
        /**
         * get the underlying string tensor data. Should only use when type is STRING
         */
        get stringData() {
          if (this.type !== "string") {
            throw new TypeError("data type is not string");
          }
          return this.data;
        }
        /**
         * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
         * INT16, INT32, UINT32, BOOL)
         */
        get integerData() {
          switch (this.type) {
            case "uint8":
            case "int8":
            case "uint16":
            case "int16":
            case "int32":
            case "uint32":
            case "bool":
              return this.data;
            default:
              throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
          }
        }
        /**
         * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)
         */
        get floatData() {
          switch (this.type) {
            case "float32":
            case "float64":
              return this.data;
            default:
              throw new TypeError("data type is not float (float32, float64)");
          }
        }
        /**
         * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
         * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)
         */
        get numberData() {
          if (this.type !== "string") {
            return this.data;
          }
          throw new TypeError("type cannot be non-number (string)");
        }
        /**
         * get value of an element at the given indices
         */
        get(indices) {
          return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];
        }
        /**
         * set value of an element at the given indices
         */
        set(indices, value) {
          this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;
        }
        /**
         * get the underlying tensor data asynchronously
         */
        async getData() {
          if (this.cache === void 0) {
            this.cache = await this.asyncDataProvider(this.dataId);
          }
          return this.cache;
        }
        /**
         * get the strides for each dimension
         */
        get strides() {
          if (!this._strides) {
            this._strides = ShapeUtil.computeStrides(this.dims);
          }
          return this._strides;
        }
        /**
         * Construct new Tensor from a ONNX Tensor object
         * @param tensorProto the ONNX Tensor
         */
        static fromProto(tensorProto) {
          if (!tensorProto) {
            throw new Error("cannot construct Value from an empty tensor");
          }
          const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType);
          const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims);
          const value = new _Tensor(dims, type);
          if (type === "string") {
            tensorProto.stringData.forEach((str, i) => {
              value.data[i] = decodeUtf8String(str);
            });
          } else if (tensorProto.rawData && typeof tensorProto.rawData.byteLength === "number" && tensorProto.rawData.byteLength > 0) {
            const dataDest = value.data;
            const dataSource = new DataView(
              tensorProto.rawData.buffer,
              tensorProto.rawData.byteOffset,
              tensorProto.rawData.byteLength
            );
            const elementSize = sizeofProto(tensorProto.dataType);
            const length = tensorProto.rawData.byteLength / elementSize;
            if (tensorProto.rawData.byteLength % elementSize !== 0) {
              throw new Error("invalid buffer length");
            }
            if (dataDest.length !== length) {
              throw new Error("buffer length mismatch");
            }
            for (let i = 0; i < length; i++) {
              const n = readProto(dataSource, tensorProto.dataType, i * elementSize);
              dataDest[i] = n;
            }
          } else {
            let array;
            switch (tensorProto.dataType) {
              case import_onnx2.onnx.TensorProto.DataType.FLOAT:
                array = tensorProto.floatData;
                break;
              case import_onnx2.onnx.TensorProto.DataType.INT32:
              case import_onnx2.onnx.TensorProto.DataType.INT16:
              case import_onnx2.onnx.TensorProto.DataType.UINT16:
              case import_onnx2.onnx.TensorProto.DataType.INT8:
              case import_onnx2.onnx.TensorProto.DataType.UINT8:
              case import_onnx2.onnx.TensorProto.DataType.BOOL:
                array = tensorProto.int32Data;
                break;
              case import_onnx2.onnx.TensorProto.DataType.INT64:
                array = tensorProto.int64Data;
                break;
              case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
                array = tensorProto.doubleData;
                break;
              case import_onnx2.onnx.TensorProto.DataType.UINT32:
              case import_onnx2.onnx.TensorProto.DataType.UINT64:
                array = tensorProto.uint64Data;
                break;
              default:
                throw new Error("unspecific error");
            }
            if (array === null || array === void 0) {
              throw new Error("failed to populate data from a tensorproto value");
            }
            const data = value.data;
            if (data.length !== array.length) {
              throw new Error("array length mismatch");
            }
            for (let i = 0; i < array.length; i++) {
              const element = array[i];
              if (long_default.isLong(element)) {
                data[i] = longToNumber(element, tensorProto.dataType);
              } else {
                data[i] = element;
              }
            }
          }
          return value;
        }
        /**
         * Construct new Tensor from raw data
         * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array
         * for other types of tensor.
         * @param dims the dimensions of the tensor
         * @param type the type of the tensor
         */
        static fromData(data, dims, type) {
          return new _Tensor(dims, type, void 0, void 0, data);
        }
        static fromOrtTensor(ortTensor) {
          if (!ortTensor) {
            throw new Error("cannot construct Value from an empty tensor");
          }
          const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);
          const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());
          const value = new _Tensor(dims, type);
          if (type === "string") {
            for (let i = 0; i < ortTensor.stringDataLength(); i++) {
              value.data[i] = ortTensor.stringData(i);
            }
          } else if (ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === "number" && ortTensor.rawDataLength() > 0) {
            const dataDest = value.data;
            const dataSource = new DataView(
              ortTensor.rawDataArray().buffer,
              ortTensor.rawDataArray().byteOffset,
              ortTensor.rawDataLength()
            );
            const elementSize = sizeofProto(ortTensor.dataType());
            const length = ortTensor.rawDataLength() / elementSize;
            if (ortTensor.rawDataLength() % elementSize !== 0) {
              throw new Error("invalid buffer length");
            }
            if (dataDest.length !== length) {
              throw new Error("buffer length mismatch");
            }
            for (let i = 0; i < length; i++) {
              const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);
              dataDest[i] = n;
            }
          }
          return value;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-source.ts
  function getGlsl(version3) {
    return version3 === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;
  }
  function getVertexShaderSource(version3) {
    const glsl = getGlsl(version3);
    return `${glsl.version}
      precision highp float;
      ${glsl.attribute} vec3 position;
      ${glsl.attribute} vec2 textureCoord;

      ${glsl.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
  }
  function getFragShaderPreamble(version3) {
    const glsl = getGlsl(version3);
    return `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFrag} vec2 TexCoords;
    ${glsl.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
  }
  function getDefaultFragShaderMain(version3, outputShapeLength) {
    const glsl = getGlsl(version3);
    return `
  void main() {
    int indices[${outputShapeLength}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${glsl.output} = result;
  }
  `;
  }
  var GLSL_ES_2_0, GLSL_ES_3_0;
  var init_glsl_source = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-source.ts"() {
      "use strict";
      GLSL_ES_2_0 = {
        version: "",
        attribute: "attribute",
        varyingVertex: "varying",
        varyingFrag: "varying",
        texture2D: "texture2D",
        output: "gl_FragColor",
        outputDeclaration: ""
      };
      GLSL_ES_3_0 = {
        version: "#version 300 es",
        attribute: "in",
        varyingVertex: "out",
        varyingFrag: "in",
        texture2D: "texture",
        output: "outputColor",
        outputDeclaration: "out vec4 outputColor;"
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/types.ts
  var init_types = __esm({
    "web/lib/onnxjs/backends/webgl/types.ts"() {
      "use strict";
    }
  });

  // web/lib/onnxjs/backends/webgl/utils.ts
  async function repeatedTry(checkFn, delayFn = (_counter) => 0, maxCounter) {
    return new Promise((resolve, reject) => {
      let tryCount = 0;
      const tryFn = () => {
        if (checkFn()) {
          resolve();
          return;
        }
        tryCount++;
        const nextBackoff = delayFn(tryCount);
        if (maxCounter != null && tryCount >= maxCounter) {
          reject();
          return;
        }
        setTimeout(tryFn, nextBackoff);
      };
      tryFn();
    });
  }
  function generateShaderFuncNameFromInputSamplerName(samplerName) {
    assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
    return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);
  }
  function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName) {
    assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
    return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + "AtOutCoords";
  }
  function squeezeInputShape(inputShape, squeezedShape) {
    let newInputShape = JSON.parse(JSON.stringify(inputShape));
    newInputShape = squeezedShape;
    return newInputShape;
  }
  function getSqueezedParams(params, keptDims) {
    return keptDims.map((d) => params[d]).join(", ");
  }
  function getCoordsDataType(rank) {
    if (rank <= 1) {
      return "int";
    } else if (rank === 2) {
      return "ivec2";
    } else if (rank === 3) {
      return "ivec3";
    } else if (rank === 4) {
      return "ivec4";
    } else if (rank === 5) {
      return "ivec5";
    } else if (rank === 6) {
      return "ivec6";
    } else {
      throw Error(`GPU for rank ${rank} is not yet supported`);
    }
  }
  function getGlChannels(rank = 6) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, rank);
  }
  var init_utils = __esm({
    "web/lib/onnxjs/backends/webgl/utils.ts"() {
      "use strict";
      init_util();
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/packing-utils.ts
  function getVecChannels(name2, rank) {
    return getGlChannels(rank).map((d) => `${name2}.${d}`);
  }
  function getChannels(name2, rank) {
    if (rank === 1) {
      return [name2];
    }
    return getVecChannels(name2, rank);
  }
  function unpackFromChannel() {
    return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
  }
  var init_packing_utils = __esm({
    "web/lib/onnxjs/backends/webgl/ops/packing-utils.ts"() {
      "use strict";
      init_utils();
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/pack.ts
  function getOutOfBoundsCondition(rank, shape2, dims) {
    if (rank === 0) {
      return "false";
    }
    if (rank === 1) {
      return `rc > ${shape2[0]}`;
    }
    let cond = "";
    for (let i = rank - 2; i < rank; i++) {
      cond += `${dims[i]} >= ${shape2[i - rank + 2]}`;
      if (i < rank - 1) {
        cond += "||";
      }
    }
    return cond;
  }
  function getOutput(shape2, dims) {
    const rank = shape2.length;
    if (rank === 0) {
      return "getA(), 0, 0, 0";
    }
    if (rank === 1) {
      return `getA(rc),
            rc + 1 >= ${shape2[0]} ? 0. : getA(rc + 1),
            0, 0`;
    }
    const coord00 = "r, c";
    const coord01 = "r, cp1";
    const coord10 = "rp1, c";
    const coord11 = "rp1, cp1";
    let D = "";
    if (rank > 2) {
      for (let i = 0; i < rank - 2; ++i) {
        D = D + `${dims[i]},`;
      }
    }
    return `getA(${D}${coord00}),
          rEdge ? 0. : getA(${D}${coord10}),
          cEdge ? 0. : getA(${D}${coord01}),
          rEdge || cEdge ? 0. : getA(${D}${coord11})`;
  }
  function getSetup(rank, dims, rows, cols) {
    if (rank === 0 || rank === 1) {
      return "";
    } else {
      const setup = `
    int r = ${dims[rank - 2]};
    int c = ${dims[rank - 1]};
    int rp1 = ${dims[rank - 2]} + 1;
    int cp1 = ${dims[rank - 1]} + 1;
    bool rEdge = rp1 >= ${cols};
    bool cEdge = cp1 >= ${rows};
    `;
      return setup;
    }
  }
  var packProgramMetadata, createPackProgramInfo, createPackProgramInfoLoader;
  var init_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/pack.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      packProgramMetadata = {
        name: "pack",
        inputNames: ["A"],
        inputTypes: [1 /* unpackedReversed */]
      };
      createPackProgramInfo = (handler, input) => {
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const inputShape = input.dims;
        const inputRank = inputShape.length;
        const outputRank = input.dims.length;
        const coordsDataType = getCoordsDataType(outputRank);
        const channels = getChannels("rc", outputRank);
        const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);
        let reversedInputWH;
        if (inputRank === 0) {
          reversedInputWH = [1, 1];
        } else if (inputRank === 1) {
          reversedInputWH = [inputShape[0], 1];
        } else {
          reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];
        }
        const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);
        const output = getOutput(inputShape, channels);
        const shaderSource = `
        void main() {
          ${coordsDataType} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            ${glsl.output} = vec4(0);
          } else {
            ${setup}

            ${glsl.output} = vec4(${output});
          }
        }
      `;
        return {
          ...packProgramMetadata,
          hasMain: true,
          output: { dims: input.dims, type: input.type, textureType: 2 /* packed */ },
          shaderSource
        };
      };
      createPackProgramInfoLoader = (handler, input) => ({
        ...packProgramMetadata,
        get: () => createPackProgramInfo(handler, input)
      });
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts
  function processDims3D(shape2) {
    if (shape2.length === 0) {
      return [1, 1, 1];
    }
    let batch = 1;
    for (let i = 0; i < shape2.length - 2; ++i) {
      batch *= shape2[i];
    }
    return [batch, shape2.length > 1 ? shape2[shape2.length - 2] : 1, shape2[shape2.length - 1]];
  }
  function isReshapeCheap(dims, reshapedDims) {
    let isCheapReshape = false;
    if (dims.length === 0 || reshapedDims.length === 0) {
      isCheapReshape = true;
    } else if (dims.length < 2 || reshapedDims.length < 2) {
      isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];
    } else {
      isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] && dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];
    }
    return isCheapReshape;
  }
  function getReshapedInputCoords(shape2) {
    const strides = ShapeUtil.computeStrides(shape2);
    const coords = ["b", "r", "c"];
    const index = "index";
    const coordsFromIndexSnippet = strides.map((stride, i) => {
      const line1 = `int ${coords[i]} = ${index} / ${stride}`;
      const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;
      return `${line1}; ${line2};`;
    }).join("");
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(b, r, c);
    }
  `;
  }
  function getFlattenedIndexFrom3D(shape2) {
    const strides = ShapeUtil.computeStrides(shape2);
    return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;
  }
`;
  }
  var createPackedReshape3DProgramMetadata, createPackedReshape3DProgramInfo, createPackedReshape3DProgramInfoLoader;
  var init_reshape_packed = __esm({
    "web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts"() {
      "use strict";
      init_util();
      init_glsl_source();
      init_types();
      init_packing_utils();
      createPackedReshape3DProgramMetadata = (outputShape3D) => ({
        name: "Reshape (packed)",
        inputTypes: [2 /* packed */],
        inputNames: ["A"],
        cacheHint: `${outputShape3D}`
      });
      createPackedReshape3DProgramInfo = (handler, input3D, metadata, outputShape3D) => {
        const inputShape3D = input3D.dims;
        const squeezedOutputShape = outputShape3D;
        let mainLoop = "";
        for (let i = 0; i < 4; i++) {
          let outputCoords = "";
          switch (i) {
            case 0:
              outputCoords = "outputCoords = rc;";
              break;
            case 1:
              outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
              break;
            case 2:
              outputCoords = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
              break;
            case 3:
              outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
              break;
            default:
              throw new Error();
          }
          mainLoop += `
        ${outputCoords}
        ${i > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${i > 0 ? "}" : ""}
      `;
        }
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      ${getReshapedInputCoords(inputShape3D)}
      ${getFlattenedIndexFrom3D(squeezedOutputShape)}
      ${unpackFromChannel()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${squeezedOutputShape[2]};
        int cols = ${squeezedOutputShape[1]};

        ${mainLoop}
        ${glsl.output} = result;
      }
    `;
        return {
          ...metadata,
          output: { dims: squeezedOutputShape, type: input3D.type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedReshape3DProgramInfoLoader = (handler, input3D, outputShape3D) => {
        const metadata = createPackedReshape3DProgramMetadata(outputShape3D);
        return { ...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D) };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts
  var encodeAsUint8;
  var init_uint8_encode = __esm({
    "web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      encodeAsUint8 = (inferenceHandler, input) => {
        const outputShape = input.shape;
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${glsl.texture2D}(X,TexCoords).r;
      ${glsl.output} = encodeAsUint8(value);
    }`;
        const programInfo = {
          name: "Uint8Encode",
          inputTypes: [0 /* unpacked */],
          inputNames: ["X"],
          output: { dims: outputShape, type: input.tensor.type, textureType: 3 /* downloadUint8AsFloat */ },
          shaderSource,
          hasMain: true
        };
        return inferenceHandler.executeProgram(programInfo, [input.tensor]);
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/unpack.ts
  function getSourceCoords(rank, dims) {
    if (rank === 1) {
      return "rc";
    }
    let coords = "";
    for (let i = 0; i < rank; i++) {
      coords += dims[i];
      if (i < rank - 1) {
        coords += ",";
      }
    }
    return coords;
  }
  var unpackProgramMetadata, createUnpackProgramInfo, createUnpackProgramInfoLoader;
  var init_unpack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/unpack.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      unpackProgramMetadata = {
        name: "unpack",
        inputNames: ["A"],
        inputTypes: [2 /* packed */]
      };
      createUnpackProgramInfo = (handler, input) => {
        const rank = input.dims.length;
        const channels = getChannels("rc", rank);
        const innerDims = channels.slice(-2);
        const coordsDataType = getCoordsDataType(rank);
        const unpackChannel = unpackFromChannel();
        const isScalar = input.dims.length === 0;
        const sourceCoords = isScalar ? "" : getSourceCoords(rank, channels);
        const coords = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
    ${unpackChannel}
    void main() {
      ${coordsDataType} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${sourceCoords});

       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);
     }
   `;
        return {
          ...unpackProgramMetadata,
          hasMain: true,
          output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createUnpackProgramInfoLoader = (handler, input) => ({
        ...unpackProgramMetadata,
        get: () => createUnpackProgramInfo(handler, input)
      });
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-data-encoder.ts
  var RedFloat32DataEncoder, RGBAFloatDataEncoder, Uint8DataEncoder;
  var init_texture_data_encoder = __esm({
    "web/lib/onnxjs/backends/webgl/texture-data-encoder.ts"() {
      "use strict";
      init_instrument();
      RedFloat32DataEncoder = class {
        constructor(gl, channels = 1) {
          if (channels === 1) {
            this.internalFormat = gl.R32F;
            this.format = gl.RED;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
          } else if (channels === 4) {
            this.internalFormat = gl.RGBA32F;
            this.format = gl.RGBA;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
          } else {
            throw new Error(`Invalid number of channels: ${channels}`);
          }
        }
        encode(src, textureSize) {
          let result;
          let source;
          if (src.constructor !== Float32Array) {
            Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array");
            source = new Float32Array(src);
          }
          if (textureSize * this.channelSize > src.length) {
            Logger.warning("Encoder", "Source data too small. Allocating larger array");
            source = src;
            result = this.allocate(textureSize * this.channelSize);
            source.forEach((v, i) => result[i] = v);
          } else {
            source = src;
            result = source;
          }
          return result;
        }
        allocate(size) {
          return new Float32Array(size * 4);
        }
        decode(buffer, dataSize) {
          if (this.channelSize === 1) {
            const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
            return filteredData;
          }
          return buffer.subarray(0, dataSize);
        }
      };
      RGBAFloatDataEncoder = class {
        constructor(gl, channels = 1, textureType) {
          if (channels !== 1 && channels !== 4) {
            throw new Error(`Invalid number of channels: ${channels}`);
          }
          this.internalFormat = gl.RGBA;
          this.format = gl.RGBA;
          this.channelSize = channels;
          this.textureType = textureType || gl.FLOAT;
        }
        encode(src, textureSize) {
          let dest = src;
          if (this.channelSize === 1) {
            Logger.verbose("Encoder", "Exploding into a larger array");
            dest = this.allocate(textureSize);
            src.forEach((v, i) => dest[i * 4] = v);
          }
          return dest;
        }
        allocate(size) {
          return new Float32Array(size * 4);
        }
        decode(buffer, dataSize) {
          if (this.channelSize === 1) {
            const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
            return filteredData;
          }
          return buffer.subarray(0, dataSize);
        }
      };
      Uint8DataEncoder = class {
        constructor(gl, channels = 1) {
          this.channelSize = 4;
          if (channels === 1) {
            this.internalFormat = gl.ALPHA;
            this.format = gl.ALPHA;
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
          } else if (channels === 4) {
            this.internalFormat = gl.RGBA;
            this.format = gl.RGBA;
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
          } else {
            throw new Error(`Invalid number of channels: ${channels}`);
          }
        }
        encode(src, _textureSize) {
          return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);
        }
        allocate(size) {
          return new Uint8Array(size * this.channelSize);
        }
        decode(buffer, dataSize) {
          if (buffer instanceof Uint8Array) {
            return buffer.subarray(0, dataSize);
          }
          throw new Error(`Invalid array type: ${buffer.constructor}`);
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-layout.ts
  var createTextureLayoutFromTextureType, calculateTextureWidthAndHeight, createTextureLayoutFromShape;
  var init_texture_layout = __esm({
    "web/lib/onnxjs/backends/webgl/texture-layout.ts"() {
      "use strict";
      init_util();
      init_types();
      createTextureLayoutFromTextureType = (textureLayoutStrategy, shape2, textureType) => {
        const channel = textureType === 0 /* unpacked */ || textureType === 1 /* unpackedReversed */ ? 1 : 4;
        const isPacked = textureType === 2 /* packed */;
        const reverseWH = textureType === 1 /* unpackedReversed */ || textureType === 2 /* packed */;
        const breakAxis = textureType === 4 /* packedLastDimension */ ? shape2.length - 1 : void 0;
        const unpackedShape = textureType === 4 /* packedLastDimension */ ? shape2.map((d, i) => i === shape2.length - 1 ? d * 4 : d) : void 0;
        return createTextureLayoutFromShape(textureLayoutStrategy, shape2, channel, unpackedShape, {
          isPacked,
          reverseWH,
          breakAxis
        });
      };
      calculateTextureWidthAndHeight = (textureLayoutStrategy, shape2, textureType) => {
        const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape2, textureType);
        return [layout.width, layout.height];
      };
      createTextureLayoutFromShape = (textureLayoutStrategy, shape2, channels = 1, unpackedShape, prefs) => {
        const isPacked = !!(prefs && prefs.isPacked);
        const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape2 : shape2, prefs);
        const rank = shape2.length;
        let inferredDims = shape2.slice(0);
        if (rank === 0) {
          inferredDims = [1];
        }
        if (channels === 1) {
          unpackedShape = shape2;
        } else if (isPacked) {
          if (channels !== 4) {
            throw new Error("a packed texture must be 4-channel");
          }
          unpackedShape = shape2;
          if (rank > 0) {
            inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);
          }
          if (rank > 1) {
            inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);
          }
        } else if (!unpackedShape) {
          throw new Error("Unpacked shape is needed when using channels > 1");
        }
        return {
          width,
          height,
          channels,
          isPacked,
          shape: inferredDims,
          strides: ShapeUtil.computeStrides(inferredDims),
          unpackedShape,
          reversedWH: prefs && prefs.reverseWH
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/inference-handler.ts
  var getProgramInfoUniqueKey, WebGLInferenceHandler;
  var init_inference_handler = __esm({
    "web/lib/onnxjs/backends/webgl/inference-handler.ts"() {
      "use strict";
      init_instrument();
      init_tensor2();
      init_util();
      init_pack();
      init_reshape_packed();
      init_uint8_encode();
      init_unpack();
      init_texture_data_encoder();
      init_texture_layout();
      init_types();
      getProgramInfoUniqueKey = (programInfo, inputTextureDatas) => {
        const inputs = inputTextureDatas.map((texture) => `${texture.unpackedShape.join(",")};${texture.width}x${texture.height}`).join("_");
        let key = programInfo.name;
        if (programInfo.cacheHint) {
          key += "[" + programInfo.cacheHint + "]";
        }
        key += ":" + inputs;
        return key;
      };
      WebGLInferenceHandler = class {
        constructor(session) {
          this.session = session;
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        /**
         * @returns [width, height]
         */
        calculateTextureWidthAndHeight(shape2, textureType) {
          return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape2, textureType);
        }
        executeProgram(program, inputs) {
          if (inputs.length < program.inputNames.length) {
            throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);
          }
          if (program.inputNames.length !== program.inputTypes.length) {
            throw new Error("input names size does not match input types");
          }
          const inputTextureDatas = [];
          for (let i = 0; i < program.inputNames.length; ++i) {
            inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);
          }
          const key = getProgramInfoUniqueKey(program, inputTextureDatas);
          let artifact = this.session.programManager.getArtifact(key);
          const programInfo = artifact ? artifact.programInfo : typeof program.get === "function" ? program.get() : program;
          const outputTextureLayout = createTextureLayoutFromTextureType(
            this.session.layoutStrategy,
            programInfo.output.dims,
            programInfo.output.textureType
          );
          const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);
          if (!artifact) {
            artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);
            this.session.programManager.setArtifact(key, artifact);
          }
          this.runProgram(artifact, inputTextureDatas, outputTextureData);
          return outputTextureData;
        }
        run(program, inputs) {
          const outputTextureData = this.executeProgram(program, inputs);
          return outputTextureData.tensor;
        }
        runProgram(artifact, inputs, output) {
          for (let i = 0; i < inputs.length; ++i) {
            if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === 2 /* packed */)) {
              throw new Error(`input[${i}] property packed inconsistent`);
            }
          }
          if (!!output.isPacked !== (artifact.programInfo.output.textureType === 2 /* packed */)) {
            throw new Error("output property packed inconsistent");
          }
          this.session.programManager.run(artifact, inputs, output);
        }
        /**
         * Create a TextureData object from a tensor.
         * Usage = EncoderUsage.UploadOnly.
         * If a related texture data is found in cache, returns it;
         * Otherwise:
         *   Creates a new texture layout if not provided;
         *   Creates WebGLTexture with the layout;
         *   Upload tensor data to the texture;
         *   Creates a texture data object associated with the given tensor.
         * @param tensor the tensor with data to upload
         */
        getOrCreateTextureData(tensor, textureType) {
          let td = this.getTextureData(tensor.dataId, textureType === 2 /* packed */);
          if (!td) {
            td = this.getTextureData(tensor.dataId, textureType !== 2 /* packed */);
            if (td) {
              if (textureType === 2 /* packed */) {
                return this.pack(td);
              } else {
                return this.unpack(td);
              }
            }
          }
          if (!td) {
            const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);
            if (textureType === 4 /* packedLastDimension */) {
              const group = 1;
              const channels = 4;
              const shape2 = tensor.dims;
              if (shape2.length === 4) {
                const adjustedKernelShape = [shape2[0], Math.ceil(shape2[1] * shape2[2] * shape2[3] / channels)];
                const adjustedLayout = createTextureLayoutFromTextureType(
                  this.session.layoutStrategy,
                  adjustedKernelShape,
                  textureType
                );
                let buffer = tensor.numberData;
                if (shape2[1] * shape2[2] * shape2[3] % channels !== 0) {
                  const numFeatureMaps = shape2[0];
                  const oldRowSize = shape2[1] * shape2[2] * shape2[3];
                  const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;
                  const newSize = numFeatureMaps * newRowSize;
                  buffer = new Float32Array(newSize);
                  for (let f = 0; f < numFeatureMaps; ++f) {
                    const oldOffset = f * oldRowSize;
                    const newOffset = f * newRowSize + f % group * oldRowSize;
                    buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);
                  }
                }
                return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, 1 /* UploadOnly */);
              }
            }
            if (textureType === 2 /* packed */) {
              const unpackedTextureLayout = createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], {
                reverseWH: true
              });
              const unpackedTextureData = this.createTextureData(
                unpackedTextureLayout,
                tensor.type,
                tensor.numberData,
                tensor,
                1 /* UploadOnly */
              );
              td = this.pack(unpackedTextureData);
            } else {
              td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
            }
          }
          return td;
        }
        /**
         * Create a TextureData object using the given data and bind to the given tensor.
         * Usage = EncoderUsage.UploadOnly.
         * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv
         * implementation by Graph.Transformer
         * @param dataType the tensor data type
         * @param data the actual data to upload
         * @param tensor the tensor to bind. tensor's data is ignored.
         */
        createTextureDataFromLayoutBindTensor(layout, dataType, data, tensor) {
          return this.createTextureData(layout, dataType, data, tensor, 1 /* UploadOnly */);
        }
        createTextureData(layout, dataType, data, tensor, usage) {
          Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(layout)}]`);
          const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);
          return this.createTextureDataFromTexture(layout, dataType, texture, tensor);
        }
        reshapeUnpacked(input, reshapedDims) {
          const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
          const newTextureLayout = {
            channels: inputTD.channels,
            height: inputTD.height,
            width: inputTD.width,
            // handle reshaping into scalar Tensors
            shape: reshapedDims.length !== 0 ? reshapedDims : [1],
            strides: ShapeUtil.computeStrides(reshapedDims),
            unpackedShape: reshapedDims
          };
          const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
          return newTextureData.tensor;
        }
        reshapePacked(input, reshapedDims) {
          const inputTD = this.getOrCreateTextureData(input, 2 /* packed */);
          if (isReshapeCheap(input.dims, reshapedDims)) {
            const newTextureLayout = {
              channels: inputTD.channels,
              height: inputTD.height,
              width: inputTD.width,
              // handle reshaping into scalar Tensors
              shape: reshapedDims.length !== 0 ? reshapedDims : [1],
              strides: ShapeUtil.computeStrides(reshapedDims),
              unpackedShape: reshapedDims,
              isPacked: true
            };
            const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
            return newTextureData.tensor;
          }
          const squeezedInputShape = processDims3D(input.dims);
          const squeezedOutputShape = processDims3D(reshapedDims);
          const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);
          const squeezedOutputTensor = this.run(
            createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape),
            [squeezedInputTensor]
          );
          const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);
          return outputTensor;
        }
        cast(input, type) {
          const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
          const newTextureData = this.createTextureDataFromTexture(inputTD, type, inputTD.texture);
          return newTextureData.tensor;
        }
        createTextureDataFromTexture(layout, dataType, texture, tensor, tensorId) {
          const textureData = {
            ...layout,
            tensor: tensor || new Tensor3(
              layout.unpackedShape,
              dataType,
              (_id) => this.readTexture(textureData),
              async (_id) => this.readTextureAsync(textureData),
              void 0,
              tensorId
            ),
            texture
          };
          this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);
          return textureData;
        }
        getTextureData(tensorId, isPacked = false) {
          return this.session.isInitializer(tensorId) ? this.session.getTextureData(tensorId, isPacked) : isPacked ? this.packedTextureDataCache.get(tensorId) : this.unpackedTextureDataCache.get(tensorId);
        }
        setTextureData(tensorId, td, isPacked = false) {
          if (this.session.isInitializer(tensorId)) {
            this.session.setTextureData(tensorId, td, isPacked);
          } else {
            (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);
          }
        }
        isTextureLayoutCached(tensor, isPacked = false) {
          return !!this.getTextureData(tensor.dataId, isPacked);
        }
        dispose() {
          this.session.textureManager.clearActiveTextures();
          this.packedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        readTexture(textureData) {
          if (textureData.isPacked) {
            return this.readTexture(this.unpack(textureData));
          }
          if (!this.session.backend.glContext.isFloat32DownloadSupported) {
            return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
          }
          return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);
        }
        async readTextureAsync(textureData) {
          if (textureData.isPacked) {
            return this.readTextureAsync(this.unpack(textureData));
          }
          if (!this.session.backend.glContext.isFloat32DownloadSupported) {
            return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
          }
          return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);
        }
        pack(input) {
          const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);
          return outputTextureData;
        }
        unpack(input) {
          const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);
          return outputTextureData;
        }
      };
    }
  });

  // web/lib/onnxjs/attribute-with-cache-key.ts
  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
  var init_attribute_with_cache_key = __esm({
    "web/lib/onnxjs/attribute-with-cache-key.ts"() {
      "use strict";
      AttributeWithCacheKeyImpl = class {
        constructor(attribute) {
          Object.assign(this, attribute);
        }
        get cacheKey() {
          if (!this.key) {
            this.key = Object.getOwnPropertyNames(this).sort().map((name2) => `${this[name2]}`).join(";");
          }
          return this.key;
        }
      };
      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts
  var batchNormalizationProgramMetadata, batchNormalization, parseBatchNormalizationAttributes, createBatchNormalizationProgramInfo, validateInputs;
  var init_batch_normalization = __esm({
    "web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_glsl_source();
      init_types();
      batchNormalizationProgramMetadata = {
        name: "BatchNormalization",
        inputNames: ["A", "Scale", "B", "Mean", "Variance"],
        inputTypes: [
          0 /* unpacked */,
          0 /* unpacked */,
          0 /* unpacked */,
          0 /* unpacked */,
          0 /* unpacked */
        ]
      };
      batchNormalization = (inferenceHandler, inputs, attributes) => {
        validateInputs(inputs);
        const output = inferenceHandler.run(
          {
            ...batchNormalizationProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes)
          },
          inputs
        );
        return [output];
      };
      parseBatchNormalizationAttributes = (node) => {
        const epsilon = node.attributes.getFloat("epsilon", 1e-5);
        const momentum = node.attributes.getFloat("momentum", 0.9);
        const spatial = node.attributes.getInt("spatial", 1);
        return createAttributeWithCacheKey({ epsilon, momentum, spatial });
      };
      createBatchNormalizationProgramInfo = (inferenceHandler, inputs, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const rank = inputs[0].dims.length;
        const [scaleWidth, scaleHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          inputs[1].dims,
          0 /* unpacked */
        );
        const shaderSource = `
  float process(int[${rank}] indices) {
    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});
    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));
    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));
    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));
    float b = getColorAsFloat(${glsl.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;
  }`;
        return {
          ...batchNormalizationProgramMetadata,
          output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs = (inputs) => {
        if (!inputs || inputs.length !== 5) {
          throw new Error("BatchNormalization requires 5 inputs.");
        }
        const X = inputs[0];
        const scale = inputs[1];
        const B = inputs[2];
        const mean = inputs[3];
        const var_ = inputs[4];
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 || var_.dims.length !== 1) {
          throw new Error("invalid input shape.");
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] || var_.dims[0] !== X.dims[1]) {
          throw new Error("invalid input shape.");
        }
        if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64" || mean.type !== "float32" && mean.type !== "float64" || var_.type !== "float32" && var_.type !== "float64") {
          throw new Error("invalid input tensor types.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-definitions.ts
  var GlslContext, GlslLib, GlslLibRoutine, GlslLibRoutineNode, TopologicalSortGlslRoutines;
  var init_glsl_definitions = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-definitions.ts"() {
      "use strict";
      GlslContext = class {
        constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
          this.glContext = glContext;
          this.programInfo = programInfo;
          this.inputTextureLayouts = inputTextureLayouts;
          this.outputTextureLayout = outputTextureLayout;
        }
      };
      GlslLib = class {
        constructor(context) {
          this.context = context;
        }
      };
      GlslLibRoutine = class {
        constructor(routineBody, dependencies) {
          this.routineBody = routineBody;
          this.dependencies = dependencies;
        }
      };
      GlslLibRoutineNode = class {
        constructor(name2, routineBody, dependencies) {
          this.name = name2;
          if (dependencies) {
            this.dependencies = dependencies;
          } else {
            this.dependencies = [];
          }
          if (routineBody) {
            this.routineBody = routineBody;
          }
        }
        addDependency(node) {
          if (node) {
            this.dependencies.push(node);
          }
        }
      };
      TopologicalSortGlslRoutines = class {
        static returnOrderedNodes(nodes) {
          if (!nodes || nodes.length === 0) {
            return [];
          }
          if (nodes.length === 1) {
            return nodes;
          }
          const cycleCheck = /* @__PURE__ */ new Set();
          const alreadyTraversed = /* @__PURE__ */ new Set();
          const result = new Array();
          this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);
          return result;
        }
        static createOrderedNodes(graphNodes, cycleCheck, alreadyTraversed, result) {
          for (let i = 0; i < graphNodes.length; ++i) {
            this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);
          }
        }
        static dfsTraverse(root, cycleCheck, alreadyTraversed, result) {
          if (!root || alreadyTraversed.has(root.name)) {
            return;
          }
          if (cycleCheck.has(root.name)) {
            throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
          }
          cycleCheck.add(root.name);
          const dependencies = root.dependencies;
          if (dependencies && dependencies.length > 0) {
            for (let i = 0; i < dependencies.length; ++i) {
              this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);
            }
          }
          result.push(root);
          alreadyTraversed.add(root.name);
          cycleCheck.delete(root.name);
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/binary-op.ts
  function glslAdd() {
    const name2 = "add_";
    const body = `
  float ${name2}(float a, float b) {
    return a + b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslDiv() {
    const name2 = "div_";
    const body = `
  float ${name2}(float a, float b) {
    return a / b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslMul() {
    const name2 = "mul_";
    const body = `
  float ${name2}(float a, float b) {
    return a * b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSub() {
    const name2 = "sub_";
    const body = `
  float ${name2}(float a, float b) {
    return a - b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslEqual() {
    const name2 = "equal_";
    const body = `
  float ${name2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslGreater() {
    const name2 = "greater_";
    const body = `
  float ${name2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslLess() {
    const name2 = "less_";
    const body = `
  float ${name2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslAnd() {
    const name2 = "and_";
    const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslOr() {
    const name2 = "or_";
    const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslXor() {
    const name2 = "xor_";
    const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslPow() {
    return glslBuiltinBinary("pow");
  }
  function glslPRelu() {
    const name2 = "prelu_";
    const body = `
  float ${name2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslBuiltinBinary(fname) {
    const name2 = `${fname}_`;
    const body = `
  float ${name2}(float a, float b) {
    return ${fname}(a, b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return ${fname}(v1, v2);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  var createBinaryProgramInfoLoader, createBinaryProgramInfo, add2, and2, div, equal, greater, less, mul, or2, pow, pRelu, sub, xor2;
  var init_binary_op = __esm({
    "web/lib/onnxjs/backends/webgl/ops/binary-op.ts"() {
      "use strict";
      init_util();
      init_glsl_definitions();
      init_glsl_source();
      init_types();
      createBinaryProgramInfoLoader = (handler, inputs, glslFunc, outputTensorType = inputs[0].type, cacheKey) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        return {
          name: glslFunc.name,
          inputNames: ["A", "B"],
          inputTypes: [textureType, textureType],
          cacheHint: cacheKey,
          get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType)
        };
      };
      createBinaryProgramInfo = (handler, inputs, glslFunc, outputTensorType = inputs[0].type) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
        let outputShape = inputs[0].dims;
        const usePackedTexture = handler.session.pack;
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);
          if (!calculatedShape) {
            throw new Error("Can't perform binary op on the given tensors");
          }
          outputShape = calculatedShape;
          const outputRank = outputShape.length;
          const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;
          const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;
          const aBcast = inputs[0].dims.length !== 0 ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;";
          const bBcast = inputs[1].dims.length !== 0 ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;";
          const glsl2 = getGlsl(handler.session.backend.glContext.version);
          const shaderSource2 = usePackedTexture ? `
      ${glslFunc.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${glslFunc.name}(a, b);
        ${glsl2.output} = result;
      }` : `
      ${glslFunc.body}
      float process(int indices[${outputRank}]) {
        int aindices[${aRank}];
        int bindices[${bRank}];
        ${aBcast}
        ${bBcast}
        return ${glslFunc.name}(_A(aindices), _B(bindices));
      }`;
          return {
            name: glslFunc.name,
            inputNames: ["A", "B"],
            inputTypes: [textureType, textureType],
            output: { dims: outputShape, type: outputTensorType, textureType },
            shaderSource: shaderSource2,
            hasMain: usePackedTexture
          };
        }
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
    ${glslFunc.body}
    void main() {
      vec4 v1 = ${glsl.texture2D}(A, TexCoords);
      vec4 v2 = ${glsl.texture2D}(B, TexCoords);
      vec4 result = ${glslFunc.name}(v1, v2);
      ${glsl.output} = result;
    }
    `;
        return {
          name: glslFunc.name,
          inputNames: ["A", "B"],
          inputTypes: [textureType, textureType],
          output: { dims: inputs[0].dims, type: outputTensorType, textureType },
          shaderSource,
          hasMain: true
        };
      };
      add2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs)
      ];
      and2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), "bool"), inputs)
      ];
      div = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs)
      ];
      equal = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), "bool"), inputs)
      ];
      greater = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), "bool"), inputs)
      ];
      less = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), "bool"), inputs)
      ];
      mul = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs)
      ];
      or2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), "bool"), inputs)
      ];
      pow = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs)
      ];
      pRelu = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs)
      ];
      sub = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs)
      ];
      xor2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), "bool"), inputs)
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/cast.ts
  var cast, parseCastAttributes, validateInputs2;
  var init_cast = __esm({
    "web/lib/onnxjs/backends/webgl/ops/cast.ts"() {
      "use strict";
      init_util();
      cast = (handler, inputs, to) => {
        validateInputs2(inputs);
        return [handler.cast(inputs[0], to)];
      };
      parseCastAttributes = (node) => ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt("to"));
      validateInputs2 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Cast requires 1 input.");
        }
        if (inputs[0].type === "string") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/concat-packed.ts
  var createPackedConcatProgramMetadata, createPackedConcatProgramInfo, createPackedConcatProgramInfoLoader, getShiftedChannelsSnippet;
  var init_concat_packed = __esm({
    "web/lib/onnxjs/backends/webgl/ops/concat-packed.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      createPackedConcatProgramMetadata = (inputCount, cacheHint) => ({
        name: "Concat (packed)",
        inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
        inputTypes: Array(inputCount).fill(2 /* packed */),
        cacheHint
      });
      createPackedConcatProgramInfo = (handler, metadata, inputs, axis) => {
        const inputShape = inputs[0].dims.slice();
        if (axis >= inputShape.length || axis < -1 * inputShape.length) {
          throw new Error("axis specified for concat doesn't match input dimensionality");
        }
        if (axis < 0) {
          axis = inputShape.length + axis;
        }
        const outputShape = inputShape.slice(0);
        for (let i = 1; i < inputs.length; i++) {
          const dataNShape = inputs[i].dims.slice();
          for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
            if (axisIndex === axis) {
              outputShape[axis] += dataNShape[axisIndex];
            } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
              throw new Error("non concat dimensions must match");
            }
          }
        }
        const rank = outputShape.length;
        const coords = getChannels("coords", rank);
        const dtype = getCoordsDataType(rank);
        const unpackChannel = unpackFromChannel();
        const shapes = inputs.map((i) => i.dims);
        const channels = getGlChannels(rank);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][axis];
        for (let i = 1; i < offsets.length; i++) {
          offsets[i] = offsets[i - 1] + shapes[i][axis];
        }
        const channel = channels[axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getX0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
        for (let i = 1; i < offsets.length; i++) {
          const shift2 = offsets[i - 1];
          getValueSnippet += `
            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
              return getChannel(
                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift2)}),
                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift2)}));
            }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
            return getChannel(
              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),
              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
          ${unpackChannel}
          float getValue(${channels.map((x) => "int " + x)}) {
            ${getValueSnippet}
          }

          void main() {
            ${dtype} coords = getOutputCoords();
            int lastDim = coords.${channels[rank - 1]};
            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};
            coords.${channels[rank - 2]} = lastDim;

            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.g = getValue(${coords});
            }

            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {
              result.a = getValue(${coords});
            }

            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&
                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.b = getValue(${coords});
            }
            ${glsl.output} = result;
          }
        `;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
        return { ...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
      };
      getShiftedChannelsSnippet = (channels, channel, shift) => {
        const channelIdx = channels.indexOf(channel);
        const res = channels.map((c, idx) => {
          if (idx === channelIdx) {
            return `${c} - ${shift}`;
          } else {
            return c;
          }
        });
        return res.join();
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/concat.ts
  var concat, createUnpackedConcatProgramMetadata, createUnpackedConcatProgramInfo, createUnpackedConcatProgramInfoLoader, getTextureIndexWhereDataResidesLinearSearch, getTextureIndexWhereDataResidesBinarySearch, getFetchDataFromCorrectTextureMethod, getGetSizeInConcatAxisValueFromIndexMethod, parseConcatAttributes, validateInputs3;
  var init_concat = __esm({
    "web/lib/onnxjs/backends/webgl/ops/concat.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_types();
      init_concat_packed();
      concat = (inferenceHandler, inputs, attributes) => {
        validateInputs3(inputs);
        if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {
          const output = inferenceHandler.run(
            createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),
            inputs
          );
          return [output];
        } else {
          const output = inferenceHandler.run(
            createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),
            inputs
          );
          return [output];
        }
      };
      createUnpackedConcatProgramMetadata = (inputCount, cacheHint) => ({
        name: "Concat",
        inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
        inputTypes: Array(inputCount).fill(0 /* unpacked */),
        cacheHint
      });
      createUnpackedConcatProgramInfo = (_handler, metadata, inputs, axis) => {
        const inputShape = inputs[0].dims.slice();
        if (axis >= inputShape.length || axis < -1 * inputShape.length) {
          throw new Error("axis specified for concat doesn't match input dimensionality");
        }
        if (axis < 0) {
          axis = inputShape.length + axis;
        }
        const outputShape = inputShape.slice(0);
        for (let i = 1; i < inputs.length; i++) {
          const dataNShape = inputs[i].dims.slice();
          for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
            if (axisIndex === axis) {
              outputShape[axis] += dataNShape[axisIndex];
            } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
              throw new Error("non concat dimensions must match");
            }
          }
        }
        const rank = outputShape.length;
        const sizeInConcatAxis = new Array(inputs.length);
        let previousSum = 0;
        for (let i = 0; i < sizeInConcatAxis.length; ++i) {
          previousSum += inputs[i].dims[axis];
          sizeInConcatAxis[i] = previousSum;
        }
        let getTextureIndexWhereDataResidesMethod = "";
        if (inputs.length < 5) {
          getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
        } else {
          getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);
        }
        const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);
        const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);
        const shaderSource = `
        ${fetchDataFromCorrectTextureMethod}
        ${getSizeInConcatAxisValueFromIndexMethod}
        ${getTextureIndexWhereDataResidesMethod}
        float process(int indices[${rank}]) {
          int textureIndex = getTextureWhereDataResides (indices[${axis}]);

          if(textureIndex != 0) {
            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createUnpackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
        return { ...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
      };
      getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis) => {
        const searchAxis = sizeInConcatAxis.map(
          (size, i) => `if(index<${size}) {return ${i};}
`
        );
        return `int getTextureWhereDataResides(int index) {
      ${searchAxis.join("")}
    }`;
      };
      getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis) => getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
      getFetchDataFromCorrectTextureMethod = (numberOfTensors, tensorRank) => {
        const codeLines = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];
        for (let i = 0; i < numberOfTensors; ++i) {
          if (i === 0) {
            codeLines.push(`	if (textureIndex == ${i}) { return _X${i}(indices); }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`	else { return _X${i}(indices); }`);
          } else {
            codeLines.push(`	else if (textureIndex == ${i}) { return _X${i}(indices); }`);
          }
        }
        codeLines.push("	}");
        return codeLines.join("\n");
      };
      getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis) => {
        const codeLines = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
        for (let i = 0; i < sizeInConcatAxis.length; ++i) {
          if (i === 0) {
            codeLines.push(`	if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);
          } else if (i === sizeInConcatAxis.length - 1) {
            codeLines.push(`	else { return ${sizeInConcatAxis[i]}; }`);
          } else {
            codeLines.push(`	else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);
          }
        }
        codeLines.push("	}");
        return codeLines.join("\n");
      };
      parseConcatAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis") });
      validateInputs3 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        const inputType = inputs[0].type;
        const inputDimensionality = inputs[0].dims.length;
        if (inputType === "string") {
          throw new Error("string tensor is not supported yet");
        }
        for (const input of inputs) {
          if (input.type !== inputType) {
            throw new Error("input tensors should be one type");
          }
          if (input.dims.length !== inputDimensionality) {
            throw new Error("input tensors should have the same shape");
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/unary-op.ts
  function glslAbs() {
    return glslBuiltinUnary("abs");
  }
  function glslAcos() {
    return glslBuiltinUnary("acos");
  }
  function glslAsin() {
    return glslBuiltinUnary("asin");
  }
  function glslAtan() {
    return glslBuiltinUnary("atan");
  }
  function glslCeil() {
    return glslBuiltinUnary("ceil");
  }
  function glslCos() {
    return glslBuiltinUnary("cos");
  }
  function glslElu(alpha) {
    const name2 = "elu";
    const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslExp() {
    return glslBuiltinUnary("exp");
  }
  function glslFloor() {
    return glslBuiltinUnary("floor");
  }
  function glslClip(min, max) {
    const name2 = "clip";
    const body = `
  const float min = float(${min});
  const float max = float(${max});

  float ${name2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${name2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslIdentity() {
    const name2 = "indentity";
    const body = `
  float ${name2}_(float a) {
    return a;
  }
  vec4 ${name2}_(vec4 v) {
    return v;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslLeakyRelu(alpha) {
    const name2 = "leakyRelu";
    const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslLog() {
    return glslBuiltinUnary("log");
  }
  function glslNeg() {
    const name2 = "neg";
    const body = `
  float ${name2}_(float a) {
    return -a;
  }
  vec4 ${name2}_(vec4 v) {
    return -v;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslNot() {
    const name2 = "not";
    const body = `
  float ${name2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${name2}_(bool a) {
    return !a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${name2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSin() {
    return glslBuiltinUnary("sin");
  }
  function glslRelu() {
    const name2 = "relu";
    const body = `
  float ${name2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${name2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSigmoid() {
    const name2 = "sigmoid";
    const body = `
  float ${name2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${name2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSqrt() {
    return glslBuiltinUnary("sqrt");
  }
  function glslTan() {
    return glslBuiltinUnary("tan");
  }
  function glslTanh() {
    const name2 = "tanh";
    const body = `
  float ${name2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${name2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslBuiltinUnary(name2) {
    const body = `
  float ${name2}_(float a) {
    return ${name2}(a);
  }
  vec4 ${name2}_(vec4 v) {
    return ${name2}(v);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  var createElementwiseProgramInfo, createElementwiseProgramInfoLoader, abs, acos, asin, atan, clip, parseClipAttributes, clipV11, generateClipAttributesFromInputs, ceil, cos, elu, parseEluAttributes, exp, floor, identity, leakyRelu, parseLeakyReluAttributes, log2, neg, not2, relu, sigmoid, sin, sqrt, tan, tanh;
  var init_unary_op = __esm({
    "web/lib/onnxjs/backends/webgl/ops/unary-op.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_glsl_definitions();
      init_glsl_source();
      init_types();
      createElementwiseProgramInfo = (handler, metadata, input, glslFunc) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        const glsl = getGlsl(handler.session.backend.glContext.version);
        return {
          ...metadata,
          output: { dims: input.dims, type: input.type, textureType },
          shaderSource: `
     ${glslFunc.body}
     void main() {
       vec4 v = ${glsl.texture2D}(A, TexCoords);
       v = ${glslFunc.name}_(v);
       ${glsl.output} = v;
     }
     `,
          hasMain: true
        };
      };
      createElementwiseProgramInfoLoader = (handler, input, glslFunc, cacheKey) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        const metadata = { name: glslFunc.name, inputTypes: [textureType], inputNames: ["A"], cacheHint: cacheKey };
        return { ...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc) };
      };
      abs = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs)
      ];
      acos = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs)
      ];
      asin = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs)
      ];
      atan = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs)
      ];
      clip = (handler, inputs, attributes) => [
        handler.run(
          createElementwiseProgramInfoLoader(
            handler,
            inputs[0],
            glslClip(attributes.min, attributes.max),
            attributes.cacheKey
          ),
          inputs
        )
      ];
      parseClipAttributes = (node) => createAttributeWithCacheKey({
        min: node.attributes.getFloat("min", MIN_CLIP),
        max: node.attributes.getFloat("max", MAX_CLIP)
      });
      clipV11 = (handler, inputs) => {
        const attributes = generateClipAttributesFromInputs(handler, inputs);
        return clip(handler, [inputs[0]], attributes);
      };
      generateClipAttributesFromInputs = (handler, inputs) => {
        if (inputs.length >= 3 && (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))) {
          throw new Error("dynamic clip attributes are not allowed");
        }
        const min = inputs.length >= 3 ? inputs[1].numberData[0] : MIN_CLIP;
        const max = inputs.length >= 3 ? inputs[2].numberData[0] : MAX_CLIP;
        return createAttributeWithCacheKey({ min, max });
      };
      ceil = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs)
      ];
      cos = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs)
      ];
      elu = (handler, inputs, attributes) => [
        handler.run(
          createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),
          inputs
        )
      ];
      parseEluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 1) });
      exp = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs)
      ];
      floor = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs)
      ];
      identity = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs)
      ];
      leakyRelu = (handler, inputs, attributes) => [
        handler.run(
          createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),
          inputs
        )
      ];
      parseLeakyReluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 0.01) });
      log2 = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs)
      ];
      neg = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs)
      ];
      not2 = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs)
      ];
      relu = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs)
      ];
      sigmoid = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs)
      ];
      sin = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs)
      ];
      sqrt = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs)
      ];
      tan = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs)
      ];
      tanh = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs)
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts
  function getActivationSnippet(attributes) {
    let func;
    switch (attributes.activation) {
      case "Relu":
        func = glslRelu();
        break;
      case "Sigmoid":
        func = glslSigmoid();
        break;
      case "Clip":
        func = glslClip(attributes.clipMin, attributes.clipMax);
        break;
      default:
        return { activationFunction: "", applyActivation: "" };
    }
    const activationName = func.name;
    const activationFunction = func.body;
    const applyActivation = `value = ${activationName}_(value);`;
    return { activationFunction, applyActivation };
  }
  var parseInternalActivationAttributes;
  var init_fuse_utils = __esm({
    "web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts"() {
      "use strict";
      init_util();
      init_unary_op();
      parseInternalActivationAttributes = (attributes) => {
        const activation = attributes.getString("activation", "");
        if (activation === "Clip") {
          const [clipMin, clipMax] = attributes.getFloats("activation_params", [MIN_CLIP, MAX_CLIP]);
          return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };
        }
        return { activation, activationCacheKey: activation };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts
  var createUnpackedGroupedConvProgramMetadata, createUnpackedGroupedConvProgramInfo, createUnpackedGroupedConvProgramInfoLoader;
  var init_conv_grouped = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts"() {
      "use strict";
      init_instrument();
      init_glsl_source();
      init_types();
      init_conv();
      init_fuse_utils();
      createUnpackedGroupedConvProgramMetadata = (hasBias, cacheHint) => ({
        name: "GroupedConv",
        inputNames: hasBias ? ["X", "W", "Bias"] : ["X", "W"],
        inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        cacheHint
      });
      createUnpackedGroupedConvProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += getBias(output_channel);" : "";
        const xShape = inputs[0].dims.slice();
        const wShape = inputs[1].dims.slice();
        const outputChannelsPerGroup = wShape[0] / attributes.group;
        Logger.verbose(
          "GroupedConv",
          `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`
        );
        const outputShape = calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const { activationFunction, applyActivation } = getActivationSnippet(attributes);
        const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${outputChannelsPerGroup};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {
      int input_channel = group_id * ${wShape[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};

        if (xHeight < 0 || xHeight >= ${xShape[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};
          if (xWidth < 0 || xWidth >= ${xShape[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${processBias}
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource,
          hasMain: true
        };
      };
      createUnpackedGroupedConvProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
        const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);
        return {
          ...metadata,
          get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts
  var createPackedIm2ColProgramMetadata, createPackedIm2ColProgramInfo, createPackedIm2ColProgramInfoLoader;
  var init_im2col_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_packing_utils();
      createPackedIm2ColProgramMetadata = (cacheHint) => ({
        name: "Im2Col (packed)",
        inputNames: ["A"],
        inputTypes: [2 /* packed */],
        cacheHint
      });
      createPackedIm2ColProgramInfo = (inferenceHandler, metadata, x, w, outputShape, attributes) => {
        const xshape = x.dims;
        const wshape = w.dims;
        const rowDim = 2;
        const colDim = 3;
        const rank = outputShape.length;
        const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];
        const kernelSize = wshape[2] * wshape[3];
        const unpackChannel = unpackFromChannel();
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        let unrolled = "";
        for (let row = 0; row <= 1; row++) {
          for (let col = 0; col <= 1; col++) {
            unrolled += `
            blockIndex = rc.x + ${col};
            pos = rc.y + ${row};

            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {
              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -
                ${attributes.pads[0]};
              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});

              if(d0 < ${xshape[rowDim]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -
                  ${attributes.pads[1]};
                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});

                if(d1 < ${xshape[colDim]} && d1 >= 0) {

                  ch = int(float(pos)/ ${kernelSize}.);
                    innerDims = vec2(d0, d1);
                    result[${row * 2 + col}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
          }
        }
        const shaderSource = `
      ${unpackChannel}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${unrolled}
          ${glsl.output} = result;
      }
            `;
        return {
          ...metadata,
          output: { dims: im2colShape, type: x.type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
        const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);
        return {
          ...metadata,
          get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/matmul.ts
  function createMatmulProgramInfo(metadata, inputs, activationAttributes) {
    const aShape = inputs[0].dims;
    const bShape = inputs[1].dims;
    const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
    if (!outputShape) {
      throw new Error("Can't use matmul on the given tensors");
    }
    const coordsDataType = getCoordsDataType(outputShape.length);
    const allGlChannels = getGlChannels();
    const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
    const hasBias = inputs.length > 2;
    const processBias = hasBias ? "value += getBiasForMatmul();" : "";
    const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}` : "";
    const rank = outputShape.length;
    const arank = aShape.length;
    const brank = bShape.length;
    const sharedDim = aShape[aShape.length - 1];
    const shaderSource = `
    ${activationFunction}
    ${getBiasForMatmulSnippet}
    float process(int indices[${rank}]) {
        int a[${arank}];
        int b[${brank}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${sharedDim}; ++k) {
            a[${arank - 1}] = k;
            b[${brank - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${processBias}
        ${applyActivation}
        return value;
    }`;
    return {
      ...metadata,
      output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
      shaderSource
    };
  }
  function createMatmulProgramInfoLoader(inputs, activationAttributes) {
    const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
    return { ...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes) };
  }
  function getBiasForMatmul(coordsDataType, allGlChannels, inShape, outShape, isPacked) {
    let unpackedCoordsSnippet = "";
    const inRank = inShape.length;
    const outRank = outShape.length;
    const rankDiff = outRank - inRank;
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(", ");
    }
    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
    const coordsSnippet = broadcastDims.map((d) => `coords.${allGlChannels[d + rankDiff]} = 0;`).join("\n");
    const inSize = ShapeUtil.size(inShape);
    const isInputScalar = inSize === 1;
    let output = "vec4(outputValue.xx, outputValue.yy)";
    if (isInputScalar) {
      output = "vec4(outputValue.x)";
    }
    const getBiasForMatmulSource = isPacked ? `
vec4 getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  vec4 outputValue = getBias(${unpackedCoordsSnippet});
  return ${output};
}` : `
float getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  return getBias(coords.x);
}`;
    return getBiasForMatmulSource;
  }
  var matMul, parseMatMulAttributes, createMatmulProgramMetadata, validateInputs4;
  var init_matmul = __esm({
    "web/lib/onnxjs/backends/webgl/ops/matmul.ts"() {
      "use strict";
      init_util();
      init_types();
      init_utils();
      init_fuse_utils();
      init_matmul_pack();
      matMul = (inferenceHandler, inputs, attributes) => {
        validateInputs4(inputs);
        if (inferenceHandler.session.pack) {
          return [inferenceHandler.run(createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes), inputs)];
        } else {
          return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];
        }
      };
      parseMatMulAttributes = (node) => parseInternalActivationAttributes(node.attributes);
      createMatmulProgramMetadata = (hasBias, cacheHint) => ({
        name: "MatMul",
        inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
        inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        cacheHint
      });
      validateInputs4 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("MatMul requires 2 inputs.");
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
          throw new Error("shared dimension does not match.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64") {
          throw new Error("inputs should be float type");
        }
        if (inputs[0].type !== inputs[1].type) {
          throw new Error("inputs types should match");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts
  function getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outShape) {
    let unpackedACoordsSnippet = [];
    let unpackedBCoordsSnippet = [];
    const inAShape = inputs[0].dims;
    const inBShape = inputs[1].dims;
    const inARank = inAShape.length;
    const inBRank = inBShape.length;
    const outRank = outShape.length;
    const rankADiff = outRank - inARank;
    const rankBDiff = outRank - inBRank;
    unpackedACoordsSnippet = inAShape.map((_s, i) => `coords.${allGlChannels[i + rankADiff]}`);
    unpackedACoordsSnippet[inARank - 1] = "i*2";
    unpackedACoordsSnippet.join(", ");
    unpackedBCoordsSnippet = inBShape.map((_s, i) => `coords.${allGlChannels[i + rankBDiff]}`);
    unpackedBCoordsSnippet[inBRank - 2] = "i*2";
    unpackedBCoordsSnippet.join(", ");
    const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);
    const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);
    const coordsASnippet = broadcastADims.map((d) => `coords.${allGlChannels[d + rankADiff]} = 0;`).join("\n");
    const coordsBSnippet = broadcastBDims.map((d) => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join("\n");
    const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};
  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};
  coords.${allGlChannels[outRank - 2]} = lastDim;`;
    const getBcastSamplerMatmulSource = `
vec4 getAAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsASnippet}
  vec4 outputValue = getA(${unpackedACoordsSnippet});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsBSnippet}
  vec4 outputValue = getB(${unpackedBCoordsSnippet});
  return outputValue;
}`;
    return getBcastSamplerMatmulSource;
  }
  function getA(allGlChannels, rank) {
    let res = "";
    for (let i = 0; i < rank - 2; i++) {
      res += `rc.${allGlChannels[i]}, `;
    }
    res += `rc.${allGlChannels[rank - 2]}, i*2`;
    return res;
  }
  function getB(allGlChannels, rank) {
    let res = "";
    for (let i = 0; i < rank - 2; i++) {
      res += `rc.${allGlChannels[i]}, `;
    }
    res += `i*2, rc.${allGlChannels[rank - 1]}`;
    return res;
  }
  var createPackedMatmulProgramMetadata, createPackedMatmulProgramInfo, createPackedMatmulProgramInfoLoader;
  var init_matmul_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts"() {
      "use strict";
      init_util();
      init_glsl_source();
      init_types();
      init_utils();
      init_fuse_utils();
      init_matmul();
      createPackedMatmulProgramMetadata = (hasBias, cacheHint) => ({
        name: "MatMul (packed)",
        inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
        inputTypes: hasBias ? [2 /* packed */, 2 /* packed */, 2 /* packed */] : [2 /* packed */, 2 /* packed */],
        cacheHint
      });
      createPackedMatmulProgramInfo = (inferenceHandler, metadata, inputs, activationAttributes) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += getBiasForMatmul();" : "";
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
        const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
        if (!outputShape) {
          throw new Error("Can't use matmul on the given tensors");
        }
        const sharedDim = aShape[aShape.length - 1];
        const sharedDimIndex = Math.ceil(sharedDim / 2);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const coordsDataType = getCoordsDataType(outputShape.length);
        const outRank = outputShape.length;
        const allGlChannels = getGlChannels();
        const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
        const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}` : "";
        const getBcastedSamplerForMatmulSnippet = isBroadcast ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}` : "";
        const getSamplerAInLoopSnippet = isBroadcast ? "getAAtOutCoordsMatmul(i)" : `getA(${getA(allGlChannels, aRank)})`;
        const getSamplerBInLoopSnippet = isBroadcast ? "getBAtOutCoordsMatmul(i)" : `getB(${getB(allGlChannels, bRank)})`;
        const getOutputCoordsSnippet = isBroadcast ? "" : `${coordsDataType} rc =
          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =
          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;
      `;
        const shaderSource = `
            ${getBcastedSamplerForMatmulSnippet}
            ${getBiasForMatmulSnippet}
            ${activationFunction}
            void main() {
              ${getOutputCoordsSnippet}

              vec4 value = vec4(0);
              for (int i = 0; i < ${sharedDimIndex}; i++) {
                vec4 a = ${getSamplerAInLoopSnippet};
                vec4 b = ${getSamplerBInLoopSnippet};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${processBias}
              ${applyActivation}
              ${glsl.output} = value;
            }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedMatmulProgramInfoLoader = (inferenceHandler, inputs, activationAttributes) => {
        const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
        return {
          ...metadata,
          get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv-pack.ts
  var conv2DPacked;
  var init_conv_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv-pack.ts"() {
      "use strict";
      init_conv();
      init_im2col_pack();
      init_matmul_pack();
      conv2DPacked = (inferenceHandler, inputs, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
        const im2colOutput = inferenceHandler.run(
          createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
          [inputs[0]]
        );
        const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);
        const matmulInputs = inputs.length === 3 ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];
        const matmulOutput = inferenceHandler.run(
          createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),
          matmulInputs
        );
        const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);
        return outputReshaped;
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/im2col.ts
  var createIm2ColProgramMetadata, createIm2ColProgramInfo, createIm2ColProgramInfoLoader, calculateIm2ColDims;
  var init_im2col = __esm({
    "web/lib/onnxjs/backends/webgl/ops/im2col.ts"() {
      "use strict";
      init_types();
      createIm2ColProgramMetadata = (cacheHint) => ({
        name: "Im2Col",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */],
        cacheHint
      });
      createIm2ColProgramInfo = (_inferenceHandler, metadata, x, w, outputShape, attributes) => {
        const xshape = x.dims;
        const wshape = w.dims;
        const rank = outputShape.length;
        const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);
        const shaderSource = `
        const int XC = ${xshape[1]};
        const int XH = ${xshape[2]};
        const int XW = ${xshape[3]};
        const int KH = ${attributes.kernelShape[0]};
        const int KW = ${attributes.kernelShape[1]};
        const int dilationH = ${attributes.dilations[0]};
        const int dilationW = ${attributes.dilations[1]};
        const int strideH = ${attributes.strides[0]};
        const int strideW = ${attributes.strides[1]};
        const int padH = ${attributes.pads[0]};
        const int padW = ${attributes.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${rank}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${xshape.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
        return {
          ...metadata,
          output: { dims: im2colDims, type: x.type, textureType: 4 /* packedLastDimension */ },
          shaderSource
        };
      };
      createIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
        const metadata = createIm2ColProgramMetadata(attributes.cacheKey);
        return {
          ...metadata,
          get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
        };
      };
      calculateIm2ColDims = (inputShape, kernelShape, outputShape, channels = 4) => [
        outputShape[0],
        outputShape[2],
        outputShape[3],
        Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/dot-product.ts
  var createDotProductProgramMetadata, createDotProductProgramInfo, createDotProductProgramInfoLoader;
  var init_dot_product = __esm({
    "web/lib/onnxjs/backends/webgl/ops/dot-product.ts"() {
      "use strict";
      init_util();
      init_glsl_source();
      init_types();
      init_fuse_utils();
      init_im2col();
      createDotProductProgramMetadata = (hasBias, attributes) => ({
        name: "ConvDotProduct",
        inputNames: hasBias ? ["Im2Col", "K", "B"] : ["Im2Col", "K"],
        inputTypes: hasBias ? [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */] : [0 /* unpacked */, 4 /* packedLastDimension */],
        cacheKey: attributes.activationCacheKey
      });
      createDotProductProgramInfo = (inferenceHandler, metadata, inputs, outputShape, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const adjustedKernelShape = [kshape[0], Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4)];
        const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);
        const [kWidth, kHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          adjustedKernelShape,
          4 /* packedLastDimension */
        );
        const im2colStrides = ShapeUtil.computeStrides(im2colShape);
        const [im2colWidth, im2colHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          im2colShape,
          4 /* packedLastDimension */
        );
        const rank = outputShape.length;
        const initValue = inputs.length < 3 ? "0.0" : "_B(b)";
        const sharedDim = Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4);
        const { activationFunction, applyActivation } = getActivationSnippet(attributes);
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
${activationFunction}
float process(int indices[${rank}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${im2colStrides[2]};
  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};
  float value = ${initValue};
  for (int i = 0; i < ${sharedDim}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});
    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${applyActivation}
  return value;
}`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createDotProductProgramInfoLoader = (inferenceHandler, inputs, outputShape, attributes) => {
        const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);
        return {
          ...metadata,
          get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv.ts
  var calculateOutputShape, conv, conv2d, conv2DUnpackedPointwise, conv2DUnpacked, getAdjustedConvAttributes, parseConvAttributes, validateInputs5;
  var init_conv = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_conv_grouped();
      init_conv_pack();
      init_dot_product();
      init_fuse_utils();
      init_im2col();
      init_matmul();
      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides) => {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(2);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputSpatialShape = inputSpatialShapeWithPad.map(
          (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
        );
        const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);
        return outputShape;
      };
      conv = (inferenceHandler, inputs, attributes) => {
        validateInputs5(inputs, attributes);
        return conv2d(inferenceHandler, inputs, attributes);
      };
      conv2d = (inferenceHandler, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const packMode = inferenceHandler.session.pack;
        const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;
        if (adjustedAttributes.group > 1) {
          const result = inferenceHandler.run(
            createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes),
            inputs
          );
          return [result];
        } else if (isPointwise && packMode) {
          return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];
        } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {
          return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];
        } else {
          return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
        }
      };
      conv2DUnpackedPointwise = (inferenceHandler, inputs, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
        const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);
        const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);
        const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];
        const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);
        return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);
      };
      conv2DUnpacked = (inferenceHandler, inputs, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
        const xIm2Col = inferenceHandler.run(
          createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
          [inputs[0]]
        );
        const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];
        const output = inferenceHandler.run(
          createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes),
          dotProductInputs
        );
        return output;
      };
      getAdjustedConvAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0) {
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPadsBasedOnAutoPad(
          inputs[0].dims,
          attributes.strides,
          attributes.dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });
        return newAttributes;
      };
      parseConvAttributes = (node) => {
        const attributes = node.attributes;
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const autoPad = attributes.getString("auto_pad", "NOTSET");
        const dilations = attributes.getInts("dilations", [1, 1]);
        const group = attributes.getInt("group", 1);
        const kernelShape = attributes.getInts("kernel_shape", []);
        const pads = attributes.getInts("pads", [0, 0, 0, 0]);
        const strides = attributes.getInts("strides", [1, 1]);
        return createAttributeWithCacheKey({
          autoPad,
          dilations,
          group,
          kernelShape,
          pads,
          strides,
          ...activationAttributes
        });
      };
      validateInputs5 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
          throw new Error("currently only support 2-dimensional conv");
        }
        const dataChannel = inputs[0].dims[1];
        const filterInChannel = inputs[1].dims[1] * attributes.group;
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
          throw new Error("Conv input(X,W) should be float tensor");
        }
        if (inputs.length === 3 && inputs[2].type !== "float32") {
          throw new Error("Conv input(bias) should be float tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts
  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, convTranspose, convTranspose2d, createConvTransposeProgramMetadata, createUnpackedConvTransposeProgramInfo, createUnpackedConvTransposeProgramInfoLoader, convTranspose2DUnpacked, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs6;
  var init_conv_transpose = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_glsl_source();
      init_types();
      init_fuse_utils();
      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
      distributePadding = (totalPad, autoPad, pads, head, tail) => {
        const smallPad = Math.floor(totalPad / 2);
        if (autoPad === "SAME_UPPER") {
          pads[head] = smallPad;
          pads[tail] = totalPad - smallPad;
        } else if (autoPad === "SAME_LOWER") {
          pads[head] = totalPad - smallPad;
          pads[tail] = smallPad;
        }
      };
      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, pads, strides, outputPadding, outputShape) => {
        const spatialRank = inputShape.length - 2;
        const updateShape = outputShape.length === 0;
        for (let i = 0; i < spatialRank; ++i) {
          const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];
          const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);
          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
          if (updateShape) {
            outputShape.push(
              strides[i] * (inputShape[i + 2] - 1) + outputPadding[i] + (kernelShape[i] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
            );
          }
        }
      };
      convTranspose = (inferenceHandler, inputs, attributes) => {
        validateInputs6(inputs, attributes);
        return convTranspose2d(inferenceHandler, inputs, attributes);
      };
      convTranspose2d = (inferenceHandler, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
        return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
      };
      createConvTransposeProgramMetadata = (hasBias, cacheHint) => ({
        name: "ConvTranspose",
        inputNames: hasBias ? ["X", "W", "B"] : ["X", "W"],
        inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        cacheHint
      });
      createUnpackedConvTransposeProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
        const hasBias = inputs.length > 2;
        const valueInit = hasBias ? "getB(output_channel)" : "0.0";
        const xShape = inputs[0].dims;
        const wShape = inputs[1].dims;
        const outputChannelsPerGroup = wShape[1];
        const inputChannelsPerGroup = wShape[0] / attributes.group;
        const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const { activationFunction, applyActivation } = getActivationSnippet(attributes);
        const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${outputChannelsPerGroup};
    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};

    float value = ${valueInit};
    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {
      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource,
          hasMain: true
        };
      };
      createUnpackedConvTransposeProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
        const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);
        return {
          ...metadata,
          get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes)
        };
      };
      convTranspose2DUnpacked = (inferenceHandler, inputs, attributes) => {
        const result = inferenceHandler.run(
          createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes),
          inputs
        );
        return result;
      };
      getAdjustedConvTransposeAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0) {
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const pads = attributes.pads.slice();
        const outputShape = attributes.outputShape.slice();
        const inputShape = inputs[0].dims;
        calculateOutputShapeAndPads(
          inputShape,
          kernelShape,
          attributes.dilations,
          attributes.autoPad,
          pads,
          attributes.strides,
          attributes.outputPadding,
          outputShape
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, outputShape, cacheKey: attributes.cacheKey });
        return newAttributes;
      };
      parseConvTransposeAttributes = (node) => {
        const attributes = node.attributes;
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const autoPad = attributes.getString("auto_pad", "NOTSET");
        const dilations = attributes.getInts("dilations", [1, 1]);
        const group = attributes.getInt("group", 1);
        const kernelShape = attributes.getInts("kernel_shape", []);
        const outputPadding = attributes.getInts("output_padding", [0, 0]);
        const outputShape = attributes.getInts("output_shape", []);
        const pads = attributes.getInts("pads", [0, 0, 0, 0]);
        const strides = attributes.getInts("strides", [1, 1]);
        return createAttributeWithCacheKey({
          autoPad,
          dilations,
          group,
          kernelShape,
          outputPadding,
          outputShape,
          pads,
          strides,
          ...activationAttributes
        });
      };
      validateInputs6 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
          throw new Error("currently only support 2-dimensional conv");
        }
        const dataChannel = inputs[0].dims[1];
        const filterInChannel = inputs[1].dims[0];
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        const featureMaps = inputs[1].dims[1] * attributes.group;
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.outputPadding.length !== spatialRank) {
          throw new Error(`output_padding should be ${spatialRank}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
          throw new Error("invalid output shape");
        }
        if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
          throw new Error("ConvTranspose input(X,W) should be float tensor");
        }
        if (inputs.length === 3 && inputs[2].type !== "float32") {
          throw new Error("ConvTranspose input(bias) should be float tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/transpose.ts
  var transposeProgramMetadata, transpose, parseTransposeAttributes, createTransposeProgramInfo, getAdjustedPerm, getOutputShape, getPermFunctionBody, validateInputs7;
  var init_transpose = __esm({
    "web/lib/onnxjs/backends/webgl/ops/transpose.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      transposeProgramMetadata = {
        name: "Transpose",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      transpose = (inferenceHandler, inputs, attributes) => {
        validateInputs7(inputs);
        const output = inferenceHandler.run(
          {
            ...transposeProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm)
          },
          inputs
        );
        return [output];
      };
      parseTransposeAttributes = (node) => createAttributeWithCacheKey({ perm: node.attributes.getInts("perm", []) });
      createTransposeProgramInfo = (_inferenceHandler, input, perm) => {
        const inputShape = input.dims;
        perm = getAdjustedPerm(inputShape, perm);
        const unpackedOutputShape = getOutputShape(inputShape, perm);
        const rank = inputShape.length;
        const shaderSource = `
      ${getPermFunctionBody("perm", perm, rank)}
      float process(int indices[${rank}]) {
        int a[${rank}];
        perm(a, indices);
        return _A(a);
      }`;
        return {
          ...transposeProgramMetadata,
          output: { dims: unpackedOutputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      getAdjustedPerm = (inputShape, perm) => {
        if (perm && perm.length !== inputShape.length) {
          perm = [...inputShape.keys()].reverse();
        }
        return perm;
      };
      getOutputShape = (inputShape, perm) => {
        perm = getAdjustedPerm(inputShape, perm);
        return ShapeUtil.sortBasedOnPerm(inputShape, perm);
      };
      getPermFunctionBody = (name2, perm, rank) => {
        const reverseFunc = [];
        reverseFunc.push(`void ${name2}(out int a[${rank}], int src[${rank}]) {`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(`	a[${perm[i]}]=src[${i}];`);
        }
        reverseFunc.push("	}");
        return reverseFunc.join("\n");
      };
      validateInputs7 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Transpose requires 1 input.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("input should be float tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts
  var depthToSpace, parseDepthToSpaceAttributes, validateInputs8;
  var init_depth_to_space = __esm({
    "web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts"() {
      "use strict";
      init_transpose();
      depthToSpace = (inferenceHandler, inputs, attributes) => {
        validateInputs8(inputs);
        const blocksize = attributes.blocksize;
        const blocksizeSqr = blocksize * blocksize;
        const transposePerm = attributes.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        const firstReshapeShape = attributes.mode === "DCR" ? [
          inputs[0].dims[0],
          blocksize,
          blocksize,
          inputs[0].dims[1] / blocksizeSqr,
          inputs[0].dims[2],
          inputs[0].dims[3]
        ] : [
          inputs[0].dims[0],
          inputs[0].dims[1] / blocksizeSqr,
          blocksize,
          blocksize,
          inputs[0].dims[2],
          inputs[0].dims[3]
        ];
        const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);
        const transposeAttributes = { perm: transposePerm, cacheKey: `${transposePerm}` };
        const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);
        const secondReshapeShape = [
          inputs[0].dims[0],
          inputs[0].dims[1] / blocksizeSqr,
          inputs[0].dims[2] * blocksize,
          inputs[0].dims[3] * blocksize
        ];
        const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);
        return [result];
      };
      parseDepthToSpaceAttributes = (node) => {
        const blocksize = node.attributes.getInt("blocksize");
        if (blocksize < 1) {
          throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);
        }
        const mode = node.attributes.getString("mode", "DCR");
        if (mode !== "DCR" && mode !== "CRD") {
          throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);
        }
        return { mode, blocksize };
      };
      validateInputs8 = (inputs) => {
        if (inputs.length !== 1) {
          throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);
        }
        if (inputs[0].type === "string" || inputs[0].dims.length !== 4) {
          throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/flatten.ts
  var flatten, parseFlattenAttributes, validateInputs9;
  var init_flatten = __esm({
    "web/lib/onnxjs/backends/webgl/ops/flatten.ts"() {
      "use strict";
      init_util();
      flatten = (inferenceHandler, inputs, axis) => {
        validateInputs9(inputs, axis);
        const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);
        return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];
      };
      parseFlattenAttributes = (node) => node.attributes.getInt("axis", 1);
      validateInputs9 = (inputs, axis) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Flatten requires 1 input.");
        }
        const r = inputs[0].dims.length;
        if (r === 0) {
          throw new Error("scalar tensor is not supported.");
        }
        if (axis < -r || axis > r) {
          throw new Error("Invalid axis");
        }
        if (inputs[0].type === "string") {
          throw new Error("string tensor is not supported.");
        }
      };
    }
  });

  // web/lib/onnxjs/operators.ts
  var NUMBER_TYPES;
  var init_operators = __esm({
    "web/lib/onnxjs/operators.ts"() {
      "use strict";
      NUMBER_TYPES = [
        "float32",
        "float64",
        "int32",
        "int16",
        "int8",
        "uint16",
        "uint32",
        "uint8"
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/gather.ts
  var gather, parseGatherAttributes, gatherProgramMetadata, createGatherProgramInfo, createGatherProgramInfoLoader, validateInputs10;
  var init_gather = __esm({
    "web/lib/onnxjs/backends/webgl/ops/gather.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_operators();
      init_util();
      init_types();
      gather = (inferenceHandler, inputs, attributes) => {
        validateInputs10(inputs, attributes.axis);
        const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      };
      parseGatherAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 0) });
      gatherProgramMetadata = {
        name: "Gather",
        inputNames: ["A", "B"],
        inputTypes: [0 /* unpacked */, 0 /* unpacked */]
      };
      createGatherProgramInfo = (_handler, metadata, inputs, axis) => {
        const inputShape = inputs[0].dims.slice();
        const indexDataShape = inputs[1].dims.slice();
        const outputShape = new Array(inputShape.length + indexDataShape.length - 1);
        axis = ShapeUtil.normalizeAxis(axis, inputShape.length);
        const indexCopyOps = [];
        for (let i = 0; i < outputShape.length; i++) {
          if (i < axis) {
            outputShape[i] = inputShape[i];
            indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);
          } else {
            if (i < axis + indexDataShape.length) {
              outputShape[i] = indexDataShape[i - axis];
              indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);
            } else {
              outputShape[i] = inputShape[i - indexDataShape.length + 1];
              indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);
            }
          }
        }
        const orank = outputShape.length || 1;
        const irank = inputShape.length;
        const iDrank = indexDataShape.length || 1;
        const shaderSource = `
      float process(int outputIdx[${orank}]) {
        int inputIdx[${irank}];
        int indexDataIdx[${iDrank}];
        indexDataIdx[0] = 0;
        ${indexCopyOps.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;
        return _A(inputIdx);
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createGatherProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = { ...gatherProgramMetadata, cacheHint: attributes.cacheKey };
        return { ...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis) };
      };
      validateInputs10 = (inputs, axis) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Gather requires 2 inputs.");
        }
        const tensorRank = inputs[0].dims.length;
        if (tensorRank < 1) {
          throw new Error("Invalid input shape.");
        }
        if (axis < -tensorRank || axis > tensorRank - 1) {
          throw new Error("Invalid axis.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invaid input type.");
        }
        if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
          throw new Error("Invaid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/gemm.ts
  var gemm, parseGemmAttributes, parseGemmAttributesV7, parseGemmAttributesV11, createGemmProgramInfoLoader, createGemmProgramInfo, validateInputs11;
  var init_gemm = __esm({
    "web/lib/onnxjs/backends/webgl/ops/gemm.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      gemm = (inferenceHandler, inputs, attributes) => {
        validateInputs11(inputs, attributes);
        const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);
        return [output];
      };
      parseGemmAttributes = (node, isOptionalC) => {
        const transA = node.attributes.getInt("transA", 0) !== 0;
        const transB = node.attributes.getInt("transB", 0) !== 0;
        const alpha = node.attributes.getFloat("alpha", 1);
        const beta = node.attributes.getFloat("beta", 1);
        return createAttributeWithCacheKey({ transA, transB, alpha, beta, isOptionalC });
      };
      parseGemmAttributesV7 = (node) => parseGemmAttributes(node, false);
      parseGemmAttributesV11 = (node) => parseGemmAttributes(node, true);
      createGemmProgramInfoLoader = (inputs, attributes) => {
        const metadata = {
          name: "Gemm",
          inputNames: inputs.length === 3 ? ["A", "B", "C"] : ["A", "B"],
          inputTypes: inputs.length === 3 ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
          key: attributes.cacheKey
        };
        return { ...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes) };
      };
      createGemmProgramInfo = (metadata, inputs, attributes) => {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N] = GemmUtil.getShapeOfGemmResult(
          aShape,
          attributes.transA,
          bShape,
          attributes.transB,
          inputs.length === 3 ? inputs[2].dims : void 0
        );
        const outputShape = [M, N];
        if (!outputShape) {
          throw new Error("Can't use gemm on the given tensors");
        }
        let sharedDim = aShape[aShape.length - 1];
        let line = "";
        if (attributes.transA) {
          sharedDim = aShape[0];
        }
        if (attributes.transA && attributes.transB) {
          line = "value += _A_T(a) * _B_T(b);";
        } else if (attributes.transA && !attributes.transB) {
          line = "value += _A_T(a) * _B(b);";
        } else if (!attributes.transA && attributes.transB) {
          line = "value += _A(a) * _B_T(b);";
        } else if (!attributes.transA && !attributes.transB) {
          line = "value += _A(a) * _B(b);";
        }
        const rank = outputShape.length;
        const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : "";
        const broadcastC = inputs.length === 3 ? "bcastIndices_C(indices, c);" : "";
        const calculateC = inputs.length === 3 ? "value += beta * _C(c);" : "";
        const shaderSource = `
      float process(int indices[${rank}]) {
          int a[${rank}];
          int b[${rank}];
          ${declareC}

          copyVec(indices, a);
          copyVec(indices, b);
          ${broadcastC}

          float value = 0.0;
          for (int k=0; k<${sharedDim}; ++k) {
              a[${rank - 1}] = k;
              b[${rank - 2}] = k;
              ${line}
          }

          value = value * alpha;
          ${calculateC}
          return value;
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          variables: [
            { name: "alpha", type: "float", data: attributes.alpha },
            { name: "beta", type: "float", data: attributes.beta }
          ],
          shaderSource
        };
      };
      validateInputs11 = (inputs, attributes) => {
        if (!inputs) {
          throw new Error("Input is missing");
        }
        if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {
          throw new Error("Invaid input shape.");
        }
        if (!attributes.isOptionalC && inputs.length !== 3) {
          throw new Error("Gemm requires 3 inputs");
        }
        if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {
          throw new Error("Invalid input shape of C");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64" || inputs.length === 3 && inputs[2].type !== "float32" && inputs[2].type !== "float64") {
          throw new Error("Invalid input type.");
        }
        if (inputs[0].type !== inputs[1].type || inputs.length === 3 && inputs[0].type !== inputs[2].type) {
          throw new Error("Input types are mismatched");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/image-scaler.ts
  var imageScaler, parseImageScalerAttributes, imageScalerProgramMetadata, createImageScalerProgramInfo, createImageScalerProgramInfoLoader, createGetBiasMethod, validateInputs12;
  var init_image_scaler = __esm({
    "web/lib/onnxjs/backends/webgl/ops/image-scaler.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_types();
      imageScaler = (inferenceHandler, inputs, attributes) => {
        validateInputs12(inputs);
        const output = inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      };
      parseImageScalerAttributes = (node) => {
        const scale = node.attributes.getFloat("scale");
        const bias = node.attributes.getFloats("bias");
        return createAttributeWithCacheKey({ scale, bias });
      };
      imageScalerProgramMetadata = {
        name: "ImageScaler",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      createImageScalerProgramInfo = (_handler, metadata, inputs, attributes) => {
        const outputShape = inputs[0].dims.slice();
        const rank = outputShape.length;
        const getBiasMethod = createGetBiasMethod(attributes.bias.length);
        const shaderSource = `
      ${getBiasMethod}
      float process(int indices[${rank}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          variables: [
            { name: "bias", type: "float", arrayLength: attributes.bias.length, data: attributes.bias },
            { name: "scale", type: "float", data: attributes.scale }
          ],
          shaderSource
        };
      };
      createImageScalerProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = { ...imageScalerProgramMetadata, cacheHint: attributes.cacheKey };
        return { ...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes) };
      };
      createGetBiasMethod = (numChannels) => {
        const codeLines = [`float getBias(float bias[${numChannels}], int channel) {`];
        for (let i = 0; i < numChannels; ++i) {
          if (i === 0) {
            codeLines.push(`	if (channel == ${i}) { return bias[${i}]; }`);
          } else if (i === numChannels - 1) {
            codeLines.push(`	else { return bias[${i}]; }`);
          } else {
            codeLines.push(`	else if (channel == ${i}) { return bias[${i}]; }`);
          }
        }
        codeLines.push("	}");
        return codeLines.join("\n");
      };
      validateInputs12 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("ImageScaler requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("Invalid input shape.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts
  var instanceNormalization, parseInstanceNormalizationAttributes, meanAndVarianceProgramMetadata, createMeanAndVarianceProgramInfo, createMeanAndVarianceProgramInfoLoader, computeOutputProgramMetadata, createComputeOutputProgramInfo, createComputeOutputProgramInfoLoader, validateInputs13;
  var init_instance_normalization = __esm({
    "web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      instanceNormalization = (inferenceHandler, inputs, epsilon) => {
        validateInputs13(inputs);
        const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);
        const output = inferenceHandler.run(
          createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),
          [inputs[0], meanAndVariance, inputs[1], inputs[2]]
        );
        return [output];
      };
      parseInstanceNormalizationAttributes = (node) => node.attributes.getFloat("epsilon", 1e-5);
      meanAndVarianceProgramMetadata = {
        name: "InstanceNormalization_MeanAndVariance",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      createMeanAndVarianceProgramInfo = (metadata, input) => {
        const xDims = input.dims.slice();
        const channel = xDims[1];
        const channelSize = xDims[2] * xDims[3];
        const outputShape = [xDims[0], channel];
        const shaderSource = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${channelSize});
        temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${channelSize});

        return v;
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: input.type, textureType: 4 /* packedLastDimension */ },
          shaderSource
        };
      };
      createMeanAndVarianceProgramInfoLoader = (input) => ({
        ...meanAndVarianceProgramMetadata,
        get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input)
      });
      computeOutputProgramMetadata = {
        name: "InstanceNormalization_ComputeOutput",
        inputNames: ["X", "MeanAndVariance", "Scale", "B"],
        inputTypes: [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */, 0 /* unpacked */]
      };
      createComputeOutputProgramInfo = (inferenceHandler, metadata, input, epsilon, meanAndVarianceShape) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          meanAndVarianceShape,
          4 /* packedLastDimension */
        );
        const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];
        const shaderSource = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});
        return ${glsl.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
        return {
          ...metadata,
          output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
          variables: [{ name: "epsilon", type: "float", data: epsilon }],
          shaderSource
        };
      };
      createComputeOutputProgramInfoLoader = (inferenceHandler, input, epsilon, meanAndVarianceShape) => {
        const metadata = { ...computeOutputProgramMetadata, cacheHint: `${epsilon}` };
        return {
          ...metadata,
          get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape)
        };
      };
      validateInputs13 = (inputs) => {
        if (!inputs || inputs.length !== 3) {
          throw new Error("InstanceNormalization requires 3 inputs.");
        }
        const X = inputs[0];
        const scale = inputs[1];
        const B = inputs[2];
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {
          throw new Error("Invalid input shape.");
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {
          throw new Error("Input shapes are mismatched.");
        }
        if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64") {
          throw new Error("Invalid input type.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("Only support 4-D input shape.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/lrn.ts
  function createLrnProgramInfo(inputs, attributes) {
    const C = inputs[0].dims[1];
    const rank = inputs[0].dims.length;
    const from = -Math.floor((attributes.size - 1) / 2);
    const to = Math.ceil((attributes.size - 1) / 2);
    const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;
    const bias = `float(${attributes.bias})`;
    const beta = `float(${attributes.beta})`;
    const shaderSource = `
    float process(int indices[${rank}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${from}; i <= ${to}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${C}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${bias} + ${alpha} * square_sum, ${beta});
    }`;
    return {
      ...lrnProgramMetadata,
      cacheHint: attributes.cacheKey,
      output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
      shaderSource
    };
  }
  function createLrnProgramInfoLoader(inputs, attributes) {
    return { ...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes) };
  }
  var lrn, parseLrnAttributes, lrnProgramMetadata, validateInputs14;
  var init_lrn = __esm({
    "web/lib/onnxjs/backends/webgl/ops/lrn.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_types();
      lrn = (inferenceHandler, inputs, attributes) => {
        validateInputs14(inputs);
        return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];
      };
      parseLrnAttributes = (node) => {
        const alpha = node.attributes.getFloat("alpha", 1e-4);
        const beta = node.attributes.getFloat("beta", 0.75);
        const bias = node.attributes.getFloat("bias", 1);
        const size = node.attributes.getInt("size");
        return createAttributeWithCacheKey({ alpha, beta, bias, size });
      };
      lrnProgramMetadata = {
        name: "LRN",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      validateInputs14 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("LRN requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error('currently only support LRN for input with "NCHW" format');
        }
        if (inputs[0].type !== "float32") {
          throw new Error("input should be float type");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/pad.ts
  var padProgramMetadata, padV2, parsePadAttributesV2, padV11, parsePadAttributesV11, generatePadAttributesFromInputs, createPadProgramInfo, validateInputsV2, validateInputsV11, getPadFunction, getPadConstant, getPadReflect, getPadEdge;
  var init_pad = __esm({
    "web/lib/onnxjs/backends/webgl/ops/pad.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_glsl_source();
      init_types();
      padProgramMetadata = {
        name: "Pad",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      padV2 = (inferenceHandler, inputs, attributes) => {
        validateInputsV2(inputs);
        const output = inferenceHandler.run(
          {
            ...padProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes)
          },
          inputs
        );
        return [output];
      };
      parsePadAttributesV2 = (node) => {
        const mode = node.attributes.getString("mode", "constant");
        const value = node.attributes.getFloat("value", 0);
        const pads = node.attributes.getInts("pads");
        return createAttributeWithCacheKey({ mode, value, pads });
      };
      padV11 = (inferenceHandler, inputs, mode) => {
        validateInputsV11(inputs);
        const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);
        return padV2(inferenceHandler, [inputs[0]], attrubutes);
      };
      parsePadAttributesV11 = (node) => node.attributes.getString("mode", "constant");
      generatePadAttributesFromInputs = (inferenceHandler, inputs, mode) => {
        if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId)) {
          throw new Error("dynamic pad attributes are not allowed");
        }
        const pads = Array.from(inputs[1].integerData);
        const value = inputs.length >= 3 ? inputs[2].floatData[0] : 0;
        return createAttributeWithCacheKey({ mode, pads, value });
      };
      createPadProgramInfo = (inferenceHandler, input, attributes) => {
        const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);
        const rank = outputShape.length;
        const padFunction = getPadFunction(inferenceHandler, input, attributes);
        const shaderSource = `
      ${padFunction}
      float process(int[${rank}] indices) {
          return padA(indices);
      }`;
        return {
          name: "Pad",
          inputNames: ["A"],
          inputTypes: [0 /* unpacked */],
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputsV2 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Pad requires 1 input");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
      };
      validateInputsV11 = (inputs) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Pad requires 2 or 3 inputs");
        }
        if (inputs[1].type !== "int32") {
          throw new Error("Invalid input type.");
        }
        if (inputs.length >= 3 && inputs[2].type === "string") {
          throw new Error("Invalid input type.");
        }
      };
      getPadFunction = (inferenceHandler, input, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
        const strides = ShapeUtil.computeStrides(input.dims);
        switch (attributes.mode) {
          case "constant":
            return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);
          case "reflect":
            return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);
          case "edge":
            return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);
          default:
            throw new Error("Invalid mode");
        }
      };
      getPadConstant = (glsl, shape2, strides, width, height, pads, value) => {
        const rank = shape2.length;
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  return constant;
        if (k >= ${shape2[i]}) return constant;
        offset += k * ${strides[i]};
        `;
        }
        return `
      float padA(int m[${rank}]) {
        const float constant = float(${value});
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
      };
      getPadReflect = (glsl, shape2, strides, width, height, pads) => {
        const rank = shape2.length;
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (shape2[i] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${shape2[i]}) { k = _2n_1 - k; }
        }
        offset += k * ${strides[i]};
        `;
        }
        return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
      };
      getPadEdge = (glsl, shape2, strides, width, height, pads) => {
        const rank = shape2.length;
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  k = 0;
        if (k >= ${shape2[i]}) k = ${shape2[i] - 1};
        offset += k * ${strides[i]};
      `;
        }
        return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/pool.ts
  var averagePool, parseAveragePoolAttributes, createAveragePoolProgramInfo, globalAveragePool, parseGlobalAveragePoolAttributes, maxPool, parseMaxPoolAttributes, createMaxPoolProgramInfo, getAdjustedPoolAttributesAndOutputShape, globalMaxPoolAttributes, globalMaxPoolMetadata, globalMaxPool, validateInputs15, generatePoolingCode, copyArray, offsetToIndices;
  var init_pool = __esm({
    "web/lib/onnxjs/backends/webgl/ops/pool.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      averagePool = (inferenceHandler, inputs, attributes) => {
        validateInputs15(inputs);
        const metadata = {
          name: "AveragePool",
          inputNames: ["X"],
          inputTypes: [0 /* unpacked */],
          cacheHint: attributes.cacheKey
        };
        const output = inferenceHandler.run(
          { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes) },
          inputs
        );
        return [output];
      };
      parseAveragePoolAttributes = (node) => {
        const autoPad = node.attributes.getString("auto_pad", "NOTSET");
        const ceilMode = node.attributes.getInt("ceil_mode", 0);
        const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
        const kernelShape = node.attributes.getInts("kernel_shape");
        const strides = node.attributes.getInts("strides", []);
        const pads = node.attributes.getInts("pads", []);
        if (ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        }
        return createAttributeWithCacheKey({ autoPad, ceilMode, countIncludePad, kernelShape, strides, pads });
      };
      createAveragePoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          inputs,
          attributes,
          isGlobalOperator
        );
        const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);
        const op1 = "value += _X(x);";
        let op2 = "";
        if (adjustedAttributes.countIncludePad) {
          op2 += `value /= float(${kernelSize});`;
        } else {
          op2 += `value /= float(${kernelSize} - pad);`;
        }
        const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "0.0");
        const shaderSource = `
        ${poolingCode}
      `;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      globalAveragePool = (inferenceHandler, inputs, attributes) => {
        validateInputs15(inputs);
        const metadata = {
          name: "GlobalAveragePool",
          inputNames: ["X"],
          inputTypes: [0 /* unpacked */],
          cacheHint: `${attributes.countIncludePad}`
        };
        const output = inferenceHandler.run(
          { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes) },
          inputs
        );
        return [output];
      };
      parseGlobalAveragePoolAttributes = (node) => {
        const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
        return createAttributeWithCacheKey({
          autoPad: "",
          ceilMode: 0,
          countIncludePad,
          kernelShape: [],
          strides: [],
          pads: []
        });
      };
      maxPool = (inferenceHandler, inputs, attributes) => {
        validateInputs15(inputs);
        const metadata = {
          name: "MaxPool",
          inputNames: ["X"],
          inputTypes: [0 /* unpacked */],
          cacheHint: attributes.cacheKey
        };
        const output = inferenceHandler.run(
          { ...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes) },
          inputs
        );
        return [output];
      };
      parseMaxPoolAttributes = (node) => {
        const autoPad = node.attributes.getString("auto_pad", "NOTSET");
        const ceilMode = node.attributes.getInt("ceil_mode", 0);
        const kernelShape = node.attributes.getInts("kernel_shape");
        const strides = node.attributes.getInts("strides", []);
        const pads = node.attributes.getInts("pads", []);
        const storageOrder = node.attributes.getInt("storage_order", 0);
        const dilations = node.attributes.getInts("dilations", []);
        if (storageOrder !== 0) {
          throw new Error("column major storage order is not yet supported for MaxPool");
        }
        if (ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        }
        return createAttributeWithCacheKey({
          autoPad,
          ceilMode,
          countIncludePad: false,
          kernelShape,
          strides,
          pads,
          storageOrder,
          dilations
        });
      };
      createMaxPoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          inputs,
          attributes,
          isGlobalOperator
        );
        const op1 = `
      value = max(_X(x), value);
    `;
        const op2 = "";
        const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "-1e5");
        const shaderSource = `
      ${poolingCode}
    `;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      getAdjustedPoolAttributesAndOutputShape = (inputs, attributes, isGlobalOperator) => {
        const inputShape = inputs[0].dims.slice();
        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
        const kernelShape = attributes.kernelShape.slice();
        const strides = attributes.strides.slice();
        const dilations = hasDilations ? attributes.dilations.slice() : [];
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);
        const outputShape = PoolConvUtil.computePoolOutputShape(
          isGlobalOperator,
          inputShape,
          strides,
          dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        if (hasDilations) {
          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
        } else {
          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
        }
        return [newAttributes, outputShape];
      };
      globalMaxPoolAttributes = {
        autoPad: "",
        ceilMode: 0,
        countIncludePad: false,
        kernelShape: [],
        strides: [],
        pads: [],
        storageOrder: 0,
        dilations: [],
        cacheKey: ""
      };
      globalMaxPoolMetadata = {
        name: "GlobalMaxPool",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      globalMaxPool = (inferenceHandler, inputs) => {
        validateInputs15(inputs);
        const output = inferenceHandler.run(
          {
            ...globalMaxPoolMetadata,
            get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes)
          },
          inputs
        );
        return [output];
      };
      validateInputs15 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Pool ops requires 1 input.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
      };
      generatePoolingCode = (inputDims, attributes, op1, op2, start) => {
        const rank = inputDims.length;
        if (attributes.kernelShape.length <= 2) {
          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
          const sw = attributes.strides[attributes.strides.length - 1];
          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
          const pwEnd = attributes.pads[attributes.pads.length - 1];
          const dimW = inputDims[rank - 1];
          let codeW = "";
          let codeH = "";
          let codeHEnd = "";
          if (pwStart + pwEnd !== 0) {
            codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {
              pad++;
              continue;
            }
            ${op1}
          }`;
          } else {
            codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            ${op1}
          }`;
          }
          if (attributes.kernelShape.length === 2) {
            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
            const sh = attributes.strides[attributes.strides.length - 2];
            const phStart = attributes.pads[attributes.pads.length / 2 - 2];
            const phEnd = attributes.pads[attributes.pads.length - 2];
            const dimH = inputDims[rank - 2];
            if (phStart + phEnd !== 0) {
              codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {
                pad+= ${kw};
                continue;
              }
          `;
            } else {
              codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
            `;
            }
            codeHEnd = `
          }
        `;
          }
          const poolingCode = `
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);

          float value = ${start};
          int pad = 0;
          ${codeH}
          ${codeW}
          ${codeHEnd}
          ${op2}
          return value;
        }
      `;
          return poolingCode;
        } else {
          const kernelSize = ShapeUtil.size(attributes.kernelShape);
          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
          const stridesRank = kernelStrides.length;
          const padsRank = attributes.pads.length;
          const offsetToIndicesFunction = offsetToIndices(stridesRank);
          const copyInputDims = copyArray(inputDims, "inputDims");
          const copyPads = copyArray(attributes.pads, "pads");
          const copyKernelStrides = copyArray(kernelStrides, "kernelStrides");
          const copyStrides = copyArray(attributes.strides, "strides");
          const hasPads = attributes.pads.reduce((sum2, cur) => sum2 + cur);
          let padCode = "";
          if (hasPads) {
            padCode = `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${op1}
          }`;
          } else {
            padCode = `
          }
          ${op1}
        `;
          }
          const poolingCode = `
        ${offsetToIndicesFunction}
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);
          int offset[${stridesRank}];
          int pads[${padsRank}];
          int inputDims[${rank}];
          int kernelStrides[${stridesRank}];
          int strides[${stridesRank}];
          ${copyPads}
          ${copyInputDims}
          ${copyStrides}
          ${copyKernelStrides}

          float value = ${start};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${kernelSize}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {
              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]
                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];
              ${padCode}
          }
          ${op2}

          return value;
        }
      `;
          return poolingCode;
        }
      };
      copyArray = (array, arrayName) => {
        let block = "";
        for (let i = 0; i < array.length; i++) {
          block += `
      ${arrayName}[${i}] = ${array[i]};
    `;
        }
        return block;
      };
      offsetToIndices = (rank) => `
  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {
    if (${rank} == 0) {
      return;
    }
    for (int i = 0; i < ${rank} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${rank} - 1] = offset;
  }`;
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/reduce.ts
  var reduce, parseReduceAttributes, createReduceProgramInfo, validateInputs16, reduceSum, reduceMean, reduceMax, reduceMin, reduceProd, reduceLogSum, reduceLogSumSquare;
  var init_reduce = __esm({
    "web/lib/onnxjs/backends/webgl/ops/reduce.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_operators();
      init_util();
      init_types();
      reduce = (inferenceHandler, inputs, attributes, name2, reduceOp) => {
        validateInputs16(inputs);
        const reduceProgramMetadata = {
          name: name2,
          inputNames: ["A"],
          inputTypes: [0 /* unpacked */]
        };
        const output = inferenceHandler.run(
          {
            ...reduceProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createReduceProgramInfo(inferenceHandler, inputs, attributes, name2, reduceOp, reduceProgramMetadata)
          },
          inputs
        );
        return [output];
      };
      parseReduceAttributes = (node) => {
        const axes = node.attributes.getInts("axes", []);
        const keepDims = node.attributes.getInt("keepdims", 1) === 1;
        return createAttributeWithCacheKey({ axes, keepDims });
      };
      createReduceProgramInfo = (_handler, inputs, attributes, _name, reduceOp, reduceProgramMetadata) => {
        const outputShape = [];
        const iRank = inputs[0].dims.length || 1;
        const idxCopy = [];
        const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);
        const ops = reduceOp(inputs, axes);
        let reduceOps = ops[1];
        for (let k = 0; k < inputs[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            if (attributes.keepDims) {
              outputShape.push(1);
            }
            reduceOps = `
          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {
            inputIdx[${k}] = j${k};
            ${reduceOps}
          }`;
          } else {
            idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);
            outputShape.push(inputs[0].dims[k]);
          }
        }
        const oRank = outputShape.length || 1;
        const shaderSource = `
      float process(int outputIdx[${oRank}]) {
        float value;                 // final result
        int inputIdx[${iRank}];      // addressing input data
        ${idxCopy.join("\n")}
        ${ops[0]}       // init ops for reduce max/min
        ${reduceOps}
        ${ops[2]}       // final computation for reduce mean
        return value;
      }`;
        return {
          ...reduceProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs16 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Reduce op requires 1 input.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invalid input type.");
        }
      };
      reduceSum = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", ""];
        return reduce(inferenceHandler, inputs, attributes, "ReduceSum", reduceOp);
      };
      reduceMean = (inferenceHandler, inputs, attributes) => {
        const reduceOp = (inputs2, axes) => {
          let size = 1;
          for (let k = 0; k < inputs2[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              size *= inputs2[0].dims[k];
            }
          }
          return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${size}.;`];
        };
        return reduce(inferenceHandler, inputs, attributes, "ReduceMean", reduceOp);
      };
      reduceMax = (inferenceHandler, inputs, attributes) => {
        const reduceOp = (inputs2, axes) => {
          const idxZero = [];
          for (let k = 0; k < inputs2[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`inputIdx[${k}] = 0;`);
            }
          }
          return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
        };
        return reduce(inferenceHandler, inputs, attributes, "ReduceMax", reduceOp);
      };
      reduceMin = (inferenceHandler, inputs, attributes) => {
        const reduceOp = (inputs2, axes) => {
          const idxZero = [];
          for (let k = 0; k < inputs2[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`inputIdx[${k}] = 0;`);
            }
          }
          return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
        };
        return reduce(inferenceHandler, inputs, attributes, "ReduceMin", reduceOp);
      };
      reduceProd = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["value = 1.0;", "value *= _A(inputIdx);", ""];
        return reduce(inferenceHandler, inputs, attributes, "ReduceProd", reduceOp);
      };
      reduceLogSum = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"];
        return reduce(inferenceHandler, inputs, attributes, "ReduceLogSum", reduceOp);
      };
      reduceLogSumSquare = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""];
        return reduce(inferenceHandler, inputs, attributes, "ReduceLogSumSquare", reduceOp);
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/reshape.ts
  var reshape;
  var init_reshape = __esm({
    "web/lib/onnxjs/backends/webgl/ops/reshape.ts"() {
      "use strict";
      init_util();
      reshape = (handler, inputs) => {
        const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);
        if (handler.session.pack) {
          return [handler.reshapePacked(inputs[0], reshapedDims)];
        } else {
          return [handler.reshapeUnpacked(inputs[0], reshapedDims)];
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/upsample.ts
  var upsampleProgramMetadata, upsample, parseUpsampleAttributesV7, parseUpsampleAttributesV9, parseUpsampleAttributes, createUpsampleProgramInfo, validateInputs17, scalesValidation;
  var init_upsample = __esm({
    "web/lib/onnxjs/backends/webgl/ops/upsample.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_glsl_source();
      init_types();
      upsampleProgramMetadata = {
        name: "Upsample",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      upsample = (inferenceHandler, inputs, attributes) => {
        validateInputs17(inputs, attributes);
        const output = inferenceHandler.run(
          {
            ...upsampleProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes)
          },
          inputs
        );
        return [output];
      };
      parseUpsampleAttributesV7 = (node) => parseUpsampleAttributes(node, 7);
      parseUpsampleAttributesV9 = (node) => parseUpsampleAttributes(node, 9);
      parseUpsampleAttributes = (node, opset) => {
        const isResize = opset >= 10;
        const mode = node.attributes.getString("mode", "nearest");
        if (mode !== "nearest" && mode !== "linear" && (opset < 11 || mode !== "cubic")) {
          throw new Error(`unrecognized mode: ${mode}`);
        }
        let scales = [];
        if (opset < 9) {
          scales = node.attributes.getFloats("scales");
          scalesValidation(scales, mode, isResize);
        }
        const extrapolationValue = node.attributes.getFloat("extrapolation_value", 0);
        const coordinateTransformMode = opset > 10 ? node.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
        if ([
          "asymmetric",
          "pytorch_half_pixel",
          "tf_half_pixel_for_nn",
          "align_corners",
          "tf_crop_and_resize",
          "half_pixel"
        ].indexOf(coordinateTransformMode) === -1) {
          throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);
        }
        const needRoiInput = coordinateTransformMode === "tf_crop_and_resize";
        const useExtrapolation = needRoiInput;
        const nearestMode = mode === "nearest" && opset >= 11 ? node.attributes.getString("nearest_mode", "round_prefer_floor") : "";
        if (["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(nearestMode) === -1) {
          throw new Error(`nearest_mode '${nearestMode}' is not supported`);
        }
        const cubicCoefficientA = node.attributes.getFloat("cubic_coeff_a", -0.75);
        const excludeOutside = node.attributes.getInt("exclude_outside", 0) !== 0;
        if (excludeOutside && mode !== "cubic") {
          throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
        }
        const useNearest2xOptimization = opset < 11 ? true : mode === "nearest" && coordinateTransformMode === "asymmetric" && nearestMode === "floor";
        let roiInputIdx = 0;
        let scalesInputIdx = 0;
        let sizesInputIdx = 0;
        if (opset > 10) {
          if (node.inputs.length > 2) {
            roiInputIdx = 1;
            scalesInputIdx = 2;
            sizesInputIdx = 3;
          } else {
            scalesInputIdx = 1;
            sizesInputIdx = 2;
          }
        } else if (opset === 9) {
          scalesInputIdx = 1;
        }
        return createAttributeWithCacheKey({
          opset,
          isResize,
          mode,
          scales,
          extrapolationValue,
          coordinateTransformMode,
          useExtrapolation,
          needRoiInput,
          nearestMode,
          cubicCoefficientA,
          excludeOutside,
          useNearest2xOptimization,
          roiInputIdx,
          scalesInputIdx,
          sizesInputIdx
        });
      };
      createUpsampleProgramInfo = (inferenceHandler, inputs, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [inputWidth, inputHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          inputs[0].dims,
          0 /* unpacked */
        );
        const outputShape = inputs[0].dims.map((dim2, i) => Math.floor(dim2 * attributes.scales[i]));
        const [outputWidth, outputHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          outputShape,
          0 /* unpacked */
        );
        const dim = outputShape.length;
        const outputPitches = new Array(dim);
        const inputPitches = new Array(dim);
        let precalculatedPitches = `
      int output_pitches[${dim}];
      int input_pitches[${dim}];
      `;
        for (let d = dim - 1; d >= 0; d--) {
          outputPitches[d] = d === dim - 1 ? 1 : outputPitches[d + 1] * outputShape[d + 1];
          inputPitches[d] = d === dim - 1 ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];
          precalculatedPitches += `
        output_pitches[${d}] = ${outputPitches[d]};
        input_pitches[${d}] = ${inputPitches[d]};
        `;
        }
        const getInputFloatFunction = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});
        float value = getColorAsFloat(${glsl.texture2D}(X, coords));
        return value;
      }
      `;
        const shaderSource = attributes.mode === "nearest" ? (
          // nearest
          `
    ${getInputFloatFunction}
    float process(int indices[${dim}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int d, m;
      for (int dim = 0; dim < ${dim}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`
        ) : dim === 4 ? (
          // bilinear 4D
          `
    ${getInputFloatFunction}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`
        ) : (
          // bilinear 2D
          `
    ${getInputFloatFunction}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`
        );
        return {
          ...upsampleProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource,
          variables: [
            {
              name: "scales",
              type: "int",
              arrayLength: attributes.scales.length,
              data: attributes.scales.map((x) => Math.ceil(x))
            }
          ]
        };
      };
      validateInputs17 = (inputs, attribute) => {
        if (!inputs || attribute.opset < 9 && inputs.length !== 1 || attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2 || attribute.opset >= 11 && inputs.length < 2) {
          throw new Error("invalid inputs.");
        }
        if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {
          throw new Error("Invalid input shape.");
        }
        if (inputs[0].type === "string") {
          throw new Error("Invalid input tensor types.");
        }
      };
      scalesValidation = (scales, mode, isResize) => {
        if (!isResize) {
          for (const scale of scales) {
            if (scale < 1) {
              throw new Error("Scale value should be greater than or equal to 1.");
            }
          }
        } else {
          for (const scale of scales) {
            if (scale <= 0) {
              throw new Error("Scale value should be greater than 0.");
            }
          }
        }
        if (mode === "linear" || mode === "cubic") {
          if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${isResize ? "Resize" : "Upsample"} opeartor.`);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/resize-packed.ts
  var resizeProgramMetadata, resize, parseResizeAttributesV10, parseResizeAttributesV11, createPackedResizeProgramInfo, prepareInputs, parseScalesData, parseScalesDataFromOutputSize;
  var init_resize_packed = __esm({
    "web/lib/onnxjs/backends/webgl/ops/resize-packed.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      init_upsample();
      resizeProgramMetadata = {
        name: "Resize",
        inputNames: ["A"],
        inputTypes: [2 /* packed */]
      };
      resize = (inferenceHandler, inputs, attributes) => {
        validateInputs17(inputs, attributes);
        const output = inferenceHandler.run(
          {
            ...resizeProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes)
          },
          inputs
        );
        return [output];
      };
      parseResizeAttributesV10 = (node) => parseUpsampleAttributes(node, 10);
      parseResizeAttributesV11 = (node) => parseUpsampleAttributes(node, 11);
      createPackedResizeProgramInfo = (inferenceHandler, inputs, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [scales, outputShape] = prepareInputs(inputs, attributes);
        const isSame = scales.every((s) => s === 1) && attributes.coordinateTransformMode !== "tf_crop_and_resize";
        if (isSame) {
          return {
            ...resizeProgramMetadata,
            output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
            hasMain: true,
            shaderSource: `void main() {
                    vec4 v = ${glsl.texture2D}(X, TexCoords);
                    ${glsl.output} = v;
                }`
          };
        }
        const dim = outputShape.length;
        if (dim < 2) {
          throw new Error(`output dimension should be at least 2, but got ${dim}`);
        }
        const outputHeight = outputShape[dim - 2];
        const outputWidth = outputShape[dim - 1];
        const inputShape = inputs[0].dims;
        if (dim !== inputShape.length) {
          throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);
        }
        const inputHeight = inputShape[dim - 2];
        const inputWidth = inputShape[dim - 1];
        const scalesHeight = scales[dim - 2];
        const scalesWidth = scales[dim - 1];
        let getSourceFracIndex = "";
        if (attributes.mode !== "linear") {
          throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);
        }
        switch (attributes.coordinateTransformMode) {
          case "asymmetric":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
            break;
          case "half_pixel":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
            break;
          case "pytorch_half_pixel":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
            break;
          case "align_corners":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,
                            ${outputHeight}.0 - 1.0);
                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,
                            ${inputHeight}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
            break;
          default:
            throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${attributes.coordinateTransformMode}'`);
        }
        const coordsDataType = getCoordsDataType(dim);
        const unpackChannel = unpackFromChannel();
        const shaderSource = `
            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);
            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${scalesWidth}));
            ${unpackChannel}
            ${getSourceFracIndex}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${coordsDataType} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${outputHeight - 1};
                bool hasNextCol = rc.z < ${outputWidth - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${glsl.output} = vec4(newValue);
            }
        `;
        return {
          ...resizeProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          hasMain: true,
          shaderSource
        };
      };
      prepareInputs = (inputs, attributes) => {
        const x = inputs[0];
        const xDims = x.dims;
        let scales = attributes.scales;
        let outputSizes;
        if (scales.length === 0) {
          const scalesTensor = inputs[attributes.scalesInputIdx];
          if (scalesTensor && scalesTensor.size !== 0) {
            if (inputs[attributes.sizesInputIdx]) {
              throw new Error("Only one of scales or sizes must be provided as input.");
            }
            scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);
          } else {
            const sizesTensor = inputs[attributes.sizesInputIdx];
            if (!sizesTensor || sizesTensor.size === 0) {
              throw new Error("Either scales or sizes MUST be provided as input.");
            }
            outputSizes = Array.from(sizesTensor.integerData);
            scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);
          }
        } else {
          if (inputs[attributes.sizesInputIdx]) {
            throw new Error("Only one of scales or sizes must be provided as input.");
          }
        }
        const yDims = outputSizes || xDims.map((dim, i) => Math.floor(dim * scales[i]));
        return [scales, yDims];
      };
      parseScalesData = (scale, mode, isResize) => {
        const scales = Array.from(scale.floatData);
        scalesValidation(scales, mode, isResize);
        return scales;
      };
      parseScalesDataFromOutputSize = (yDims, xDims, mode, isResize) => {
        const length = xDims.length;
        const scales = new Array(length);
        for (let i = 0, end = length; i < end; i++) {
          if (xDims[i] === 0) {
            if (yDims[i] !== 0) {
              throw new Error("Input dim is zero but required output dim is non-zero.");
            }
            scales[i] = 1;
          } else {
            scales[i] = yDims[i] / xDims[i];
          }
        }
        scalesValidation(scales, mode, isResize);
        return scales;
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/shape.ts
  var shape, validateInputs18;
  var init_shape = __esm({
    "web/lib/onnxjs/backends/webgl/ops/shape.ts"() {
      "use strict";
      init_tensor2();
      shape = (_inferenceHandler, inputs) => {
        validateInputs18(inputs);
        return [new Tensor3([inputs[0].dims.length], "int32", void 0, void 0, new Int32Array(inputs[0].dims))];
      };
      validateInputs18 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Shape requires 1 input.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/slice.ts
  var sliceProgramMetadata, slice, parseSliceAttributes, createSliceProgramInfo, validateInputs19, sliceV10, generateSliceAttributesFromInputs, validateInputsV10;
  var init_slice = __esm({
    "web/lib/onnxjs/backends/webgl/ops/slice.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_operators();
      init_util();
      init_types();
      sliceProgramMetadata = {
        name: "Slice",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      slice = (inferenceHandler, inputs, attributes) => {
        validateInputs19(inputs);
        const output = inferenceHandler.run(
          {
            ...sliceProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
          },
          inputs
        );
        return [output];
      };
      parseSliceAttributes = (node) => {
        const starts = node.attributes.getInts("starts");
        const ends = node.attributes.getInts("ends");
        const axes = node.attributes.getInts("axes", []);
        return createAttributeWithCacheKey({ starts, ends, axes });
      };
      createSliceProgramInfo = (_inferenceHandler, input, attributes) => {
        const axes = attributes.axes.length === 0 ? input.dims.slice(0).map((_val, i) => i) : attributes.axes;
        const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);
        const starts = attributes.starts.map((start, i) => {
          if (start > input.dims[normalizedAxes[i]] - 1) {
            return input.dims[normalizedAxes[i]];
          }
          return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);
        });
        const ends = attributes.ends.map((end, i) => {
          if (end > input.dims[normalizedAxes[i]] - 1) {
            return input.dims[normalizedAxes[i]];
          }
          return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);
        });
        const outputShape = input.dims.slice();
        const sliceOps = [];
        for (let i = 0; i < normalizedAxes.length; i++) {
          outputShape[normalizedAxes[i]] = ends[i] - starts[i];
          if (starts[i] > 0) {
            sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);
          }
        }
        const rank = outputShape.length;
        const shaderSource = `
      float process(int outputIdx[${rank}]) {
        ${sliceOps.join("\n      ")}
        return _A(outputIdx);
      }`;
        return {
          ...sliceProgramMetadata,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs19 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Slice requires 1 input.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invalid input type.");
        }
      };
      sliceV10 = (inferenceHandler, inputs) => {
        validateInputsV10(inputs);
        const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);
        const output = inferenceHandler.run(
          {
            ...sliceProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
          },
          [inputs[0]]
        );
        return [output];
      };
      generateSliceAttributesFromInputs = (inferenceHandler, inputs) => {
        if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || !inferenceHandler.session.isInitializer(inputs[2].dataId) || inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId) || inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId)) {
          throw new Error("dynamic slice attributes are not allowed");
        }
        if (inputs.length >= 5 && inputs[4].integerData.some((i) => i !== 1)) {
          throw new Error("currently non-1 steps is not supported for Slice");
        }
        const starts = Array.from(inputs[1].integerData);
        const ends = Array.from(inputs[2].integerData);
        const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];
        const cacheKey = `${axes};${starts};${ends}`;
        return { starts, ends, axes, cacheKey };
      };
      validateInputsV10 = (inputs) => {
        if (!inputs || inputs.length < 3 || inputs.length > 5) {
          throw new Error("Invalid input number.");
        }
        if (inputs[1].type !== "int32" || inputs[1].dims.length !== 1) {
          throw new Error("Invalid input type.");
        }
        if (inputs[2].type !== "int32" || inputs[2].dims.length !== 1) {
          throw new Error("Invalid input type.");
        }
        if (inputs.length >= 4 && (inputs[3].type !== "int32" || inputs[3].dims.length !== 1)) {
          throw new Error("Invalid input type.");
        }
        if (inputs.length >= 5 && (inputs[4].type !== "int32" || inputs[4].dims.length !== 1)) {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/softmax.ts
  var softmaxComputeMaxProgramMetadata, softmaxComputeScaleProgramMetadata, softmaxProgramMetadata, softmax, parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmaxV13, computeSoftmax, createComputeMaxProgramInfo, createComputScaleProgramInfo, createSoftMaxProgramInfo, validateInputs20;
  var init_softmax = __esm({
    "web/lib/onnxjs/backends/webgl/ops/softmax.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_glsl_source();
      init_types();
      init_transpose();
      softmaxComputeMaxProgramMetadata = {
        name: "SoftmaxComputeMax",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      softmaxComputeScaleProgramMetadata = {
        name: "SoftmaxComputeScale",
        inputNames: ["A", "Max"],
        inputTypes: [0 /* unpacked */, 0 /* unpacked */]
      };
      softmaxProgramMetadata = {
        name: "SoftMax",
        inputNames: ["A", "Max", "Norm"],
        inputTypes: [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */]
      };
      softmax = (inferenceHandler, inputs, attributes) => {
        validateInputs20(inputs);
        const inputShape = inputs[0].dims.slice();
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);
        const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);
        const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);
        return output;
      };
      parseSoftmaxAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 1) });
      parseSoftmaxAttributesV13 = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", -1) });
      softmaxV13 = (inferenceHandler, inputs, attributes) => {
        validateInputs20(inputs);
        const inputShape = inputs[0].dims.slice();
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const rank = inputShape.length;
        const isTransposeRequired = axis !== rank - 1 ? true : false;
        const transposedInputShape = [];
        let perm = [];
        let transposedInputs = [];
        let transposeAttribute;
        if (isTransposeRequired) {
          perm = Array.from({ length: rank }).map((_, i) => i);
          perm[axis] = rank - 1;
          perm[rank - 1] = axis;
          perm.map((p) => transposedInputShape.push(inputShape[p]));
          transposeAttribute = createAttributeWithCacheKey({ perm });
          transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);
        }
        const logicalRowCount = isTransposeRequired ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeToDimension(inputShape, rank - 1);
        const featureCount = isTransposeRequired ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeFromDimension(inputShape, rank - 1);
        const output = computeSoftmax(
          inferenceHandler,
          isTransposeRequired ? transposedInputs : inputs,
          attributes,
          logicalRowCount,
          featureCount
        );
        if (isTransposeRequired) {
          const reversedOutput = transpose(inferenceHandler, output, transposeAttribute);
          return reversedOutput;
        } else {
          return output;
        }
      };
      computeSoftmax = (inferenceHandler, inputs, attributes, logicalRowCount, featureCount) => {
        const computeMaxProgramInfo = createComputeMaxProgramInfo(
          inferenceHandler,
          inputs[0],
          logicalRowCount,
          featureCount,
          [logicalRowCount]
        );
        const max = inferenceHandler.run(
          { ...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo },
          inputs
        );
        const computeScaleProgramInfo = createComputScaleProgramInfo(
          inferenceHandler,
          inputs[0],
          logicalRowCount,
          featureCount,
          computeMaxProgramInfo.output.dims,
          [logicalRowCount]
        );
        const scale = inferenceHandler.run(
          { ...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo },
          [inputs[0], max]
        );
        const softMaxProgramInfo = createSoftMaxProgramInfo(
          inferenceHandler,
          inputs[0],
          logicalRowCount,
          featureCount,
          computeMaxProgramInfo.output.dims,
          computeScaleProgramInfo.output.dims
        );
        const output = inferenceHandler.run(
          { ...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo },
          [inputs[0], max, scale]
        );
        return [output];
      };
      createComputeMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, outputShape) => {
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          input.dims,
          0 /* unpacked */
        );
        const rank = outputShape.length;
        if (logicalRowCount < 1 || featureCount < 1) {
          throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        }
        if (outputShape.length !== 1) {
          throw new Error("Dimensionality of the output should be 1");
        }
        if (outputShape[0] !== logicalRowCount) {
          throw new Error("Shape of the output should be equal to logical row count");
        }
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},
        ${textureHeight} )));
        for(int i=1; i<${featureCount}; ++i)
        {
          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
        return {
          ...softmaxComputeMaxProgramMetadata,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createComputScaleProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, outputShape) => {
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          input.dims,
          0 /* unpacked */
        );
        const rank = outputShape.length;
        if (logicalRowCount < 1 || featureCount < 1) {
          throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        }
        if (outputShape.length !== 1) {
          throw new Error("Dimensionality of the output should be 1");
        }
        if (outputShape[0] !== logicalRowCount) {
          throw new Error("Shape of the output should be equal to logical row count");
        }
        if (maxElementPerLogicalRow.length !== 1) {
          throw new Error("Dimensionality of the intermediate results should be 1");
        }
        if (maxElementPerLogicalRow[0] !== logicalRowCount) {
          throw new Error("Shape of the intermediate results should be equal to logical row count");
        }
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${featureCount}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight}))) - max);
        }

        return norm_factor;
      }`;
        return {
          ...softmaxComputeScaleProgramMetadata,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createSoftMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, normalizationPerLogicalRow) => {
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          input.dims,
          0 /* unpacked */
        );
        const rank = input.dims.length;
        if (logicalRowCount < 1 || featureCount < 1) {
          throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        }
        if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {
          throw new Error("Dimensionality of the intermediate results should be 1");
        }
        if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {
          throw new Error("Shape of the intermediate results should be equal to logical row count");
        }
        const shaderSource = `
      float process(int[${rank}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${featureCount};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
        return {
          ...softmaxProgramMetadata,
          output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs20 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Softmax requires 1 input.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/split.ts
  var splitProgramMetadata, split, parseSplitAttributes, getProgramCount, createSplitProgramInfo, validateInputs21;
  var init_split = __esm({
    "web/lib/onnxjs/backends/webgl/ops/split.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      splitProgramMetadata = {
        name: "Split",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      split = (inferenceHandler, inputs, attributes) => {
        validateInputs21(inputs);
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
        const count = getProgramCount(inferenceHandler, inputs, axis, attributes);
        const output = [];
        for (let i = 0; i < count; ++i) {
          output.push(
            inferenceHandler.run(
              {
                ...splitProgramMetadata,
                cacheHint: `${attributes.cacheKey};${i}`,
                get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i)
              },
              inputs
            )
          );
        }
        return output;
      };
      parseSplitAttributes = (node) => {
        const axis = node.attributes.getInt("axis", 0);
        const split2 = node.attributes.getInts("split", []);
        const numOutputs = node.outputs.length;
        return createAttributeWithCacheKey({ axis, split: split2, numOutputs });
      };
      getProgramCount = (_inferenceHandler, inputs, axis, attributes) => {
        const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);
        return offsets.length;
      };
      createSplitProgramInfo = (_inferenceHandler, input, attributes, axis, index) => {
        const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);
        const offset = offsets[index];
        const outputShape = shapes[index];
        const rank = outputShape.length;
        const shaderSource = `
      float process(int indices[${rank}]) {
        indices[${axis}] += ${offset};
        return _A(indices);
      }
    `;
        return {
          ...splitProgramMetadata,
          cacheHint: `${attributes.cacheKey}:${index}`,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs21 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Split requires one input.");
        }
        if (inputs[0].type !== "int8" && inputs[0].type !== "uint8" && inputs[0].type !== "int16" && inputs[0].type !== "uint16" && inputs[0].type !== "int32" && inputs[0].type !== "uint32" && inputs[0].type !== "float32" && inputs[0].type !== "float64" && inputs[0].type !== "bool") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/squeeze.ts
  var squeeze, squeezeV13, parseSqueezeAttributes, validateInputs22, validateInputsV13;
  var init_squeeze = __esm({
    "web/lib/onnxjs/backends/webgl/ops/squeeze.ts"() {
      "use strict";
      init_util();
      squeeze = (inferenceHandler, inputs, axes) => {
        validateInputs22(inputs);
        const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);
        const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
        return [output];
      };
      squeezeV13 = (inferenceHandler, inputs) => {
        validateInputsV13(inputs);
        return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
      };
      parseSqueezeAttributes = (node) => node.attributes.getInts("axes");
      validateInputs22 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Squeeze requires 1 input.");
        }
        if (inputs[0].type === "string") {
          throw new Error("invalid input tensor types.");
        }
      };
      validateInputsV13 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Squeeze requires 2 inputs.");
        }
        if (inputs[1].type !== "int32") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/sum.ts
  var sum, createSumProgramInfo, validateInputs23;
  var init_sum = __esm({
    "web/lib/onnxjs/backends/webgl/ops/sum.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      sum = (inferenceHandler, inputs) => {
        validateInputs23(inputs);
        const sumProgramMetadata = {
          name: "Sum",
          inputNames: inputs.map((_v, i) => `X${i}`),
          inputTypes: new Array(inputs.length).fill(0 /* unpacked */)
        };
        const output = inferenceHandler.run(
          { ...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata) },
          inputs
        );
        return [output];
      };
      createSumProgramInfo = (inferenceHandler, inputs, sumProgramMetadata) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const outputShape = inputs[0].dims.slice();
        const sumLine = inputs.map((_v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(" + ");
        const shaderSource = `
      void main() {
        vec4 result = ${sumLine};
        ${glsl.output} = result;
      }
    `;
        return {
          ...sumProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          hasMain: true,
          shaderSource
        };
      };
      validateInputs23 = (inputs) => {
        if (!inputs || inputs.length === 0) {
          throw new Error("Sum requires inputs.");
        }
        const length = inputs[0].dims.length;
        for (let i = 1; i < inputs.length; i++) {
          if (length !== inputs[i].dims.length) {
            throw new Error("Input shapes are mismatched.");
          }
          for (let j = 0; j < length; j++) {
            if (inputs[0].dims[j] !== inputs[i].dims[j]) {
              throw new Error("Input shapes are not matched.");
            }
          }
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
        for (let i = 1; i < inputs.length; i++) {
          if (inputs[0].type !== inputs[i].type) {
            throw new Error("Input types are not matched.");
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/tile.ts
  var tile, createTileProgramInfo, validateInputs24;
  var init_tile = __esm({
    "web/lib/onnxjs/backends/webgl/ops/tile.ts"() {
      "use strict";
      init_operators();
      init_types();
      tile = (inferenceHandler, inputs) => {
        validateInputs24(inputs);
        const tileProgramMetadata = {
          name: "Tile",
          inputNames: ["A"],
          inputTypes: [0 /* unpacked */]
        };
        const output = inferenceHandler.run(
          { ...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata) },
          inputs
        );
        return [output];
      };
      createTileProgramInfo = (_handler, inputs, tileProgramMetadata) => {
        const inputShape = inputs[0].dims.slice();
        const outputShape = new Array(inputShape.length);
        const tileOps = [];
        for (let i = 0; i < inputShape.length; i++) {
          outputShape[i] = inputShape[i] * inputs[1].numberData[i];
          tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);
        }
        const rank = outputShape.length;
        const shaderSource = `
      float process(int outputIdx[${rank}]) {
        int inputIdx[${rank}];
        ${tileOps.join("\n")}
        return _A(inputIdx);
      }
    `;
        return {
          ...tileProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs24 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Tile requires 2 input.");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("The second input shape must 1 dimension.");
        }
        if (inputs[1].dims[0] !== inputs[0].dims.length) {
          throw new Error("Invalid input shape.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invalid input type.");
        }
        if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
          throw new Error("Invalid repeat type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts
  var unsqueeze, unsqueezeV13, parseUnsqueezeAttributes, validateInputs25, validateInputsV132;
  var init_unsqueeze = __esm({
    "web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts"() {
      "use strict";
      init_util();
      unsqueeze = (inferenceHandler, inputs, axes) => {
        validateInputs25(inputs);
        const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);
        const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
        return [output];
      };
      unsqueezeV13 = (inferenceHandler, inputs) => {
        validateInputsV132(inputs);
        return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
      };
      parseUnsqueezeAttributes = (node) => node.attributes.getInts("axes");
      validateInputs25 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Unsqueeze requires 1 input.");
        }
        if (inputs[0].type === "string") {
          throw new Error("invalid input tensor types.");
        }
      };
      validateInputsV132 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Unsqueeze requires 2 inputs.");
        }
        if (inputs[1].type !== "int32") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/op-resolve-rules.ts
  var WEBGL_OP_RESOLVE_RULES;
  var init_op_resolve_rules = __esm({
    "web/lib/onnxjs/backends/webgl/op-resolve-rules.ts"() {
      "use strict";
      init_batch_normalization();
      init_binary_op();
      init_cast();
      init_concat();
      init_conv();
      init_conv_transpose();
      init_depth_to_space();
      init_flatten();
      init_gather();
      init_gemm();
      init_image_scaler();
      init_instance_normalization();
      init_lrn();
      init_matmul();
      init_pad();
      init_pool();
      init_reduce();
      init_reshape();
      init_resize_packed();
      init_shape();
      init_slice();
      init_softmax();
      init_split();
      init_squeeze();
      init_sum();
      init_tile();
      init_transpose();
      init_unary_op();
      init_unsqueeze();
      init_upsample();
      WEBGL_OP_RESOLVE_RULES = [
        ["Abs", "", "6+", abs],
        ["Acos", "", "7+", acos],
        ["Add", "", "7+", add2],
        ["And", "", "7+", and2],
        ["Asin", "", "7+", asin],
        ["Atan", "", "7+", atan],
        // TODO: support new attributes for AveragePool-10
        ["AveragePool", "", "7+", averagePool, parseAveragePoolAttributes],
        ["BatchNormalization", "", "7+", batchNormalization, parseBatchNormalizationAttributes],
        ["Cast", "", "6+", cast, parseCastAttributes],
        ["Ceil", "", "6+", ceil],
        ["Clip", "", "6-10", clip, parseClipAttributes],
        ["Clip", "", "11+", clipV11],
        ["Concat", "", "4+", concat, parseConcatAttributes],
        ["Conv", "", "1+", conv, parseConvAttributes],
        ["ConvTranspose", "", "1+", convTranspose, parseConvTransposeAttributes],
        ["Cos", "", "7+", cos],
        ["Div", "", "7+", div],
        ["Dropout", "", "7+", identity],
        ["DepthToSpace", "", "1+", depthToSpace, parseDepthToSpaceAttributes],
        ["Equal", "", "7+", equal],
        ["Elu", "", "6+", elu, parseEluAttributes],
        ["Exp", "", "6+", exp],
        ["Flatten", "", "1+", flatten, parseFlattenAttributes],
        ["Floor", "", "6+", floor],
        ["FusedConv", "com.microsoft", "1+", conv, parseConvAttributes],
        ["Gather", "", "1+", gather, parseGatherAttributes],
        ["Gemm", "", "7-10", gemm, parseGemmAttributesV7],
        ["Gemm", "", "11+", gemm, parseGemmAttributesV11],
        ["GlobalAveragePool", "", "1+", globalAveragePool, parseGlobalAveragePoolAttributes],
        ["GlobalMaxPool", "", "1+", globalMaxPool],
        ["Greater", "", "7+", greater],
        ["Identity", "", "1+", identity],
        ["ImageScaler", "", "1+", imageScaler, parseImageScalerAttributes],
        ["InstanceNormalization", "", "6+", instanceNormalization, parseInstanceNormalizationAttributes],
        ["LeakyRelu", "", "6+", leakyRelu, parseLeakyReluAttributes],
        ["Less", "", "7+", less],
        ["LRN", "", "1+", lrn, parseLrnAttributes],
        ["Log", "", "6+", log2],
        ["MatMul", "", "1+", matMul, parseMatMulAttributes],
        // TODO: support new attributes for MaxPool-8 and MaxPool-10
        ["MaxPool", "", "1+", maxPool, parseMaxPoolAttributes],
        ["Mul", "", "7+", mul],
        ["Neg", "", "6+", neg],
        ["Not", "", "1+", not2],
        ["Or", "", "7+", or2],
        ["Pad", "", "2-10", padV2, parsePadAttributesV2],
        ["Pad", "", "11+", padV11, parsePadAttributesV11],
        ["Pow", "", "7+", pow],
        ["PRelu", "", "7+", pRelu],
        ["ReduceLogSum", "", "1+", reduceLogSum, parseReduceAttributes],
        ["ReduceMax", "", "1+", reduceMax, parseReduceAttributes],
        ["ReduceMean", "", "1+", reduceMean, parseReduceAttributes],
        ["ReduceMin", "", "1+", reduceMin, parseReduceAttributes],
        ["ReduceProd", "", "1+", reduceProd, parseReduceAttributes],
        ["ReduceSum", "", "1-12", reduceSum, parseReduceAttributes],
        ["ReduceSumSquare", "", "1+", reduceLogSumSquare, parseReduceAttributes],
        ["Relu", "", "6+", relu],
        ["Reshape", "", "5+", reshape],
        ["Resize", "", "10", resize, parseResizeAttributesV10],
        ["Resize", "", "11+", resize, parseResizeAttributesV11],
        ["Shape", "", "1+", shape],
        ["Sigmoid", "", "6+", sigmoid],
        ["Sin", "", "7+", sin],
        ["Slice", "", "10+", sliceV10],
        // TODO: support 'steps' for Slice-10
        ["Slice", "", "1-9", slice, parseSliceAttributes],
        // The "semantic" meaning of axis has changed in opset-13.
        ["Softmax", "", "1-12", softmax, parseSoftmaxAttributes],
        ["Softmax", "", "13+", softmaxV13, parseSoftmaxAttributesV13],
        // 'Split' operator has an optional attribute 'split'
        // this attribute determines how the specified axis of input data is split.
        // When the attribute is missing, we need the count of number of outputs
        // so that we can determine the 'split' attribute from the runtime input to the Operator
        ["Split", "", "2-12", split, parseSplitAttributes],
        ["Sqrt", "", "6+", sqrt],
        ["Squeeze", "", "1-12", squeeze, parseSqueezeAttributes],
        ["Squeeze", "", "13+", squeezeV13],
        ["Sub", "", "7+", sub],
        ["Sum", "", "6+", sum],
        ["Tan", "", "7+", tan],
        ["Tanh", "", "6+", tanh],
        ["Tile", "", "6+", tile],
        ["Transpose", "", "1+", transpose, parseTransposeAttributes],
        ["Upsample", "", "7-8", upsample, parseUpsampleAttributesV7],
        ["Upsample", "", "9", upsample, parseUpsampleAttributesV9],
        ["Unsqueeze", "", "1-12", unsqueeze, parseUnsqueezeAttributes],
        ["Unsqueeze", "", "13+", unsqueezeV13],
        ["Xor", "", "7+", xor2]
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts
  function replaceInlines(script) {
    const inlineDefs = {};
    let match;
    while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {
      const params = match[3].split(",").map((s) => {
        const tokens = s.trim().split(" ");
        if (tokens && tokens.length === 2) {
          return { type: tokens[0], name: tokens[1] };
        }
        return null;
      }).filter((v) => v !== null);
      inlineDefs[match[2]] = { params, body: match[4] };
    }
    for (const name2 in inlineDefs) {
      const regexString = FUNC_CALL_REGEX.replace("__FUNC__", name2);
      const regex = new RegExp(regexString, "gm");
      while ((match = regex.exec(script)) !== null) {
        const type = match[1];
        const variable = match[2];
        const params = match[3].split(",");
        const declLine = type ? `${type} ${variable};` : "";
        let newBody = inlineDefs[name2].body;
        let paramRedecLine = "";
        inlineDefs[name2].params.forEach((v, i) => {
          if (v) {
            paramRedecLine += `${v.type} ${v.name} = ${params[i]};
`;
          }
        });
        newBody = `${paramRedecLine}
 ${newBody}`;
        newBody = newBody.replace("return", `${variable} = `);
        const replacement = `
      ${declLine}
      {
        ${newBody}
      }
      `;
        script = script.replace(match[0], replacement);
      }
    }
    script = script.replace(INLINE_FUNC_DEF_REGEX, "");
    return script;
  }
  var INLINE_FUNC_DEF_REGEX, FUNC_CALL_REGEX;
  var init_glsl_function_inliner = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts"() {
      "use strict";
      INLINE_FUNC_DEF_REGEX = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
      FUNC_CALL_REGEX = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;";
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts
  function squeezeShape(shape2, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape2).sort();
    let j = 0;
    for (let i = 0; i < shape2.length; ++i) {
      if (axes != null) {
        if (axes[j] === i && shape2[i] !== 1) {
          throw new Error(`Can't squeeze axis ${i} since its dim '${shape2[i]}' is not 1`);
        }
        if ((axes[j] == null || axes[j] > i) && shape2[i] === 1) {
          newShape.push(shape2[i]);
          keptDims.push(i);
        }
        if (axes[j] <= i) {
          j++;
        }
      }
      if (shape2[i] !== 1) {
        newShape.push(shape2[i]);
        keptDims.push(i);
      }
    }
    return { newShape, keptDims };
  }
  function parseAxisParam(axis, shape2) {
    const rank = shape2.length;
    axis = axis == null ? shape2.map((_s, i) => i) : [].concat(axis);
    assert(
      axis.every((ax) => ax >= -rank && ax < rank),
      () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`
    );
    assert(axis.every(isInt), () => `All values in axis param must be integers but got axis ${axis}`);
    return axis.map((a) => a < 0 ? rank + a : a);
  }
  function isInt(a) {
    return a % 1 === 0;
  }
  function sizeFromShape(shape2) {
    if (shape2.length === 0) {
      return 1;
    }
    let size = shape2[0];
    for (let i = 1; i < shape2.length; i++) {
      size *= shape2[i];
    }
    return size;
  }
  function sizeToSquarishShape(size) {
    const width = Math.ceil(Math.sqrt(size));
    return [width, Math.ceil(size / width)];
  }
  var PreferLogicalStrategy;
  var init_texture_layout_strategy = __esm({
    "web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts"() {
      "use strict";
      init_instrument();
      init_util();
      PreferLogicalStrategy = class {
        constructor(maxTextureSize) {
          this.maxTextureSize = maxTextureSize;
        }
        computeTextureWH(shape2, prefs) {
          const wh = this.computeTexture(shape2, prefs);
          if (prefs && prefs.isPacked) {
            wh[0] /= 2;
            wh[1] /= 2;
          }
          if (prefs && prefs.reverseWH) {
            return [wh[1], wh[0]];
          }
          return wh;
        }
        computeTexture(shape2, prefs) {
          const isPacked = prefs && prefs.isPacked;
          if (shape2.length === 0) {
            return isPacked ? [2, 2] : [1, 1];
          }
          let maxTextureSize = this.maxTextureSize;
          if (prefs && prefs.breakAxis !== void 0) {
            const wsize = prefs.breakAxis >= shape2.length ? 1 : shape2.slice(prefs.breakAxis).reduce((a, b) => a * b);
            const hsize = prefs.breakAxis <= 0 ? 1 : shape2.slice(0, prefs.breakAxis).reduce((a, b) => a * b);
            if (wsize > maxTextureSize || hsize > maxTextureSize) {
              Logger.verbose(
                "TextureLayout",
                `Given width/height preferences were unattainable: shape:${shape2}, breakAxis:${prefs.breakAxis}`
              );
            } else {
              return [wsize, hsize];
            }
          }
          let logShape = shape2.slice(0);
          if (isPacked) {
            maxTextureSize = maxTextureSize * 2;
            logShape = logShape.map(
              (_d, i) => i >= logShape.length - 2 ? logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1 : logShape[i]
            );
            if (logShape.length === 1) {
              logShape = [2, logShape[0]];
            }
          }
          if (logShape.length !== 2) {
            const squeezeResult = squeezeShape(logShape);
            logShape = squeezeResult.newShape;
          }
          const size = sizeFromShape(logShape);
          if (logShape.length <= 1 && size <= maxTextureSize) {
            return [1, size];
          } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {
            return logShape;
          } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {
            return [logShape[0] * logShape[1], logShape[2]];
          } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2]];
          } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize && logShape[3] <= maxTextureSize) {
            return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
          } else if (logShape.length === 4 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
          } else {
            if (isPacked) {
              return sizeToSquarishShape(size / 4).map((d) => d * 2);
            }
            return sizeToSquarishShape(size);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts
  var CoordsGlslLib;
  var init_glsl_coordinate_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts"() {
      "use strict";
      init_util();
      init_glsl_definitions();
      init_glsl_source();
      init_texture_layout_strategy();
      init_utils();
      CoordsGlslLib = class extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return {
            ...this.offsetToCoords(),
            ...this.coordsToOffset(),
            ...this.toVec(),
            ...this.valueFrom(),
            // TODO return these only when packing is enabled.
            ...this.getCommonUtilFuncs(),
            ...this.getInputsSamplingSnippets(),
            ...this.getOutputSamplingSnippet()
          };
        }
        getCustomTypes() {
          return {};
        }
        /**
         * Produces a function that can map from
         * 2D normalzied coordinates (s,t) to a flat offset
         */
        offsetToCoords() {
          const funcName = "offsetToCoords";
          return {
            offsetToCoords: new GlslLibRoutine(`
      vec2 ${funcName}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)
          };
        }
        /**
         * Produces a function that can map from
         * 2D normalzied coordinates (s,t) to a flat offset
         */
        coordsToOffset() {
          const funcName = "coordsToOffset";
          return {
            coordsToOffset: new GlslLibRoutine(`
      int ${funcName}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)
          };
        }
        /**
         * Generates code for output sampler.
         */
        getOutputSamplingSnippet() {
          const outputLayout = this.context.outputTextureLayout;
          if (outputLayout.isPacked) {
            return this.getPackedOutputSamplingSnippet(outputLayout);
          } else {
            return this.getUnpackedOutputSamplingSnippet(outputLayout);
          }
        }
        /**
         * Generates code for packed output sampler.
         */
        getPackedOutputSamplingSnippet(outputLayout) {
          const outShape = outputLayout.unpackedShape;
          const outTexShape = [outputLayout.width, outputLayout.height];
          const result = {};
          const funcName = "getOutputCoords";
          switch (outShape.length) {
            case 0:
              result[funcName] = this.getOutputScalarCoords();
              break;
            case 1:
              result[funcName] = this.getOutputPacked1DCoords(outShape, outTexShape);
              break;
            case 2:
              result[funcName] = this.getOutputPacked2DCoords(outShape, outTexShape);
              break;
            case 3:
              result[funcName] = this.getOutputPacked3DCoords(
                outShape,
                outTexShape
              );
              break;
            default:
              result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape);
          }
          const glsl = getGlsl(this.context.glContext.version);
          const floatTextureSetRGBASource = `
      void setOutput(vec4 val) {
        ${glsl.output} = val;
      }
    `;
          const floatTextureSetRGBAFuncName = "floatTextureSetRGBA";
          result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);
          return result;
        }
        /**
         * Generates code for unpacked output sampler.
         */
        getUnpackedOutputSamplingSnippet(outputLayout) {
          const outShape = outputLayout.unpackedShape;
          const outTexShape = [outputLayout.width, outputLayout.height];
          const result = {};
          const funcName = "getOutputCoords";
          switch (outShape.length) {
            case 0:
              result[funcName] = this.getOutputScalarCoords();
              break;
            case 1:
              result[funcName] = this.getOutputUnpacked1DCoords(outShape, outTexShape);
              break;
            case 2:
              result[funcName] = this.getOutputUnpacked2DCoords(
                outShape,
                outTexShape
              );
              break;
            case 3:
              result[funcName] = this.getOutputUnpacked3DCoords(
                outShape,
                outTexShape
              );
              break;
            case 4:
              result[funcName] = this.getOutputUnpacked4DCoords(
                outShape,
                outTexShape
              );
              break;
            case 5:
              result[funcName] = this.getOutputUnpacked5DCoords(
                outShape,
                outTexShape
              );
              break;
            case 6:
              result[funcName] = this.getOutputUnpacked6DCoords(
                outShape,
                outTexShape
              );
              break;
            default:
              throw new Error(`Unsupported output dimensionality: ${outShape.length}`);
          }
          const glsl = getGlsl(this.context.glContext.version);
          const floatTextureSetRSource = `
        void setOutput(float val) {
          ${glsl.output} = vec4(val, 0, 0, 0);
        }
    `;
          const floatTextureSetRFuncName = "floatTextureSetR";
          result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);
          return result;
        }
        /**
         * Scalar output coordinates.
         */
        getOutputScalarCoords() {
          return new GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `);
        }
        /**
         * 1D packed output coordinates.
         */
        getOutputPacked1DCoords(_shape, texShape) {
          const packedTexShape = texShape;
          let source = "";
          if (packedTexShape[0] === 1) {
            source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);
          }
        `;
            return new GlslLibRoutine(source);
          }
          if (packedTexShape[1] === 1) {
            source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);
          }
        `;
            return new GlslLibRoutine(source);
          }
          source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * 2D packed output coordinates.
         */
        getOutputPacked2DCoords(shape2, texShape) {
          let source = "";
          if (ArrayUtil.arraysEqual(shape2, texShape)) {
            source = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));
        }
      `;
            return new GlslLibRoutine(source);
          }
          const packedTexShape = texShape;
          const texelsInLogicalRow = Math.ceil(shape2[1] / 2);
          source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec2(r, c);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * 3D packed output coordinates.
         */
        getOutputPacked3DCoords(shape2, texShape) {
          const packedTexShape = [texShape[0], texShape[1]];
          const texelsInLogicalRow = Math.ceil(shape2[2] / 2);
          const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[1] / 2);
          const source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          int b = index / ${texelsInBatch};
          index -= b * ${texelsInBatch};

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec3(b, r, c);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * ND packed output coordinates.
         */
        getOutputPackedNDCoords(shape2, texShape) {
          const packedTexShape = [texShape[0], texShape[1]];
          const texelsInLogicalRow = Math.ceil(shape2[shape2.length - 1] / 2);
          const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[shape2.length - 2] / 2);
          let texelsInBatchN = texelsInBatch;
          let batches = "";
          let coords = "b, r, c";
          for (let b = 2; b < shape2.length - 1; b++) {
            texelsInBatchN *= shape2[shape2.length - b - 1];
            batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
            coords = `b${b}, ` + coords;
          }
          const source = `
      ivec${shape2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

        ${batches}

        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};

        // reverse r and c order for packed texture
        int r = imod(index, ${texelsInLogicalRow}) * 2;
        int c = 2 * (index / ${texelsInLogicalRow});

        return ivec${shape2.length}(${coords});
      }
    `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 1D output coordinates.
         */
        getOutputUnpacked1DCoords(_shape, texShape) {
          const source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          return resTexRC.y * ${texShape[0]} + resTexRC.x;
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 2D output coordinates.
         */
        getOutputUnpacked2DCoords(shape2, texShape) {
          const source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          int r = index / ${shape2[1]};
          int c = index - r * ${shape2[1]};
          return ivec2(r, c);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 3D output coordinates.
         */
        getOutputUnpacked3DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec3(r, c, d);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 4D output coordinates.
         */
        getOutputUnpacked4DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d", "d2"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec4(r, c, d, d2);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 5D output coordinates.
         */
        getOutputUnpacked5DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d", "d2", "d3"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec5(r, c, d, d2, d3);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 6D output coordinates.
         */
        getOutputUnpacked6DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d", "d2", "d3", "d4"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${texShape[0]}, ${texShape[1]}));
         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
         ${coordsFromIndexSnippet}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `;
          return new GlslLibRoutine(source);
        }
        /**
         * Generates code for common UV coords computation utility functions.
         */
        getCommonUtilFuncs() {
          const result = {};
          let funcName = "uvFromFlat";
          result[funcName] = new GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `);
          funcName = "packedUVfrom1D";
          result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
          funcName = "packedUVfrom2D";
          result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
          funcName = "packedUVfrom3D";
          result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
          funcName = "sampleTexture";
          const glsl = getGlsl(this.context.glContext.version);
          result[funcName] = new GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${glsl.texture2D}(textureSampler, uv).r;
        }`);
          return result;
        }
        /**
         * Constructing snippets for inputs
         */
        getInputsSamplingSnippets() {
          const result = {};
          const outputLayout = this.context.outputTextureLayout;
          this.context.programInfo.inputNames.forEach((samplerName, i) => {
            const inputLayout = this.context.inputTextureLayouts[i];
            const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);
            if (inputLayout.isPacked) {
              result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);
            } else {
              result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);
            }
            const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);
            if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {
              if (inputLayout.isPacked) {
                result[outCoordFuncName] = this.getPackedSamplerAtOutputCoords(
                  outCoordFuncName,
                  inputLayout,
                  outputLayout,
                  samplerName
                );
              } else {
                result[outCoordFuncName] = this.getUnpackedSamplerAtOutputCoords(
                  outCoordFuncName,
                  inputLayout,
                  outputLayout,
                  samplerName
                );
              }
            }
          });
          return result;
        }
        /**
         * Constructing snippets for output coordinates of samplers
         */
        getPackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
          const inShape = inputLayout.unpackedShape;
          const outShape = outputLayout.unpackedShape;
          const texName = name2;
          const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);
          const inRank = inShape.length;
          const outRank = outShape.length;
          const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
          const type = getCoordsDataType(outRank);
          const rankDiff = outRank - inRank;
          let coordsSnippet;
          const fields = getGlChannels();
          if (inRank === 0) {
            coordsSnippet = "";
          } else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = "coords = 0;";
          } else {
            coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
          }
          let unpackedCoordsSnippet = "";
          if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = "coords";
          } else {
            unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
          }
          let output = "return outputValue;";
          const inSize = ShapeUtil.size(inShape);
          const isInputScalar = inSize === 1;
          const outSize = ShapeUtil.size(outShape);
          const isOutputScalar = outSize === 1;
          if (inRank === 1 && !isInputScalar && !isOutputScalar) {
            output = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
          } else if (isInputScalar && !isOutputScalar) {
            if (outRank === 1) {
              output = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `;
            } else {
              output = `
          return vec4(outputValue.x);
        `;
            }
          } else if (broadcastDims.length) {
            const rows = inRank - 2;
            const cols = inRank - 1;
            if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
              output = "return vec4(outputValue.x);";
            } else if (broadcastDims.indexOf(rows) > -1) {
              output = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);";
            } else if (broadcastDims.indexOf(cols) > -1) {
              output = "return vec4(outputValue.xx, outputValue.zz);";
            }
          }
          const swapLastDimsSnippet = `
        int lastDim = coords.${fields[outRank - 1]};
        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};
        coords.${fields[outRank - 2]} = lastDim;
      `;
          const source = `
      vec4 ${funcName}() {
        ${type} coords = getOutputCoords();
        ${swapLastDimsSnippet}
        ${coordsSnippet}
        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});
        ${output}
      }
    `;
          return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
        }
        /**
         * Constructing snippets for unpacked output coordinates of samplers
         */
        getUnpackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
          const outTexShape = [outputLayout.width, outputLayout.height];
          const inTexShape = [inputLayout.width, inputLayout.height];
          const inRank = inputLayout.unpackedShape.length;
          const outRank = outputLayout.unpackedShape.length;
          const inShape = inputLayout.unpackedShape;
          const outShape = outputLayout.unpackedShape;
          const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name2);
          if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {
            const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, TexCoords);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const type = getCoordsDataType(outRank);
          const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
          const rankDiff = outRank - inRank;
          let coordsSnippet;
          const fields = getGlChannels();
          if (inRank === 0) {
            coordsSnippet = "";
          } else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = "coords = 0;";
          } else {
            coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
          }
          let unpackedCoordsSnippet = "";
          if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = "coords";
          } else {
            unpackedCoordsSnippet = inputLayout.unpackedShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
          }
          const source = `
        float ${funcName}() {
          ${type} coords = getOutputCoords();
          ${coordsSnippet}
          return ${texFuncSnippet}(${unpackedCoordsSnippet});
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
        }
        /**
         * Constructing snippets for packed operations.
         */
        getPackedSamplerFromInput(funcName, name2, inputLayout) {
          switch (inputLayout.unpackedShape.length) {
            case 0:
              return this.getPackedSamplerScalar(funcName, name2);
            case 1:
              return this.getPackedSampler1D(funcName, name2, inputLayout);
            case 2:
              return this.getPackedSampler2D(funcName, name2, inputLayout);
            case 3:
              return this.getPackedSampler3D(funcName, name2, inputLayout);
            default:
              return this.getPackedSamplerND(funcName, name2, inputLayout);
          }
        }
        /**
         * Constructing snippets for unpacked operations.
         */
        getUnpackedSamplerFromInput(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          switch (shape2.length) {
            case 0:
              return this.getUnpackedSamplerScalar(funcName, name2, inputLayout);
            case 1:
              return this.getUnpackedSampler1D(funcName, name2, inputLayout);
            case 2:
              return this.getUnpackedSampler2D(funcName, name2, inputLayout);
            case 3:
              return this.getUnpackedSampler3D(funcName, name2, inputLayout);
            case 4:
              return this.getUnpackedSampler4D(funcName, name2, inputLayout);
            case 5:
              return this.getUnpackedSampler5D(funcName, name2, inputLayout);
            case 6:
              return this.getUnpackedSampler6D(funcName, name2, inputLayout);
            default:
              throw new Error(`Unsupported dimension ${shape2.length}-D`);
          }
        }
        /**
         * Packed scalar snippet.
         */
        getPackedSamplerScalar(funcName, name2) {
          const glsl = getGlsl(this.context.glContext.version);
          const source = `
          vec4 ${funcName}() {
            return ${glsl.texture2D}(${name2}, halfCR);
          }
        `;
          return new GlslLibRoutine(source);
        }
        /**
         * Packed 1D snippet.
         */
        getPackedSampler1D(funcName, name2, inputLayout) {
          const texShape = [inputLayout.width, inputLayout.height];
          const packedTexShape = [texShape[1], texShape[0]];
          const glsl = getGlsl(this.context.glContext.version);
          const packedSampler = `vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
      ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
          const source = packedSampler;
          return new GlslLibRoutine(source, ["coordinates.packedUVfrom1D"]);
        }
        /**
         * Packed 2D snippet.
         */
        getPackedSampler2D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const texShape = [inputLayout.width, inputLayout.height];
          const glsl = getGlsl(this.context.glContext.version);
          const texNumR = texShape[0];
          const texNumC = texShape[1];
          if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
            const packedSampler2 = `vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
        return ${glsl.texture2D}(${name2}, uv);
      }`;
            return new GlslLibRoutine(packedSampler2);
          }
          const packedTexShape = texShape;
          const valuesPerRow = Math.ceil(shape2[1] / 2);
          const packedSampler = `vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
          const source = packedSampler;
          return new GlslLibRoutine(source, ["coordinates.packedUVfrom2D"]);
        }
        /**
         * Packed 3D snippet.
         */
        getPackedSampler3D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const texShape = [inputLayout.width, inputLayout.height];
          const packedTexShape = [texShape[0], texShape[1]];
          const glsl = getGlsl(this.context.glContext.version);
          if (shape2[0] === 1) {
            const squeezedShape = shape2.slice(1);
            const keptDims = [1, 2];
            const newInputShape = squeezeInputShape(shape2, squeezedShape);
            const params = ["b", "row", "col"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const samplerRoutine = this.getPackedSamplerFromInput(funcName, name2, newInputLayout);
            const packedSampler2 = `${samplerRoutine.routineBody}
      vec4 ${funcName}(int b, int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      } `;
            const source2 = packedSampler2;
            return new GlslLibRoutine(source2, samplerRoutine.dependencies);
          }
          const texNumR = packedTexShape[0];
          const texNumC = packedTexShape[1];
          const valuesPerRow = Math.ceil(shape2[2] / 2);
          const texelsInBatch = valuesPerRow * Math.ceil(shape2[1] / 2);
          const packedSampler = `vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${name2}, uv);}`;
          const source = packedSampler;
          return new GlslLibRoutine(source, ["coordinates.packedUVfrom3D"]);
        }
        /*
         * Packed ND snippet.
         */
        getPackedSamplerND(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const rank = shape2.length;
          const texShape = [inputLayout.width, inputLayout.height];
          const glsl = getGlsl(this.context.glContext.version);
          const packedTexShape = [texShape[0], texShape[1]];
          const texNumR = packedTexShape[1];
          const texNumC = packedTexShape[0];
          const valuesPerRow = Math.ceil(shape2[rank - 1] / 2);
          let texelsInBatch = valuesPerRow * Math.ceil(shape2[rank - 2] / 2);
          let params = "int b, int row, int col";
          let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
          for (let b = 2; b < rank - 1; b++) {
            params = `int b${b}, ` + params;
            texelsInBatch *= shape2[rank - b - 1];
            index = `b${b} * ${texelsInBatch} + ` + index;
          }
          const packedSampler = `vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${name2}, uv);
    }`;
          const source = packedSampler;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked scalar snippet.
         */
        getUnpackedSamplerScalar(funcName, name2, inputLayout) {
          const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];
          if (texNumR === 1 && texNumC === 1) {
            const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, halfCR);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const source = `
        float ${funcName}() {
          int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name2});
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * Unpacked 1D snippet.
         */
        getUnpackedSampler1D(funcName, name2, inputLayout) {
          const tNumR = inputLayout.width;
          const tNumC = inputLayout.height;
          if (tNumC === 1 && tNumR === 1) {
            const source2 = `
        float ${funcName}(int index) {
          return sampleTexture(${name2}, halfCR);
        }
      `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          if (tNumC === 1) {
            const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          if (tNumR === 1) {
            const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const source = `
        float ${funcName}(int index) {
          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        /**
         * Unpacked 2D snippet.
         */
        getUnpackedSampler2D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const texShape = [inputLayout.height, inputLayout.width];
          if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
            const texNumR2 = texShape[1];
            const texNumC2 = texShape[0];
            const source2 = `
          float ${funcName}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR2}.0, ${texNumC2}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const { newShape, keptDims } = squeezeShape(shape2);
          const squeezedShape = newShape;
          if (squeezedShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, squeezedShape);
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const params = ["col", "row"];
            const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const texNumR = texShape[1];
          const texNumC = texShape[0];
          if (texNumC === 1) {
            const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          if (texNumR === 1) {
            const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          const source = `
        float ${funcName}(int row, int col) {
          int index = col * ${shape2[1]} + row;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * Unpacked 3D snippet.
         */
        getUnpackedSampler3D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride0 = shape2[1] * shape2[2];
          const stride1 = shape2[2];
          const { newShape, keptDims } = squeezeShape(shape2);
          const squeezedShape = newShape;
          if (squeezedShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, squeezedShape);
            const params = ["batch", "col", "row"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const routine = this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout);
            const revDims = keptDims.reverse();
            const source2 = `
          ${routine.routineBody}
          float ${funcName}(int batch, int row, int col) {
            return ${funcName}(${getSqueezedParams(params, revDims)});
          }
        `;
            return new GlslLibRoutine(source2, routine.dependencies);
          }
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
          float ${funcName}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${stride0} + col * ${stride1} + row;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
      `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * Unpacked 4D snippet.
         */
        getUnpackedSampler4D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride2 = shape2[3];
          const stride1 = shape2[2] * stride2;
          const stride0 = shape2[1] * stride1;
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
        float ${funcName}(int row, int col, int depth, int depth2) {
          int index = row * ${stride0} + col * ${stride1} +
              depth2 * ${stride2} + depth;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        /**
         * Unpacked 5D snippet.
         */
        getUnpackedSampler5D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride3 = shape2[4];
          const stride2 = shape2[3] * stride3;
          const stride1 = shape2[2] * stride2;
          const stride0 = shape2[1] * stride1;
          const { newShape, keptDims } = squeezeShape(shape2);
          if (newShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, newShape);
            const params = ["row", "col", "depth", "depth2", "depth3"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth3 * ${stride3} + depth2;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        /**
         * Unpacked 6D snippet.
         */
        getUnpackedSampler6D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride4 = shape2[5];
          const stride3 = shape2[4] * stride4;
          const stride2 = shape2[3] * stride3;
          const stride1 = shape2[2] * stride2;
          const stride0 = shape2[1] * stride1;
          const { newShape, keptDims } = squeezeShape(shape2);
          if (newShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, newShape);
            const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const source2 = `
            ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
            float ${funcName}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${funcName}(${getSqueezedParams(params, keptDims)});
            }
          `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
          float ${funcName}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 * ${stride4} + depth4;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * This is the main function to map from the given texture coordinates (s,t)
         * to logical indices for the output
         * There will only be one single variation of this
         * Also see coordsToOffset and offsetToIndices for input-specific versions
         */
        toVec() {
          const output = this.context.outputTextureLayout;
          const rank = output.shape.length;
          const strides = output.strides;
          const xScale = output.width;
          const yScale = output.height;
          const stridesBlock = [];
          for (let i = 0; i < rank - 1; ++i) {
            stridesBlock.push(`
        c[${i}] = offset / ${strides[i]};`);
            stridesBlock.push(`
        offset -= c[${i}] * ${strides[i]};`);
          }
          stridesBlock.push(`
        c[${rank - 1}] = offset;`);
          const body = `
      void toVec(vec2 texCoords, out int c[${rank}]) {
        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});
        ${stridesBlock.join("")}
      }
      void toVec(int offset, out int c[${rank}]) {
        ${stridesBlock.join("")}
      }
    `;
          return { toVec: new GlslLibRoutine(body, ["coordinates.coordsToOffset"]) };
        }
        /**
         * These are value getter functions generated for each input
         * Each function is hardwired to the name and dimensions of the input
         * An '_T' variation is also produced which accesses values as if the
         * input was transposed
         */
        valueFrom() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const layout = this.context.inputTextureLayouts[i];
            const shape2 = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;
            const rank = shape2.length;
            let funcName = `_${name2}`;
            result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name2, rank, layout.width, layout.height, false), [
              `shapeUtils.indicesToOffset${funcName}`,
              "coordinates.offsetToCoords",
              "fragcolor.getColorAsFloat"
            ]);
            funcName = funcName + "_T";
            result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name2, rank, layout.width, layout.height, true), [
              `shapeUtils.indicesToOffset${funcName}`,
              "coordinates.offsetToCoords",
              "fragcolor.getColorAsFloat"
            ]);
          });
          return result;
        }
        /**
         * Produces one value getter function for the name and rank given
         * If a transpose is set proper offsetToCoords mapping will be used
         * @param name name of the function
         * @param rank rank of the input
         * @param transpose whether or not should generate a transpose variation
         */
        getValueFromSingle(varName, rank, width, height, transpose2) {
          let name2 = `_${varName}`;
          if (transpose2) {
            name2 = name2 + "_T";
          }
          const glsl = getGlsl(this.context.glContext.version);
          return `
        float ${name2}(int m[${rank}]) {
          int offset = indicesToOffset${name2}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));
          return value;
        }
        `;
        }
        /**
         * Produces a packed value getter function for the name and rank given
         * If a transpose is set proper offsetToCoords mapping will be used
         * @param name name of the function
         * @param rank rank of the input
         * @param transpose whether or not should generate a transpose variation
         */
        getPackedValueFrom(varName, rank, width, height, transpose2) {
          let name2 = `_${varName}_Pack`;
          if (transpose2) {
            name2 = name2 + "_T";
          }
          const glsl = getGlsl(this.context.glContext.version);
          return `
        vec4 ${name2}(int m[${rank}]) {
          int offset = indicesToOffset_${varName}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          return ${glsl.texture2D}(${varName}, coords);
        }
        `;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts
  var EncodingGlslLib;
  var init_glsl_encoding_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      EncodingGlslLib = class _EncodingGlslLib extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return { ...this.encodeFloat32(), ...this.decodeFloat32() };
        }
        getCustomTypes() {
          return {};
        }
        encodeFloat32() {
          return {
            encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)
          };
        }
        decodeFloat32() {
          return {
            decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)
          };
        }
        /**
         * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)
         * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
         */
        encodeUint8() {
          const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return {
            encode: new GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${endianness}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)
          };
        }
        /**
         * returns the routine to encode a vec4 of unsigned bytes to float32
         * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
         */
        decodeUint8() {
          const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return {
            decode: new GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${endianness}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)
          };
        }
        /**
         * Determines if the machine is little endian or not
         * @credit: https://gist.github.com/TooTallNate/4750953
         */
        static isLittleEndian() {
          const b = new ArrayBuffer(4);
          const a = new Uint32Array(b);
          const c = new Uint8Array(b);
          a[0] = 3735928559;
          if (c[0] === 239) {
            return true;
          }
          if (c[0] === 222) {
            return false;
          }
          throw new Error("unknown endianness");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts
  var FragColorGlslLib;
  var init_glsl_fragcolor_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      init_glsl_source();
      FragColorGlslLib = class extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return { ...this.setFragColor(), ...this.getColorAsFloat() };
        }
        getCustomTypes() {
          return {};
        }
        setFragColor() {
          const glsl = getGlsl(this.context.glContext.version);
          return {
            setFragColor: new GlslLibRoutine(
              `
        void setFragColor(float value) {
            ${glsl.output} = encode(value);
        }
        `,
              ["encoding.encode"]
            )
          };
        }
        getColorAsFloat() {
          return {
            getColorAsFloat: new GlslLibRoutine(
              `
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,
              ["encoding.decode"]
            )
          };
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts
  var ShapeUtilsGlslLib;
  var init_glsl_shape_utils_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      ShapeUtilsGlslLib = class _ShapeUtilsGlslLib extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return {
            ...this.bcastIndex(),
            ...this.bcastMatmulIndex(),
            ...this.offsetToIndices(),
            ...this.indicesToOffset(),
            ...this.incrementIndices()
          };
        }
        getCustomTypes() {
          return {};
        }
        bcastIndex() {
          const outputRank = this.context.outputTextureLayout.shape.length;
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].unpackedShape;
            if (shape2.length <= outputRank) {
              const rank = shape2.length;
              const dimOffset = outputRank - rank;
              const funcName = `bcastIndices_${name2}`;
              let block = "";
              for (let i2 = 0; i2 < rank; ++i2) {
                block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
              }
              const body = `
        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
        }
        `;
              result[funcName] = new GlslLibRoutine(body);
            }
          });
          return result;
        }
        bcastMatmulIndex() {
          const outputRank = this.context.outputTextureLayout.shape.length;
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            if (!(shape2.length < 2 || shape2.length > outputRank)) {
              const rank = shape2.length;
              const dimOffset = outputRank - rank;
              const funcName = `bcastMatmulIndices_${name2}`;
              let block = "";
              for (let i2 = 0; i2 < rank - 2; ++i2) {
                block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
              }
              const body = `
        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];
          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];
        }
        `;
              result[funcName] = new GlslLibRoutine(body);
            }
          });
          return result;
        }
        indicesToOffset() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            const strides = this.context.inputTextureLayouts[i].strides;
            const rank = shape2.length;
            let funcName = `indicesToOffset_${name2}`;
            result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));
            funcName = `indicesToOffset_${name2}_T`;
            result[funcName] = new GlslLibRoutine(
              _ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse())
            );
          });
          return result;
        }
        static indexToOffsetSingle(name2, rank, strides) {
          let block = "";
          for (let i = rank - 1; i >= 0; --i) {
            block += `
        offset += indices[${i}] * ${strides[i]};
        `;
          }
          return `
      int ${name2}(int indices[${rank}]) {
        int offset = 0;
        ${block}
        return offset;
      }
      `;
        }
        offsetToIndices() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            const strides = this.context.inputTextureLayouts[i].strides;
            const rank = shape2.length;
            let funcName = `offsetToIndices_${name2}`;
            result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));
            funcName = `offsetToIndices_${name2}_T`;
            result[funcName] = new GlslLibRoutine(
              _ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse())
            );
          });
          return result;
        }
        static offsetToIndicesSingle(name2, rank, strides) {
          const stridesBlock = [];
          for (let i = 0; i < rank - 1; ++i) {
            stridesBlock.push(`
      indices[${i}] = offset / ${strides[i]};`);
            stridesBlock.push(`
        offset -= indices[${i}] * ${strides[i]};`);
          }
          stridesBlock.push(`
      indices[${rank - 1}] = offset;`);
          return `
      void ${name2}(int offset, out int indices[${rank}]) {
        ${stridesBlock.join("")}
      }
      `;
        }
        incrementIndices() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            const rank = shape2.length;
            const funcName = `incrementIndices_${name2}`;
            let shapeInit = "";
            for (let i2 = 0; i2 < rank; ++i2) {
              shapeInit += `
        shape[${i2}] = ${shape2[i2]};`;
            }
            const body = `
        void ${funcName}(int axis, out int indices[${rank}]) {
          int shape[${rank}];
          ${shapeInit};
          for(int i = ${rank} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
            result[funcName] = new GlslLibRoutine(body);
          });
          return result;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts
  var VecGlslLib;
  var init_glsl_vec_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      VecGlslLib = class extends GlslLib {
        constructor(context) {
          super(context);
        }
        getCustomTypes() {
          return {};
        }
        getFunctions() {
          return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };
        }
        binaryVecFunctions() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          const nameOp = { add: "+=", sub: "-=", mul: "*=", div: "/=" };
          const result = {};
          for (const name2 in nameOp) {
            const fname = `${name2}Vec`;
            let assignmentBlock = "";
            for (let i = 0; i < rank; ++i) {
              assignmentBlock += `
          dest[${i}] ${nameOp[name2]} src[${i}];
          `;
            }
            const body = `
        void ${fname}(int src[${rank}], out int dest[${rank}]) {
          ${assignmentBlock}
        }
        `;
            result[fname] = new GlslLibRoutine(body);
          }
          return result;
        }
        copyVec() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          let assignmentBlock = "";
          for (let i = 0; i < rank; ++i) {
            assignmentBlock += `
        dest[${i}] = src[${i}];
        `;
          }
          const body = `
      void copyVec(int src[${rank}], out int dest[${rank}]) {
        ${assignmentBlock}
      }
      `;
          return { copyVec: new GlslLibRoutine(body) };
        }
        setVecItem() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          let block = `
        if(index < 0)
            index =${rank} + index;
        if (index == 0)
            m[0] = value;
        `;
          for (let i = 1; i < rank - 1; ++i) {
            block += `
        else if (index == ${i})
            m[${i}] = value;
            `;
          }
          block += `
        else
            m[${rank - 1}] = value;
        `;
          const body = `
      void setVecItem(out int m[${rank}], int index, int value) {
        ${block}
      }
        `;
          return { setVecItem: new GlslLibRoutine(body) };
        }
        getVecItem() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          let block = `
        if(index < 0)
            index = ${rank} + index;
        if (index == 0)
            return m[0];
      `;
          for (let i = 1; i < rank - 1; ++i) {
            block += `
        else if (index == ${i})
            return m[${i}];
      `;
          }
          block += `
        else
            return m[${rank - 1}];
        `;
          const body = `
      int getVecItem(int m[${rank}], int index) {
        ${block}
      }
    `;
          return { getVecItem: new GlslLibRoutine(body) };
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts
  var glslRegistry;
  var init_glsl_registered_libs = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts"() {
      "use strict";
      init_glsl_coordinate_lib();
      init_glsl_encoding_lib();
      init_glsl_fragcolor_lib();
      init_glsl_shape_utils_lib();
      init_glsl_vec_lib();
      glslRegistry = {
        encoding: EncodingGlslLib,
        fragcolor: FragColorGlslLib,
        vec: VecGlslLib,
        shapeUtils: ShapeUtilsGlslLib,
        coordinates: CoordsGlslLib
        //  'arrays': ArrayGlslSLib
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts
  var GlslPreprocessor;
  var init_glsl_preprocessor = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts"() {
      "use strict";
      init_glsl_definitions();
      init_glsl_function_inliner();
      init_glsl_registered_libs();
      init_glsl_source();
      GlslPreprocessor = class {
        constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
          this.libs = {};
          this.glslLibRoutineDependencyGraph = {};
          this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);
          Object.keys(glslRegistry).forEach((name2) => {
            const lib = new glslRegistry[name2](this.context);
            this.libs[name2] = lib;
          });
          const map = this.glslLibRoutineDependencyGraph;
          for (const libName in this.libs) {
            const lib = this.libs[libName];
            const routinesInLib = lib.getFunctions();
            for (const routine in routinesInLib) {
              const key = libName + "." + routine;
              let currentNode;
              if (map[key]) {
                currentNode = map[key];
                currentNode.routineBody = routinesInLib[routine].routineBody;
              } else {
                currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);
                map[key] = currentNode;
              }
              const dependencies = routinesInLib[routine].dependencies;
              if (dependencies) {
                for (let i = 0; i < dependencies.length; ++i) {
                  if (!map[dependencies[i]]) {
                    const node = new GlslLibRoutineNode(dependencies[i]);
                    map[dependencies[i]] = node;
                    currentNode.addDependency(node);
                  } else {
                    currentNode.addDependency(map[dependencies[i]]);
                  }
                }
              }
            }
          }
        }
        preprocess() {
          const programInfo = this.context.programInfo;
          let source = programInfo.shaderSource;
          if (!this.context.programInfo.hasMain) {
            source = `${source}
      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;
          }
          source = replaceInlines(source);
          return `${getFragShaderPreamble(this.context.glContext.version)}
    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}
    ${this.getImports(source)}
    ${source}`;
        }
        getImports(script) {
          const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);
          if (routinesIncluded.length === 0) {
            return "";
          }
          let routines = "";
          for (let i = 0; i < routinesIncluded.length; ++i) {
            if (routinesIncluded[i].routineBody) {
              routines += routinesIncluded[i].routineBody + "\n";
            } else {
              throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);
            }
          }
          return routines;
        }
        selectGlslLibRoutinesToBeIncluded(script) {
          const nodes = [];
          Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine) => {
            const routine = classAndRoutine.split(".")[1];
            if (script.indexOf(routine) !== -1) {
              nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);
            }
          });
          return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);
        }
        getUniforms(samplers, variables) {
          const uniformLines = [];
          if (samplers) {
            for (const sampler of samplers) {
              uniformLines.push(`uniform sampler2D ${sampler};`);
            }
          }
          if (variables) {
            for (const variable of variables) {
              uniformLines.push(
                `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ""};`
              );
            }
          }
          return uniformLines.join("\n");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/program-manager.ts
  var ProgramManager;
  var init_program_manager = __esm({
    "web/lib/onnxjs/backends/webgl/program-manager.ts"() {
      "use strict";
      init_esm();
      init_instrument();
      init_glsl_preprocessor();
      init_glsl_source();
      ProgramManager = class {
        constructor(profiler, glContext, textureLayoutStrategy) {
          this.profiler = profiler;
          this.glContext = glContext;
          this.textureLayoutStrategy = textureLayoutStrategy;
          this.repo = /* @__PURE__ */ new Map();
          this.attributesBound = false;
        }
        getArtifact(key) {
          return this.repo.get(key);
        }
        setArtifact(key, artifact) {
          this.repo.set(key, artifact);
        }
        run(buildArtifact, inputs, output) {
          this.profiler.event(
            "op",
            `ProgramManager.run ${buildArtifact.programInfo.name ?? "unknown kernel"}`,
            () => {
              const gl = this.glContext.gl;
              const program = buildArtifact.program;
              gl.useProgram(program);
              try {
                this.bindOutput(output);
                if (!this.attributesBound) {
                  this.bindAttributes(buildArtifact.attribLocations);
                }
                this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);
              } catch (err) {
                Logger.error("ProgramManager", buildArtifact.programInfo.shaderSource);
                throw err;
              }
              this.profiler.event("backend", "GlContext.draw()", () => {
                this.glContext.draw();
              });
            },
            this.glContext
          );
        }
        dispose() {
          if (this.vertexShader) {
            this.glContext.deleteShader(this.vertexShader);
          }
          this.repo.forEach((a) => this.glContext.deleteProgram(a.program));
        }
        build(programInfo, inputTextureLayouts, outputTextureLayout) {
          return this.profiler.event("backend", "ProgramManager.build", () => {
            const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);
            const fragScript = preprocessor.preprocess();
            const program = this.compile(fragScript);
            const artifact = {
              programInfo,
              program,
              uniformLocations: this.getUniformLocations(
                program,
                preprocessor.context.programInfo.inputNames,
                preprocessor.context.programInfo.variables
              ),
              attribLocations: this.getAttribLocations(program)
            };
            return artifact;
          });
        }
        compile(fragShaderScript) {
          if (!this.vertexShader) {
            Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
            const vertexShaderScript = getVertexShaderSource(this.glContext.version);
            this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);
          }
          if (env2.debug) {
            Logger.verbose(
              "ProrgramManager",
              `FragShader:
${fragShaderScript}
`
            );
          }
          const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);
          const program = this.glContext.createProgram(this.vertexShader, fragShader);
          this.glContext.deleteShader(fragShader);
          return program;
        }
        bindOutput(td) {
          const width = td.width;
          const height = td.height;
          Logger.verbose(
            "ProrgramManager",
            `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`
          );
          this.glContext.attachFramebuffer(td.texture, width, height);
        }
        bindAttributes(attribLocations) {
          const positionHandle = attribLocations.position;
          const textureCoordHandle = attribLocations.textureCoord;
          this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);
          this.attributesBound = true;
        }
        bindUniforms(uniformLocations, variables, textures) {
          const gl = this.glContext.gl;
          let texturePosition = 0;
          for (const { name: name2, type, location: location2, arrayLength } of uniformLocations) {
            const value = variables.find((v) => v.name === name2)?.data;
            if (type !== "sampler2D" && !value) {
              throw new Error(`variable '${name2}' does not have data defined in program info`);
            }
            switch (type) {
              case "sampler2D":
                this.bindTexture(textures[texturePosition], location2, texturePosition);
                texturePosition++;
                break;
              case "float":
                if (arrayLength) {
                  gl.uniform1fv(location2, value);
                } else {
                  gl.uniform1f(location2, value);
                }
                break;
              case "int":
                if (arrayLength) {
                  gl.uniform1iv(location2, value);
                } else {
                  gl.uniform1i(location2, value);
                }
                break;
              default:
                throw new Error(`Uniform not implemented: ${type}`);
            }
          }
        }
        bindTexture(td, uniformHandle, position) {
          this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);
        }
        getAttribLocations(program) {
          return {
            position: this.getAttribLocation(program, "position"),
            textureCoord: this.getAttribLocation(program, "textureCoord")
          };
        }
        getUniformLocations(program, samplers, variables) {
          const uniformLocations = [];
          if (samplers) {
            for (const sampler of samplers) {
              uniformLocations.push({
                name: sampler,
                type: "sampler2D",
                location: this.getUniformLocation(program, sampler)
              });
            }
          }
          if (variables) {
            for (const variable of variables) {
              uniformLocations.push({ ...variable, location: this.getUniformLocation(program, variable.name) });
            }
          }
          return uniformLocations;
        }
        getUniformLocation(program, name2) {
          const gl = this.glContext.gl;
          const reference = gl.getUniformLocation(program, name2);
          if (reference === null) {
            throw new Error(`Uniform ${name2} not found.`);
          }
          return reference;
        }
        getAttribLocation(program, name2) {
          const gl = this.glContext.gl;
          const attributeLocation = gl.getAttribLocation(program, name2);
          return attributeLocation;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-manager.ts
  var TextureManager;
  var init_texture_manager = __esm({
    "web/lib/onnxjs/backends/webgl/texture-manager.ts"() {
      "use strict";
      init_instrument();
      init_texture_data_encoder();
      TextureManager = class {
        constructor(glContext, layoutStrategy, profiler, config) {
          this.glContext = glContext;
          this.layoutStrategy = layoutStrategy;
          this.profiler = profiler;
          this.config = config;
          this.pendingRead = /* @__PURE__ */ new Map();
          if (config.reuseTextures) {
            this.inUseTextures = /* @__PURE__ */ new Map();
            this.idleTextures = /* @__PURE__ */ new Map();
            this.textureLookup = /* @__PURE__ */ new Map();
          }
        }
        createTextureFromLayout(dataType, layout, data, usage) {
          const textureDataType = this.toEncoderType(dataType);
          const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);
          if (layout.isPacked && usage === 1 /* UploadOnly */) {
            throw new Error("not implemented");
          }
          const width = layout.width;
          const height = layout.height;
          let key;
          let inUseTextures;
          if (this.config.reuseTextures) {
            key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;
            inUseTextures = this.inUseTextures.get(key);
            if (!inUseTextures) {
              inUseTextures = [];
              this.inUseTextures.set(key, inUseTextures);
            }
            const idleTextures = this.idleTextures.get(key);
            if (idleTextures && idleTextures.length > 0) {
              const texture2 = idleTextures.pop();
              inUseTextures.push(texture2);
              if (usage === 1 /* UploadOnly */) {
                this.glContext.updateTexture(texture2, width, height, encoder, this.toTextureData(dataType, data));
              }
              return texture2;
            }
          }
          Logger.verbose("TextureManager", `Creating new texture of size ${layout.width}x${layout.height}`);
          const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));
          if (this.config.reuseTextures) {
            inUseTextures.push(texture);
            this.textureLookup.set(texture, key);
          }
          return texture;
        }
        readTexture(td, dataType, channels) {
          if (!channels) {
            channels = 1;
          }
          return this.profiler.event("backend", "TextureManager.readTexture", () => {
            const dataSize = td.shape.reduce((a, b) => a * b) * channels;
            const data = this.glContext.readTexture(
              td.texture,
              td.width,
              td.height,
              dataSize,
              this.toEncoderType(dataType),
              channels
            );
            return this.toTensorData(dataType, data);
          });
        }
        async readTextureAsync(td, dataType, channels) {
          const dataId = td.tensor.dataId;
          if (!channels) {
            channels = 1;
          }
          if (this.pendingRead.has(dataId)) {
            const subscribers = this.pendingRead.get(dataId);
            return new Promise((resolve) => subscribers?.push(resolve));
          }
          return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
            this.pendingRead.set(dataId, []);
            const dataSize = td.shape.reduce((a, b) => a * b) * channels;
            await this.glContext.createAndWaitForFence();
            const data = this.glContext.readTexture(
              td.texture,
              td.width,
              td.height,
              dataSize,
              this.toEncoderType(dataType),
              channels
            );
            const tensorData = this.toTensorData(dataType, data);
            const subscribers = this.pendingRead.get(dataId);
            this.pendingRead.delete(dataId);
            subscribers?.forEach((resolve) => resolve(tensorData));
            return tensorData;
          });
        }
        readUint8TextureAsFloat(td) {
          return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
            const dataSize = td.shape.reduce((a, b) => a * b);
            const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, "byte", 4);
            return new Float32Array(data.buffer, data.byteOffset, dataSize);
          });
        }
        releaseTexture(textureData, deleteTexture) {
          let key;
          if (this.config.reuseTextures) {
            key = this.textureLookup.get(textureData.texture);
            if (key) {
              if (deleteTexture) {
                this.textureLookup.delete(key);
              }
              const inUseTextures = this.inUseTextures.get(key);
              if (inUseTextures) {
                const index = inUseTextures.indexOf(textureData.texture);
                if (index !== -1) {
                  inUseTextures.splice(index, 1);
                  let idleTextures = this.idleTextures.get(key);
                  if (!idleTextures) {
                    idleTextures = [];
                    this.idleTextures.set(key, idleTextures);
                  }
                  idleTextures.push(textureData.texture);
                }
              }
            }
          }
          if (!key || deleteTexture) {
            Logger.verbose("TextureManager", `Deleting texture of size ${textureData.width}x${textureData.height}`);
            this.glContext.deleteTexture(textureData.texture);
          }
        }
        toTensorData(dataType, data) {
          switch (dataType) {
            case "int16":
              return data instanceof Int16Array ? data : Int16Array.from(data);
            case "int32":
              return data instanceof Int32Array ? data : Int32Array.from(data);
            case "int8":
              return data instanceof Int8Array ? data : Int8Array.from(data);
            case "uint16":
              return data instanceof Uint16Array ? data : Uint16Array.from(data);
            case "uint32":
              return data instanceof Uint32Array ? data : Uint32Array.from(data);
            case "uint8":
            case "bool":
              return data instanceof Uint8Array ? data : Uint8Array.from(data);
            case "float32":
              return data instanceof Float32Array ? data : Float32Array.from(data);
            case "float64":
              return data instanceof Float64Array ? data : Float64Array.from(data);
            default:
              throw new Error(`TensorData type ${dataType} is not supported`);
          }
        }
        toTextureData(_dataType, data) {
          if (!data) {
            return void 0;
          }
          return data instanceof Float32Array ? data : new Float32Array(data);
        }
        toEncoderType(_dataType) {
          return "float";
        }
        clearActiveTextures() {
          this.glContext.clearActiveTextures();
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/session-handler.ts
  var WebGLSessionHandler;
  var init_session_handler = __esm({
    "web/lib/onnxjs/backends/webgl/session-handler.ts"() {
      "use strict";
      init_instrument();
      init_opset();
      init_inference_handler();
      init_op_resolve_rules();
      init_program_manager();
      init_texture_layout_strategy();
      init_texture_manager();
      WebGLSessionHandler = class {
        constructor(backend2, context) {
          this.backend = backend2;
          this.context = context;
          this.layoutStrategy = new PreferLogicalStrategy(backend2.glContext.maxTextureSize);
          this.programManager = new ProgramManager(this.context.profiler, backend2.glContext, this.layoutStrategy);
          this.textureManager = new TextureManager(backend2.glContext, this.layoutStrategy, this.context.profiler, {
            reuseTextures: backend2.textureCacheMode === "full"
          });
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          this.pack = backend2.pack;
          this.pack2unpackMap = /* @__PURE__ */ new Map();
          this.unpack2packMap = /* @__PURE__ */ new Map();
        }
        createInferenceHandler() {
          return new WebGLInferenceHandler(this);
        }
        onGraphInitialized(graph) {
          const initializers = graph.getValues().filter((v) => v.from === -1 && v.tensor).map((v) => v.tensor.dataId);
          this.initializers = new Set(initializers);
        }
        isInitializer(tensorId) {
          return this.initializers ? this.initializers.has(tensorId) : false;
        }
        addInitializer(tensorId) {
          this.initializers.add(tensorId);
        }
        getTextureData(tensorId, isPacked) {
          if (isPacked) {
            return this.packedTextureDataCache.get(tensorId);
          } else {
            return this.unpackedTextureDataCache.get(tensorId);
          }
        }
        setTextureData(tensorId, textureData, isPacked = false) {
          Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache");
          if (isPacked) {
            this.packedTextureDataCache.set(tensorId, textureData);
          } else {
            this.unpackedTextureDataCache.set(tensorId, textureData);
          }
        }
        dispose() {
          this.programManager.dispose();
          this.textureManager.clearActiveTextures();
          this.packedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        resolve(node, opsets, graph) {
          const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);
          return { impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node };
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/webgl-context.ts
  function linearSearchLastTrue(arr) {
    let i = 0;
    for (; i < arr.length; ++i) {
      const isDone = arr[i]();
      if (!isDone) {
        break;
      }
    }
    return i - 1;
  }
  var WebGLContext;
  var init_webgl_context = __esm({
    "web/lib/onnxjs/backends/webgl/webgl-context.ts"() {
      "use strict";
      init_esm();
      init_texture_data_encoder();
      init_texture_data_encoder();
      init_utils();
      WebGLContext = class {
        constructor(gl, version3) {
          this.frameBufferBound = false;
          this.itemsToPoll = [];
          this.gl = gl;
          this.version = version3;
          this.getExtensions();
          this.vertexbuffer = this.createVertexbuffer();
          this.framebuffer = this.createFramebuffer();
          this.queryVitalParameters();
        }
        allocateTexture(width, height, encoder, data) {
          const gl = this.gl;
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          const buffer = data ? encoder.encode(data, width * height) : null;
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            // Level of detail.
            encoder.internalFormat,
            width,
            height,
            0,
            // Always 0 in OpenGL ES.
            encoder.format,
            encoder.textureType,
            buffer
          );
          this.checkError();
          return texture;
        }
        updateTexture(texture, width, height, encoder, data) {
          const gl = this.gl;
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const buffer = encoder.encode(data, width * height);
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            // level
            0,
            // xoffset
            0,
            // yoffset
            width,
            height,
            encoder.format,
            encoder.textureType,
            buffer
          );
          this.checkError();
        }
        attachFramebuffer(texture, width, height) {
          const gl = this.gl;
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          this.checkError();
          gl.viewport(0, 0, width, height);
          gl.scissor(0, 0, width, height);
        }
        readTexture(texture, width, height, dataSize, dataType, channels) {
          const gl = this.gl;
          if (!channels) {
            channels = 1;
          }
          if (!this.frameBufferBound) {
            this.attachFramebuffer(texture, width, height);
          }
          const encoder = this.getEncoder(dataType, channels);
          const buffer = encoder.allocate(width * height);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);
          this.checkError();
          return encoder.decode(buffer, dataSize);
        }
        isFramebufferReady() {
          return true;
        }
        getActiveTexture() {
          const gl = this.gl;
          const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);
          return `TEXTURE${n - gl.TEXTURE0}`;
        }
        getTextureBinding() {
          return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
        }
        getFramebufferBinding() {
          return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
        }
        setVertexAttributes(positionHandle, textureCoordHandle) {
          const gl = this.gl;
          gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);
          gl.enableVertexAttribArray(positionHandle);
          if (textureCoordHandle !== -1) {
            gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);
            gl.enableVertexAttribArray(textureCoordHandle);
          }
          this.checkError();
        }
        createProgram(vertexShader, fragShader) {
          const gl = this.gl;
          const program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragShader);
          gl.linkProgram(program);
          return program;
        }
        compileShader(shaderSource, shaderType) {
          const gl = this.gl;
          const shader = gl.createShader(shaderType);
          if (!shader) {
            throw new Error(`createShader() returned null with type ${shaderType}`);
          }
          gl.shaderSource(shader, shaderSource);
          gl.compileShader(shader);
          if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}
Shader source:
${shaderSource}`);
          }
          return shader;
        }
        deleteShader(shader) {
          this.gl.deleteShader(shader);
        }
        bindTextureToUniform(texture, position, uniformHandle) {
          const gl = this.gl;
          gl.activeTexture(gl.TEXTURE0 + position);
          this.checkError();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          this.checkError();
          gl.uniform1i(uniformHandle, position);
          this.checkError();
        }
        draw() {
          this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
          this.checkError();
        }
        checkError() {
          if (env2.debug) {
            const gl = this.gl;
            const error = gl.getError();
            let label = "";
            switch (error) {
              case gl.NO_ERROR:
                return;
              case gl.INVALID_ENUM:
                label = "INVALID_ENUM";
                break;
              case gl.INVALID_VALUE:
                label = "INVALID_VALUE";
                break;
              case gl.INVALID_OPERATION:
                label = "INVALID_OPERATION";
                break;
              case gl.INVALID_FRAMEBUFFER_OPERATION:
                label = "INVALID_FRAMEBUFFER_OPERATION";
                break;
              case gl.OUT_OF_MEMORY:
                label = "OUT_OF_MEMORY";
                break;
              case gl.CONTEXT_LOST_WEBGL:
                label = "CONTEXT_LOST_WEBGL";
                break;
              default:
                label = `Unknown WebGL Error: ${error.toString(16)}`;
            }
            throw new Error(label);
          }
        }
        deleteTexture(texture) {
          this.gl.deleteTexture(texture);
        }
        deleteProgram(program) {
          this.gl.deleteProgram(program);
        }
        getEncoder(dataType, channels, usage = 0 /* Default */) {
          if (this.version === 2) {
            return new RedFloat32DataEncoder(this.gl, channels);
          }
          switch (dataType) {
            case "float":
              if (usage === 1 /* UploadOnly */ || this.isRenderFloat32Supported) {
                return new RGBAFloatDataEncoder(this.gl, channels);
              } else {
                return new RGBAFloatDataEncoder(
                  this.gl,
                  channels,
                  this.textureHalfFloatExtension.HALF_FLOAT_OES
                );
              }
            case "int":
              throw new Error("not implemented");
            case "byte":
              return new Uint8DataEncoder(this.gl, channels);
            default:
              throw new Error(`Invalid dataType: ${dataType}`);
          }
        }
        clearActiveTextures() {
          const gl = this.gl;
          for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, null);
          }
        }
        dispose() {
          if (this.disposed) {
            return;
          }
          const gl = this.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.deleteFramebuffer(this.framebuffer);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.deleteBuffer(this.vertexbuffer);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          gl.finish();
          this.disposed = true;
        }
        createDefaultGeometry() {
          return new Float32Array([
            -1,
            1,
            0,
            0,
            1,
            // upper left
            -1,
            -1,
            0,
            0,
            0,
            // lower left
            1,
            1,
            0,
            1,
            1,
            // upper right
            1,
            -1,
            0,
            1,
            0
            // lower right
          ]);
        }
        createVertexbuffer() {
          const gl = this.gl;
          const buffer = gl.createBuffer();
          if (!buffer) {
            throw new Error("createBuffer() returned null");
          }
          const geometry = this.createDefaultGeometry();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);
          this.checkError();
          return buffer;
        }
        createFramebuffer() {
          const fb = this.gl.createFramebuffer();
          if (!fb) {
            throw new Error("createFramebuffer returned null");
          }
          return fb;
        }
        queryVitalParameters() {
          const gl = this.gl;
          this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();
          this.isRenderFloat32Supported = this.checkRenderFloat32();
          this.isFloat32DownloadSupported = this.checkFloat32Download();
          if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {
            throw new Error("both float32 and float16 TextureType are not supported");
          }
          this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();
          this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          if (this.version === 2) {
          }
        }
        getExtensions() {
          if (this.version === 2) {
            this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
            this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
          } else {
            this.textureFloatExtension = this.gl.getExtension("OES_texture_float");
            this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float");
          }
        }
        checkFloatTextureAttachableToFrameBuffer() {
          const gl = this.gl;
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
          const frameBuffer = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.deleteTexture(texture);
          gl.deleteFramebuffer(frameBuffer);
          return isComplete;
        }
        checkRenderFloat32() {
          if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
              return false;
            }
          } else {
            if (!this.textureFloatExtension) {
              return false;
            }
          }
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        checkFloat32Download() {
          if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
              return false;
            }
          } else {
            if (!this.textureFloatExtension) {
              return false;
            }
            if (!this.gl.getExtension("WEBGL_color_buffer_float")) {
              return false;
            }
          }
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        /**
         * Check whether GL_BLEND is supported
         */
        checkFloat32Blend() {
          const gl = this.gl;
          let texture;
          let frameBuffer;
          let vertexShader;
          let fragmentShader;
          let program;
          try {
            texture = gl.createTexture();
            frameBuffer = gl.createFramebuffer();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.enable(gl.BLEND);
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            if (!vertexShader) {
              return false;
            }
            gl.shaderSource(vertexShader, "void main(){}");
            gl.compileShader(vertexShader);
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            if (!fragmentShader) {
              return false;
            }
            gl.shaderSource(fragmentShader, "precision highp float;void main(){gl_FragColor=vec4(0.5);}");
            gl.compileShader(fragmentShader);
            program = gl.createProgram();
            if (!program) {
              return false;
            }
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            gl.drawArrays(gl.POINTS, 0, 1);
            return gl.getError() === gl.NO_ERROR;
          } finally {
            gl.disable(gl.BLEND);
            if (program) {
              gl.deleteProgram(program);
            }
            if (vertexShader) {
              gl.deleteShader(vertexShader);
            }
            if (fragmentShader) {
              gl.deleteShader(fragmentShader);
            }
            if (frameBuffer) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.deleteFramebuffer(frameBuffer);
            }
            if (texture) {
              gl.bindTexture(gl.TEXTURE_2D, null);
              gl.deleteTexture(texture);
            }
          }
        }
        beginTimer() {
          if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            const query = gl2.createQuery();
            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
            return query;
          } else {
            throw new Error("WebGL1 profiling currently not supported.");
          }
        }
        endTimer() {
          if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            gl2.endQuery(ext.TIME_ELAPSED_EXT);
            return;
          } else {
            throw new Error("WebGL1 profiling currently not supported");
          }
        }
        isTimerResultAvailable(query) {
          let available = false, disjoint = false;
          if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);
          } else {
            throw new Error("WebGL1 profiling currently not supported");
          }
          return available && !disjoint;
        }
        getTimerResult(query) {
          let timeElapsed = 0;
          if (this.version === 2) {
            const gl2 = this.gl;
            timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            gl2.deleteQuery(query);
          } else {
            throw new Error("WebGL1 profiling currently not supported");
          }
          return timeElapsed / 1e6;
        }
        async waitForQueryAndGetTime(query) {
          await repeatedTry(() => this.isTimerResultAvailable(query));
          return this.getTimerResult(query);
        }
        async createAndWaitForFence() {
          const fenceContext = this.createFence(this.gl);
          return this.pollFence(fenceContext);
        }
        createFence(gl) {
          let isFencePassed;
          const gl2 = gl;
          const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
          gl.flush();
          if (query === null) {
            isFencePassed = () => true;
          } else {
            isFencePassed = () => {
              const status = gl2.clientWaitSync(query, 0, 0);
              return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
            };
          }
          return { query, isFencePassed };
        }
        async pollFence(fenceContext) {
          return new Promise((resolve) => {
            void this.addItemToPoll(
              () => fenceContext.isFencePassed(),
              () => resolve()
            );
          });
        }
        pollItems() {
          const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
          for (let i = 0; i <= index; ++i) {
            const { resolveFn } = this.itemsToPoll[i];
            resolveFn();
          }
          this.itemsToPoll = this.itemsToPoll.slice(index + 1);
        }
        async addItemToPoll(isDoneFn, resolveFn) {
          this.itemsToPoll.push({ isDoneFn, resolveFn });
          if (this.itemsToPoll.length > 1) {
            return;
          }
          await repeatedTry(() => {
            this.pollItems();
            return this.itemsToPoll.length === 0;
          });
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/webgl-context-factory.ts
  function createWebGLContext(contextId) {
    let context;
    if ((!contextId || contextId === "webgl2") && "webgl2" in cache) {
      context = cache.webgl2;
    } else if ((!contextId || contextId === "webgl") && "webgl" in cache) {
      context = cache.webgl;
    }
    if (!context) {
      try {
        const offscreenCanvas = createOffscreenCanvas();
        context = createNewWebGLContext(offscreenCanvas, contextId);
      } catch (e) {
        const canvas = createCanvas();
        context = createNewWebGLContext(canvas, contextId);
      }
    }
    contextId = contextId || context.version === 1 ? "webgl" : "webgl2";
    const gl = context.gl;
    cache[contextId] = context;
    if (gl.isContextLost()) {
      delete cache[contextId];
      return createWebGLContext(contextId);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return context;
  }
  function createNewWebGLContext(canvas, contextId) {
    const contextAttributes = {
      alpha: false,
      depth: false,
      antialias: false,
      stencil: false,
      preserveDrawingBuffer: false,
      premultipliedAlpha: false,
      failIfMajorPerformanceCaveat: false
    };
    let gl;
    const ca = contextAttributes;
    if (!contextId || contextId === "webgl2") {
      gl = canvas.getContext("webgl2", ca);
      if (gl) {
        try {
          return new WebGLContext(gl, 2);
        } catch (err) {
          Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);
        }
      }
    }
    if (!contextId || contextId === "webgl") {
      gl = canvas.getContext("webgl", ca) || canvas.getContext("experimental-webgl", ca);
      if (gl) {
        try {
          return new WebGLContext(gl, 1);
        } catch (err) {
          Logger.warning(
            "GlContextFactory",
            `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`
          );
        }
      }
    }
    throw new Error("WebGL is not supported");
  }
  function createCanvas() {
    if (typeof document === "undefined") {
      throw new TypeError("failed to create canvas: document is not supported");
    }
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    return canvas;
  }
  function createOffscreenCanvas() {
    if (typeof OffscreenCanvas === "undefined") {
      throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
    }
    return new OffscreenCanvas(1, 1);
  }
  var cache;
  var init_webgl_context_factory = __esm({
    "web/lib/onnxjs/backends/webgl/webgl-context-factory.ts"() {
      "use strict";
      init_instrument();
      init_webgl_context();
      cache = {};
    }
  });

  // web/lib/onnxjs/backends/backend-webgl.ts
  var WebGLBackend;
  var init_backend_webgl = __esm({
    "web/lib/onnxjs/backends/backend-webgl.ts"() {
      "use strict";
      init_esm();
      init_instrument();
      init_session_handler();
      init_webgl_context_factory();
      WebGLBackend = class {
        get contextId() {
          return env2.webgl.contextId;
        }
        set contextId(value) {
          env2.webgl.contextId = value;
        }
        get matmulMaxBatchSize() {
          return env2.webgl.matmulMaxBatchSize;
        }
        set matmulMaxBatchSize(value) {
          env2.webgl.matmulMaxBatchSize = value;
        }
        get textureCacheMode() {
          return env2.webgl.textureCacheMode;
        }
        set textureCacheMode(value) {
          env2.webgl.textureCacheMode = value;
        }
        get pack() {
          return env2.webgl.pack;
        }
        set pack(value) {
          env2.webgl.pack = value;
        }
        get async() {
          return env2.webgl.async;
        }
        set async(value) {
          env2.webgl.async = value;
        }
        initialize() {
          try {
            this.glContext = createWebGLContext(this.contextId);
            if (typeof this.matmulMaxBatchSize !== "number") {
              this.matmulMaxBatchSize = 16;
            }
            if (typeof this.textureCacheMode !== "string") {
              this.textureCacheMode = "full";
            }
            if (typeof this.pack !== "boolean") {
              this.pack = false;
            }
            if (typeof this.async !== "boolean") {
              this.async = false;
            }
            Logger.setWithEnv(env2);
            if (!env2.webgl.context) {
              Object.defineProperty(env2.webgl, "context", { value: this.glContext.gl });
            }
            Logger.verbose(
              "WebGLBackend",
              `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`
            );
            return true;
          } catch (e) {
            Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e}`);
            return false;
          }
        }
        createSessionHandler(context) {
          return new WebGLSessionHandler(this, context);
        }
        dispose() {
          this.glContext.dispose();
        }
      };
    }
  });

  // web/lib/onnxjs/backend.ts
  async function resolveBackend(hint) {
    if (!hint) {
      return resolveBackend(["webgl"]);
    } else {
      const hints = typeof hint === "string" ? [hint] : hint;
      for (const backendHint of hints) {
        const cache2 = backendsCache.get(backendHint);
        if (cache2) {
          return cache2;
        }
        const backend2 = await tryLoadBackend(backendHint);
        if (backend2) {
          return backend2;
        }
      }
    }
    throw new Error("no available backend to use");
  }
  async function tryLoadBackend(backendHint) {
    const backendObj = backend;
    if (typeof backendObj[backendHint] !== "undefined" && isBackend(backendObj[backendHint])) {
      const backend2 = backendObj[backendHint];
      let init = backend2.initialize();
      if (typeof init === "object" && "then" in init) {
        init = await init;
      }
      if (init) {
        backendsCache.set(backendHint, backend2);
        return backend2;
      }
    }
    return void 0;
  }
  function isBackend(obj) {
    const o = obj;
    if ("initialize" in o && typeof o.initialize === "function" && // initialize()
    "createSessionHandler" in o && typeof o.createSessionHandler === "function" && // createSessionHandler()
    "dispose" in o && typeof o.dispose === "function") {
      return true;
    }
    return false;
  }
  var backendsCache, backend;
  var init_backend2 = __esm({
    "web/lib/onnxjs/backend.ts"() {
      "use strict";
      init_backend_webgl();
      backendsCache = /* @__PURE__ */ new Map();
      backend = {
        webgl: new WebGLBackend()
      };
    }
  });

  // web/lib/onnxjs/execution-plan.ts
  var KernelOp, ExecutionPlan;
  var init_execution_plan = __esm({
    "web/lib/onnxjs/execution-plan.ts"() {
      "use strict";
      init_instrument();
      KernelOp = class {
        constructor(op, node) {
          this.op = op;
          this.node = node;
        }
      };
      ExecutionPlan = class {
        constructor(graph, ops, profiler) {
          this.graph = graph;
          this.profiler = profiler;
          this.initialize(ops);
        }
        initialize(ops) {
          this.profiler.event("session", "ExecutionPlan.initialize", () => {
            const graphNodes = this.graph.getNodes();
            if (graphNodes.length !== ops.length) {
              throw new Error("The size of nodes and OPs do not match.");
            }
            this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));
            this.reset();
            this._starter = [];
            this._ops.forEach((op, i) => {
              let resolved = true;
              for (const input of op.node.inputs) {
                if (!this._values[input] && // not an initialized input
                this.graph.getInputIndices().indexOf(input) === -1) {
                  resolved = false;
                  break;
                }
              }
              if (resolved) {
                this._starter.push(i);
              }
            });
          });
        }
        reset() {
          this._values = this.graph.getValues().map((i) => i.tensor);
        }
        async execute(sessionHandler, modelInputs) {
          return this.profiler.event("session", "ExecutionPlan.execute", async () => {
            this.reset();
            const inferenceHandler = sessionHandler.createInferenceHandler();
            const graphInputs = this.graph.getInputIndices();
            if (modelInputs.length !== graphInputs.length) {
              throw new Error(
                `number of input tensors don't match the number of inputs to the model: actual: ${modelInputs.length} expected: ${graphInputs.length}`
              );
            }
            modelInputs.forEach((input, i) => {
              const index = graphInputs[i];
              this._values[index] = input;
            });
            const sequence = this._starter.slice(0);
            const graphValues = this.graph.getValues();
            const graphNodes = this.graph.getNodes();
            let rear = 0;
            while (rear < sequence.length) {
              const thisOpIndex = sequence[rear++];
              const thisOp = this._ops[thisOpIndex];
              const inputList = thisOp.node.inputs.map((i) => this._values[i]);
              if (inputList.indexOf(void 0) !== -1) {
                throw new Error(`unresolved input detected: op: ${thisOp.node}`);
              }
              const inputTensors = inputList;
              Logger.verbose(
                "ExecPlan",
                `Running op:${thisOp.node.name} (${inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(",")}]`).join(", ")})`
              );
              const outputList = await this.profiler.event(
                "node",
                thisOp.node.name,
                async () => thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context)
              );
              if (outputList.length !== thisOp.node.outputs.length) {
                throw new Error("the size of output does not match model definition.");
              }
              outputList.forEach((output2, i) => {
                const j = thisOp.node.outputs[i];
                if (this._values[j]) {
                  throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);
                }
                this._values[j] = output2;
              });
              const downstreamNodes = /* @__PURE__ */ new Set();
              outputList.forEach((_output, i) => {
                const j = thisOp.node.outputs[i];
                for (const currentDownstreamNodeIndex of graphValues[j].to) {
                  const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];
                  let resolved = true;
                  for (const k of currentDownstreamNode.inputs) {
                    if (!this._values[k]) {
                      resolved = false;
                      break;
                    }
                  }
                  if (resolved) {
                    downstreamNodes.add(currentDownstreamNodeIndex);
                  }
                }
              });
              sequence.push(...downstreamNodes);
            }
            const output = [];
            for (let i = 0; i < this.graph.getOutputIndices().length; i++) {
              const outputIndex = this.graph.getOutputIndices()[i];
              const outputTensor = this._values[outputIndex];
              if (outputTensor === void 0) {
                throw new Error(`required output [${outputIndex}] does not have value`);
              }
              if (outputIndex === 0) {
                await outputTensor.getData();
              } else {
                outputTensor.data;
              }
              output.push(outputTensor);
            }
            Logger.verbose("ExecPlan", "disposing of inferenceHandler");
            inferenceHandler.dispose();
            return output;
          });
        }
      };
    }
  });

  // web/lib/onnxjs/attribute.ts
  var import_onnx3, ortFbs2, Attribute;
  var init_attribute = __esm({
    "web/lib/onnxjs/attribute.ts"() {
      "use strict";
      init_ort_generated();
      import_onnx3 = __toESM(require_onnx());
      init_tensor2();
      init_util();
      ortFbs2 = onnxruntime.experimental.fbs;
      Attribute = class _Attribute {
        constructor(attributes) {
          this._attributes = /* @__PURE__ */ new Map();
          if (attributes !== null && attributes !== void 0) {
            for (const attr of attributes) {
              if (attr instanceof import_onnx3.onnx.AttributeProto) {
                this._attributes.set(attr.name, [_Attribute.getValue(attr), _Attribute.getType(attr)]);
              } else if (attr instanceof ortFbs2.Attribute) {
                this._attributes.set(attr.name(), [_Attribute.getValue(attr), _Attribute.getType(attr)]);
              }
            }
            if (this._attributes.size < attributes.length) {
              throw new Error("duplicated attribute names");
            }
          }
        }
        set(key, type, value) {
          this._attributes.set(key, [value, type]);
        }
        delete(key) {
          this._attributes.delete(key);
        }
        getFloat(key, defaultValue) {
          return this.get(key, "float", defaultValue);
        }
        getInt(key, defaultValue) {
          return this.get(key, "int", defaultValue);
        }
        getString(key, defaultValue) {
          return this.get(key, "string", defaultValue);
        }
        getTensor(key, defaultValue) {
          return this.get(key, "tensor", defaultValue);
        }
        getFloats(key, defaultValue) {
          return this.get(key, "floats", defaultValue);
        }
        getInts(key, defaultValue) {
          return this.get(key, "ints", defaultValue);
        }
        getStrings(key, defaultValue) {
          return this.get(key, "strings", defaultValue);
        }
        getTensors(key, defaultValue) {
          return this.get(key, "tensors", defaultValue);
        }
        get(key, type, defaultValue) {
          const valueAndType = this._attributes.get(key);
          if (valueAndType === void 0) {
            if (defaultValue !== void 0) {
              return defaultValue;
            }
            throw new Error(`required attribute not found: ${key}`);
          }
          if (valueAndType[1] !== type) {
            throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);
          }
          return valueAndType[0];
        }
        static getType(attr) {
          const type = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
          switch (type) {
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
              return "float";
            case import_onnx3.onnx.AttributeProto.AttributeType.INT:
              return "int";
            case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
              return "string";
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
              return "tensor";
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
              return "floats";
            case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
              return "ints";
            case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
              return "strings";
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
              return "tensors";
            default:
              throw new Error(`attribute type is not supported yet: ${import_onnx3.onnx.AttributeProto.AttributeType[type]}`);
          }
        }
        static getValue(attr) {
          const attrType = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPH || attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS) {
            throw new Error("graph attribute is not supported yet");
          }
          const value = this.getValueNoCheck(attr);
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {
            return LongUtil.longToNumber(value);
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INTS) {
            const arr = value;
            const numberValue = new Array(arr.length);
            for (let i = 0; i < arr.length; i++) {
              const maybeLong = arr[i];
              numberValue[i] = LongUtil.longToNumber(maybeLong);
            }
            return numberValue;
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSOR) {
            return attr instanceof import_onnx3.onnx.AttributeProto ? Tensor3.fromProto(value) : Tensor3.fromOrtTensor(value);
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSORS) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              const tensorProtos = value;
              return tensorProtos.map((value2) => Tensor3.fromProto(value2));
            } else if (attr instanceof ortFbs2.Attribute) {
              const tensorProtos = value;
              return tensorProtos.map((value2) => Tensor3.fromOrtTensor(value2));
            }
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRING) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              const utf8String = value;
              return decodeUtf8String(utf8String);
            }
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRINGS) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              const utf8Strings = value;
              return utf8Strings.map(decodeUtf8String);
            }
          }
          return value;
        }
        static getValueNoCheck(attr) {
          return attr instanceof import_onnx3.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(attr) : this.getValueNoCheckFromOrtFormat(attr);
        }
        static getValueNoCheckFromOnnxFormat(attr) {
          switch (attr.type) {
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
              return attr.f;
            case import_onnx3.onnx.AttributeProto.AttributeType.INT:
              return attr.i;
            case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
              return attr.s;
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
              return attr.t;
            case import_onnx3.onnx.AttributeProto.AttributeType.GRAPH:
              return attr.g;
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
              return attr.floats;
            case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
              return attr.ints;
            case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
              return attr.strings;
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
              return attr.tensors;
            case import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS:
              return attr.graphs;
            default:
              throw new Error(`unsupported attribute type: ${import_onnx3.onnx.AttributeProto.AttributeType[attr.type]}`);
          }
        }
        static getValueNoCheckFromOrtFormat(attr) {
          switch (attr.type()) {
            case ortFbs2.AttributeType.FLOAT:
              return attr.f();
            case ortFbs2.AttributeType.INT:
              return attr.i();
            case ortFbs2.AttributeType.STRING:
              return attr.s();
            case ortFbs2.AttributeType.TENSOR:
              return attr.t();
            case ortFbs2.AttributeType.GRAPH:
              return attr.g();
            case ortFbs2.AttributeType.FLOATS:
              return attr.floatsArray();
            case ortFbs2.AttributeType.INTS: {
              const ints = [];
              for (let i = 0; i < attr.intsLength(); i++) {
                ints.push(attr.ints(i));
              }
              return ints;
            }
            case ortFbs2.AttributeType.STRINGS: {
              const strings = [];
              for (let i = 0; i < attr.stringsLength(); i++) {
                strings.push(attr.strings(i));
              }
              return strings;
            }
            case ortFbs2.AttributeType.TENSORS: {
              const tensors = [];
              for (let i = 0; i < attr.tensorsLength(); i++) {
                tensors.push(attr.tensors(i));
              }
              return tensors;
            }
            default:
              throw new Error(`unsupported attribute type: ${ortFbs2.AttributeType[attr.type()]}`);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/graph.ts
  var import_onnx4, ortFbs3, Graph, Value, Node, GraphImpl;
  var init_graph = __esm({
    "web/lib/onnxjs/graph.ts"() {
      "use strict";
      init_attribute();
      init_ort_generated();
      import_onnx4 = __toESM(require_onnx());
      init_tensor2();
      init_util();
      ortFbs3 = onnxruntime.experimental.fbs;
      Graph = {
        /**
         * construct a graph from a graph protobuf type
         */
        from: (graphProto, initializer) => new GraphImpl(graphProto, initializer)
      };
      Value = class {
        constructor(valueInfo) {
          this._from = void 0;
          this._to = [];
          this.tensor = void 0;
          this.type = void 0;
          if (valueInfo) {
            this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType);
          }
        }
        // -1 represent from initializer
        get from() {
          return this._from;
        }
        get to() {
          return this._to;
        }
      };
      Node = class {
        constructor(_nodeProto, name2) {
          if (_nodeProto instanceof import_onnx4.onnx.NodeProto) {
            this.name = _nodeProto.name;
            this.opType = _nodeProto.opType;
            this.attributes = new Attribute(_nodeProto.attribute);
          } else if (_nodeProto instanceof ortFbs3.Node) {
            this.name = name2 ?? _nodeProto.name();
            this.opType = _nodeProto.opType();
            this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));
          }
          this.inputs = [];
          this.outputs = [];
          this.executeNode = true;
        }
      };
      GraphImpl = class {
        constructor(graph, graphInitializer) {
          if (!graph) {
            throw new TypeError("graph is empty");
          }
          this.buildGraph(graph);
          this.transformGraph(graphInitializer);
          this.checkIsAcyclic();
        }
        getInputIndices() {
          return this._allInputIndices;
        }
        getInputNames() {
          return this._allInputNames;
        }
        getOutputIndices() {
          return this._allOutputIndices;
        }
        getOutputNames() {
          return this._allOutputNames;
        }
        getValues() {
          return this._allData;
        }
        getNodes() {
          return this._nodes;
        }
        buildGraph(graph) {
          if (graph instanceof import_onnx4.onnx.GraphProto) {
            this.buildGraphFromOnnxFormat(graph);
          } else if (graph instanceof ortFbs3.Graph) {
            this.buildGraphFromOrtFormat(graph);
          } else {
            throw new TypeError("Graph type is not supported.");
          }
        }
        buildGraphFromOnnxFormat(graph) {
          const dataIndices = /* @__PURE__ */ new Map();
          this._allData = [];
          this._allInputIndices = [];
          this._allInputNames = [];
          this._allOutputIndices = [];
          this._allOutputNames = [];
          this._nodes = [];
          const nodesIndices = /* @__PURE__ */ new Map();
          if (!graph.input) {
            throw new Error("missing information in graph: input");
          }
          const inputValueNames = [];
          for (const i of graph.input) {
            if (dataIndices.has(i.name)) {
              throw new Error(`duplicated input name: ${i.name}`);
            }
            const currentIndex = this._allData.push(new Value(i)) - 1;
            dataIndices.set(i.name, currentIndex);
            inputValueNames.push(i.name);
          }
          if (!graph.initializer) {
            throw new Error("missing information in graph: initializer");
          }
          for (const i of graph.initializer) {
            let index = dataIndices.get(i.name);
            if (index === void 0) {
              const value = new Value();
              value.type = {
                shape: { dims: ProtoUtil.tensorDimsFromProto(i.dims) },
                tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType)
              };
              index = this._allData.push(value) - 1;
              dataIndices.set(i.name, index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = Tensor3.fromProto(i);
          }
          for (let i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
              this._allInputIndices.push(i);
              this._allInputNames.push(inputValueNames[i]);
            }
          }
          if (!graph.output) {
            throw new Error("missing information in graph: output");
          }
          for (const i of graph.output) {
            if (dataIndices.has(i.name)) {
              throw new Error(`duplicated output name: ${i.name}`);
            }
            const currentIndex = this._allData.push(new Value(i)) - 1;
            dataIndices.set(i.name, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(i.name);
          }
          if (!graph.node) {
            throw new Error("missing information in graph: node");
          }
          for (const nodeProto of graph.node) {
            if (!nodeProto.name) {
              for (let pick = 0; ; pick++) {
                const name2 = `unnamed_${nodeProto.opType}_${pick}`;
                if (!nodesIndices.has(name2)) {
                  nodeProto.name = name2;
                  break;
                }
              }
            }
            if (nodesIndices.has(nodeProto.name)) {
              throw new Error(`duplicated node name: ${nodeProto.name}`);
            }
            const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;
            nodesIndices.set(nodeProto.name, currentIndex);
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.node[i];
            if (!nodeProto.output) {
              throw new Error(`missing output for node: ${nodeProto.name}`);
            }
            for (const output of nodeProto.output) {
              let dataIndex = dataIndices.get(output);
              if (typeof dataIndex === "undefined") {
                dataIndex = this._allData.push(new Value()) - 1;
                dataIndices.set(output, dataIndex);
              }
              node.outputs.push(dataIndex);
              if (this._allData[dataIndex]._from !== void 0) {
                throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
              }
              this._allData[dataIndex]._from = i;
              if (nodeProto.opType === "Constant") {
                if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {
                  throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                }
                if (!nodeProto.output || nodeProto.output.length !== 1) {
                  throw new Error("missing output or incorrect number of outputs for this Constant operator");
                }
                node.outputs.pop();
                node.executeNode = false;
                this._allData[dataIndex]._from = -1;
                this._allData[dataIndex].tensor = Tensor3.fromProto(nodeProto.attribute[0].t);
              }
            }
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.node[i];
            if (!nodeProto.input) {
              throw new Error(`missing input for node: ${nodeProto.name}`);
            }
            for (const input of nodeProto.input) {
              const dataIndex = dataIndices.get(input);
              if (typeof dataIndex === "undefined") {
                if (input === "" && (nodeProto.input.length === 3 || nodeProto.input.length === 4) && nodeProto.opType === "Resize") {
                  continue;
                }
                throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);
              }
              node.inputs.push(dataIndex);
              this._allData[dataIndex]._to.push(i);
            }
          }
          return true;
        }
        buildGraphFromOrtFormat(graph) {
          const dataIndices = /* @__PURE__ */ new Map();
          this._allData = [];
          this._allInputIndices = [];
          this._allInputNames = [];
          this._allOutputIndices = [];
          this._allOutputNames = [];
          this._nodes = [];
          const nodesIndices = /* @__PURE__ */ new Map();
          const inputValueNames = [];
          for (let i = 0; i < graph.inputsLength(); i++) {
            const inputName = graph.inputs(i);
            if (dataIndices.has(inputName)) {
              throw new Error(`duplicated input name: ${inputName}`);
            }
            for (let j = 0; j < graph.nodeArgsLength(); j++) {
              if (graph.nodeArgs(j)?.name() === inputName) {
                const value = new Value();
                const valueType = graph.nodeArgs(j)?.type()?.valueType();
                if (valueType !== ortFbs3.TypeInfoValue.tensor_type) {
                  throw new Error("Unexpected value type for the nodeArg.");
                }
                const valueInfo = graph.nodeArgs(j).type().value(new ortFbs3.TensorTypeAndShape());
                const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());
                const shape2 = valueInfo.shape();
                const dims = [];
                for (let k = 0; k < shape2.dimLength(); k++) {
                  dims.push(LongUtil.longToNumber(shape2.dim(k).value().dimValue()));
                }
                value.type = { shape: { dims }, tensorType: type };
                const currentIndex = this._allData.push(value) - 1;
                dataIndices.set(inputName, currentIndex);
                inputValueNames.push(inputName);
              }
            }
          }
          for (let i = 0; i < graph.initializersLength(); i++) {
            const initializer = graph.initializers(i);
            let index = dataIndices.get(initializer.name());
            if (index === void 0) {
              const value = new Value();
              const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);
              const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());
              value.type = { shape: { dims }, tensorType: type };
              index = this._allData.push(value) - 1;
              dataIndices.set(initializer.name(), index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = Tensor3.fromOrtTensor(initializer);
          }
          for (let i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
              this._allInputIndices.push(i);
              this._allInputNames.push(inputValueNames[i]);
            }
          }
          for (let i = 0; i < graph.outputsLength(); i++) {
            const outputName = graph.outputs(i);
            if (dataIndices.has(outputName)) {
              throw new Error(`duplicated output name: ${outputName}`);
            }
            const currentIndex = this._allData.push(new Value()) - 1;
            dataIndices.set(outputName, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(outputName);
          }
          if (!graph.nodes) {
            throw new Error("missing information in graph: node");
          }
          for (let i = 0; i < graph.nodesLength(); i++) {
            const nodeProto = graph.nodes(i);
            let name2 = nodeProto.name();
            if (!name2) {
              for (let pick = 0; ; pick++) {
                name2 = `unnamed_${nodeProto.opType()}_${pick}`;
                if (!nodesIndices.has(name2)) {
                  break;
                }
              }
            }
            if (nodesIndices.has(name2)) {
              throw new Error(`duplicated node name: ${name2}`);
            }
            const currentIndex = this._nodes.push(new Node(nodeProto, name2)) - 1;
            nodesIndices.set(name2, currentIndex);
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.nodes(i);
            if (nodeProto == null) {
              throw new Error(`No node exists at index ${i}`);
            }
            if (nodeProto?.outputsLength() === 0) {
              throw new Error(`missing output for node: ${nodeProto.name}`);
            }
            for (let j = 0; j < nodeProto?.outputsLength(); j++) {
              const output = nodeProto?.outputs(j);
              let dataIndex = dataIndices.get(output);
              if (typeof dataIndex === "undefined") {
                dataIndex = this._allData.push(new Value()) - 1;
                dataIndices.set(output, dataIndex);
              }
              node.outputs.push(dataIndex);
              if (this._allData[dataIndex]._from !== void 0) {
                throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
              }
              this._allData[dataIndex]._from = i;
              if (nodeProto.opType() === "Constant") {
                if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0).t()) {
                  throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                }
                if (nodeProto.outputsLength() !== 1) {
                  throw new Error("missing output or incorrect number of outputs for this Constant operator");
                }
                node.outputs.pop();
                node.executeNode = false;
                this._allData[dataIndex]._from = -1;
                this._allData[dataIndex].tensor = Tensor3.fromOrtTensor(nodeProto.attributes(0).t());
              }
            }
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.nodes(i);
            if (nodeProto.inputsLength() === 0) {
              throw new Error(`missing input for node: ${nodeProto.name}`);
            }
            for (let j = 0; j < nodeProto.inputsLength(); j++) {
              const input = nodeProto.inputs(j);
              const dataIndex = dataIndices.get(input);
              if (typeof dataIndex === "undefined") {
                throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name()}`);
              }
              node.inputs.push(dataIndex);
              this._allData[dataIndex]._to.push(i);
            }
          }
        }
        checkIsAcyclic() {
          const starters = /* @__PURE__ */ new Set();
          this._allInputIndices.forEach((i) => {
            const data = this._allData[i];
            data._to.forEach((j) => {
              starters.add(j);
            });
          });
          const nodesStack = Array.from(starters);
          const nodesState = new Array(this._nodes.length).fill("white");
          while (nodesStack.length > 0) {
            const nodeIndex = nodesStack.pop();
            if (nodesState[nodeIndex] === "gray") {
              nodesState[nodeIndex] = "black";
            } else {
              nodesStack.push(nodeIndex);
              nodesState[nodeIndex] = "gray";
              this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {
                const data = this._allData[outgoingEdgeIndex];
                if (typeof data.tensor !== "undefined") {
                  throw new Error("node outputs should not be initialized");
                }
                if (data._from !== nodeIndex) {
                  throw new Error("from property of the Value object doesn't match index of Node being processed");
                }
                data._to.forEach((downstreamNodeIndex) => {
                  if (nodesState[downstreamNodeIndex] === "gray") {
                    throw new Error("model graph is cyclic");
                  } else if (nodesState[downstreamNodeIndex] === "white") {
                    nodesStack.push(downstreamNodeIndex);
                  }
                });
              });
            }
          }
        }
        transformGraph(graphInitializer) {
          this.removeAllIdentityNodes();
          this.removeAllDropoutNodes();
          this.fuseConvActivationNodes();
          if (graphInitializer) {
            graphInitializer.transformGraph(this);
          }
          this.finalizeGraph();
        }
        /**
         * finalize the graph.
         *
         * this function should be called after all the transformation completed.
         * this function removes all unnecessary nodes and values from the graph
         */
        finalizeGraph() {
          let offset = 0;
          const newIndices = new Array(this._nodes.length, 0);
          let nodePossition = 0;
          for (let i = 0; i < this._nodes.length; i++) {
            newIndices[i] = nodePossition;
            if (this._nodes[i].executeNode) {
              if (nodePossition !== i) {
                this._nodes[nodePossition] = this._nodes[i];
              }
              nodePossition++;
            } else {
              this._nodes[i].outputs.forEach((ind) => {
                this._allData[ind]._from = -2;
              });
            }
          }
          this._nodes.splice(nodePossition, this._nodes.length - nodePossition);
          for (let i = 0; i < this._allData.length; i++) {
            const currentData = this._allData[i];
            if (currentData._from !== void 0 && currentData._from !== -1 && currentData._from !== -2) {
              currentData._from = newIndices[currentData._from];
            }
            for (let j = 0; j < currentData._to.length; j++) {
              if (currentData._to[j] >= 0) {
                currentData._to[j] = newIndices[currentData._to[j]];
              } else {
                throw new Error("Trying to update a removed node");
              }
            }
          }
          offset = 0;
          for (let i = 0; i < this._allData.length; i++) {
            if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {
              offset++;
              this._allData.splice(i, 1);
              i--;
              continue;
            }
            if (offset > 0) {
              let ind = -1;
              if (this._allData[i].from !== void 0 && this._allData[i].from !== -1) {
                ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);
                if (ind !== -1) {
                  this._nodes[this._allData[i].from].outputs[ind] = i;
                }
              } else {
                ind = this._allInputIndices.indexOf(i + offset);
                if (ind !== -1) {
                  this._allInputIndices[ind] = i;
                }
              }
              this._allData[i].to.forEach((node) => {
                ind = this._nodes[node].inputs.indexOf(i + offset);
                if (ind !== -1) {
                  this._nodes[node].inputs[ind] = i;
                }
              });
              if (this._allData[i].to.length === 0) {
                ind = this._allOutputIndices.indexOf(i + offset);
                if (ind !== -1) {
                  this._allOutputIndices[ind] = i;
                }
              }
            }
          }
        }
        /**
         * Delete the specified node. Assume the node has one incoming input and the first output connected to other nodes.
         * An input validation must be done before calling this function.
         * @param nodeIndex The index of node to be deleted
         */
        deleteNode(nodeIndex) {
          const node = this._nodes[nodeIndex];
          if (node.outputs.length > 1) {
            for (let i = 1; i < node.outputs.length; i++) {
              if (this._allData[node.outputs[i]].to.length > 0) {
                throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
              }
            }
          }
          node.executeNode = false;
          const inputValueIndex = node.inputs[0];
          const outputValueIndex = node.outputs[0];
          const nodesConsumingOutput = this._allData[outputValueIndex].to;
          for (let i = 0; i < node.inputs.length; i++) {
            const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);
            if (delIndex === -1) {
              throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
            }
            this._allData[node.inputs[i]].to.splice(delIndex, 1);
          }
          this._allData[outputValueIndex]._to = [];
          const index = this._allOutputIndices.indexOf(outputValueIndex);
          if (index !== -1) {
            this._allOutputIndices[index] = inputValueIndex;
          }
          if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {
            for (const nodeIndex2 of nodesConsumingOutput) {
              const replaceIndex = this._nodes[nodeIndex2].inputs.indexOf(outputValueIndex);
              if (replaceIndex === -1) {
                throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
              }
              this._nodes[nodeIndex2].inputs[replaceIndex] = inputValueIndex;
              this._allData[inputValueIndex].to.push(nodeIndex2);
            }
          }
        }
        removeAllDropoutNodes() {
          let nodeIndex = 0;
          for (const node of this._nodes) {
            if (node.opType === "Dropout") {
              if (node.inputs.length !== 1) {
                throw new Error("Dropout nodes should only contain one input. ");
              }
              if (node.outputs.length !== 1 && node.outputs.length !== 2) {
                throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
              }
              if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {
                throw new Error("Dropout nodes's second output should not be referenced by other nodes");
              }
              this.deleteNode(nodeIndex);
            }
            nodeIndex++;
          }
        }
        removeAllIdentityNodes() {
          let nodeIndex = 0;
          for (const node of this._nodes) {
            if (node.opType === "Identity") {
              this.deleteNode(nodeIndex);
            }
            nodeIndex++;
          }
        }
        isActivation(n) {
          switch (n.opType) {
            case "Relu":
            case "Sigmoid":
            case "Clip":
              return true;
            default:
              return false;
          }
        }
        fuseConvActivationNodes() {
          for (const node of this._nodes) {
            if (node.opType === "Conv") {
              const next = this._allData[node.outputs[0]]._to;
              if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {
                const child = this._nodes[next[0]];
                if (child.opType === "Clip") {
                  if (child.inputs.length === 1) {
                    try {
                      node.attributes.set("activation_params", "floats", [
                        child.attributes.getFloat("min"),
                        child.attributes.getFloat("max")
                      ]);
                    } catch (e) {
                      node.attributes.set("activation_params", "floats", [MIN_CLIP, MAX_CLIP]);
                    }
                  } else if (child.inputs.length >= 3 && this._allData[child.inputs[1]].tensor !== void 0 && this._allData[child.inputs[2]].tensor !== void 0) {
                    node.attributes.set("activation_params", "floats", [
                      this._allData[child.inputs[1]].tensor.floatData[0],
                      this._allData[child.inputs[2]].tensor.floatData[0]
                    ]);
                  } else {
                    continue;
                  }
                }
                node.attributes.set("activation", "string", child.opType);
                this.deleteNode(next[0]);
              }
            }
          }
        }
      };
    }
  });

  // web/lib/onnxjs/model.ts
  var import_onnx5, ortFbs4, Model;
  var init_model = __esm({
    "web/lib/onnxjs/model.ts"() {
      "use strict";
      init_flatbuffers();
      init_graph();
      init_ort_generated();
      import_onnx5 = __toESM(require_onnx());
      init_util();
      ortFbs4 = onnxruntime.experimental.fbs;
      Model = class {
        // empty model
        constructor() {
        }
        load(buf, graphInitializer, isOrtFormat) {
          let onnxError;
          if (!isOrtFormat) {
            try {
              this.loadFromOnnxFormat(buf, graphInitializer);
              return;
            } catch (e) {
              if (isOrtFormat !== void 0) {
                throw e;
              }
              onnxError = e;
            }
          }
          try {
            this.loadFromOrtFormat(buf, graphInitializer);
          } catch (e) {
            if (isOrtFormat !== void 0) {
              throw e;
            }
            throw new Error(`Failed to load model as ONNX format: ${onnxError}
as ORT format: ${e}`);
          }
        }
        loadFromOnnxFormat(buf, graphInitializer) {
          const modelProto = import_onnx5.onnx.ModelProto.decode(buf);
          const irVersion = LongUtil.longToNumber(modelProto.irVersion);
          if (irVersion < 3) {
            throw new Error("only support ONNX model with IR_VERSION>=3");
          }
          this._opsets = modelProto.opsetImport.map((i) => ({
            domain: i.domain,
            version: LongUtil.longToNumber(i.version)
          }));
          this._graph = Graph.from(modelProto.graph, graphInitializer);
        }
        loadFromOrtFormat(buf, graphInitializer) {
          const fb = new flatbuffers.ByteBuffer(buf);
          const ortModel = ortFbs4.InferenceSession.getRootAsInferenceSession(fb).model();
          const irVersion = LongUtil.longToNumber(ortModel.irVersion());
          if (irVersion < 3) {
            throw new Error("only support ONNX model with IR_VERSION>=3");
          }
          this._opsets = [];
          for (let i = 0; i < ortModel.opsetImportLength(); i++) {
            const opsetId = ortModel.opsetImport(i);
            this._opsets.push({ domain: opsetId?.domain(), version: LongUtil.longToNumber(opsetId.version()) });
          }
          this._graph = Graph.from(ortModel.graph(), graphInitializer);
        }
        get graph() {
          return this._graph;
        }
        get opsets() {
          return this._opsets;
        }
      };
    }
  });

  // web/lib/onnxjs/session.ts
  var Session;
  var init_session = __esm({
    "web/lib/onnxjs/session.ts"() {
      "use strict";
      init_backend2();
      init_execution_plan();
      init_instrument();
      init_model();
      Session = class {
        constructor(config = {}) {
          this._initialized = false;
          this.backendHint = config.backendHint;
          this.profiler = Profiler.create(config.profiler);
          this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
        }
        get inputNames() {
          return this._model.graph.getInputNames();
        }
        get outputNames() {
          return this._model.graph.getOutputNames();
        }
        startProfiling() {
          this.profiler.start();
        }
        endProfiling() {
          this.profiler.stop();
        }
        async loadModel(arg, byteOffset, length) {
          await this.profiler.event("session", "Session.loadModel", async () => {
            const backend2 = await resolveBackend(this.backendHint);
            this.sessionHandler = backend2.createSessionHandler(this.context);
            this._model = new Model();
            if (typeof arg === "string") {
              const isOrtFormat = arg.endsWith(".ort");
              if (false) {
                const { readFile } = null;
                const buf = await readFile(arg);
                this.initialize(buf, isOrtFormat);
              } else {
                const response = await fetch(arg);
                const buf = await response.arrayBuffer();
                this.initialize(new Uint8Array(buf), isOrtFormat);
              }
            } else if (!ArrayBuffer.isView(arg)) {
              const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
              this.initialize(arr);
            } else {
              this.initialize(arg);
            }
          });
        }
        initialize(modelProtoBlob, isOrtFormat) {
          if (this._initialized) {
            throw new Error("already initialized");
          }
          this.profiler.event("session", "Session.initialize", () => {
            const graphInitializer = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
            this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);
            if (this.sessionHandler.onGraphInitialized) {
              this.sessionHandler.onGraphInitialized(this._model.graph);
            }
            this.initializeOps(this._model.graph);
            this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);
          });
          this._initialized = true;
        }
        async run(inputs) {
          if (!this._initialized) {
            throw new Error("session not initialized yet");
          }
          return this.profiler.event("session", "Session.run", async () => {
            const inputTensors = this.normalizeAndValidateInputs(inputs);
            const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);
            return this.createOutput(outputTensors);
          });
        }
        normalizeAndValidateInputs(inputs) {
          const modelInputNames = this._model.graph.getInputNames();
          if (Array.isArray(inputs)) {
            if (inputs.length !== modelInputNames.length) {
              throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);
            }
          } else {
            if (inputs.size !== modelInputNames.length) {
              throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);
            }
            const sortedInputs = new Array(inputs.size);
            let sortedInputsIndex = 0;
            for (let i = 0; i < modelInputNames.length; ++i) {
              const tensor = inputs.get(modelInputNames[i]);
              if (!tensor) {
                throw new Error(`missing input tensor for: '${name}'`);
              }
              sortedInputs[sortedInputsIndex++] = tensor;
            }
            inputs = sortedInputs;
          }
          if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {
            const modelInputIndices = this._model.graph.getInputIndices();
            const modelValues = this._model.graph.getValues();
            const graphInputDims = new Array(modelInputIndices.length);
            for (let i = 0; i < modelInputIndices.length; ++i) {
              const graphInput = modelValues[modelInputIndices[i]];
              graphInputDims[i] = graphInput.type.shape.dims;
              this.context.graphInputTypes.push(graphInput.type.tensorType);
              this.context.graphInputDims.push(inputs[i].dims);
            }
            this.validateInputTensorDims(graphInputDims, inputs, true);
          } else {
            this.validateInputTensorDims(this.context.graphInputDims, inputs, false);
          }
          this.validateInputTensorTypes(this.context.graphInputTypes, inputs);
          return inputs;
        }
        validateInputTensorTypes(graphInputTypes, givenInputs) {
          for (let i = 0; i < givenInputs.length; i++) {
            const expectedType = graphInputTypes[i];
            const actualType = givenInputs[i].type;
            if (expectedType !== actualType) {
              throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);
            }
          }
        }
        validateInputTensorDims(graphInputDims, givenInputs, noneDimSupported) {
          for (let i = 0; i < givenInputs.length; i++) {
            const expectedDims = graphInputDims[i];
            const actualDims = givenInputs[i].dims;
            if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {
              throw new Error(
                `input tensor[${i}] check failed: expected shape '[${expectedDims.join(",")}]' but got [${actualDims.join(
                  ","
                )}]`
              );
            }
          }
        }
        compareTensorDims(expectedDims, actualDims, noneDimSupported) {
          if (expectedDims.length !== actualDims.length) {
            return false;
          }
          for (let i = 0; i < expectedDims.length; ++i) {
            if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {
              return false;
            }
          }
          return true;
        }
        createOutput(outputTensors) {
          const modelOutputNames = this._model.graph.getOutputNames();
          if (outputTensors.length !== modelOutputNames.length) {
            throw new Error("expected number of outputs do not match number of generated outputs");
          }
          const output = /* @__PURE__ */ new Map();
          for (let i = 0; i < modelOutputNames.length; ++i) {
            output.set(modelOutputNames[i], outputTensors[i]);
          }
          return output;
        }
        initializeOps(graph) {
          const nodes = graph.getNodes();
          this._ops = new Array(nodes.length);
          for (let i = 0; i < nodes.length; i++) {
            this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/session-handler-inference.ts
  var OnnxjsSessionHandler;
  var init_session_handler_inference = __esm({
    "web/lib/onnxjs/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_tensor2();
      OnnxjsSessionHandler = class {
        constructor(session) {
          this.session = session;
          this.inputNames = this.session.inputNames;
          this.outputNames = this.session.outputNames;
        }
        async dispose() {
        }
        async run(feeds, _fetches, _options) {
          const inputMap = /* @__PURE__ */ new Map();
          for (const name2 in feeds) {
            if (Object.hasOwnProperty.call(feeds, name2)) {
              const feed = feeds[name2];
              inputMap.set(
                name2,
                new Tensor3(
                  feed.dims,
                  feed.type,
                  void 0,
                  void 0,
                  feed.data
                )
              );
            }
          }
          const outputMap = await this.session.run(inputMap);
          const output = {};
          outputMap.forEach((tensor, name2) => {
            output[name2] = new Tensor2(tensor.type, tensor.data, tensor.dims);
          });
          return output;
        }
        startProfiling() {
          this.session.startProfiling();
        }
        endProfiling() {
          this.session.endProfiling();
        }
      };
    }
  });

  // web/lib/backend-onnxjs.ts
  var backend_onnxjs_exports = {};
  __export(backend_onnxjs_exports, {
    onnxjsBackend: () => onnxjsBackend
  });
  var OnnxjsBackend, onnxjsBackend;
  var init_backend_onnxjs = __esm({
    "web/lib/backend-onnxjs.ts"() {
      "use strict";
      init_session();
      init_session_handler_inference();
      OnnxjsBackend = class {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        async init() {
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const session = new Session(options);
          if (typeof pathOrBuffer === "string") {
            await session.loadModel(pathOrBuffer);
          } else {
            await session.loadModel(pathOrBuffer);
          }
          return new OnnxjsSessionHandler(session);
        }
      };
      onnxjsBackend = new OnnxjsBackend();
    }
  });

  // web/lib/wasm/wasm-utils-env.ts
  var isNode;
  var init_wasm_utils_env = __esm({
    "web/lib/wasm/wasm-utils-env.ts"() {
      "use strict";
      isNode = false;
    }
  });

  // web/lib/wasm/proxy-worker/main.ts
  var main_exports = {};
  __export(main_exports, {
    default: () => main_default
  });
  var WORKER_NAME, isProxyWorker, main_default;
  var init_main = __esm({
    "web/lib/wasm/proxy-worker/main.ts"() {
      "use strict";
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      WORKER_NAME = "ort-wasm-proxy-worker";
      isProxyWorker = globalThis.self?.name === WORKER_NAME;
      if (isProxyWorker) {
        self.onmessage = (ev) => {
          const { type, in: message } = ev.data;
          try {
            switch (type) {
              case "init-wasm":
                initializeWebAssembly(message.wasm).then(
                  () => {
                    initRuntime(message).then(
                      () => {
                        postMessage({ type });
                      },
                      (err) => {
                        postMessage({ type, err });
                      }
                    );
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              case "init-ep": {
                const { epName, env: env3 } = message;
                initEp(env3, epName).then(
                  () => {
                    postMessage({ type });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "copy-from": {
                const { buffer } = message;
                const bufferData = copyFromExternalBuffer(buffer);
                postMessage({ type, out: bufferData });
                break;
              }
              case "create": {
                const { model, options } = message;
                createSession(model, options).then(
                  (sessionMetadata) => {
                    postMessage({ type, out: sessionMetadata });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "release":
                releaseSession(message);
                postMessage({ type });
                break;
              case "run": {
                const { sessionId, inputIndices, inputs, outputIndices, options } = message;
                run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                  (outputs) => {
                    if (outputs.some((o) => o[3] !== "cpu")) {
                      postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                    } else {
                      postMessage(
                        { type, out: outputs },
                        extractTransferableBuffers([...inputs, ...outputs])
                      );
                    }
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "end-profiling":
                endProfiling(message);
                postMessage({ type });
                break;
              default:
            }
          } catch (err) {
            postMessage({ type, err });
          }
        };
      }
      main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: false ? "module" : "classic", name: WORKER_NAME });
    }
  });

  // web/lib/wasm/wasm-utils-import.ts
  var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
  var init_wasm_utils_import = __esm({
    "web/lib/wasm/wasm-utils-import.ts"() {
      "use strict";
      init_wasm_utils_env();
      scriptSrc = // if Nodejs, return undefined
      isNode ? void 0 : (
        // use `document.currentScript.src` if available
        typeof document !== "undefined" ? document.currentScript?.src : (
          // use `self.location.href` if available
          typeof self !== "undefined" ? self.location?.href : void 0
        )
      );
      origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
      isSameOrigin = (filename, prefixOverride) => {
        try {
          const baseUrl = prefixOverride ?? scriptSrc;
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.origin === origin;
        } catch {
          return false;
        }
      };
      normalizeUrl = (filename, prefixOverride) => {
        const baseUrl = prefixOverride ?? scriptSrc;
        try {
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.href;
        } catch {
          return void 0;
        }
      };
      fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
      preload = async (absoluteUrl) => {
        const response = await fetch(absoluteUrl, { credentials: "same-origin" });
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };
      dynamicImportDefault = async (url) => (await import(
        /* webpackIgnore: true */
        url
      )).default;
      createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
      importProxyWorker = async () => {
        if (!scriptSrc) {
          throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
        }
        if (isSameOrigin(scriptSrc)) {
          return [void 0, createProxyWorker()];
        }
        const url = await preload(scriptSrc);
        return [url, createProxyWorker(url)];
      };
      embeddedWasmModule = false ? (
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        (false ? null : null).default
      ) : void 0;
      importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
        if (false) {
          return [void 0, embeddedWasmModule];
        } else {
          const wasmModuleFilename = false ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
          const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
          const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
          const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
          return [needPreload ? url : void 0, await dynamicImportDefault(url)];
        }
      };
    }
  });

  // web/lib/wasm/wasm-factory.ts
  var wasm2, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
  var init_wasm_factory = __esm({
    "web/lib/wasm/wasm-factory.ts"() {
      "use strict";
      init_wasm_utils_import();
      initialized = false;
      initializing = false;
      aborted = false;
      isMultiThreadSupported = () => {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        try {
          if (typeof MessageChannel !== "undefined") {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
          }
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              5,
              4,
              1,
              3,
              1,
              1,
              10,
              11,
              1,
              9,
              0,
              65,
              0,
              254,
              16,
              2,
              0,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              10,
              30,
              1,
              28,
              0,
              65,
              0,
              253,
              15,
              253,
              12,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              253,
              186,
              1,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      initializeWebAssembly = async (flags) => {
        if (initialized) {
          return Promise.resolve();
        }
        if (initializing) {
          throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        }
        if (aborted) {
          throw new Error("previous call to 'initializeWebAssembly()' failed.");
        }
        initializing = true;
        const timeout = flags.initTimeout;
        let numThreads = flags.numThreads;
        if (!isSimdSupported()) {
          throw new Error("WebAssembly SIMD is not supported in the current environment.");
        }
        const multiThreadSupported = isMultiThreadSupported();
        if (numThreads > 1 && !multiThreadSupported) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            console.warn(
              "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
            );
          }
          console.warn(
            "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
          );
          flags.numThreads = numThreads = 1;
        }
        const wasmPaths = flags.wasmPaths;
        const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
        const mjsPathOverrideFlag = wasmPaths?.mjs;
        const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
        const wasmPathOverrideFlag = wasmPaths?.wasm;
        const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
        const wasmBinaryOverride = flags.wasmBinary;
        const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
        let isTimeout = false;
        const tasks = [];
        if (timeout > 0) {
          tasks.push(
            new Promise((resolve) => {
              setTimeout(() => {
                isTimeout = true;
                resolve();
              }, timeout);
            })
          );
        }
        tasks.push(
          new Promise((resolve, reject) => {
            const config = {
              /**
               * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
               * created.
               */
              numThreads
            };
            if (wasmBinaryOverride) {
              config.wasmBinary = wasmBinaryOverride;
            } else if (wasmPathOverride || wasmPrefixOverride) {
              config.locateFile = (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;
            }
            ortWasmFactory(config).then(
              // wasm module initialized successfully
              (module2) => {
                initializing = false;
                initialized = true;
                wasm2 = module2;
                resolve();
                if (objectUrl) {
                  URL.revokeObjectURL(objectUrl);
                }
              },
              // wasm module failed to initialize
              (what) => {
                initializing = false;
                aborted = true;
                reject(what);
              }
            );
          })
        );
        await Promise.race(tasks);
        if (isTimeout) {
          throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
        }
      };
      getInstance = () => {
        if (initialized && wasm2) {
          return wasm2;
        }
        throw new Error("WebAssembly is not initialized yet.");
      };
    }
  });

  // web/lib/wasm/wasm-utils.ts
  var allocWasmString, iterateExtraOptions, checkLastError;
  var init_wasm_utils = __esm({
    "web/lib/wasm/wasm-utils.ts"() {
      "use strict";
      init_wasm_factory();
      allocWasmString = (data, allocs) => {
        const wasm3 = getInstance();
        const dataLength = wasm3.lengthBytesUTF8(data) + 1;
        const dataOffset = wasm3._malloc(dataLength);
        wasm3.stringToUTF8(data, dataOffset, dataLength);
        allocs.push(dataOffset);
        return dataOffset;
      };
      iterateExtraOptions = (options, prefix, seen, handler) => {
        if (typeof options == "object" && options !== null) {
          if (seen.has(options)) {
            throw new Error("Circular reference in options");
          } else {
            seen.add(options);
          }
        }
        Object.entries(options).forEach(([key, value]) => {
          const name2 = prefix ? prefix + key : key;
          if (typeof value === "object") {
            iterateExtraOptions(value, name2 + ".", seen, handler);
          } else if (typeof value === "string" || typeof value === "number") {
            handler(name2, value.toString());
          } else if (typeof value === "boolean") {
            handler(name2, value ? "1" : "0");
          } else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
          }
        });
      };
      checkLastError = (message) => {
        const wasm3 = getInstance();
        const stack = wasm3.stackSave();
        try {
          const paramsOffset = wasm3.stackAlloc(8);
          wasm3._OrtGetLastError(paramsOffset, paramsOffset + 4);
          const errorCode = wasm3.HEAP32[paramsOffset / 4];
          const errorMessagePointer = wasm3.HEAPU32[paramsOffset / 4 + 1];
          const errorMessage = errorMessagePointer ? wasm3.UTF8ToString(errorMessagePointer) : "";
          throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
        } finally {
          wasm3.stackRestore(stack);
        }
      };
    }
  });

  // web/lib/wasm/run-options.ts
  var setRunOptions;
  var init_run_options = __esm({
    "web/lib/wasm/run-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      setRunOptions = (options) => {
        const wasm3 = getInstance();
        let runOptionsHandle = 0;
        const allocs = [];
        const runOptions = options || {};
        try {
          if (options?.logSeverityLevel === void 0) {
            runOptions.logSeverityLevel = 2;
          } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
          }
          if (options?.logVerbosityLevel === void 0) {
            runOptions.logVerbosityLevel = 0;
          } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
          }
          if (options?.terminate === void 0) {
            runOptions.terminate = false;
          }
          let tagDataOffset = 0;
          if (options?.tag !== void 0) {
            tagDataOffset = allocWasmString(options.tag, allocs);
          }
          runOptionsHandle = wasm3._OrtCreateRunOptions(
            runOptions.logSeverityLevel,
            runOptions.logVerbosityLevel,
            !!runOptions.terminate,
            tagDataOffset
          );
          if (runOptionsHandle === 0) {
            checkLastError("Can't create run options.");
          }
          if (options?.extra !== void 0) {
            iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm3._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
              }
            });
          }
          return [runOptionsHandle, allocs];
        } catch (e) {
          if (runOptionsHandle !== 0) {
            wasm3._OrtReleaseRunOptions(runOptionsHandle);
          }
          allocs.forEach((alloc) => wasm3._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/session-options.ts
  var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
  var init_session_options = __esm({
    "web/lib/wasm/session-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      getGraphOptimzationLevel = (graphOptimizationLevel) => {
        switch (graphOptimizationLevel) {
          case "disabled":
            return 0;
          case "basic":
            return 1;
          case "extended":
            return 2;
          case "all":
            return 99;
          default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
        }
      };
      getExecutionMode = (executionMode) => {
        switch (executionMode) {
          case "sequential":
            return 0;
          case "parallel":
            return 1;
          default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
        }
      };
      appendDefaultOptions = (options) => {
        if (!options.extra) {
          options.extra = {};
        }
        if (!options.extra.session) {
          options.extra.session = {};
        }
        const session = options.extra.session;
        if (!session.use_ort_model_bytes_directly) {
          session.use_ort_model_bytes_directly = "1";
        }
        if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
          options.enableMemPattern = false;
        }
      };
      setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
        for (const ep of executionProviders) {
          let epName = typeof ep === "string" ? ep : ep.name;
          switch (epName) {
            case "webnn":
              epName = "WEBNN";
              if (typeof ep !== "string") {
                const webnnOptions = ep;
                const deviceType = webnnOptions?.deviceType;
                if (deviceType) {
                  const keyDataOffset = allocWasmString("deviceType", allocs);
                  const valueDataOffset = allocWasmString(deviceType, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                  }
                }
              }
              break;
            case "webgpu":
              epName = "JS";
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions?.preferredLayout) {
                  if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                    throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                  }
                  const keyDataOffset = allocWasmString("preferredLayout", allocs);
                  const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`);
                  }
                }
              }
              break;
            case "wasm":
            case "cpu":
              continue;
            default:
              throw new Error(`not supported execution provider: ${epName}`);
          }
          const epNameDataOffset = allocWasmString(epName, allocs);
          if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
            checkLastError(`Can't append execution provider: ${epName}.`);
          }
        }
      };
      setSessionOptions = (options) => {
        const wasm3 = getInstance();
        let sessionOptionsHandle = 0;
        const allocs = [];
        const sessionOptions = options || {};
        appendDefaultOptions(sessionOptions);
        try {
          const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
          const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
          const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
          const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
          if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
          }
          const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
          if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
          }
          const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
          sessionOptionsHandle = wasm3._OrtCreateSessionOptions(
            graphOptimizationLevel,
            !!sessionOptions.enableCpuMemArena,
            !!sessionOptions.enableMemPattern,
            executionMode,
            !!sessionOptions.enableProfiling,
            0,
            logIdDataOffset,
            logSeverityLevel,
            logVerbosityLevel,
            optimizedModelFilePathOffset
          );
          if (sessionOptionsHandle === 0) {
            checkLastError("Can't create session options.");
          }
          if (sessionOptions.executionProviders) {
            setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
          }
          if (sessionOptions.enableGraphCapture !== void 0) {
            if (typeof sessionOptions.enableGraphCapture !== "boolean") {
              throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
            }
            const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
            const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
            if (wasm3._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(
                `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
              );
            }
          }
          if (sessionOptions.freeDimensionOverrides) {
            for (const [name2, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
              if (typeof name2 !== "string") {
                throw new Error(`free dimension override name must be a string: ${name2}`);
              }
              if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
                throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
              }
              const nameOffset = allocWasmString(name2, allocs);
              if (wasm3._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
                checkLastError(`Can't set a free dimension override: ${name2} - ${value}.`);
              }
            }
          }
          if (sessionOptions.extra !== void 0) {
            iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm3._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
              }
            });
          }
          return [sessionOptionsHandle, allocs];
        } catch (e) {
          if (sessionOptionsHandle !== 0) {
            wasm3._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm3._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/wasm-common.ts
  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
  var init_wasm_common = __esm({
    "web/lib/wasm/wasm-common.ts"() {
      "use strict";
      tensorDataTypeStringToEnum = (type) => {
        switch (type) {
          case "int8":
            return 3 /* int8 */;
          case "uint8":
            return 2 /* uint8 */;
          case "bool":
            return 9 /* bool */;
          case "int16":
            return 5 /* int16 */;
          case "uint16":
            return 4 /* uint16 */;
          case "int32":
            return 6 /* int32 */;
          case "uint32":
            return 12 /* uint32 */;
          case "float16":
            return 10 /* float16 */;
          case "float32":
            return 1 /* float */;
          case "float64":
            return 11 /* double */;
          case "string":
            return 8 /* string */;
          case "int64":
            return 7 /* int64 */;
          case "uint64":
            return 13 /* uint64 */;
          case "int4":
            return 22 /* int4 */;
          case "uint4":
            return 21 /* uint4 */;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      };
      tensorDataTypeEnumToString = (typeProto) => {
        switch (typeProto) {
          case 3 /* int8 */:
            return "int8";
          case 2 /* uint8 */:
            return "uint8";
          case 9 /* bool */:
            return "bool";
          case 5 /* int16 */:
            return "int16";
          case 4 /* uint16 */:
            return "uint16";
          case 6 /* int32 */:
            return "int32";
          case 12 /* uint32 */:
            return "uint32";
          case 10 /* float16 */:
            return "float16";
          case 1 /* float */:
            return "float32";
          case 11 /* double */:
            return "float64";
          case 8 /* string */:
            return "string";
          case 7 /* int64 */:
            return "int64";
          case 13 /* uint64 */:
            return "uint64";
          case 22 /* int4 */:
            return "int4";
          case 21 /* uint4 */:
            return "uint4";
          default:
            throw new Error(`unsupported data type: ${typeProto}`);
        }
      };
      calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
        const elementSize = [
          -1,
          // undefined = 0
          4,
          // float = 1
          1,
          // uint8 = 2
          1,
          // int8 = 3
          2,
          // uint16 = 4
          2,
          // int16 = 5
          4,
          // int32 = 6
          8,
          // int64 = 7
          -1,
          // string = 8
          1,
          // bool = 9
          2,
          // float16 = 10
          8,
          // double = 11
          4,
          // uint32 = 12
          8,
          // uint64 = 13
          -1,
          // complex64 = 14
          -1,
          // complex128 = 15
          -1,
          // bfloat16 = 16
          -1,
          // FLOAT8E4M3FN = 17
          -1,
          // FLOAT8E4M3FNUZ = 18
          -1,
          // FLOAT8E5M2 = 19
          -1,
          // FLOAT8E5M2FNUZ = 20
          0.5,
          // uint4 = 21
          0.5
          // int4 = 22
        ][dateType];
        const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
        return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
      };
      tensorTypeToTypedArrayConstructor = (type) => {
        switch (type) {
          case "float16":
            return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
          case "float32":
            return Float32Array;
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "bool":
            return Uint8Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${type}`);
        }
      };
      logLevelStringToEnum = (logLevel) => {
        switch (logLevel) {
          case "verbose":
            return 0;
          case "info":
            return 1;
          case "warning":
            return 2;
          case "error":
            return 3;
          case "fatal":
            return 4;
          default:
            throw new Error(`unsupported logging level: ${logLevel}`);
        }
      };
      isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool";
      dataLocationStringToEnum = (location2) => {
        switch (location2) {
          case "none":
            return 0;
          case "cpu":
            return 1;
          case "cpu-pinned":
            return 2;
          case "texture":
            return 3;
          case "gpu-buffer":
            return 4;
          case "ml-tensor":
            return 5;
          default:
            throw new Error(`unsupported data location: ${location2}`);
        }
      };
    }
  });

  // web/lib/wasm/wasm-utils-load-file.ts
  var loadFile;
  var init_wasm_utils_load_file = __esm({
    "web/lib/wasm/wasm-utils-load-file.ts"() {
      "use strict";
      init_wasm_utils_env();
      loadFile = async (file) => {
        if (typeof file === "string") {
          if (isNode) {
            try {
              const { readFile } = __require("node:fs/promises");
              return new Uint8Array(await readFile(file));
            } catch (e) {
              if (e.code === "ERR_FS_FILE_TOO_LARGE") {
                const { createReadStream } = __require("node:fs");
                const stream = createReadStream(file);
                const chunks = [];
                for await (const chunk of stream) {
                  chunks.push(chunk);
                }
                return new Uint8Array(Buffer.concat(chunks));
              }
              throw e;
            }
          } else {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`failed to load external data file: ${file}`);
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
            if (fileSize < 1073741824) {
              return new Uint8Array(await response.arrayBuffer());
            } else {
              if (!response.body) {
                throw new Error(`failed to load external data file: ${file}, no response body.`);
              }
              const reader = response.body.getReader();
              let buffer;
              try {
                buffer = new ArrayBuffer(fileSize);
              } catch (e) {
                if (e instanceof RangeError) {
                  const pages = Math.ceil(fileSize / 65536);
                  buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
                } else {
                  throw e;
                }
              }
              let offset = 0;
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunkSize = value.byteLength;
                const chunk = new Uint8Array(buffer, offset, chunkSize);
                chunk.set(value);
                offset += chunkSize;
              }
              return new Uint8Array(buffer, 0, fileSize);
            }
          }
        } else if (file instanceof Blob) {
          return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Uint8Array) {
          return file;
        } else {
          return new Uint8Array(file);
        }
      };
    }
  });

  // web/lib/wasm/wasm-core-impl.ts
  var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
  var init_wasm_core_impl = __esm({
    "web/lib/wasm/wasm-core-impl.ts"() {
      "use strict";
      init_run_options();
      init_session_options();
      init_wasm_common();
      init_wasm_factory();
      init_wasm_utils();
      init_wasm_utils_load_file();
      initOrt = (numThreads, loggingLevel) => {
        const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
        if (errorCode !== 0) {
          checkLastError("Can't initialize onnxruntime.");
        }
      };
      initRuntime = async (env3) => {
        initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
      };
      initEp = async (env3, epName) => {
        if (false) {
          const initJsep = null.init;
          if (epName === "webgpu") {
            if (typeof navigator === "undefined" || !navigator.gpu) {
              throw new Error("WebGPU is not supported in current environment");
            }
            let adapter = env3.webgpu.adapter;
            if (!adapter) {
              const powerPreference = env3.webgpu.powerPreference;
              if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
                throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
              }
              const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
              if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
                throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
              }
              adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
              if (!adapter) {
                throw new Error(
                  'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
                );
              }
            } else {
              if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
                throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
              }
            }
            await initJsep("webgpu", getInstance(), env3, adapter);
          }
          if (epName === "webnn") {
            if (typeof navigator === "undefined" || !navigator.ml) {
              throw new Error("WebNN is not supported in current environment");
            }
            await initJsep("webnn", getInstance(), env3);
          }
        }
      };
      activeSessions = /* @__PURE__ */ new Map();
      getSessionInputOutputCount = (sessionHandle) => {
        const wasm3 = getInstance();
        const stack = wasm3.stackSave();
        try {
          const dataOffset = wasm3.stackAlloc(8);
          const errorCode = wasm3._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output count.");
          }
          return [wasm3.HEAP32[dataOffset / 4], wasm3.HEAP32[dataOffset / 4 + 1]];
        } finally {
          wasm3.stackRestore(stack);
        }
      };
      copyFromExternalBuffer = (model) => {
        const wasm3 = getInstance();
        const modelDataOffset = wasm3._malloc(model.byteLength);
        if (modelDataOffset === 0) {
          throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
        }
        wasm3.HEAPU8.set(model, modelDataOffset);
        return [modelDataOffset, model.byteLength];
      };
      createSession = async (modelData, options) => {
        let modelDataOffset, modelDataLength;
        const wasm3 = getInstance();
        if (Array.isArray(modelData)) {
          [modelDataOffset, modelDataLength] = modelData;
        } else if (modelData.buffer === wasm3.HEAPU8.buffer) {
          [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
        } else {
          [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
        }
        let sessionHandle = 0;
        let sessionOptionsHandle = 0;
        let ioBindingHandle = 0;
        let allocs = [];
        const inputNamesUTF8Encoded = [];
        const outputNamesUTF8Encoded = [];
        try {
          [sessionOptionsHandle, allocs] = setSessionOptions(options);
          if (options?.externalData && wasm3.mountExternalData) {
            const loadingPromises = [];
            for (const file of options.externalData) {
              const path = typeof file === "string" ? file : file.path;
              loadingPromises.push(
                loadFile(typeof file === "string" ? file : file.data).then((data) => {
                  wasm3.mountExternalData(path, data);
                })
              );
            }
            await Promise.all(loadingPromises);
          }
          for (const provider of options?.executionProviders ?? []) {
            const providerName = typeof provider === "string" ? provider : provider.name;
            if (providerName === "webnn") {
              wasm3.shouldTransferToMLTensor = false;
              if (wasm3.currentContext) {
                throw new Error("WebNN execution provider is already set.");
              }
              if (typeof provider !== "string") {
                const webnnOptions = provider;
                const context = webnnOptions?.context;
                const gpuDevice = webnnOptions?.gpuDevice;
                const deviceType = webnnOptions?.deviceType;
                const numThreads = webnnOptions?.numThreads;
                const powerPreference = webnnOptions?.powerPreference;
                if (context) {
                  wasm3.currentContext = context;
                } else if (gpuDevice) {
                  wasm3.currentContext = await navigator.ml.createContext(gpuDevice);
                } else {
                  wasm3.currentContext = await navigator.ml.createContext({ deviceType, numThreads, powerPreference });
                }
              } else {
                wasm3.currentContext = await navigator.ml.createContext();
              }
              break;
            }
          }
          sessionHandle = await wasm3._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
          if (sessionHandle === 0) {
            checkLastError("Can't create a session.");
          }
          if (wasm3.currentContext) {
            wasm3.jsepRegisterMLContext(sessionHandle, wasm3.currentContext);
            wasm3.currentContext = void 0;
            wasm3.shouldTransferToMLTensor = true;
          }
          const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
          const enableGraphCapture = !!options?.enableGraphCapture;
          const inputNames = [];
          const outputNames = [];
          const outputPreferredLocations = [];
          for (let i = 0; i < inputCount; i++) {
            const name2 = wasm3._OrtGetInputName(sessionHandle, i);
            if (name2 === 0) {
              checkLastError("Can't get an input name.");
            }
            inputNamesUTF8Encoded.push(name2);
            inputNames.push(wasm3.UTF8ToString(name2));
          }
          for (let i = 0; i < outputCount; i++) {
            const name2 = wasm3._OrtGetOutputName(sessionHandle, i);
            if (name2 === 0) {
              checkLastError("Can't get an output name.");
            }
            outputNamesUTF8Encoded.push(name2);
            const nameString = wasm3.UTF8ToString(name2);
            outputNames.push(nameString);
            if (false) {
              if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
                outputPreferredLocations.push("gpu-buffer");
                continue;
              }
              const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
              if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
                throw new Error(`Not supported preferred output location: ${location2}.`);
              }
              if (enableGraphCapture && location2 !== "gpu-buffer") {
                throw new Error(
                  `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
                );
              }
              outputPreferredLocations.push(location2);
            }
          }
          let bindingState = null;
          if (false) {
            ioBindingHandle = wasm3._OrtCreateBinding(sessionHandle);
            if (ioBindingHandle === 0) {
              checkLastError("Can't create IO binding.");
            }
            bindingState = {
              handle: ioBindingHandle,
              outputPreferredLocations,
              outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
            };
          }
          activeSessions.set(sessionHandle, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            bindingState,
            enableGraphCapture,
            false
          ]);
          return [sessionHandle, inputNames, outputNames];
        } catch (e) {
          inputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
          outputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
          if (ioBindingHandle !== 0) {
            wasm3._OrtReleaseBinding(ioBindingHandle);
          }
          if (sessionHandle !== 0) {
            wasm3._OrtReleaseSession(sessionHandle);
          }
          throw e;
        } finally {
          wasm3._free(modelDataOffset);
          if (sessionOptionsHandle !== 0) {
            wasm3._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm3._free(alloc));
          wasm3.unmountExternalData?.();
        }
      };
      releaseSession = (sessionId) => {
        const wasm3 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot release session. invalid session id: ${sessionId}`);
        }
        const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
        if (ioBindingState) {
          if (enableGraphCapture) {
            wasm3._OrtClearBoundOutputs(ioBindingState.handle);
          }
          wasm3._OrtReleaseBinding(ioBindingState.handle);
        }
        wasm3.jsepOnReleaseSession?.(sessionId);
        inputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
        wasm3._OrtReleaseSession(sessionHandle);
        activeSessions.delete(sessionId);
      };
      prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
        if (!tensor) {
          tensorHandles.push(0);
          return;
        }
        const wasm3 = getInstance();
        const dataType = tensor[0];
        const dims = tensor[1];
        const location2 = tensor[3];
        let rawData;
        let dataByteLength;
        if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
          throw new Error("String tensor is not supported on GPU.");
        }
        if (enableGraphCapture && location2 !== "gpu-buffer") {
          throw new Error(
            `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
          );
        }
        if (location2 === "gpu-buffer") {
          const gpuBuffer = tensor[2].gpuBuffer;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerBuffer = wasm3.jsepRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
        } else if (location2 === "ml-tensor") {
          const mlTensor = tensor[2].mlTensor;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerMLTensor = wasm3.jsepRegisterMLTensor;
          if (!registerMLTensor) {
            throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
          }
          rawData = registerMLTensor(mlTensor, tensorDataTypeStringToEnum(dataType), dims);
        } else {
          const data = tensor[2];
          if (Array.isArray(data)) {
            dataByteLength = 4 * data.length;
            rawData = wasm3._malloc(dataByteLength);
            allocs.push(rawData);
            let dataIndex = rawData / 4;
            for (let i = 0; i < data.length; i++) {
              if (typeof data[i] !== "string") {
                throw new TypeError(`tensor data at index ${i} is not a string`);
              }
              wasm3.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
            }
          } else {
            dataByteLength = data.byteLength;
            rawData = wasm3._malloc(dataByteLength);
            allocs.push(rawData);
            wasm3.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
          }
        }
        const stack = wasm3.stackSave();
        const dimsOffset = wasm3.stackAlloc(4 * dims.length);
        try {
          let dimIndex = dimsOffset / 4;
          dims.forEach((d) => wasm3.HEAP32[dimIndex++] = d);
          const tensor2 = wasm3._OrtCreateTensor(
            tensorDataTypeStringToEnum(dataType),
            rawData,
            dataByteLength,
            dimsOffset,
            dims.length,
            dataLocationStringToEnum(location2)
          );
          if (tensor2 === 0) {
            checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
          }
          tensorHandles.push(tensor2);
        } finally {
          wasm3.stackRestore(stack);
        }
      };
      run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
        const wasm3 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
        }
        const sessionHandle = session[0];
        const inputNamesUTF8Encoded = session[1];
        const outputNamesUTF8Encoded = session[2];
        const ioBindingState = session[3];
        const enableGraphCapture = session[4];
        const inputOutputBound = session[5];
        const inputCount = inputIndices.length;
        const outputCount = outputIndices.length;
        let runOptionsHandle = 0;
        let runOptionsAllocs = [];
        const inputTensorHandles = [];
        const outputTensorHandles = [];
        const inputOutputAllocs = [];
        const beforeRunStack = wasm3.stackSave();
        const inputValuesOffset = wasm3.stackAlloc(inputCount * 4);
        const inputNamesOffset = wasm3.stackAlloc(inputCount * 4);
        const outputValuesOffset = wasm3.stackAlloc(outputCount * 4);
        const outputNamesOffset = wasm3.stackAlloc(outputCount * 4);
        try {
          wasm3.jsepOnRunStart?.(sessionHandle);
          [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
          for (let i = 0; i < inputCount; i++) {
            prepareInputOutputTensor(
              inputTensors[i],
              inputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputIndices[i],
              enableGraphCapture
            );
          }
          for (let i = 0; i < outputCount; i++) {
            prepareInputOutputTensor(
              outputTensors[i],
              outputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputCount + outputIndices[i],
              enableGraphCapture
            );
          }
          let inputValuesIndex = inputValuesOffset / 4;
          let inputNamesIndex = inputNamesOffset / 4;
          let outputValuesIndex = outputValuesOffset / 4;
          let outputNamesIndex = outputNamesOffset / 4;
          for (let i = 0; i < inputCount; i++) {
            wasm3.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
            wasm3.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
          }
          for (let i = 0; i < outputCount; i++) {
            wasm3.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
            wasm3.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
          }
          if (false) {
            const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
            if (inputNamesUTF8Encoded.length !== inputCount) {
              throw new Error(
                `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
              );
            }
            for (let i = 0; i < inputCount; i++) {
              const index = inputIndices[i];
              const errorCode2 = await wasm3._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
              }
            }
            for (let i = 0; i < outputCount; i++) {
              const index = outputIndices[i];
              const location2 = outputTensors[i]?.[3];
              if (location2) {
                const errorCode2 = wasm3._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
                }
              } else {
                const errorCode2 = wasm3._OrtBindOutput(
                  handle,
                  outputNamesUTF8Encoded[index],
                  0,
                  outputPreferredLocationsEncoded[index]
                );
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
                }
              }
            }
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              true
            ]);
          }
          let errorCode;
          if (false) {
            errorCode = await wasm3._OrtRunWithBinding(
              sessionHandle,
              ioBindingState.handle,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          } else {
            errorCode = await wasm3._OrtRun(
              sessionHandle,
              inputNamesOffset,
              inputValuesOffset,
              inputCount,
              outputNamesOffset,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          }
          if (errorCode !== 0) {
            checkLastError("failed to call OrtRun().");
          }
          const output = [];
          for (let i = 0; i < outputCount; i++) {
            const tensor = wasm3.HEAPU32[outputValuesOffset / 4 + i];
            if (tensor === outputTensorHandles[i]) {
              output.push(outputTensors[i]);
              continue;
            }
            const beforeGetTensorDataStack = wasm3.stackSave();
            const tensorDataOffset = wasm3.stackAlloc(4 * 4);
            let keepOutputTensor = false;
            let type, dataOffset = 0;
            try {
              const errorCode2 = wasm3._OrtGetTensorData(
                tensor,
                tensorDataOffset,
                tensorDataOffset + 4,
                tensorDataOffset + 8,
                tensorDataOffset + 12
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't access output tensor data on index ${i}.`);
              }
              let tensorDataIndex = tensorDataOffset / 4;
              const dataType = wasm3.HEAPU32[tensorDataIndex++];
              dataOffset = wasm3.HEAPU32[tensorDataIndex++];
              const dimsOffset = wasm3.HEAPU32[tensorDataIndex++];
              const dimsLength = wasm3.HEAPU32[tensorDataIndex++];
              const dims = [];
              for (let i2 = 0; i2 < dimsLength; i2++) {
                dims.push(wasm3.HEAPU32[dimsOffset / 4 + i2]);
              }
              wasm3._OrtFree(dimsOffset);
              const size = dims.reduce((a, b) => a * b, 1);
              type = tensorDataTypeEnumToString(dataType);
              const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
              if (type === "string") {
                if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                  throw new Error("String tensor is not supported on GPU.");
                }
                const stringData = [];
                let dataIndex = dataOffset / 4;
                for (let i2 = 0; i2 < size; i2++) {
                  const offset = wasm3.HEAPU32[dataIndex++];
                  const maxBytesToRead = i2 === size - 1 ? void 0 : wasm3.HEAPU32[dataIndex] - offset;
                  stringData.push(wasm3.UTF8ToString(offset, maxBytesToRead));
                }
                output.push([type, dims, stringData, "cpu"]);
              } else {
                if (preferredLocation === "gpu-buffer" && size > 0) {
                  const getBuffer = wasm3.jsepGetBuffer;
                  if (!getBuffer) {
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  }
                  const gpuBuffer = getBuffer(dataOffset);
                  const bufferSize = calculateTensorSizeInBytes(dataType, size);
                  if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: wasm3.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                      dispose: () => {
                        wasm3._OrtReleaseTensor(tensor);
                      }
                    },
                    "gpu-buffer"
                  ]);
                } else if (preferredLocation === "ml-tensor" && size > 0) {
                  const ensureTensor = wasm3.jsepEnsureTensor;
                  if (!ensureTensor) {
                    throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                  }
                  const tensorSize = calculateTensorSizeInBytes(dataType, size);
                  if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  const mlTensor = await ensureTensor(dataOffset, dataType, dims, false);
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      mlTensor,
                      download: wasm3.jsepCreateMLTensorDownloader(dataOffset, type),
                      dispose: () => {
                        wasm3.jsepReleaseTensorId(dataOffset);
                        wasm3._OrtReleaseTensor(tensor);
                      }
                    },
                    "ml-tensor"
                  ]);
                } else {
                  const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                  const data = new typedArrayConstructor(size);
                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                    wasm3.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                  );
                  output.push([type, dims, data, "cpu"]);
                }
              }
            } finally {
              wasm3.stackRestore(beforeGetTensorDataStack);
              if (type === "string" && dataOffset) {
                wasm3._free(dataOffset);
              }
              if (!keepOutputTensor) {
                wasm3._OrtReleaseTensor(tensor);
              }
            }
          }
          if (ioBindingState && !enableGraphCapture) {
            wasm3._OrtClearBoundOutputs(ioBindingState.handle);
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              false
            ]);
          }
          return output;
        } finally {
          wasm3.stackRestore(beforeRunStack);
          inputTensorHandles.forEach((v) => wasm3._OrtReleaseTensor(v));
          outputTensorHandles.forEach((v) => wasm3._OrtReleaseTensor(v));
          inputOutputAllocs.forEach((p) => wasm3._free(p));
          if (runOptionsHandle !== 0) {
            wasm3._OrtReleaseRunOptions(runOptionsHandle);
          }
          runOptionsAllocs.forEach((p) => wasm3._free(p));
        }
      };
      endProfiling = (sessionId) => {
        const wasm3 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error("invalid session id");
        }
        const sessionHandle = session[0];
        const profileFileName = wasm3._OrtEndProfiling(sessionHandle);
        if (profileFileName === 0) {
          checkLastError("Can't get an profile file name.");
        }
        wasm3._OrtFree(profileFileName);
      };
      extractTransferableBuffers = (tensors) => {
        const buffers = [];
        for (const tensor of tensors) {
          const data = tensor[2];
          if (!Array.isArray(data) && "buffer" in data) {
            buffers.push(data.buffer);
          }
        }
        return buffers;
      };
    }
  });

  // web/lib/wasm/proxy-wrapper.ts
  var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
  var init_proxy_wrapper = __esm({
    "web/lib/wasm/proxy-wrapper.ts"() {
      "use strict";
      init_esm();
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
      initializing2 = false;
      initialized2 = false;
      aborted2 = false;
      queuedCallbacks = /* @__PURE__ */ new Map();
      enqueueCallbacks = (type, callbacks) => {
        const queue = queuedCallbacks.get(type);
        if (queue) {
          queue.push(callbacks);
        } else {
          queuedCallbacks.set(type, [callbacks]);
        }
      };
      ensureWorker = () => {
        if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
          throw new Error("worker not ready");
        }
      };
      onProxyWorkerMessage = (ev) => {
        switch (ev.data.type) {
          case "init-wasm":
            initializing2 = false;
            if (ev.data.err) {
              aborted2 = true;
              initWasmCallbacks[1](ev.data.err);
            } else {
              initialized2 = true;
              initWasmCallbacks[0]();
            }
            if (temporaryObjectUrl) {
              URL.revokeObjectURL(temporaryObjectUrl);
              temporaryObjectUrl = void 0;
            }
            break;
          case "init-ep":
          case "copy-from":
          case "create":
          case "release":
          case "run":
          case "end-profiling": {
            const callbacks = queuedCallbacks.get(ev.data.type);
            if (ev.data.err) {
              callbacks.shift()[1](ev.data.err);
            } else {
              callbacks.shift()[0](ev.data.out);
            }
            break;
          }
          default:
        }
      };
      initializeWebAssemblyAndOrtRuntime = async () => {
        if (initialized2) {
          return;
        }
        if (initializing2) {
          throw new Error("multiple calls to 'initWasm()' detected.");
        }
        if (aborted2) {
          throw new Error("previous call to 'initWasm()' failed.");
        }
        initializing2 = true;
        if (isProxy()) {
          return new Promise((resolve, reject) => {
            proxyWorker?.terminate();
            void importProxyWorker().then(([objectUrl, worker]) => {
              try {
                proxyWorker = worker;
                proxyWorker.onerror = (ev) => reject(ev);
                proxyWorker.onmessage = onProxyWorkerMessage;
                initWasmCallbacks = [resolve, reject];
                const message = { type: "init-wasm", in: env2 };
                proxyWorker.postMessage(message);
                temporaryObjectUrl = objectUrl;
              } catch (e) {
                reject(e);
              }
            }, reject);
          });
        } else {
          try {
            await initializeWebAssembly(env2.wasm);
            await initRuntime(env2);
            initialized2 = true;
          } catch (e) {
            aborted2 = true;
            throw e;
          } finally {
            initializing2 = false;
          }
        }
      };
      initializeOrtEp = async (epName) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("init-ep", [resolve, reject]);
            const message = { type: "init-ep", in: { epName, env: env2 } };
            proxyWorker.postMessage(message);
          });
        } else {
          await initEp(env2, epName);
        }
      };
      copyFromExternalBuffer2 = async (buffer) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("copy-from", [resolve, reject]);
            const message = { type: "copy-from", in: { buffer } };
            proxyWorker.postMessage(message, [buffer.buffer]);
          });
        } else {
          return copyFromExternalBuffer(buffer);
        }
      };
      createSession2 = async (model, options) => {
        if (isProxy()) {
          if (options?.preferredOutputLocation) {
            throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("create", [resolve, reject]);
            const message = { type: "create", in: { model, options: { ...options } } };
            const transferable = [];
            if (model instanceof Uint8Array) {
              transferable.push(model.buffer);
            }
            proxyWorker.postMessage(message, transferable);
          });
        } else {
          return createSession(model, options);
        }
      };
      releaseSession2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("release", [resolve, reject]);
            const message = { type: "release", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          releaseSession(sessionId);
        }
      };
      run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
        if (isProxy()) {
          if (inputs.some((t) => t[3] !== "cpu")) {
            throw new Error("input tensor on GPU is not supported for proxy.");
          }
          if (outputs.some((t) => t)) {
            throw new Error("pre-allocated output tensor is not supported for proxy.");
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("run", [resolve, reject]);
            const serializableInputs = inputs;
            const message = {
              type: "run",
              in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
            };
            proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
          });
        } else {
          return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
        }
      };
      endProfiling2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("end-profiling", [resolve, reject]);
            const message = { type: "end-profiling", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          endProfiling(sessionId);
        }
      };
    }
  });

  // web/lib/wasm/session-handler-inference.ts
  var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
  var init_session_handler_inference2 = __esm({
    "web/lib/wasm/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_wasm_common();
      init_wasm_utils_env();
      init_wasm_utils_load_file();
      encodeTensorMetadata = (tensor, getName) => {
        switch (tensor.location) {
          case "cpu":
            return [tensor.type, tensor.dims, tensor.data, "cpu"];
          case "gpu-buffer":
            return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
          case "ml-tensor":
            return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
          default:
            throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
        }
      };
      decodeTensorMetadata = (tensor) => {
        switch (tensor[3]) {
          case "cpu":
            return new Tensor2(tensor[0], tensor[2], tensor[1]);
          case "gpu-buffer": {
            const dataType = tensor[0];
            if (!isGpuBufferSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
            }
            const { gpuBuffer, download, dispose } = tensor[2];
            return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
          }
          case "ml-tensor": {
            const dataType = tensor[0];
            if (!isMLTensorSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
            }
            const { mlTensor, download, dispose } = tensor[2];
            return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
          }
          default:
            throw new Error(`invalid data location: ${tensor[3]}`);
        }
      };
      OnnxruntimeWebAssemblySessionHandler = class {
        async fetchModelAndCopyToWasmMemory(path) {
          return copyFromExternalBuffer2(await loadFile(path));
        }
        async loadModel(pathOrBuffer, options) {
          TRACE_FUNC_BEGIN();
          let model;
          if (typeof pathOrBuffer === "string") {
            if (isNode) {
              model = await loadFile(pathOrBuffer);
            } else {
              model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
            }
          } else {
            model = pathOrBuffer;
          }
          [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
          TRACE_FUNC_END();
        }
        async dispose() {
          return releaseSession2(this.sessionId);
        }
        async run(feeds, fetches, options) {
          TRACE_FUNC_BEGIN();
          const inputArray = [];
          const inputIndices = [];
          Object.entries(feeds).forEach((kvp) => {
            const name2 = kvp[0];
            const tensor = kvp[1];
            const index = this.inputNames.indexOf(name2);
            if (index === -1) {
              throw new Error(`invalid input '${name2}'`);
            }
            inputArray.push(tensor);
            inputIndices.push(index);
          });
          const outputArray = [];
          const outputIndices = [];
          Object.entries(fetches).forEach((kvp) => {
            const name2 = kvp[0];
            const tensor = kvp[1];
            const index = this.outputNames.indexOf(name2);
            if (index === -1) {
              throw new Error(`invalid output '${name2}'`);
            }
            outputArray.push(tensor);
            outputIndices.push(index);
          });
          const inputs = inputArray.map(
            (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
          );
          const outputs = outputArray.map(
            (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
          );
          const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
          const resultMap = {};
          for (let i = 0; i < results.length; i++) {
            resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
          }
          TRACE_FUNC_END();
          return resultMap;
        }
        startProfiling() {
        }
        endProfiling() {
          void endProfiling2(this.sessionId);
        }
      };
    }
  });

  // web/lib/backend-wasm.ts
  var backend_wasm_exports = {};
  __export(backend_wasm_exports, {
    OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
    initializeFlags: () => initializeFlags,
    wasmBackend: () => wasmBackend
  });
  var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
  var init_backend_wasm = __esm({
    "web/lib/backend-wasm.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_session_handler_inference2();
      init_wasm_utils_import();
      initializeFlags = () => {
        if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
          env2.wasm.initTimeout = 0;
        }
        if (env2.wasm.simd === false) {
          console.warn(
            'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
          );
        }
        if (typeof env2.wasm.proxy !== "boolean") {
          env2.wasm.proxy = false;
        }
        if (typeof env2.wasm.trace !== "boolean") {
          env2.wasm.trace = false;
        }
        if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            env2.wasm.numThreads = 1;
          } else {
            const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
            env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
          }
        }
        if (true) {
          if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
            env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
          }
        }
      };
      OnnxruntimeWebAssemblyBackend = class {
        /**
         * This function initializes the WebAssembly backend.
         *
         * This function will be called only once for each backend name. It will be called the first time when
         * `ort.InferenceSession.create()` is called with a registered backend name.
         *
         * @param backendName - the registered backend name.
         */
        async init(backendName) {
          initializeFlags();
          await initializeWebAssemblyAndOrtRuntime();
          await initializeOrtEp(backendName);
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const handler = new OnnxruntimeWebAssemblySessionHandler();
          await handler.loadModel(pathOrBuffer, options);
          return Promise.resolve(handler);
        }
      };
      wasmBackend = new OnnxruntimeWebAssemblyBackend();
    }
  });

  // web/lib/index.ts
  var lib_exports = {};
  __export(lib_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    default: () => lib_default,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  init_esm();
  init_esm();
  init_esm();

  // web/lib/version.ts
  var version2 = "1.20.0";

  // web/lib/index.ts
  var lib_default = esm_exports;
  if (true) {
    const onnxjsBackend2 = (init_backend_onnxjs(), __toCommonJS(backend_onnxjs_exports)).onnxjsBackend;
    registerBackend("webgl", onnxjsBackend2, -10);
  }
  if (true) {
    const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
    if (false) {
      registerBackend("webgpu", wasmBackend2, 5);
      registerBackend("webnn", wasmBackend2, 5);
    }
    registerBackend("cpu", wasmBackend2, 10);
    registerBackend("wasm", wasmBackend2, 10);
  }
  Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
  return __toCommonJS(lib_exports);
})();
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL29ubnhqcy9pbnN0cnVtZW50LnRzIiwgIi4uL2xpYi9vbm54anMvb3BzZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2d1aWQtdHlwZXNjcmlwdC9kaXN0L2d1aWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xvbmcvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL2pzL2ZsYXRidWZmZXJzLm1qcyIsICIuLi9saWIvb25ueGpzL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCAiLi4vbGliL29ubnhqcy9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubnguanMiLCAiLi4vbGliL29ubnhqcy91dGlsLnRzIiwgIi4uL2xpYi9vbm54anMvdGVuc29yLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1zb3VyY2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90eXBlcy50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3V0aWxzLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhY2tpbmctdXRpbHMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcGFjay50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLXBhY2tlZC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91aW50OC1lbmNvZGUudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdW5wYWNrLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1kYXRhLWVuY29kZXIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2luZmVyZW5jZS1oYW5kbGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWRlZmluaXRpb25zLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jYXN0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbmNhdC1wYWNrZWQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ltMmNvbC1wYWNrLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL21hdG11bC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9tYXRtdWwtcGFjay50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb252LXBhY2sudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW0yY29sLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RvdC1wcm9kdWN0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbnYudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi10cmFuc3Bvc2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ZsYXR0ZW4udHMiLCAiLi4vbGliL29ubnhqcy9vcGVyYXRvcnMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZ2F0aGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2dlbW0udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW1hZ2Utc2NhbGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvbHJuLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhZC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wb29sLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3JlZHVjZS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vwc2FtcGxlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Jlc2l6ZS1wYWNrZWQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2hhcGUudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2xpY2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc29mdG1heC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcGxpdC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcXVlZXplLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3N1bS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy90aWxlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vuc3F1ZWV6ZS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWZ1bmN0aW9uLWlubGluZXIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC1zdHJhdGVneS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtY29vcmRpbmF0ZS1saWIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWVuY29kaW5nLWxpYi50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtZnJhZ2NvbG9yLWxpYi50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtc2hhcGUtdXRpbHMtbGliLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC12ZWMtbGliLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1yZWdpc3RlcmVkLWxpYnMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXByZXByb2Nlc3Nvci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Byb2dyYW0tbWFuYWdlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3RleHR1cmUtbWFuYWdlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Nlc3Npb24taGFuZGxlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC93ZWJnbC1jb250ZXh0LWZhY3RvcnkudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy9iYWNrZW5kLXdlYmdsLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZC50cyIsICIuLi9saWIvb25ueGpzL2V4ZWN1dGlvbi1wbGFuLnRzIiwgIi4uL2xpYi9vbm54anMvYXR0cmlidXRlLnRzIiwgIi4uL2xpYi9vbm54anMvZ3JhcGgudHMiLCAiLi4vbGliL29ubnhqcy9tb2RlbC50cyIsICIuLi9saWIvb25ueGpzL3Nlc3Npb24udHMiLCAiLi4vbGliL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLW9ubnhqcy50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb3JlLWltcGwudHMiLCAiLi4vbGliL3dhc20vcHJveHktd3JhcHBlci50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20udHMiLCAiLi4vbGliL2luZGV4LnRzIiwgIi4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5cbmludGVyZmFjZSBCYWNrZW5kSW5mbyB7XG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XG4gIHByaW9yaXR5OiBudW1iZXI7XG5cbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xuICBpbml0aWFsaXplZD86IGJvb2xlYW47XG4gIGFib3J0ZWQ/OiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eTogc3RyaW5nW10gPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWU6IHN0cmluZywgYmFja2VuZDogQmFja2VuZCwgcHJpb3JpdHk6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XG4gICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tlbmRzLnNldChuYW1lLCB7IGJhY2tlbmQsIHByaW9yaXR5IH0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jIChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kIHwgc3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXG4gIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gIC8vIHRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGFsbCByZXF1ZXN0ZWQgYmFja2VuZHNcbiAgbGV0IGJhY2tlbmQ6IEJhY2tlbmQgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCBhdmFpbGFibGVCYWNrZW5kTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0ID0gYXdhaXQgdHJ5UmVzb2x2ZUFuZEluaXRpYWxpemVCYWNrZW5kKGJhY2tlbmROYW1lKTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVSZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICBiYWNrZW5kID0gcmVzb2x2ZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgIGF2YWlsYWJsZUJhY2tlbmROYW1lcy5hZGQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIGJhY2tlbmQgaXMgYXZhaWxhYmxlLCB0aHJvdyBlcnJvci5cbiAgaWYgKCFiYWNrZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2Vycm9ycy5tYXAoKGUpID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICAvLyBmb3IgZWFjaCBleHBsaWNpdGx5IHJlcXVlc3RlZCBiYWNrZW5kLCBpZiBpdCdzIG5vdCBhdmFpbGFibGUsIG91dHB1dCB3YXJuaW5nIG1lc3NhZ2UuXG4gIGZvciAoY29uc3QgeyBuYW1lLCBlcnIgfSBvZiBlcnJvcnMpIHtcbiAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcigoaSkgPT4gYXZhaWxhYmxlQmFja2VuZE5hbWVzLmhhcyh0eXBlb2YgaSA9PT0gJ3N0cmluZycgPyBpIDogaS5uYW1lKSk7XG5cbiAgcmV0dXJuIFtcbiAgICBiYWNrZW5kLFxuICAgIG5ldyBQcm94eShvcHRpb25zLCB7XG4gICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkRXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgfSxcbiAgICB9KSxcbiAgXTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgaGFuZGxlciBpbnN0YW5jZSBvZiBhbiBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIHJ1bihcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcblxuICBjcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyPyhcbiAgICBjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIHRyYWluTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIGV2YWxNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgb3B0aW1pemVyTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMCc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiB9IGZyb20gJy4vZW52LmpzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7IGNvbW1vbjogdmVyc2lvbiB9LFxuXG4gIHNldCBsb2dMZXZlbCh2YWx1ZTogTG9nTGV2ZWxUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBsb2dMZXZlbFZhbHVlID0gdmFsdWU7XG4gIH0sXG4gIGdldCBsb2dMZXZlbCgpOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+IHtcbiAgICByZXR1cm4gbG9nTGV2ZWxWYWx1ZTtcbiAgfSxcbn07XG5cbi8vIHNldCBwcm9wZXJ0eSAnbG9nTGV2ZWwnIHNvIHRoYXQgdGhleSBjYW4gYmUgY29ycmVjdGx5IHRyYW5zZmVycmVkIHRvIHdvcmtlciBieSBgcG9zdE1lc3NhZ2UoKWAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiBhcyBlbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUGF0aFByZWZpeCA9IHN0cmluZztcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAud2FzbSBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgd2FzbT86IFVSTCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLm1qcyBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXRyYWluaW5nLXdhc20tc2ltZC10aHJlYWRlZC5tanNgIGZvciB0cmFpbmluZyBidWlsZFxuICAgICAqL1xuICAgIG1qcz86IFVSTCB8IHN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBXYXNtUGF0aFByZWZpeCB8IFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFNpbmNlIFNJTUQgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBKYXZhU2NyaXB0IGVuZ2luZXMsIG5vbi1TSU1EXG4gICAgICogYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LnRyYWNlYCBpbnN0ZWFkLiBJZiBgZW52LnRyYWNlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcbiAgICAgKiBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBgd2FzbVBhdGhzYCBwcm9wZXJ0eSB3aWxsXG4gICAgICogYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICB3YXNtQmluYXJ5PzogQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCcgfCAnd2ViZ2wyJztcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgZm9yIG1hdG11bC4gMCBtZWFucyB0byBkaXNhYmxlIGJhdGNoaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBtYXRtdWxNYXhCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgdGV4dHVyZSBjYWNoZSBtb2RlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxuICAgICAqL1xuICAgIHRleHR1cmVDYWNoZU1vZGU/OiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwYWNrZWQgdGV4dHVyZSBtb2RlXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwYWNrPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgZW5hYmxlIGFzeW5jIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgYXN5bmM/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YSB7XG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XG4gICAgdmVyc2lvbjogMTtcbiAgICBpbnB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAga2VybmVsSWQ6IG51bWJlcjtcbiAgICBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xuICAgIHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZW5kVGltZTogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKi9cbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZicgfCAnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnIHwgJ2RlZmF1bHQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgcHJvZmlsaW5nIGRhdGEgaXMgcmVjZWl2ZWQuIElmIG5vdCBzZXQsIHRoZSBwcm9maWxpbmcgZGF0YSB3aWxsIGJlXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXG4gICAgICAgKi9cbiAgICAgIG9uZGF0YT86IChkYXRhOiBXZWJHcHVQcm9maWxpbmdEYXRhKSA9PiB2b2lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBmb3JjZSBmYWxsYmFjayBhZGFwdGVyIGZsYWcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIGdldCBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVQWRhcHRlcmAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlcjtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfVxuICAgICAqL1xuICAgIGFkYXB0ZXI6IHVua25vd247XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXZpY2UgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVEZXZpY2VgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICogVXNlIGBjb25zdCBkZXZpY2UgPSBlbnYud2ViZ3B1LmRldmljZSBhcyBHUFVEZXZpY2U7YCBpbiBUeXBlU2NyaXB0IHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5IHdpdGggY29ycmVjdCB0eXBlLlxuICAgICAqXG4gICAgICogc2VlIGNvbW1lbnRzIG9uIHtAbGluayBUZW5zb3IuR3B1QnVmZmVyVHlwZX0gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB3aHkgbm90IHVzZSB0eXBlcyBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRldmljZTogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgdmFsaWRhdGUgaW5wdXQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHZhbGlkYXRlSW5wdXRDb250ZW50PzogYm9vbGVhbjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XG4gIC8qKlxuICAgKiBzZXQgdGhlIHNldmVyaXR5IGxldmVsIGZvciBsb2dnaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGAnd2FybmluZydgXG4gICAqL1xuICBsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICB0cmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHBhY2thZ2UuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczoge1xuICAgIHJlYWRvbmx5IGNvbW1vbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcbiAgICByZWFkb25seSBub2RlPzogc3RyaW5nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJBc3NlbWJseVxuICAgKi9cbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdsOiBFbnYuV2ViR0xGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHUFVcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdwdTogRW52LldlYkdwdUZsYWdzO1xuXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9EYXRhVVJMID0gKHRlbnNvcjogVGVuc29yLCBvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICBjYW52YXMuaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzXG4gICAgfCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgIHwgbnVsbDtcblxuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICAgIGNvbnN0IEcgPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgLy8gRyB2YWx1ZVxuICAgICAgICBjb25zdCBCID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIFIgKyAnLCcgKyBHICsgJywnICsgQiArICcsJyArIEEgKyAnKSc7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEgPT4ge1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgOiAobmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk7XG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgY2hhbm5lbHM6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgIChjaGFubmVscyA9PT0gMyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBjb25zdCBzdGVwID0gNDtcbiAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsXG4gICAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxuICAgICAgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaSA8IGhlaWdodCAqIHdpZHRoO1xuICAgICAgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKytcbiAgICApIHtcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxuICAgICAgICBhVGVuc29yUG9pbnRlciA9PT0gLTEgPyAyNTUgOiAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgLy8gQSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBPcHRpb25zRGltZW5zaW9ucyxcbiAgT3B0aW9uc0Zvcm1hdCxcbiAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zLFxuICBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsXG4gIFRlbnNvckZyb21VcmxPcHRpb25zLFxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckludGVyZmFjZSB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuaW50ZXJmYWNlIEJ1ZmZlclRvVGVuc29yT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICAgIE9wdGlvbnNGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xuICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm0gPz8geyBtZWFuOiAyNTUsIGJpYXM6IDAgfTtcbiAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICB9IGVsc2Uge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiFbMF0sIG5vcm0ubWVhbiFbMV0sIG5vcm0ubWVhbiFbMl0sIG5vcm0ubWVhbiFbM10gPz8gMjU1XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gIH0gZWxzZSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzIVswXSwgbm9ybS5iaWFzIVsxXSwgbm9ybS5iaWFzIVsyXSwgbm9ybS5iaWFzIVszXSA/PyAwXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcblxuICBjb25zdCBvdXRwdXRmb3JtYXQgPVxuICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogMyk7XG5cbiAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gIGxldCBzdGVwID0gNCxcbiAgICBySW1hZ2VQb2ludGVyID0gMCxcbiAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICBiSW1hZ2VQb2ludGVyID0gMixcbiAgICBhSW1hZ2VQb2ludGVyID0gMztcbiAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICBzdGVwID0gMztcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gIH1cblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9XG5cbiAgZm9yIChcbiAgICBsZXQgaSA9IDA7XG4gICAgaSA8IHN0cmlkZTtcbiAgICBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcFxuICApIHtcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1sxXSkgLyBub3JtTWVhblsxXTtcbiAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICB9XG4gIH1cblxuICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPVxuICAgIG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnXG4gICAgICA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKVxuICAgICAgOiBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XG4gIHJldHVybiBvdXRwdXRUZW5zb3I7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tSW1hZ2UoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21JbWFnZSA9IGFzeW5jIChcbiAgaW1hZ2U6IEltYWdlRGF0YSB8IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IHN0cmluZyxcbiAgb3B0aW9ucz86XG4gICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3I+ID0+IHtcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJ1ZmZlclRvVGVuc29yT3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcblxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcblxuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQodGVtcENhbnZhcyk7XG5cbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICByZXNvbHZlKGJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVRleHR1cmUoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gIHRleHR1cmU6IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuKTogVGVuc29yID0+IHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgLy8gQWx3YXlzIGFzc3VtZSBSR0JBRjMyLiBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCB0ZXh0dXJlIGZvcm1hdFxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tR3B1QnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tR3B1QnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgZ3B1QnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tTUxUZW5zb3IoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21NTFRlbnNvciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcbiAgbWxUZW5zb3I6IFRlbnNvckludGVyZmFjZS5NTFRlbnNvclR5cGUsXG4gIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ21sLXRlbnNvcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgbWxUZW5zb3IsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0pO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVBpbm5lZEJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVBpbm5lZEJ1ZmZlciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gIHR5cGU6IFQsXG4gIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLFxuICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBUZW5zb3IgPT4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF0gfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9XG4gIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yO1xuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcbiAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gIFsnYm9vbCcsIFVpbnQ4QXJyYXldLFxuICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbiAgWydpbnQ0JywgVWludDhBcnJheV0sXG4gIFsndWludDQnLCBVaW50OEFycmF5XSxcbl0pO1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsIFRlbnNvci5UeXBlPihbXG4gIFtGbG9hdDMyQXJyYXksICdmbG9hdDMyJ10sXG4gIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgW0ludDhBcnJheSwgJ2ludDgnXSxcbiAgW1VpbnQxNkFycmF5LCAndWludDE2J10sXG4gIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgW0ludDMyQXJyYXksICdpbnQzMiddLFxuICBbRmxvYXQ2NEFycmF5LCAnZmxvYXQ2NCddLFxuICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xuICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdJbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcbiAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBVaW50MTZBcnJheSk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgTUxUZW5zb3JDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXG4gICAgICAgIG1sVGVuc29yOiB0ZW5zb3IubWxUZW5zb3IsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7XG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXG4gIHRlbnNvckZyb21JbWFnZSxcbiAgdGVuc29yRnJvbU1MVGVuc29yLFxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxuICB0ZW5zb3JGcm9tVGV4dHVyZSxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzJztcbmltcG9ydCB7XG4gIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcbiAgVGVuc29yRnJvbU1MVGVuc29yT3B0aW9ucyxcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1xuICBjaGVja1R5cGVkQXJyYXksXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXksXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG59IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGUgfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IFRlbnNvclR5cGUsXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuIFR5cGUgaXMgaW5mZXJyZWQgZnJvbSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ21sLXRlbnNvcicuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYXJnMDpcbiAgICAgIHwgVGVuc29yVHlwZVxuICAgICAgfCBUZW5zb3JEYXRhVHlwZVxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfCByZWFkb25seSBzdHJpbmdbXVxuICAgICAgfCByZWFkb25seSBib29sZWFuW11cbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNcbiAgICAgIHwgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Zsb2F0MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ2NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnYm9vbCdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWxUZW5zb3JEYXRhID0gYXJnMC5tbFRlbnNvcjtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBvZiBsb2NhdGlvbiAnY3B1J1xuICAgICAgLy9cbiAgICAgIGxldCBkYXRhOiBUZW5zb3JEYXRhVHlwZTtcbiAgICAgIGxldCBtYXliZURpbXM6IHR5cGVvZiBhcmcxIHwgdHlwZW9mIGFyZzI7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGFyZzAgaXMgdHlwZSBvciBkYXRhXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIHR5cGUgPSBhcmcwO1xuICAgICAgICBtYXliZURpbXMgPSBhcmcyO1xuICAgICAgICBpZiAoYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgd2hldGhlciBldmVyeSBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBzdHJpbmc7IHRoaXMgaXMgdG9vIHNsb3cuIHdlIGFzc3VtZSBpdCdzIGNvcnJlY3QgYW5kXG4gICAgICAgICAgLy8gZXJyb3Igd2lsbCBiZSBwb3B1bGF0ZWQgYXQgaW5mZXJlbmNlXG4gICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgaWYgKChhcmcwID09PSAnZmxvYXQxNicgJiYgdHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSkgfHwgYXJnMCA9PT0gJ3VpbnQ0JyB8fCBhcmcwID09PSAnaW50NCcpIHtcbiAgICAgICAgICAgICAgLy8gLSAnZmxvYXQxNic6XG4gICAgICAgICAgICAgIC8vICAgV2hlbiBubyBGbG9hdDE2QXJyYXkgcG9seWZpbGwgaXMgdXNlZCwgd2UgY2Fubm90IGNyZWF0ZSAnZmxvYXQxNicgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5LlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAgIFRocm93IGVycm9yIGhlcmUgYmVjYXVzZSB3aGVuIHVzZXIgdHJ5IHRvIHVzZSBudW1iZXIgYXJyYXkgYXMgZGF0YSxcbiAgICAgICAgICAgICAgLy8gICBlLmcuIG5ldyBUZW5zb3IoJ2Zsb2F0MTYnLCBbMSwgMiwgMywgNF0sIGRpbXMpKSwgaXQgd2lsbCBhY3R1YWxseSBjYWxsXG4gICAgICAgICAgICAgIC8vICAgVWludDE2QXJyYXkuZnJvbShhcmcxKSB3aGljaCBnZW5lcmF0ZXMgd3JvbmcgZGF0YS5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gLSAndWludDQnIGFuZCAnaW50NCc6XG4gICAgICAgICAgICAgIC8vICAgVWludDhBcnJheS5mcm9tKGFyZzEpIHdpbGwgZ2VuZXJhdGUgd3JvbmcgZGF0YSBmb3IgJ3VpbnQ0JyBhbmQgJ2ludDQnIHRlbnNvci5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgQ3JlYXRpbmcgYSAke2FyZzB9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9IGFzIGRhdGEuYCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ3VpbnQ2NCcgfHwgYXJnMCA9PT0gJ2ludDY0Jykge1xuICAgICAgICAgICAgICAvLyB1c2UgJ2FzIGFueScgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzAwMlxuICAgICAgICAgICAgICAvLyAyLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdW5pb24gdHlwZSBvZiAnKEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yKS5mcm9tKCknXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXG4gICAgICAgICAgICAgIC8vIDMuIHBhcmFtZXRlcnMgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIHVuaW9uXG4gICAgICAgICAgICAgIC8vIHR5cGUuXG5cbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYmlnaW50W11cIiBoZXJlLlxuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBkYXRhID0gKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciBhcyBhbnkpLmZyb20oYXJnMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgaWYgKGFyZzAgPT09ICd1aW50OCcpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgbWF5YmVEaW1zID0gYXJnMTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzAgYXMgYW55W10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhcmcwIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICB0eXBlID0gJ3VpbnQ4JztcbiAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCB0ZW5zb3IgdHlwZSBmcm9tIFR5cGVkQXJyYXlcbiAgICAgICAgICBjb25zdCBtYXBwZWRUeXBlID0gTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5nZXQoXG4gICAgICAgICAgICBhcmcwLmNvbnN0cnVjdG9yIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobWFwcGVkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHthcmcwLmNvbnN0cnVjdG9yfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZSA9IG1hcHBlZFR5cGU7XG4gICAgICAgICAgZGF0YSA9IGFyZzAgYXMgU3VwcG9ydGVkVHlwZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xuICAgICAgaWYgKG1heWJlRGltcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGFzc3VtZSAxLUQgdGVuc29yIGlmIGRpbXMgb21pdHRlZFxuICAgICAgICBtYXliZURpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtYXliZURpbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGRpbXMgPSBtYXliZURpbXMgYXMgcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdjcHUnO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gY2hlY2sgb24gZGltc1xuICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVTaXplKGRpbXMpO1xuICAgIC8vIGlmIGRhdGEgaXMgb24gQ1BVLCBjaGVjayB3aGV0aGVyIGRhdGEgbGVuZ3RoIG1hdGNoZXMgdGVuc29yIHNpemVcbiAgICBpZiAodGhpcy5jcHVEYXRhICYmIHNpemUgIT09IHRoaXMuY3B1RGF0YS5sZW5ndGgpIHtcbiAgICAgIGlmICgodHlwZSA9PT0gJ3VpbnQ0JyB8fCB0eXBlID09PSAnaW50NCcpICYmIE1hdGguY2VpbChzaXplIC8gMikgPT09IHRoaXMuY3B1RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gZm9yICh1KWludDQsIHRoZSBkYXRhIGxlbmd0aCBpcyBoYWxmIG9mIHRoZSB0ZW5zb3Igc2l6ZS4gU28gd2UgY2hlY2sgdGhpcyBzcGVjaWFsIGNhc2Ugd2hlbiBzaXplIGlzIG9kZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3NpemV9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBmYWN0b3J5XG4gIHN0YXRpYyBhc3luYyBmcm9tSW1hZ2UoXG4gICAgaW1hZ2U6IEltYWdlRGF0YSB8IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzpcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnNcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xuICAgICAgfCBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUZW5zb3JJbnRlcmZhY2U+IHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxuICAgIHRleHR1cmU6IFRlbnNvclRleHR1cmVUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVRleHR1cmUodGV4dHVyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgZ3B1QnVmZmVyOiBUZW5zb3JHcHVCdWZmZXJUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+LFxuICApOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tR3B1QnVmZmVyKGdwdUJ1ZmZlciwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU1MVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuTUxUZW5zb3JEYXRhVHlwZXM+KFxuICAgIG1sVGVuc29yOiBUZW5zb3JNTFRlbnNvclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbU1MVGVuc29yT3B0aW9uczxUPixcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbU1MVGVuc29yKG1sVGVuc29yLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgICB0eXBlOiBULFxuICAgIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVBpbm5lZEJ1ZmZlcih0eXBlLCBidWZmZXIsIGRpbXMpO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gY29udmVyc2lvbnNcbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGVuc29yVG9EYXRhVVJMKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSB7XG4gICAgcmV0dXJuIHRlbnNvclRvSW1hZ2VEYXRhKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHB1YmxpYyBmaWVsZHNcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHR5cGU6IFRlbnNvclR5cGU7XG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJpdmF0ZSBmaWVsZHNcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGF0YUxvY2F0aW9uOiBUZW5zb3JEYXRhTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgZGF0YSBvbiBDUFUsIGlmIGxvY2F0aW9uIGlzICdjcHUnIG9yICdjcHUtcGlubmVkJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjcHVEYXRhPzogVGVuc29yRGF0YVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyB0ZXh0dXJlIHdoZW4gbG9jYXRpb24gaXMgJ3RleHR1cmUnLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdVRleHR1cmVEYXRhPzogVGVuc29yVGV4dHVyZVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBHUFUgYnVmZmVyIHdoZW4gbG9jYXRpb24gaXMgJ2dwdS1idWZmZXInLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdUJ1ZmZlckRhdGE/OiBUZW5zb3JHcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgV2ViTk4gTUxUZW5zb3Igd2hlbiBsb2NhdGlvbiBpcyAnbWwtdGVuc29yJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBtbFRlbnNvckRhdGE/OiBUZW5zb3JNTFRlbnNvclR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkb3dubG9hZGVyIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBkb3dubG9hZGVyPygpOiBQcm9taXNlPFRlbnNvckRhdGFUeXBlPjtcblxuICAvKipcbiAgICogYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGF0YSBpcyBiZWluZyBkb3dubG9hZGVkIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgaXNEb3dubG9hZGluZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkaXNwb3NlciBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2VyPygpOiB2b2lkO1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwcm9wZXJ0aWVzXG4gIGdldCBkYXRhKCk6IFRlbnNvckRhdGFUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmNwdURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsICcgK1xuICAgICAgICAgICdvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNwdURhdGE7XG4gIH1cblxuICBnZXQgbG9jYXRpb24oKTogVGVuc29yRGF0YUxvY2F0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhTG9jYXRpb247XG4gIH1cblxuICBnZXQgdGV4dHVyZSgpOiBUZW5zb3JUZXh0dXJlVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5ncHVUZXh0dXJlRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGE7XG4gIH1cblxuICBnZXQgZ3B1QnVmZmVyKCk6IFRlbnNvckdwdUJ1ZmZlclR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1QnVmZmVyRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YTtcbiAgfVxuXG4gIGdldCBtbFRlbnNvcigpOiBUZW5zb3JNTFRlbnNvclR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMubWxUZW5zb3JEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJOTiBNTFRlbnNvci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWxUZW5zb3JEYXRhO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIG1ldGhvZHNcblxuICBhc3luYyBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+IHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgc3dpdGNoICh0aGlzLmRhdGFMb2NhdGlvbikge1xuICAgICAgY2FzZSAnY3B1JzpcbiAgICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgY2FzZSAndGV4dHVyZSc6XG4gICAgICBjYXNlICdncHUtYnVmZmVyJzpcbiAgICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcbiAgICAgICAgaWYgKCF0aGlzLmRvd25sb2FkZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZG93bmxvYWRlcigpO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdjcHUnO1xuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICBpZiAocmVsZWFzZURhdGEgJiYgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlcigpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY3B1RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1sVGVuc29yRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0YUxvY2F0aW9uID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbnNvciBpcyBkaXNwb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKHRoaXMuZG93bmxvYWRlciB8fCB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JSZXNoYXBlKHRoaXMsIGRpbXMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yRmFjdG9yeSB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckltcGwgfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbmltcG9ydCB7IFR5cGVkVGVuc29yVXRpbHMgfSBmcm9tICcuL3RlbnNvci11dGlscy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuLyoqXG4gKiByZXByZXNlbnQgYSBiYXNpYyB0ZW5zb3Igd2l0aCBzcGVjaWZpZWQgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlLlxuICovXG5pbnRlcmZhY2UgVHlwZWRUZW5zb3JCYXNlPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gQ1BVIChlZy4gaXQncyBpbiB0aGUgZm9ybSBvZiBXZWJHTCB0ZXh0dXJlIG9yIFdlYkdQVSBidWZmZXIpLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbjtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHTCB0ZXh0dXJlLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHUFUgYnVmZmVyLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViTk4gTUxUZW5zb3IgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBpbiBhIFdlYk5OIE1MVGVuc29yLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IG1sVGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBkYXRhIG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmV0dXJucyB0aGUgZGF0YSBpbW1lZGlhdGVseS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCBkb3dubG9hZHMgdGhlIGRhdGEgYW5kIHJldHVybnMgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZWxlYXNlRGF0YSAtIHdoZXRoZXIgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuIElnbm9yZSBpZiBkYXRhIGlzIGFscmVhZHkgb24gQ1BVLlxuICAgKi9cbiAgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJlbW92ZSBpdHMgaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuXG4gICAqXG4gICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgdGhlIHRlbnNvciBpcyBjb25zaWRlcmVkIG5vIGxvbmdlciB2YWxpZC4gSXRzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdub25lJy5cbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRlbnNvciB7XG4gIGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xuICAgIHVpbnQ4OiBVaW50OEFycmF5O1xuICAgIGludDg6IEludDhBcnJheTtcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xuICAgIGludDE2OiBJbnQxNkFycmF5O1xuICAgIGludDMyOiBJbnQzMkFycmF5O1xuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xuICAgIHN0cmluZzogc3RyaW5nW107XG4gICAgYm9vbDogVWludDhBcnJheTtcbiAgICBmbG9hdDE2OiBVaW50MTZBcnJheTsgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gICAgdWludDQ6IFVpbnQ4QXJyYXk7XG4gICAgaW50NDogSW50OEFycmF5O1xuICB9XG5cbiAgaW50ZXJmYWNlIEVsZW1lbnRUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBudW1iZXI7XG4gICAgdWludDg6IG51bWJlcjtcbiAgICBpbnQ4OiBudW1iZXI7XG4gICAgdWludDE2OiBudW1iZXI7XG4gICAgaW50MTY6IG51bWJlcjtcbiAgICBpbnQzMjogbnVtYmVyO1xuICAgIGludDY0OiBiaWdpbnQ7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgYm9vbDogYm9vbGVhbjtcbiAgICBmbG9hdDE2OiBudW1iZXI7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBudW1iZXI7XG4gICAgdWludDMyOiBudW1iZXI7XG4gICAgdWludDY0OiBiaWdpbnQ7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gICAgdWludDQ6IG51bWJlcjtcbiAgICBpbnQ0OiBudW1iZXI7XG4gIH1cblxuICB0eXBlIERhdGFUeXBlID0gRGF0YVR5cGVNYXBbVHlwZV07XG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIENwdVBpbm5lZERhdGFUeXBlcyA9IEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPjtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZVR5cGUgPSBXZWJHTFRleHR1cmU7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogVGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgdXNlIHR5cGUgXCJHUFVCdWZmZXJcIiBkZWZpbmVkIGluIHdlYmdwdS5kLnRzIGZyb20gQHdlYmdwdS90eXBlcyBpcyBiZWNhdXNlIFwiQHdlYmdwdS90eXBlc1wiXG4gICAqIHJlcXVpcmVzIFwiQHR5cGVzL2RvbS13ZWJjb2RlY3NcIiBhcyBwZWVyIGRlcGVuZGVuY3kgd2hlbiB1c2luZyBUeXBlU2NyaXB0IDwgdjUuMSBhbmQgaXRzIHZlcnNpb24gbmVlZCB0byBiZSBjaG9zZW5cbiAgICogY2FyZWZ1bGx5IGFjY29yZGluZyB0byB0aGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGJlaW5nIHVzZWQuIFRoaXMgbWVhbnMgc28gZmFyIHRoZXJlIGlzIG5vdCBhIHdheSB0byBrZWVwIGV2ZXJ5XG4gICAqIFR5cGVTY3JpcHQgdmVyc2lvbiBoYXBweS4gSXQgdHVybnMgb3V0IHRoYXQgd2Ugd2lsbCBlYXNpbHkgYnJva2UgdXNlcnMgb24gc29tZSBUeXBlU2NyaXB0IHZlcnNpb24uXG4gICAqXG4gICAqIGZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHV3ZWIvdHlwZXMvaXNzdWVzLzEyN1xuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IHsgc2l6ZTogbnVtYmVyOyBtYXBTdGF0ZTogJ3VubWFwcGVkJyB8ICdwZW5kaW5nJyB8ICdtYXBwZWQnIH07XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYk5OIE1MVGVuc29yXG4gICAqXG4gICAqIFRoZSBzcGVjaWZpY2F0aW9uIGZvciBXZWJOTidzIE1MVGVuc29yIGlzIGN1cnJlbnRseSBpbiBmbHV4LlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgTUxUZW5zb3JUeXBlID0gdW5rbm93bjtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyRGF0YVR5cGVzID0gJ2Zsb2F0MzInIHwgJ2Zsb2F0MTYnIHwgJ2ludDMyJyB8ICdpbnQ2NCcgfCAndWludDMyJyB8ICd1aW50OCcgfCAnYm9vbCc7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvckRhdGFUeXBlcyA9XG4gICAgfCAnZmxvYXQzMidcbiAgICB8ICdmbG9hdDE2J1xuICAgIHwgJ2ludDgnXG4gICAgfCAndWludDgnXG4gICAgfCAnaW50MzInXG4gICAgfCAndWludDMyJ1xuICAgIHwgJ2ludDY0J1xuICAgIHwgJ3VpbnQ2NCdcbiAgICB8ICdib29sJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHdoZXJlIHRoZSB0ZW5zb3IgZGF0YSBpcyBzdG9yZWRcbiAgICovXG4gIGV4cG9ydCB0eXBlIERhdGFMb2NhdGlvbiA9ICdub25lJyB8ICdjcHUnIHwgJ2NwdS1waW5uZWQnIHwgJ3RleHR1cmUnIHwgJ2dwdS1idWZmZXInIHwgJ21sLXRlbnNvcic7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5UeXBlPiBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUPiwgVHlwZWRUZW5zb3JVdGlsczxUPiB7fVxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxuXG4vKipcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JDb25zdHJ1Y3RvciBleHRlbmRzIFRlbnNvckZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBzcGVjaWZ5IGVsZW1lbnQgdHlwZVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnc3RyaW5nJ10gfCByZWFkb25seSBzdHJpbmdbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChcbiAgICB0eXBlOiAnYm9vbCcsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIGEgVWludDhDbGFtcGVkQXJyYXksIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKHR5cGU6ICd1aW50OCcsIGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IDY0LWJpdCBpbnRlZ2VyIHR5cGVkIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyA8VCBleHRlbmRzICd1aW50NjQnIHwgJ2ludDY0Jz4oXG4gICAgdHlwZTogVCxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBudW1lcmljIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyA8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnIHwgJ2Jvb2wnIHwgJ3VpbnQ2NCcgfCAnaW50NjQnPj4oXG4gICAgdHlwZTogVCxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogRmxvYXQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogSW50OEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBCaWdJbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Jvb2wnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGZsb2F0NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEZsb2F0NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogQmlnVWludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50NjQnPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gZmFsbCBiYWNrIHRvIG5vbi1nZW5lcmljIHRlbnNvciB0eXBlIGRlY2xhcmF0aW9uXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6IFRlbnNvci5UeXBlLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZSB8IHJlYWRvbmx5IG51bWJlcltdIHwgcmVhZG9ubHkgc3RyaW5nW10gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBUZW5zb3IuRGF0YVR5cGUsIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbCBhcyBUZW5zb3JDb25zdHJ1Y3RvcjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0UgPSAoZGV2aWNlVHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lU3RhbXAoYCR7ZGV2aWNlVHlwZX06Ok9SVDo6JHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IFRSQUNFX0ZVTkMgPSAobXNnOiBzdHJpbmcsIGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKSB8fCBbXTtcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc1RyYWNlRnVuYyAmJiAhc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XG4gICAgICBpZiAoZXh0cmFNc2cpIHtcbiAgICAgICAgbGFiZWwgKz0gYDo6JHtleHRyYU1zZ31gO1xuICAgICAgfVxuICAgICAgVFJBQ0UoJ0NQVScsIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGhhc1RyYWNlRnVuYyA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdCRUdJTicsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZSB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EIH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsXG4gICAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShcbiAgICBhcmcwOiBzdHJpbmcgfCBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5LFxuICAgIGFyZzE/OiBTZXNzaW9uT3B0aW9ucyB8IG51bWJlcixcbiAgICBhcmcyPzogbnVtYmVyLFxuICAgIGFyZzM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBsZXQgb3B0aW9uczogU2Vzc2lvbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhcmcwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGFyZzAgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZzA7XG4gICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2J1ZmZlci5ieXRlTGVuZ3RofSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB9XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoZmlsZVBhdGhPclVpbnQ4QXJyYXksIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gIH1cblxuICBnZXQgaW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuaW1wb3J0IHsgT25ueE1vZGVsT3B0aW9ucyB9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUsIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIGlucHV0L291dHB1dCB0eXBlc1xuXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xuICB0eXBlIE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcblxuICAvKipcbiAgICogQSBmZWVkcyAobW9kZWwgaW5wdXRzKSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogLSBPbWl0dGVkLiBVc2UgbW9kZWwncyBvdXRwdXQgbmFtZXMgZGVmaW5pdGlvbi5cbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxuICAgKiAtIEFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIG9yIG51bGwgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEByZW1hcmtcbiAgICogZGlmZmVyZW50IGZyb20gaW5wdXQgYXJndW1lbnQsIGluIG91dHB1dCwgT25ueFZhbHVlIGlzIG9wdGlvbmFsLiBJZiBhbiBPbm54VmFsdWUgaXMgcHJlc2VudCBpdCB3aWxsIGJlXG4gICAqIHVzZWQgYXMgYSBwcmUtYWxsb2NhdGVkIHZhbHVlIGJ5IHRoZSBpbmZlcmVuY2UgZW5naW5lOyBpZiBvbWl0dGVkLCBpbmZlcmVuY2UgZW5naW5lIHdpbGwgYWxsb2NhdGUgYnVmZmVyXG4gICAqIGludGVybmFsbHkuXG4gICAqL1xuICB0eXBlIEZldGNoZXNUeXBlID0gcmVhZG9ubHkgc3RyaW5nW10gfCBOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgaW5mZXJlbmNpbmcgcmV0dXJuIHR5cGUgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBSZXR1cm5UeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBzZXNzaW9uIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIHNlc3Npb24gYmVoYXZpb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNlc3Npb25PcHRpb25zIGV4dGVuZHMgT25ueE1vZGVsT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBBbiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9uIGNhbiBiZSBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBuYW1lIG9mIHRoZSBleGVjdXRpb24gcHJvdmlkZXIsXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cbiAgICAgKi9cbiAgICBleGVjdXRpb25Qcm92aWRlcnM/OiByZWFkb25seSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludHJhIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRlck9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmcmVlRGltZW5zaW9uT3ZlcnJpZGVzPzogeyByZWFkb25seSBbZGltZW5zaW9uTmFtZTogc3RyaW5nXTogbnVtYmVyIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW1pemF0aW9uIGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/OiAnZGlzYWJsZWQnIHwgJ2Jhc2ljJyB8ICdleHRlbmRlZCcgfCAnYWxsJztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIENQVSBtZW1vcnkgYXJlbmEuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlQ3B1TWVtQXJlbmE/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgbWVtb3J5IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlTWVtUGF0dGVybj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBleGVjdXRpb25Nb2RlPzogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJztcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBtb2RlbCBmaWxlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXG4gICAgICogd2l0aCBhIHBvcC11cCB3aW5kb3cuXG4gICAgICovXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSB1c2UuXG4gICAgICovXG4gICAgZW5hYmxlUHJvZmlsaW5nPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEZpbGUgcHJlZml4IGZvciBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIHByb2ZpbGVGaWxlUHJlZml4Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIElELlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ0lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwIHwgMSB8IDIgfCAzIHwgNDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0cmluZyBhcyBhIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGZvciBhbGwgb3V0cHV0cywgb3IgYW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBhXG4gICAgICogcHJlZmVycmVkIGRhdGEgbG9jYXRpb24gYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHTCBhbmQgV2ViR1BVIEVQLlxuICAgICAqL1xuICAgIHByZWZlcnJlZE91dHB1dExvY2F0aW9uPzogT25ueFZhbHVlRGF0YUxvY2F0aW9uIHwgeyByZWFkb25seSBbb3V0cHV0TmFtZTogc3RyaW5nXTogT25ueFZhbHVlRGF0YUxvY2F0aW9uIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBncmFwaCBjYXB0dXJlLlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBlbmFibGVHcmFwaENhcHR1cmU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29uZmlndXJhdGlvbnMgZm9yIGEgc2Vzc2lvbi4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfc2Vzc2lvbl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgc2Vzc2lvbjoge1xuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXG4gICAgICogICAgIGRpc2FibGVfcHJlcGFja2luZzogXCIxXCJcbiAgICAgKiAgIH0sXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcbiAgICAgKiAgICAgZW5hYmxlX2dlbHVfYXBwcm94aW1hdGlvbjogXCIxXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xuXG4gIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGJhY2tlbmRzIHRvIHN1cHBvcnQgZXhlY3V0aW9uIHByb3ZpZGVyczpcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cbiAgLy8gQmFja2VuZCBXZWJBc3NlbWJseTogc3VwcG9ydHMgJ2NwdScsICd3YXNtJywgJ3dlYmdwdScgYW5kICd3ZWJubicuXG4gIC8vIEJhY2tlbmQgT05OWC5qczogc3VwcG9ydHMgJ3dlYmdsJy5cbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cbiAgaW50ZXJmYWNlIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwIHtcbiAgICBjb3JlbWw6IENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgY3VkYTogQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGRtbDogRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgdGVuc29ycnQ6IFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2FzbTogV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJncHU6IFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYm5uOiBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICB9XG5cbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlck5hbWUgPSBrZXlvZiBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcDtcbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZyA9XG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdXG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvblxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJOYW1lXG4gICAgfCBzdHJpbmc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XG4gICAgdXNlQXJlbmE/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjdWRhJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdkbWwnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2FzbSc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJnbCc7XG4gICAgLy8gVE9ETzogYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3hubnBhY2snO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdwdSc7XG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnIHwgJ05IV0MnO1xuICB9XG5cbiAgLy8gI3JlZ2lvbiBXZWJOTiBvcHRpb25zXG5cbiAgaW50ZXJmYWNlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJubic7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBjcmVhdGluZyBhIFdlYk5OIE1MQ29udGV4dC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RpY3RkZWYtbWxjb250ZXh0b3B0aW9uc1xuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTkNvbnRleHRPcHRpb25zIHtcbiAgICBkZXZpY2VUeXBlPzogJ2NwdScgfCAnZ3B1JyB8ICducHUnO1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2RlZmF1bHQnIHwgJ2xvdy1wb3dlcicgfCAnaGlnaC1wZXJmb3JtYW5jZSc7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aG91dCBNTENvbnRleHQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhvdXRNTENvbnRleHQgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSwgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgY29udGV4dD86IG5ldmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0LlxuICAgKlxuICAgKiBXaGVuIE1MQ29udGV4dCBpcyBwcm92aWRlZCwgdGhlIGRldmljZVR5cGUgaXMgYWxzbyByZXF1aXJlZCBzbyB0aGF0IHRoZSBXZWJOTiBFUCBjYW4gZGV0ZXJtaW5lIHRoZSBwcmVmZXJyZWRcbiAgICogY2hhbm5lbCBsYXlvdXQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XG4gICAgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcbiAgICAgIE9taXQ8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPixcbiAgICAgIFJlcXVpcmVkPFBpY2s8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPj4ge1xuICAgIGNvbnRleHQ6IHVua25vd24gLyogTUxDb250ZXh0ICovO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0IHdoaWNoIGlzIGNyZWF0ZWQgZnJvbSBHUFVEZXZpY2UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dC1ncHVkZXZpY2VcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2ViR3B1IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUge1xuICAgIGNvbnRleHQ6IHVua25vd24gLyogTUxDb250ZXh0ICovO1xuICAgIGdwdURldmljZTogdW5rbm93biAvKiBHUFVEZXZpY2UgKi87XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbiA9XG4gICAgfCBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0XG4gICAgfCBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XG4gICAgfCBXZWJOTk9wdGlvbnNXZWJHcHU7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3Fubic7XG4gICAgLy8gVE9ETyBhZGQgZmxhZ3NcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjb3JlbWwnO1xuICAgIC8qKlxuICAgICAqIFRoZSBiaXQgZmxhZ3MgZm9yIENvcmVNTCBleGVjdXRpb24gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBDT1JFTUxfRkxBR19VU0VfQ1BVX09OTFkgPSAweDAwMVxuICAgICAqIENPUkVNTF9GTEFHX0VOQUJMRV9PTl9TVUJHUkFQSCA9IDB4MDAyXG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9FTkFCTEVfREVWSUNFX1dJVEhfQU5FID0gMHgwMDRcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0FMTE9XX1NUQVRJQ19JTlBVVF9TSEFQRVMgPSAweDAwOFxuICAgICAqIENPUkVNTF9GTEFHX0NSRUFURV9NTFBST0dSQU0gPSAweDAxMFxuICAgICAqIENPUkVNTF9GTEFHX1VTRV9DUFVfQU5EX0dQVSA9IDB4MDIwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBTZWUgaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Byb3ZpZGVycy9jb3JlbWwvY29yZW1sX3Byb3ZpZGVyX2ZhY3RvcnkuaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcpLlxuICAgICAqL1xuICAgIGNvcmVNbEZsYWdzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byB1c2UgQ1BVIG9ubHkgaW4gQ29yZU1MIEVQLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIHVzZUNQVU9ubHk/OiBib29sZWFuO1xuICAgIHVzZUNQVUFuZEdQVT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBDb3JlTUwgRVAgb24gc3ViZ3JhcGguXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIG9ubHkgZW5hYmxlIENvcmVNTCBFUCBmb3IgQXBwbGUgZGV2aWNlcyB3aXRoIEFORSAoQXBwbGUgTmV1cmFsIEVuZ2luZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTm5hcGlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xuICAgIHVzZUZQMTY/OiBib29sZWFuO1xuICAgIHVzZU5DSFc/OiBib29sZWFuO1xuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcbiAgICBjcHVPbmx5PzogYm9vbGVhbjtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcnVuIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIGluZmVyZW5jZSBydW4gYmVoYXZpb3JcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwIHwgMSB8IDIgfCAzIHwgNDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgYWxsIGluY29tcGxldGUgT3J0UnVuIGNhbGxzIGFzIHNvb24gYXMgcG9zc2libGUgaWYgdHJ1ZVxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIHRlcm1pbmF0ZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIHRhZyBmb3IgdGhlIFJ1bigpIGNhbGxzIHVzaW5nIHRoaXNcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICB0YWc/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzaW5nbGUgcnVuIGNvbmZpZ3VyYXRpb24gZW50cnkuIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3J1bl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4dHJhOiB7XG4gICAgICogICBtZW1vcnk6IHtcbiAgICAgKiAgICAgZW5hYmxlX21lbW9yeV9hcmVuYV9zaHJpbmthZ2U6IFwiMVwiLFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBleHRyYT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdmFsdWUgbWV0YWRhdGFcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZVxuICBpbnRlcmZhY2UgVmFsdWVNZXRhZGF0YSB7XG4gICAgLy8gVEJEXG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvciBkZXRhaWwuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uT3V0cHV0VHlwZWAgZm9yXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YT4+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gT05OWCBtb2RlbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBvciBmaWxlIHBhdGggb2YgdGhlIG1vZGVsIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUodXJpOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIHNlZ21lbnQgb2YgYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICBieXRlTGVuZ3RoPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgYW4gT05OWCBtb2RlbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uOiBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSA9IEluZmVyZW5jZVNlc3Npb25JbXBsO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsIE9wdGlvbnNUZW5zb3JMYXlvdXQgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvblV0aWxzIHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGEgRGF0YVVSTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiBAcmV0dXJucyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yLCBUeXBlZFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgSW1hZ2VGb3JtYXQgPSAnUkdCJyB8ICdSR0JBJyB8ICdCR1InIHwgJ1JCRyc7XG5leHBvcnQgdHlwZSBJbWFnZVRlbnNvckxheW91dCA9ICdOSFdDJyB8ICdOQ0hXJztcblxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb24uXG5cbi8vICNyZWdpb24gdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb25cblxuLyoqXG4gKiByZXByZXNlbnQgY29tbW9uIHByb3BlcnRpZXMgb2YgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqL1xuaW50ZXJmYWNlIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiBleHRlbmRzIFBpY2s8VGVuc29yLCAnZGltcyc+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBHUFUgcmVzb3VyY2UuXG4gKi9cbmludGVyZmFjZSBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxuICAgKi9cbiAgZG93bmxvYWQ/KCk6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkaXNwb3NlPygpOiB2b2lkO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHBpbm5lZCBDUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzID0gVGVuc29yLkNwdVBpbm5lZERhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2NwdS1waW5uZWQnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIENQVSBwaW5uZWQgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcyA9IFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAndGV4dHVyZScuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ3RleHR1cmUnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0gVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdncHUtYnVmZmVyJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPSBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdtbC10ZW5zb3InLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdtbC10ZW5zb3InO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IG1sVGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgb2YgZWFjaCBpbmRpdmlkdWFsIG9wdGlvbnMuXG4vLyB0aGUgdGVuc29yIGZhY3RvcnkgZnVuY3Rpb25zIHVzZSBhIGNvbXBvc2l0aW9uIG9mIHRob3NlIG9wdGlvbnMgYXMgdGhlIHBhcmFtZXRlciB0eXBlLlxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgZmllbGRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCByZXByZXNlbnRlZCBpbiBSR0JBIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckZvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIG9wdGlvbiAnZm9ybWF0Jy4gV2hpbGUgb3B0aW9uICdmb3JtYXQnIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsIGltYWdlLCAndGVuc29yRm9ybWF0J1xuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cbiAgICovXG4gIHRlbnNvckZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiAnZmxvYXQzMicgfCAndWludDgnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JMYXlvdXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSB0ZW5zb3IgbGF5b3V0IHdoZW4gcmVwcmVzZW50aW5nIGRhdGEgb2Ygb25lIG9yIG1vcmUgaW1hZ2UocykuXG4gICAqL1xuICB0ZW5zb3JMYXlvdXQ/OiBJbWFnZVRlbnNvckxheW91dDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGhlaWdodCBpbiBwaXhlbFxuICAgKi9cbiAgaGVpZ2h0PzogbnVtYmVyO1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSB3aWR0aCBpbiBwaXhlbFxuICAgKi9cbiAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSByZXNpemVkIGhlaWdodC4gSWYgb21pdHRlZCwgb3JpZ2luYWwgaGVpZ2h0IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHJlc2l6ZWRIZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgcmVzaXplZCB3aWR0aCAtIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGVuc29yIGRpbWVuc2lvbnMgYXMgd2VsbFxuICAgKi9cbiAgcmVzaXplZFdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgbm9ybWFsaXphdGlvbiBwYXJhbWV0ZXJzIHdoZW4gcHJlcHJvY2Vzc2luZyB0aGUgaW1hZ2UgYXMgbW9kZWwgaW5wdXQuXG4gICAqXG4gICAqIERhdGEgZWxlbWVudCBhcmUgcmFuZ2VkIGZyb20gMCB0byAyNTUuXG4gICAqL1xuICBub3JtPzoge1xuICAgIC8qKlxuICAgICAqIFRoZSAnYmlhcycgdmFsdWUgZm9yIGltYWdlIG5vcm1hbGl6YXRpb24uXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAwLlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIGJpYXM/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMjU1LlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgfTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21VcmxPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsXG4gICAgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPlxuICBleHRlbmRzIFJlcXVpcmVkPE9wdGlvbnNEaW1lbnNpb25zPixcbiAgICBPcHRpb25zRm9ybWF0LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IC8qIFRPRE86IGFkZCBtb3JlICovIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogVDtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vKipcbiAqIHR5cGUgVGVuc29yRmFjdG9yeSBkZWZpbmVzIHRoZSBmYWN0b3J5IGZ1bmN0aW9ucyBvZiAnVGVuc29yJyB0byBjcmVhdGUgdGVuc29yIGluc3RhbmNlcyBmcm9tIGV4aXN0aW5nIGRhdGEgb3JcbiAqIHJlc291cmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGYWN0b3J5IHtcbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGFuIEltYWdlRGF0YSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRGF0YSAtIHRoZSBJbWFnZURhdGEgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSW1hZ2VEYXRhLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgSFRNTEltYWdlRWxlbWVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEhUTUxJbWFnZUVsZW1lbnQuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShcbiAgICBpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxuICAgKlxuICAgKiBAcGFyYW0gdXJsU291cmNlIC0gYSBzdHJpbmcgYXMgYSBVUkwgdG8gdGhlIGltYWdlIG9yIGEgZGF0YSBVUkwgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKHVybFNvdXJjZTogc3RyaW5nLCBvcHRpb25zPzogVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGFuIEltYWdlQml0bWFwIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gYml0bWFwIC0gdGhlIEltYWdlQml0bWFwIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKFxuICAgIGJpdG1hcDogSW1hZ2VCaXRtYXAsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICpcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdMIHRleHR1cmUuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYHdpZHRoYDogdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgaGVpZ2h0YDogdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gUmVxdWlyZWQuXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcbiAgICB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuICApOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBHUFVCdWZmZXIgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIEdQVSB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YVxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcbiAgICogbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiBHUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YSB3aWxsIG5vdCBiZSBkaXNwb3NlZC5cbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5zb3IgLSB0aGUgTUxUZW5zb3Igb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gYSBXZWJOTiBNTFRlbnNvci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIHRoZSBNTFRlbnNvciB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvclxuICAgKiBkYXRhIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgdGhlIFdlYk5OIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy5cbiAgICogVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiB0aGUgV2ViTk4gTUxUZW5zb3IuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvciB3aWxsXG4gICAqIG5vdCBiZSBkaXNwb3NlZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSB0aGUgV2ViTk4gYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvXG4gICAqIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tTUxUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz4oXG4gICAgdGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLiBUaGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhcyBhIHBpbm5lZCBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBidWZmZXIgLSBhIFR5cGVkQXJyYXkgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZS5cbiAgICogQHBhcmFtIGRpbXMgLSBzcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVBpbm5lZEJ1ZmZlcjxUIGV4dGVuZHMgRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyc+PihcbiAgICB0eXBlOiBULFxuICAgIGJ1ZmZlcjogVGVuc29yLkRhdGFUeXBlTWFwW1RdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxuICpcbiAqIFBhdGggaXMgdmFpbGFibGUgb25seSBpbiBvbm54cnVudGltZS1ub2RlIG9yIG9ubnhydW50aW1lLXdlYiBydW5uaW5nIGluIE5vZGUuanMuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVVcmxPclBhdGggPSBzdHJpbmc7XG5cbi8qKlxuICogQSBCbG9iIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XG5cbi8qKlxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxuICpcbiAqIFdoZW4gaXQgaXMgYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIsIHRoZSB3aG9sZSBidWZmZXIgaXMgYXNzdW1lZCB0byBiZSB0aGUgZmlsZSBjb250ZW50LlxuICovXG5leHBvcnQgdHlwZSBGaWxlRGF0YSA9IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlckxpa2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZpbGUgdGhhdCBjYW4gYmUgbG9hZGVkIGJ5IHRoZSBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVUeXBlID0gRmlsZVVybE9yUGF0aCB8IEZpbGVCbG9iIHwgRmlsZURhdGE7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAgICovXG4gIGRhdGE6IEZpbGVUeXBlO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZmlsZSBwYXRoLlxuICAgKi9cbiAgcGF0aDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICpcbiAqIFdoZW4gdXNpbmcgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBhIGZpbGUgVVJMIG9yIHBhdGggdGhhdCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhlIG1vZGVsIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHwgRmlsZVVybE9yUGF0aDtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBtb2RlbCBsb2FkaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9ubnhNb2RlbE9wdGlvbnMge1xuICAvKipcbiAgICogU3BlY2lmeWluZyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCByZXByZXNlbnRzIHRoZSBleHRlcm5hbCBkYXRhLlxuICAgKi9cbiAgZXh0ZXJuYWxEYXRhPzogcmVhZG9ubHkgRXh0ZXJuYWxEYXRhRmlsZVR5cGVbXTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBOb25UZW5zb3JUeXBlID0gbmV2ZXI7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWUgUmVwcmVzZW50cyBib3RoIHRlbnNvcnMgYW5kIG5vbi10ZW5zb3JzIHZhbHVlIGZvciBtb2RlbCdzIGlucHV0cy9vdXRwdXRzLlxuICpcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZSA9IFRlbnNvciB8IE5vblRlbnNvclR5cGU7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gcmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgb2YgYW4gT25ueFZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gPSBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IFNlc3Npb25IYW5kbGVyLCBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRyYWluaW5nU2Vzc2lvbiBhcyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2UsIFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMgfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZTtcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucztcblxuY29uc3Qgbm9CYWNrZW5kRXJyTXNnOiBzdHJpbmcgPVxuICAnVHJhaW5pbmcgYmFja2VuZCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuICcgKyBcIk1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbiAmIFdlYkFzc2VtYmx5IGZpbGVzLlwiO1xuXG5leHBvcnQgY2xhc3MgVHJhaW5pbmdTZXNzaW9uIGltcGxlbWVudHMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyLCBoYXNPcHRpbWl6ZXJNb2RlbDogYm9vbGVhbiwgaGFzRXZhbE1vZGVsOiBib29sZWFuKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmhhc09wdGltaXplck1vZGVsID0gaGFzT3B0aW1pemVyTW9kZWw7XG4gICAgdGhpcy5oYXNFdmFsTW9kZWwgPSBoYXNFdmFsTW9kZWw7XG4gIH1cbiAgcHJpdmF0ZSBoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyO1xuICBwcml2YXRlIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuO1xuICBwcml2YXRlIGhhc0V2YWxNb2RlbDogYm9vbGVhbjtcblxuICBnZXQgdHJhaW5pbmdJbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IHRyYWluaW5nT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXQgZXZhbElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsSW5wdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG4gIGdldCBldmFsT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsT3V0cHV0TmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0cmFpbmluZyBzZXNzaW9uIGhhcyBubyBldmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgdHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLFxuICAgIHNlc3Npb25PcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uPiB7XG4gICAgY29uc3QgZXZhbE1vZGVsOiBzdHJpbmcgfCBVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpbWl6ZXJNb2RlbDogc3RyaW5nIHwgVWludDhBcnJheSA9IHRyYWluaW5nT3B0aW9ucy5vcHRpbWl6ZXJNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpb25zOiBTZXNzaW9uT3B0aW9ucyA9IHNlc3Npb25PcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgaWYgKGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcikge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcihcbiAgICAgICAgdHJhaW5pbmdPcHRpb25zLmNoZWNrcG9pbnRTdGF0ZSxcbiAgICAgICAgdHJhaW5pbmdPcHRpb25zLnRyYWluTW9kZWwsXG4gICAgICAgIGV2YWxNb2RlbCxcbiAgICAgICAgb3B0aW1pemVyTW9kZWwsXG4gICAgICAgIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdTZXNzaW9uKGhhbmRsZXIsICEhdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsLCAhIXRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9CYWNrZW5kRXJyTXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBydW5UcmFpblN0ZXAgYW5kIGZ1dHVyZSBydW5TdGVwIG1ldGhvZHMgdGhhdCBoYW5kbGVzIHRoZSB0eXBlLW5hcnJvd2luZyBjb252ZXJzaW9uIGZyb21cbiAgICogdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgYW5kIFJ1bk9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dE5hbWVzIHRoZSBmZWVkcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZXkgY29udGFpbiBhbGwgaW5wdXQgbmFtZXMgaW4gdGhlIHByb3ZpZGVkIGxpc3Qgb2YgaW5wdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBvdXRwdXROYW1lcyB0aGUgZmV0Y2hlcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZWlyIGtleXMgbWF0Y2ggdXAgd2l0aCB2YWxpZCBuYW1lcyBpbiB0aGUgbGlzdCBvZiBvdXRwdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBmZWVkcyB0aGUgcmVxdWlyZWQgaW5wdXRcbiAgICogQHBhcmFtIGFyZzEgbmFycm93ZWQgJiBjb252ZXJ0ZWQgaW50byB0aGUgU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgb3IgUnVuT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIGFyZzIgb3B0aW9uYWwgUnVuT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB0eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgZmVlZHM6IEZlZWRzVHlwZSxcbiAgICBhcmcxPzogRmV0Y2hlc1R5cGUgfCBSdW5PcHRpb25zLFxuICAgIGFyZzI/OiBSdW5PcHRpb25zLFxuICApOiBbU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsIFJ1bk9wdGlvbnNdIHtcbiAgICBjb25zdCBmZXRjaGVzOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsIH0gPSB7fTtcbiAgICBsZXQgb3B0aW9uczogUnVuT3B0aW9ucyA9IHt9O1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgYXJnMSBpcyBmZXRjaGVzIG9yIG9wdGlvbnNcbiAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcmcxS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZzEpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmZXRjaGVzLCBvcHRpb25zXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIGZvciBydW5UcmFpblN0ZXAgYW5kIGFueSBvdGhlciBydW5TdGVwIG1ldGhvZHMuIFRha2VzIHRoZSBSZXR1cm5UeXBlIHJlc3VsdCBmcm9tIHRoZSBTZXNzaW9uSGFuZGxlclxuICAgKiBhbmQgY2hhbmdlcyBpdCBpbnRvIGEgbWFwIG9mIFRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSByZXN1bHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlKTogUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaGFuZGxlci5sYXp5UmVzZXRHcmFkKCk7XG4gIH1cblxuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID0gdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICAgIHRoaXMudHJhaW5pbmdJbnB1dE5hbWVzLFxuICAgICAgdGhpcy50cmFpbmluZ091dHB1dE5hbWVzLFxuICAgICAgZmVlZHMsXG4gICAgICBhcmcxLFxuICAgICAgYXJnMixcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuVHJhaW5TdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzKTtcbiAgfVxuXG4gIGFzeW5jIHJ1bk9wdGltaXplclN0ZXAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyB8IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmhhc09wdGltaXplck1vZGVsKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucnVuT3B0aW1pemVyU3RlcChvcHRpb25zIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gT3B0aW1pemVyTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlIHwgUnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIGNvbnN0IFtmZXRjaGVzLCBvcHRpb25zXSA9IHRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAoXG4gICAgICAgIHRoaXMuZXZhbElucHV0TmFtZXMsXG4gICAgICAgIHRoaXMuZXZhbE91dHB1dE5hbWVzLFxuICAgICAgICBmZWVkcyxcbiAgICAgICAgYXJnMSxcbiAgICAgICAgYXJnMixcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bkV2YWxTdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBFdmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXk6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFyYW1zU2l6ZSA9IGF3YWl0IHRoaXMuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gICAgLy8gY2hlY2tpbmcgdGhhdCB0aGUgc2l6ZSBvZiB0aGUgVWludDhBcnJheSBpcyBlcXVpdmFsZW50IHRvIHRoZSBieXRlIGxlbmd0aCBvZiBhIEZsb2F0MzJBcnJheSBvZiB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGFyYW1ldGVyc1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDQgKiBwYXJhbXNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdTaXplIG9mIHRoZSBidWZmZXIgcGFzc2VkIGludG8gbG9hZFBhcmFtZXRlcnNCdWZmZXIgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgaW4gJyArXG4gICAgICAgICAgJ3RoZSBtb2RlbC4gUGxlYXNlIHVzZSBnZXRQYXJhbWV0ZXJzU2l6ZSBtZXRob2QgdG8gY2hlY2suJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIubG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXksIHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPE9ubnhWYWx1ZT4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW1wbCB9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi1pbXBsLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEVpdGhlciBVUkkgZmlsZSBwYXRoIChzdHJpbmcpIG9yIFVpbnQ4QXJyYXkgY29udGFpbmluZyBtb2RlbCBvciBjaGVja3BvaW50IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgdHlwZSBVcmlPckJ1ZmZlciA9IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIHRyYWluaW5nIHNlc3Npb24sXG4gKiB3aGljaCBjb250YWlucyBhIG1vZGVsIHRoYXQgY2FuIGJlIHRyYWluZWQsIGFuZCwgb3B0aW9uYWxseSxcbiAqIGFuIGV2YWwgYW5kIG9wdGltaXplciBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIExhemlseSByZXNldHMgdGhlIGdyYWRpZW50cyBvZiBhbGwgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdG8gemVyby4gU2hvdWxkIGhhcHBlbiBhZnRlciB0aGUgaW52b2NhdGlvbiBvZlxuICAgKiBydW5PcHRpbWl6ZXJTdGVwLlxuICAgKi9cbiAgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gVHJhaW5TdGVwIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yXG4gICBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRyYWluIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBzaW5nbGUgb3B0aW1pemVyIHN0ZXAsIHdoaWNoIHBlcmZvcm1zIHdlaWdodCB1cGRhdGVzIGZvciB0aGUgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIG9wdGltaXplciBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBvcHRpbWl6aW5nLlxuICAgKi9cbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKFxuICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb3B5IHBhcmFtZXRlcnNcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGFsbCBwYXJhbWV0ZXJzIGZvciB0aGUgdHJhaW5pbmcgc3RhdGUuIENhbGN1bGF0ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBwcmltaXRpdmUgKGRhdGF0eXBlIG9mXG4gICAqIHRoZSBwYXJhbWV0ZXJzKSBlbGVtZW50cyBvZiBhbGwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIHRyYWluaW5nIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgZm9yIHRyYWluYWJsZSBwYXJhbXMgb25seS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPjtcblxuICAvKipcbiAgICogQ29waWVzIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIHRvIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGhcbiAgICogcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgRmxvYXQzMiBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFRydWUgaWYgdHJhaW5hYmxlIHBhcmFtZXRlcnMgb25seSB0byBiZSBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIG1vZGVsIHBhcmFtZXRlcnMgdG8gYSBjb250aWd1b3VzIGJ1ZmZlci4gVXN1YWxseSB1c2VkIGluIHRoZSBjb250ZXh0IG9mIEZlZGVyYXRlZCBMZWFybmluZy5cbiAgICogQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGggcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgb25seSB0cmFpbmFibGUgcGFyYW1ldGVycyBhcmUgY29waWVkLiBUcmFpbmFibGUgcGFyYW1ldGVycyBhcmUgcGFyYW1ldGVyc1xuICAgKiBmb3Igd2hpY2ggcmVxdWlyZXNfZ3JhZCBpcyBzZXQgdG8gdHJ1ZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZsb2F0MzIgT25ueFZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgcGFyYW1ldGVycy5cbiAgICovXG4gIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPE9ubnhWYWx1ZT47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIGV2YWwgbW9kZWwuIElzIGFuIGVtcHR5IGFycmF5IGlmIG5vIGV2YWwgbW9kZWwgaXMgbG9hZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byB0aGUgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIGEgLmNrcHQgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBjaGVja3BvaW50IGZvciB0aGUgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICBjaGVja3BvaW50U3RhdGU6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCB0cmFpbmluZyBmaWxlLlxuICAgKi9cbiAgdHJhaW5Nb2RlbDogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBvcHRpbWl6ZXIgbW9kZWwgZmlsZS5cbiAgICovXG4gIG9wdGltaXplck1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBldmFsIG1vZGVsIGZpbGUuXG4gICAqL1xuICBldmFsTW9kZWw/OiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG59XG5cbi8qKlxuICogRGVmaW5lcyBtZXRob2Qgb3ZlcmxvYWQgcG9zc2liaWxpdGllcyBmb3IgY3JlYXRpbmcgYSBUcmFpbmluZ1Nlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ1Nlc3Npb24gYW5kIGFzeW5jaHJvbm91c2x5IGxvYWRzIGFueSBtb2RlbHMgcGFzc2VkIGluIHRocm91Z2ggdHJhaW5pbmdPcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmluZ09wdGlvbnMgc3BlY2lmeSBtb2RlbHMgYW5kIGNoZWNrcG9pbnRzIHRvIGxvYWQgaW50byB0aGUgVHJhaW5pbmcgU2Vzc2lvblxuICAgKiBAcGFyYW0gc2Vzc2lvbk9wdGlvbnMgc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciB0cmFpbmluZyBzZXNzaW9uIGJlaGF2aW9yXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFRyYWluaW5nU2Vzc2lvbiBvYmplY3RcbiAgICovXG4gIGNyZWF0ZShcbiAgICB0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsXG4gICAgc2Vzc2lvbk9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVHJhaW5pbmdTZXNzaW9uOiBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5ID0gVHJhaW5pbmdTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgV2ViR0xDb250ZXh0IH0gZnJvbSAnLi9iYWNrZW5kcy93ZWJnbC93ZWJnbC1jb250ZXh0JztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIExvZ2dlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgU2V2ZXJpdHlUeXBlTWFwIHtcbiAgICB2ZXJib3NlOiAndic7XG4gICAgaW5mbzogJ2knO1xuICAgIHdhcm5pbmc6ICd3JztcbiAgICBlcnJvcjogJ2UnO1xuICAgIGZhdGFsOiAnZic7XG4gIH1cblxuICBleHBvcnQgdHlwZSBTZXZlcml0eSA9IGtleW9mIFNldmVyaXR5VHlwZU1hcDtcblxuICBleHBvcnQgdHlwZSBQcm92aWRlciA9ICdub25lJyB8ICdjb25zb2xlJztcblxuICAvKipcbiAgICogTG9nZ2luZyBjb25maWcgdGhhdCB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIGxvZ2dlclxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIGxvZ2dpbmcgcHJvdmlkZXIuICdjb25zb2xlJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgcHJvdmlkZXI/OiBQcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBtaW5pbWFsIGxvZ2dlciBzZXJ2ZXJpdHkuICd3YXJuaW5nJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbWluaW1hbFNldmVyaXR5PzogTG9nZ2VyLlNldmVyaXR5O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3V0cHV0IGRhdGUgdGltZSBpbiBsb2cuIHRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ0RhdGVUaW1lPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG91dHB1dCBzb3VyY2UgaW5mb3JtYXRpb24gKE5vdCB5ZXQgc3VwcG9ydGVkKS4gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ1NvdXJjZUxvY2F0aW9uPzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcml6ZWRMb2dnZXIge1xuICAgIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICAgIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICAoY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlcjtcblxuICB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHZlcmJvc2UoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgaW5mbyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHdhcm5pbmcoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgd2FybmluZyhjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgbG9nZ2VyIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBjb25maWcgc3BlY2lmeSBhbiBvcHRpb25hbCBkZWZhdWx0IGNvbmZpZ1xuICAgKi9cbiAgcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvZ2dlcidzIGJlaGF2aW9yIG9uIHRoZSBnaXZlbiBjYXRlZ29yeVxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgc3BlY2lmeSBhIGNhdGVnb3J5IHN0cmluZy4gSWYgJyonIGlzIHNwZWNpZmllZCwgYWxsIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBvdmVyd3JpdHRlbi4gSWZcbiAgICogJycgaXMgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBjb25maWcgdGhlIGNvbmZpZyBvYmplY3QgdG8gaW5kaWNhdGUgdGhlIGxvZ2dlcidzIGJlaGF2aW9yXG4gICAqL1xuICBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZDtcblxuICAvKipcbiAgICogU2V0IHRoZSBsb2dnZXIncyBiZWhhdmlvciBmcm9tIG9ydC1jb21tb24gZW52XG4gICAqIEBwYXJhbSBlbnYgdGhlIGVudiB1c2VkIHRvIHNldCBsb2dnZXIuIEN1cnJlbnRseSBvbmx5IHNldHRpbmcgbG9nbGV2ZWwgaXMgc3VwcG9ydGVkIHRocm91Z2ggRW52LlxuICAgKi9cbiAgc2V0V2l0aEVudihlbnY6IEVudik6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBMb2dnZXJQcm92aWRlciB7XG4gIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjb250ZW50OiBzdHJpbmcsIGNhdGVnb3J5Pzogc3RyaW5nKTogdm9pZDtcbn1cbmNsYXNzIE5vT3BMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKF9zZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBfY29udGVudDogc3RyaW5nLCBfY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cbn1cbmNsYXNzIENvbnNvbGVMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY29sb3Ioc2V2ZXJpdHkpfSAke2NhdGVnb3J5ID8gJ1xceDFiWzM1bScgKyBjYXRlZ29yeSArICdcXHgxYlswbSAnIDogJyd9JHtjb250ZW50fWApO1xuICB9XG5cbiAgcHJpdmF0ZSBjb2xvcihzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5KSB7XG4gICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzQ7NDBtdlxceDFiWzBtJztcbiAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMybWlcXHgxYlswbSc7XG4gICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlszMDs0M213XFx4MWJbMG0nO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMxOzQwbWVcXHgxYlswbSc7XG4gICAgICBjYXNlICdmYXRhbCc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMTAxbWZcXHgxYlswbSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNldmVyaXR5OiAke3NldmVyaXR5fWApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRVZFUklUWV9WQUxVRSA9IHtcbiAgdmVyYm9zZTogMTAwMCxcbiAgaW5mbzogMjAwMCxcbiAgd2FybmluZzogNDAwMCxcbiAgZXJyb3I6IDUwMDAsXG4gIGZhdGFsOiA2MDAwLFxufTtcblxuY29uc3QgTE9HR0VSX1BST1ZJREVSX01BUDogeyByZWFkb25seSBbcHJvdmlkZXI6IHN0cmluZ106IFJlYWRvbmx5PExvZ2dlclByb3ZpZGVyPiB9ID0ge1xuICBbJ25vbmUnXTogbmV3IE5vT3BMb2dnZXJQcm92aWRlcigpLFxuICBbJ2NvbnNvbGUnXTogbmV3IENvbnNvbGVMb2dnZXJQcm92aWRlcigpLFxufTtcbmNvbnN0IExPR0dFUl9ERUZBVUxUX0NPTkZJRyA9IHtcbiAgcHJvdmlkZXI6ICdjb25zb2xlJyxcbiAgbWluaW1hbFNldmVyaXR5OiAnd2FybmluZycsXG4gIGxvZ0RhdGVUaW1lOiB0cnVlLFxuICBsb2dTb3VyY2VMb2NhdGlvbjogZmFsc2UsXG59O1xubGV0IExPR0dFUl9DT05GSUdfTUFQOiB7IFtjYXRlZ29yeTogc3RyaW5nXTogUmVhZG9ubHk8UmVxdWlyZWQ8TG9nZ2VyLkNvbmZpZz4+IH0gPSB7XG4gIFsnJ106IExPR0dFUl9ERUZBVUxUX0NPTkZJRyBhcyBSZXF1aXJlZDxMb2dnZXIuQ29uZmlnPixcbn07XG5cbmZ1bmN0aW9uIGxvZyhjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuZnVuY3Rpb24gbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG5mdW5jdGlvbiBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbmZ1bmN0aW9uIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBhcmcxOiBzdHJpbmcsIGFyZzI/OiBzdHJpbmcpOiB2b2lkO1xuZnVuY3Rpb24gbG9nKFxuICBhcmcwOiBzdHJpbmcgfCBMb2dnZXIuU2V2ZXJpdHksXG4gIGFyZzE/OiBzdHJpbmcsXG4gIGFyZzI/OiBzdHJpbmcgfCBudW1iZXIsXG4gIGFyZzM/OiBudW1iZXIsXG4pOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXIgfCB2b2lkIHtcbiAgaWYgKGFyZzEgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuICAgIHJldHVybiBjcmVhdGVDYXRlZ29yaXplZExvZ2dlcihhcmcwKTtcbiAgfSBlbHNlIGlmIChhcmcyID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNvbnRlbnQpO1xuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcxLCAxKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicgJiYgYXJnMyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjb250ZW50LCBzdGFjaylcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMSwgYXJnMik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnICYmIGFyZzMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY2F0ZWdvcnksIGNvbnRlbnQpXG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzIsIDEsIGFyZzEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnMyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNhdGVnb3J5LCBjb250ZW50LCBzdGFjaylcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMiwgYXJnMywgYXJnMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgaXMgdmFsaWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXRlZ29yaXplZExvZ2dlcihjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJib3NlOiBsb2cudmVyYm9zZS5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICBpbmZvOiBsb2cuaW5mby5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICB3YXJuaW5nOiBsb2cud2FybmluZy5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICBlcnJvcjogbG9nLmVycm9yLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIGZhdGFsOiBsb2cuZmF0YWwuYmluZChudWxsLCBjYXRlZ29yeSksXG4gIH07XG59XG5cbi8vIE5PVEU6IGFyZ3VtZW50ICdjYXRlZ29yeScgaXMgcHV0IHRoZSBsYXN0IHBhcmFtZXRlciBiZWFjYXVzZSB0eXBlc2NyaXB0XG4vLyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIGFyZ3VtZW50IHB1dCBpbiBmcm9udCBvZiByZXF1aXJlZCBhcmd1bWVudC4gVGhpc1xuLy8gb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gYSB1c3VhbCBsb2dnaW5nIEFQSS5cbmZ1bmN0aW9uIGxvZ0ludGVybmFsKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgX3N0YWNrOiBudW1iZXIsIGNhdGVnb3J5Pzogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbmZpZyA9IExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5IHx8ICcnXSB8fCBMT0dHRVJfQ09ORklHX01BUFsnJ107XG4gIGlmIChTRVZFUklUWV9WQUxVRVtzZXZlcml0eV0gPCBTRVZFUklUWV9WQUxVRVtjb25maWcubWluaW1hbFNldmVyaXR5XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nRGF0ZVRpbWUpIHtcbiAgICBjb250ZW50ID0gYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfXwke2NvbnRlbnR9YDtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nU291cmNlTG9jYXRpb24pIHtcbiAgICAvLyBUT0RPOiBjYWxjdWxhdGUgc291cmNlIGxvY2F0aW9uIGZyb20gJ3N0YWNrJ1xuICB9XG5cbiAgTE9HR0VSX1BST1ZJREVSX01BUFtjb25maWcucHJvdmlkZXJdLmxvZyhzZXZlcml0eSwgY29udGVudCwgY2F0ZWdvcnkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxubmFtZXNwYWNlIGxvZyB7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygndmVyYm9zZScsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnaW5mbycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnd2FybmluZycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZXJyb3IoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnZXJyb3InLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGZhdGFsKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBmYXRhbChhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ2ZhdGFsJywgYXJnMCwgYXJnMSk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQge1xuICAgIExPR0dFUl9DT05GSUdfTUFQID0ge307XG4gICAgc2V0KCcnLCBjb25maWcgfHwge30pO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZCB7XG4gICAgaWYgKGNhdGVnb3J5ID09PSAnKicpIHtcbiAgICAgIHJlc2V0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ29uZmlnID0gTE9HR0VSX0NPTkZJR19NQVBbY2F0ZWdvcnldIHx8IExPR0dFUl9ERUZBVUxUX0NPTkZJRztcbiAgICAgIExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5XSA9IHtcbiAgICAgICAgcHJvdmlkZXI6IGNvbmZpZy5wcm92aWRlciB8fCBwcmV2aW91c0NvbmZpZy5wcm92aWRlcixcbiAgICAgICAgbWluaW1hbFNldmVyaXR5OiBjb25maWcubWluaW1hbFNldmVyaXR5IHx8IHByZXZpb3VzQ29uZmlnLm1pbmltYWxTZXZlcml0eSxcbiAgICAgICAgbG9nRGF0ZVRpbWU6IGNvbmZpZy5sb2dEYXRlVGltZSA9PT0gdW5kZWZpbmVkID8gcHJldmlvdXNDb25maWcubG9nRGF0ZVRpbWUgOiBjb25maWcubG9nRGF0ZVRpbWUsXG4gICAgICAgIGxvZ1NvdXJjZUxvY2F0aW9uOlxuICAgICAgICAgIGNvbmZpZy5sb2dTb3VyY2VMb2NhdGlvbiA9PT0gdW5kZWZpbmVkID8gcHJldmlvdXNDb25maWcubG9nU291cmNlTG9jYXRpb24gOiBjb25maWcubG9nU291cmNlTG9jYXRpb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdlIHdhbnQgdG8gc3VwcG9ydCB3aWxkY2FyZCBvciByZWdleD9cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXRXaXRoRW52KGVudjogRW52KTogdm9pZCB7XG4gICAgY29uc3QgY29uZmlnOiBMb2dnZXIuQ29uZmlnID0ge307XG4gICAgaWYgKGVudi5sb2dMZXZlbCkge1xuICAgICAgY29uZmlnLm1pbmltYWxTZXZlcml0eSA9IGVudi5sb2dMZXZlbCBhcyBMb2dnZXIuU2V2ZXJpdHk7XG4gICAgfVxuICAgIHNldCgnJywgY29uZmlnKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSwgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgTG9nZ2VyOiBMb2dnZXIgPSBsb2c7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBQcm9maWxlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgICBtYXhOdW1iZXJFdmVudHM/OiBudW1iZXI7XG4gICAgZmx1c2hCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzPzogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRXZlbnRDYXRlZ29yeSA9ICdzZXNzaW9uJyB8ICdub2RlJyB8ICdvcCcgfCAnYmFja2VuZCc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG4gICAgZW5kKCk6IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICB9XG59XG4vLyBUT0RPXG4vLyBjbGFzcyBXZWJHTEV2ZW50IGltcGxlbWVudHMgUHJvZmlsZXIuRXZlbnQge31cblxuY2xhc3MgRXZlbnQgaW1wbGVtZW50cyBQcm9maWxlci5FdmVudCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSxcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlcixcbiAgICBwcml2YXRlIGVuZENhbGxiYWNrOiAoZTogRXZlbnQpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+LFxuICAgIHB1YmxpYyB0aW1lcj86IFdlYkdMUXVlcnksXG4gICAgcHVibGljIGN0eD86IFdlYkdMQ29udGV4dCxcbiAgKSB7fVxuXG4gIGFzeW5jIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrVGltZXIoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAodGhpcy5jdHggPT09IHVuZGVmaW5lZCB8fCB0aGlzLnRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2ViZ2wgdGltZXIgZm91bmQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZW5kVGltZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLmN0eC53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHRoaXMudGltZXIpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBFdmVudFJlY29yZCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSxcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlcixcbiAgICBwdWJsaWMgZW5kVGltZTogbnVtYmVyLFxuICApIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9maWxlciB7XG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnPzogUHJvZmlsZXIuQ29uZmlnKTogUHJvZmlsZXIge1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhjb25maWcubWF4TnVtYmVyRXZlbnRzLCBjb25maWcuZmx1c2hCYXRjaFNpemUsIGNvbmZpZy5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihtYXhOdW1iZXJFdmVudHM/OiBudW1iZXIsIGZsdXNoQmF0Y2hTaXplPzogbnVtYmVyLCBmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM/OiBudW1iZXIpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbWF4TnVtYmVyRXZlbnRzID0gbWF4TnVtYmVyRXZlbnRzID09PSB1bmRlZmluZWQgPyAxMDAwMCA6IG1heE51bWJlckV2ZW50cztcbiAgICB0aGlzLl9mbHVzaEJhdGNoU2l6ZSA9IGZsdXNoQmF0Y2hTaXplID09PSB1bmRlZmluZWQgPyAxMCA6IGZsdXNoQmF0Y2hTaXplO1xuICAgIHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkID8gNTAwMCA6IGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcztcbiAgfVxuXG4gIC8vIHN0YXJ0IHByb2ZpbGluZ1xuICBzdGFydCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1pbmdFdmVudHMgPSBbXTtcbiAgICB0aGlzLl9mbHVzaFRpbWUgPSBub3coKTtcbiAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPSAwO1xuICB9XG5cbiAgLy8gc3RvcCBwcm9maWxpbmdcbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgZm9yICg7IHRoaXMuX2ZsdXNoUG9pbnRlciA8IHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7IHRoaXMuX2ZsdXNoUG9pbnRlcisrKSB7XG4gICAgICB0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgYW4gZXZlbnQgc2NvcGUgZm9yIHRoZSBzcGVjaWZpYyBmdW5jdGlvblxuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBULCBjdHg/OiBXZWJHTENvbnRleHQpOiBUO1xuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBQcm9taXNlPFQ+LCBjdHg/OiBXZWJHTENvbnRleHQpOiBQcm9taXNlPFQ+O1xuXG4gIGV2ZW50PFQ+KFxuICAgIGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBmdW5jOiAoKSA9PiBUIHwgUHJvbWlzZTxUPixcbiAgICBjdHg/OiBXZWJHTENvbnRleHQsXG4gICk6IFQgfCBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX3N0YXJ0ZWQgPyB0aGlzLmJlZ2luKGNhdGVnb3J5LCBuYW1lLCBjdHgpIDogdW5kZWZpbmVkO1xuICAgIGxldCBpc1Byb21pc2UgPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlcyA9IGZ1bmMoKTtcblxuICAgIC8vIHdlIGNvbnNpZGVyIGEgdGhlbi1hYmxlIG9iamVjdCBpcyBhIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiAocmVzIGFzIFByb21pc2U8VD4pLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlzUHJvbWlzZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAocmVzIGFzIFByb21pc2U8VD4pLnRoZW4oXG4gICAgICAgICAgYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc1Byb21pc2UgJiYgZXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50UmVzID0gZXZlbnQuZW5kKCk7XG4gICAgICBpZiAoZXZlbnRSZXMgJiYgdHlwZW9mIGV2ZW50UmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBldmVudFJlcy50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gYmVnaW4gYW4gZXZlbnRcbiAgYmVnaW4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgY3R4PzogV2ViR0xDb250ZXh0KTogRXZlbnQge1xuICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9maWxlciBpcyBub3Qgc3RhcnRlZCB5ZXQnKTtcbiAgICB9XG4gICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIHRoaXMuZmx1c2goc3RhcnRUaW1lKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIHN0YXJ0VGltZSwgKGUpID0+IHRoaXMuZW5kU3luYyhlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWVyOiBXZWJHTFF1ZXJ5ID0gY3R4LmJlZ2luVGltZXIoKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIDAsIGFzeW5jIChlKSA9PiB0aGlzLmVuZChlKSwgdGltZXIsIGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kIHRoZSBzcGVjaWZpYyBldmVudFxuICBwcml2YXRlIGFzeW5jIGVuZChldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBlbmRUaW1lOiBudW1iZXIgPSBhd2FpdCBldmVudC5jaGVja1RpbWVyKCk7XG4gICAgaWYgKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGggPCB0aGlzLl9tYXhOdW1iZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBFdmVudFJlY29yZChldmVudC5jYXRlZ29yeSwgZXZlbnQubmFtZSwgZXZlbnQuc3RhcnRUaW1lLCBlbmRUaW1lKSk7XG4gICAgICB0aGlzLmZsdXNoKGVuZFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5kU3luYyhldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBlbmRUaW1lOiBudW1iZXIgPSBub3coKTtcbiAgICBpZiAodGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCA8IHRoaXMuX21heE51bWJlckV2ZW50cykge1xuICAgICAgdGhpcy5fdGltaW5nRXZlbnRzLnB1c2gobmV3IEV2ZW50UmVjb3JkKGV2ZW50LmNhdGVnb3J5LCBldmVudC5uYW1lLCBldmVudC5zdGFydFRpbWUsIGVuZFRpbWUpKTtcbiAgICAgIHRoaXMuZmx1c2goZW5kVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsb2dPbmVFdmVudChldmVudDogRXZlbnRSZWNvcmQpIHtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgIGBQcm9maWxlci4ke2V2ZW50LmNhdGVnb3J5fWAsXG4gICAgICBgJHsoZXZlbnQuZW5kVGltZSAtIGV2ZW50LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHtldmVudC5uYW1lfScgYXQgJHtldmVudC5lbmRUaW1lLnRvRml4ZWQoMil9YCxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmbHVzaChjdXJyZW50VGltZTogbnVtYmVyKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCAtIHRoaXMuX2ZsdXNoUG9pbnRlciA+PSB0aGlzLl9mbHVzaEJhdGNoU2l6ZSB8fFxuICAgICAgY3VycmVudFRpbWUgLSB0aGlzLl9mbHVzaFRpbWUgPj0gdGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzXG4gICAgKSB7XG4gICAgICAvLyBzaG91bGQgZmx1c2ggd2hlbiBlaXRoZXIgYmF0Y2ggc2l6ZSBhY2N1bWxhdGVkIG9yIGludGVydmFsIGVsZXBzZWRcblxuICAgICAgZm9yIChcbiAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludGVyID0gdGhpcy5fZmx1c2hQb2ludGVyO1xuICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPCBwcmV2aW91c1BvaW50ZXIgKyB0aGlzLl9mbHVzaEJhdGNoU2l6ZSAmJiB0aGlzLl9mbHVzaFBvaW50ZXIgPCB0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIrK1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mbHVzaFRpbWUgPSBub3coKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgfVxuICBwcml2YXRlIF9zdGFydGVkID0gZmFsc2U7XG4gIHByaXZhdGUgX3RpbWluZ0V2ZW50czogRXZlbnRSZWNvcmRbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9tYXhOdW1iZXJFdmVudHM6IG51bWJlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9mbHVzaEJhdGNoU2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IF9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM6IG51bWJlcjtcblxuICBwcml2YXRlIF9mbHVzaFRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBfZmx1c2hQb2ludGVyID0gMDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGEgbnVtYmVyIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCB0aW1lc3RhbXAgaW4gYSByZXNvbHV0aW9uIGFzIGhpZ2ggYXMgcG9zc2libGUuXG4gKi9cbmV4cG9ydCBjb25zdCBub3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdyA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3c7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wU2V0IHtcbiAgZG9tYWluOiBzdHJpbmc7XG4gIHZlcnNpb246IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBPcFNldCB7XG4gIC8qKlxuICAgKiBEb21haW4gb2YgYW4gb3BzZXQsIGl0IGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcoZGVmYXVsdCB2YWx1ZSwgcmVwcmVzZW50IGZvciBhaS5vbm54KSwgb3IgJ2FpLm9ubngubWwnXG4gICAqL1xuICB0eXBlIERvbWFpbiA9ICcnIHwgJ2FpLm9ubngubWwnIHwgJ2NvbS5taWNyb3NvZnQnO1xuICAvKipcbiAgICogQSByZXNvbHZlIHJ1bGUgY29uc2lzdHMgb2YgNCBvciA1IGl0ZW1zOiBvcFR5cGUsIG9wU2V0RG9tYWluLCB2ZXJzaW9uU2VsZWN0b3IsIG9wZXJhdG9ySW1wbGVtZW50YXRpb24gYW5kXG4gICAqIG9wZXJhdG9ySW5pdGlhbGl6YXRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgdHlwZSBSZXNvbHZlUnVsZSA9XG4gICAgfCBbc3RyaW5nLCBEb21haW4sIHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHcmFwaC5Ob2RlPl1cbiAgICB8IFtzdHJpbmcsIERvbWFpbiwgc3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPHVua25vd24+LCBPcGVyYXRvckluaXRpYWxpemF0aW9uPHVua25vd24+XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPcGVyYXRvcihub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIHJ1bGVzOiByZWFkb25seSBPcFNldC5SZXNvbHZlUnVsZVtdKSB7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgIGNvbnN0IG9wVHlwZSA9IHJ1bGVbMF07XG4gICAgY29uc3QgZG9tYWluID0gcnVsZVsxXTtcbiAgICBjb25zdCB2ZXJzaW9uU2VsZWN0b3IgPSBydWxlWzJdO1xuICAgIGNvbnN0IG9wSW1wbCA9IHJ1bGVbM107XG4gICAgY29uc3Qgb3BJbml0ID0gcnVsZVs0XTtcblxuICAgIGlmIChub2RlLm9wVHlwZSA9PT0gb3BUeXBlKSB7XG4gICAgICAvLyBvcGVyYXRvciB0eXBlIG1hdGNoZXNcbiAgICAgIGZvciAoY29uc3Qgb3BzZXQgb2Ygb3BzZXRzKSB7XG4gICAgICAgIC8vIG9wc2V0ICcnIGFuZCAnYWkub25ueCcgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvcHNldC5kb21haW4gPT09IGRvbWFpbiB8fCAob3BzZXQuZG9tYWluID09PSAnYWkub25ueCcgJiYgZG9tYWluID09PSAnJykpIHtcbiAgICAgICAgICAvLyBvcHNldCBkb21haW4gZm91bmRcbiAgICAgICAgICBpZiAobWF0Y2hTZWxlY3RvcihvcHNldC52ZXJzaW9uLCB2ZXJzaW9uU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcEltcGwsIG9wSW5pdCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke25vZGUub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7b3BzZXRzXG4gICAgICAubWFwKChzZXQpID0+IGAke3NldC5kb21haW4gfHwgJ2FpLm9ubngnfSB2JHtzZXQudmVyc2lvbn1gKVxuICAgICAgLmpvaW4oJywgJyl9YCxcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTZWxlY3Rvcih2ZXJzaW9uOiBudW1iZXIsIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHNlbGVjdG9yLmVuZHNXaXRoKCcrJykpIHtcbiAgICAvLyBtaW5pbXVtIHZlcnNpb24gbWF0Y2ggKCc3KycgZXhwZWN0cyB2ZXJzaW9uPj03KVxuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3Iuc3Vic3RyaW5nKDAsIHNlbGVjdG9yLmxlbmd0aCAtIDEpLCAxMCk7XG4gICAgcmV0dXJuICFpc05hTihyYW5nZVN0YXJ0KSAmJiByYW5nZVN0YXJ0IDw9IHZlcnNpb247XG4gIH0gZWxzZSBpZiAoc2VsZWN0b3Iuc3BsaXQoJy0nKS5sZW5ndGggPT09IDIpIHtcbiAgICAvLyByYW5nZSBtYXRjaCAoJzYtOCcgZXhwZWN0cyA2PD12ZXJzaW9uPD04KVxuICAgIGNvbnN0IHBhaXIgPSBzZWxlY3Rvci5zcGxpdCgnLScpO1xuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQocGFpclswXSwgMTApO1xuICAgIGNvbnN0IHJhbmdlRW5kID0gTnVtYmVyLnBhcnNlSW50KHBhaXJbMV0sIDEwKTtcbiAgICByZXR1cm4gIWlzTmFOKHJhbmdlU3RhcnQpICYmICFpc05hTihyYW5nZUVuZCkgJiYgcmFuZ2VTdGFydCA8PSB2ZXJzaW9uICYmIHZlcnNpb24gPD0gcmFuZ2VFbmQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhhY3QgbWF0Y2ggKCc3JyBleHBlY3RzIHZlcnNpb249PT03KVxuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3IsIDEwKSA9PT0gdmVyc2lvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgR3VpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEd1aWQoZ3VpZCkge1xyXG4gICAgICAgIGlmICghZ3VpZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gR3VpZC5FTVBUWTtcclxuICAgICAgICBpZiAoZ3VpZCAmJiBHdWlkLmlzR3VpZChndWlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZ3VpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBHdWlkLmlzR3VpZCA9IGZ1bmN0aW9uIChndWlkKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZ3VpZC50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBndWlkICYmIChndWlkIGluc3RhbmNlb2YgR3VpZCB8fCBHdWlkLnZhbGlkYXRvci50ZXN0KHZhbHVlKSk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWlkKFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpKTtcclxuICAgIH07XHJcbiAgICBHdWlkLmNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3VpZChcImVtcHR5Z3VpZFwiKTtcclxuICAgIH07XHJcbiAgICBHdWlkLnBhcnNlID0gZnVuY3Rpb24gKGd1aWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEd1aWQoZ3VpZCk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5yYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpO1xyXG4gICAgfTtcclxuICAgIEd1aWQuZ2VuID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIG91dCArPSAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgLy8gQ29tcGFyaW5nIHN0cmluZyBgdmFsdWVgIGFnYWluc3QgcHJvdmlkZWQgYGd1aWRgIHdpbGwgYXV0by1jYWxsXHJcbiAgICAgICAgLy8gdG9TdHJpbmcgb24gYGd1aWRgIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgcmV0dXJuIEd1aWQuaXNHdWlkKG90aGVyKSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IEd1aWQuRU1QVFk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBHdWlkLnZhbGlkYXRvciA9IG5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLCBcImlcIik7XHJcbiAgICBHdWlkLkVNUFRZID0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIjtcclxuICAgIHJldHVybiBHdWlkO1xyXG59KCkpO1xyXG5leHBvcnRzLkd1aWQgPSBHdWlkO1xyXG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzXG4gKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8vIFdlYkFzc2VtYmx5IG9wdGltaXphdGlvbnMgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXG52YXIgd2FzbSA9IG51bGw7XG50cnkge1xuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXG4gIF0pKSwge30pLmV4cG9ydHM7XG59IGNhdGNoIChlKSB7XG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cbiAqIEBleHBvcnRzIExvbmdcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuXG4gIC8qKlxuICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcblxuICAvKipcbiAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG59XG5cbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4vL1xuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbi8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbi8vXG4vLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG5cbi8qKlxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqIEBwcml2YXRlXG4gKi9cbkxvbmcucHJvdG90eXBlLl9faXNMb25nX187XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIG51bWJlclxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpO1xuICByZXR1cm4gdmFsdWUgPyAzMSAtIGMgOiBjO1xufVxuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XG5cbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICovXG52YXIgSU5UX0NBQ0hFID0ge307XG5cbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICovXG52YXIgVUlOVF9DQUNIRSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICBpZiAodW5zaWduZWQpIHtcbiAgICB2YWx1ZSA+Pj49IDA7XG4gICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgfVxuICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICBpZiAoY2FjaGUpXG4gICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlIHw9IDA7XG4gICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XG4gICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICB9XG4gICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgIGlmIChjYWNoZSlcbiAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICBpZiAoaXNOYU4odmFsdWUpKVxuICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHVuc2lnbmVkKSB7XG4gICAgaWYgKHZhbHVlIDwgMClcbiAgICAgIHJldHVybiBVWkVSTztcbiAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXG4gICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXG4gICAgICByZXR1cm4gTUFYX1ZBTFVFO1xuICB9XG4gIGlmICh2YWx1ZSA8IDApXG4gICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQGlubmVyXG4gKi9cbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKVxuICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgIHJhZGl4ID0gdW5zaWduZWQ7XG4gICAgdW5zaWduZWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gIH1cbiAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxuICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxuICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG5cbiAgdmFyIHA7XG4gIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcbiAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICB9XG5cbiAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xuXG4gIHZhciByZXN1bHQgPSBaRVJPO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XG5cbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XG5cbi8qKlxuICogU2lnbmVkIHplcm8uXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuWkVSTyA9IFpFUk87XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG5cbi8qKlxuICogVW5zaWduZWQgemVyby5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VWkVSTyA9IFVaRVJPO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgT05FID0gZnJvbUludCgxKTtcblxuLyoqXG4gKiBTaWduZWQgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk9ORSA9IE9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuXG4vKipcbiAqIFVuc2lnbmVkIG9uZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VT05FID0gVU9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcblxuLyoqXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcblxuLyoqXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuXG4vKipcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICogQGlubmVyXG4gKi9cbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XG4gIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBvdmVycmlkZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gJzAnO1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gIH1cblxuICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgcmVtID0gdGhpcztcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgcmVtID0gcmVtRGl2O1xuICAgIGlmIChyZW0uaXNaZXJvKCkpXG4gICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxuICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICByZXR1cm4gdGhpcy5sb3c7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxuICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcbiAgICAgIGJyZWFrO1xuICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgcmV0dXJuIDA7XG4gIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXG4gICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcbiAgICByZXR1cm4gLTE7XG4gIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcbiAgICByZXR1cm4gMTtcbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XG4gIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICovXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxuICAgIHJldHVybiBNSU5fVkFMVUU7XG4gIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xufTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICogQHJldHVybnMgeyFMb25nfSBTdW1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gIGlmICghaXNMb25nKGFkZGVuZCkpXG4gICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XG5cbiAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cbiAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcblxuICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKyBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTE2ICsgYjE2O1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzMyICs9IGEzMiArIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGM0OCArPSBhNDggKyBiNDg7XG4gIGM0OCAmPSAweEZGRkY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcbiAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXG4gICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICovXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXG4gICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdyxcbiAgICAgIHRoaXMuaGlnaCxcbiAgICAgIG11bHRpcGxpZXIubG93LFxuICAgICAgbXVsdGlwbGllci5oaWdoKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcblxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcblxuICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcblxuICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cblxuICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuXG4gIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xuICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKiBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTE2ICogYjAwO1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gIGMxNiAmPSAweEZGRkY7XG4gIGMzMiArPSBhMzIgKiBiMDA7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhGRkZGO1xuICBjMzIgKz0gYTE2ICogYjE2O1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4RkZGRjtcbiAgYzMyICs9IGEwMCAqIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gIGM0OCAmPSAweEZGRkY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gKi9cbkxvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXG4gICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXG4gICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcbiAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XG4gICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcbiAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcbiAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKShcbiAgICAgIHRoaXMubG93LFxuICAgICAgdGhpcy5oaWdoLFxuICAgICAgZGl2aXNvci5sb3csXG4gICAgICBkaXZpc29yLmhpZ2hcbiAgICApO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzWmVybygpKVxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxuICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXG4gICAgICAgIHJldHVybiBPTkU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXG4gICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgcmVzID0gWkVSTztcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXG4gICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgcmV0dXJuIFVaRVJPO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICByZXR1cm4gVU9ORTtcbiAgICByZXMgPSBVWkVSTztcbiAgfVxuXG4gIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICByZW0gPSB0aGlzO1xuICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG5cbiAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXG5cbiAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXG4gICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgIH1cblxuICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxuICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXG4gICAgICBhcHByb3hSZXMgPSBPTkU7XG5cbiAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICovXG5Mb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gKi9cbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXG4gICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wicmVtX3VcIl0gOiB3YXNtW1wicmVtX3NcIl0pKFxuICAgICAgdGhpcy5sb3csXG4gICAgICB0aGlzLmhpZ2gsXG4gICAgICBkaXZpc29yLmxvdyxcbiAgICAgIGRpdmlzb3IuaGlnaFxuICAgICk7XG4gICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudExlYWRpbmdaZXJvc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zO1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRUcmFpbGluZ1plcm9zfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKVxuICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgZWxzZVxuICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gIGlmIChpc0xvbmcobnVtQml0cykpXG4gICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgZWxzZVxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gIHZhciBiO1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICBiID0gKDMyIC0gbnVtQml0cyk7XG4gICAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSksICgodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSksIHRoaXMudW5zaWduZWQpO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSksICgodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSksIHRoaXMudW5zaWduZWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7XG4gIHZhciBiO1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICBiID0gKDMyIC0gbnVtQml0cyk7XG4gICAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSksICgodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSksICgodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXG4gKi9cbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgIHJldHVybiB0aGlzO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgIGxvID0gdGhpcy5sb3c7XG4gIHJldHVybiBbXG4gICAgbG8gJiAweGZmLFxuICAgIGxvID4+PiA4ICYgMHhmZixcbiAgICBsbyA+Pj4gMTYgJiAweGZmLFxuICAgIGxvID4+PiAyNCxcbiAgICBoaSAmIDB4ZmYsXG4gICAgaGkgPj4+IDggJiAweGZmLFxuICAgIGhpID4+PiAxNiAmIDB4ZmYsXG4gICAgaGkgPj4+IDI0XG4gIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgbG8gPSB0aGlzLmxvdztcbiAgcmV0dXJuIFtcbiAgICBoaSA+Pj4gMjQsXG4gICAgaGkgPj4+IDE2ICYgMHhmZixcbiAgICBoaSA+Pj4gOCAmIDB4ZmYsXG4gICAgaGkgJiAweGZmLFxuICAgIGxvID4+PiAyNCxcbiAgICBsbyA+Pj4gMTYgJiAweGZmLFxuICAgIGxvID4+PiA4ICYgMHhmZixcbiAgICBsbyAmIDB4ZmZcbiAgXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcoXG4gICAgYnl0ZXNbMF0gfFxuICAgIGJ5dGVzWzFdIDw8IDggfFxuICAgIGJ5dGVzWzJdIDw8IDE2IHxcbiAgICBieXRlc1szXSA8PCAyNCxcbiAgICBieXRlc1s0XSB8XG4gICAgYnl0ZXNbNV0gPDwgOCB8XG4gICAgYnl0ZXNbNl0gPDwgMTYgfFxuICAgIGJ5dGVzWzddIDw8IDI0LFxuICAgIHVuc2lnbmVkXG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgcmV0dXJuIG5ldyBMb25nKFxuICAgIGJ5dGVzWzRdIDw8IDI0IHxcbiAgICBieXRlc1s1XSA8PCAxNiB8XG4gICAgYnl0ZXNbNl0gPDwgOCB8XG4gICAgYnl0ZXNbN10sXG4gICAgYnl0ZXNbMF0gPDwgMjQgfFxuICAgIGJ5dGVzWzFdIDw8IDE2IHxcbiAgICBieXRlc1syXSA8PCA4IHxcbiAgICBieXRlc1szXSxcbiAgICB1bnNpZ25lZFxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9uZztcbiIsICIvLy8gQGZpbGVcbi8vLyBAYWRkdG9ncm91cCBmbGF0YnVmZmVyc19qYXZhc2NyaXB0X2FwaVxuLy8vIEB7XG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKlxuICogTmVlZCB0byBzdXBwcmVzcyAnZ2xvYmFsIHRoaXMnIGVycm9yIHNvIHRoZSBOb2RlLmpzIGV4cG9ydCBsaW5lIGRvZXNuJ3QgY2F1c2VcbiAqIGNsb3N1cmUgY29tcGlsZSB0byBlcnJvciBvdXQuXG4gKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9XG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGZsYXRidWZmZXJzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuT2Zmc2V0O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLFxuICogICBiYl9wb3M6IG51bWJlclxuICogfX1cbiAqL1xuZmxhdGJ1ZmZlcnMuVGFibGU7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5TSVpFT0ZfU0hPUlQgPSAyO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCA9IDQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIID0gNDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCA9IDQ7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuRW5jb2RpbmcgPSB7XG4gIFVURjhfQllURVM6IDEsXG4gIFVURjE2X1NUUklORzogMlxufTtcblxuLyoqXG4gKiBAdHlwZSB7SW50MzJBcnJheX1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5pbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuXG4vKipcbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdGJ1ZmZlcnMuaW50MzIuYnVmZmVyKTtcblxuLyoqXG4gKiBAdHlwZSB7RmxvYXQ2NEFycmF5fVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGZsYXRidWZmZXJzLmludDMyLmJ1ZmZlcik7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPSBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsIDBdKS5idWZmZXIpWzBdID09PSAxO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcuY3JlYXRlID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIC8vIFNwZWNpYWwtY2FzZSB6ZXJvIHRvIGF2b2lkIEdDIG92ZXJoZWFkIGZvciBkZWZhdWx0IHZhbHVlc1xuICByZXR1cm4gbG93ID09IDAgJiYgaGlnaCA9PSAwID8gZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPIDogbmV3IGZsYXRidWZmZXJzLkxvbmcobG93LCBoaWdoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5sb3cgPj4+IDApICsgdGhpcy5oaWdoICogMHgxMDAwMDAwMDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gb3RoZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mbGF0YnVmZmVycy5Mb25nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5sb3cgPT0gb3RoZXIubG93ICYmIHRoaXMuaGlnaCA9PSBvdGhlci5oaWdoO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPID0gbmV3IGZsYXRidWZmZXJzLkxvbmcoMCwgMCk7XG5cbi8vLyBAZW5kY29uZFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlIGEgRmxhdEJ1ZmZlckJ1aWxkZXIuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9pbml0aWFsX3NpemVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlciA9IGZ1bmN0aW9uKG9wdF9pbml0aWFsX3NpemUpIHtcbiAgaWYgKCFvcHRfaW5pdGlhbF9zaXplKSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IDEwMjQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IG9wdF9pbml0aWFsX3NpemU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xuXG4gIC8qKlxuICAgKiBSZW1haW5pbmcgc3BhY2UgaW4gdGhlIEJ5dGVCdWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNwYWNlID0gaW5pdGlhbF9zaXplO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1pbmFsaWduID0gMTtcblxuICAvKipcbiAgICogVGhlIHZ0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudnRhYmxlID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgc2VyaWFsaXppbmcgYSB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFN0YXJ0aW5nIG9mZnNldCBvZiB0aGUgY3VycmVudCBzdHJ1Y3QvdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm9iamVjdF9zdGFydCA9IDA7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2Zmc2V0cyBvZiBhbGwgdnRhYmxlcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52dGFibGVzID0gW107XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgY3VycmVudCB2ZWN0b3IgYmVpbmcgYnVpbHQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSAwO1xuXG4gIC8qKlxuICAgKiBGYWxzZSBvbWl0cyBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoZSBzZXJpYWxpemVkIGRhdGFcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZmFsc2U7XG59O1xuXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJiLmNsZWFyKCk7XG4gIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gIHRoaXMubWluYWxpZ24gPSAxO1xuICB0aGlzLnZ0YWJsZSA9IG51bGw7XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IDA7XG4gIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuICB0aGlzLnZ0YWJsZXMgPSBbXTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcbiAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXG4gKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlRGVmYXVsdHMgdHJ1ZSBhbHdheXMgc2VyaWFsaXplcyBkZWZhdWx0IHZhbHVlc1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzID0gZnVuY3Rpb24oZm9yY2VEZWZhdWx0cykge1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZm9yY2VEZWZhdWx0cztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBCeXRlQnVmZmVyIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gKiBjYWxsZWQgZmluaXNoKCkuIFRoZSBhY3R1YWwgZGF0YSBzdGFydHMgYXQgdGhlIEJ5dGVCdWZmZXIncyBjdXJyZW50IHBvc2l0aW9uLFxuICogbm90IG5lY2Vzc2FyaWx5IGF0IDAuXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcbiAqIGNhbGxlZCBmaW5pc2goKS5cbiAqXG4gKiBAcmV0dXJucyB7IVVpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFzVWludDhBcnJheSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSwgdGhpcy5iYi5wb3NpdGlvbigpICsgdGhpcy5vZmZzZXQoKSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogUHJlcGFyZSB0byB3cml0ZSBhbiBlbGVtZW50IG9mIGBzaXplYCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2AgaGF2ZSBiZWVuXG4gKiB3cml0dGVuLCBlLmcuIGlmIHlvdSB3cml0ZSBhIHN0cmluZywgeW91IG5lZWQgdG8gYWxpZ24gc3VjaCB0aGUgaW50IGxlbmd0aFxuICogZmllbGQgaXMgYWxpZ25lZCB0byA0IGJ5dGVzLCBhbmQgdGhlIHN0cmluZyBkYXRhIGZvbGxvd3MgaXQgZGlyZWN0bHkuIElmIGFsbFxuICogeW91IG5lZWQgdG8gZG8gaXMgYWxpZ25tZW50LCBgYWRkaXRpb25hbF9ieXRlc2Agd2lsbCBiZSAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoaXMgaXMgdGhlIG9mIHRoZSBuZXcgZWxlbWVudCB0byB3cml0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxfYnl0ZXMgVGhlIHBhZGRpbmcgc2l6ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5wcmVwID0gZnVuY3Rpb24oc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xuICAvLyBUcmFjayB0aGUgYmlnZ2VzdCB0aGluZyB3ZSd2ZSBldmVyIGFsaWduZWQgdG8uXG4gIGlmIChzaXplID4gdGhpcy5taW5hbGlnbikge1xuICAgIHRoaXMubWluYWxpZ24gPSBzaXplO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgYW1vdW50IG9mIGFsaWdubWVudCBuZWVkZWQgc3VjaCB0aGF0IGBzaXplYCBpcyBwcm9wZXJseVxuICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxuICB2YXIgYWxpZ25fc2l6ZSA9ICgofih0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlICsgYWRkaXRpb25hbF9ieXRlcykpICsgMSkgJiAoc2l6ZSAtIDEpO1xuXG4gIC8vIFJlYWxsb2NhdGUgdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XG4gICAgdmFyIG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcbiAgICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKTtcbiAgICB0aGlzLnNwYWNlICs9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIG9sZF9idWZfc2l6ZTtcbiAgfVxuXG4gIHRoaXMucGFkKGFsaWduX3NpemUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZV9zaXplXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XG4gICAgdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUZsb2F0MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDEsIDApO1xuICB0aGlzLndyaXRlSW50OCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MTZgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MTZgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTYgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoMiwgMCk7XG4gIHRoaXMud3JpdGVJbnQxNih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MzJgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZSBUaGUgYGludDY0YCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlSW50NjQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBgZmxvYXQzMmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGBmbG9hdDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDggPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCAhdmFsdWUuZXF1YWxzKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICB0aGlzLmFkZEludDY0KHZhbHVlKTtcbiAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzIgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkRmxvYXQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEZsb2F0NjQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZE9mZnNldCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHMgYXJlIHN0b3JlZCBpbmxpbmUsIHNvIG5vdGhpbmcgYWRkaXRpb25hbCBpcyBiZWluZyBhZGRlZC4gYGRgIGlzIGFsd2F5cyAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdmFsdWVcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3QgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLm5lc3RlZCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHVyZXMgYXJlIGFsd2F5cyBzdG9yZWQgaW5saW5lLCB0aGV5IG5lZWQgdG8gYmUgY3JlYXRlZCByaWdodFxuICogd2hlcmUgdGhleSdyZSB1c2VkLiAgWW91J2xsIGdldCB0aGlzIGFzc2VydGlvbiBmYWlsdXJlIGlmIHlvdVxuICogY3JlYXRlZCBpdCBlbHNld2hlcmUuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9iaiBUaGUgb2Zmc2V0IG9mIHRoZSBjcmVhdGVkIG9iamVjdFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXG4gKiB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgY29uc3RydWN0ZWRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzTmVzdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB2dGFibGUgYXQgYHZvZmZzZXRgIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc2xvdCA9IGZ1bmN0aW9uKHZvZmZzZXQpIHtcbiAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XG59O1xuXG4vKipcbiAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXG4gKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBiYiBUaGUgY3VycmVudCBidWZmZXIgd2l0aCB0aGUgZXhpc3RpbmcgZGF0YVxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcbiAqIHRvIGl0LiBUaGUgZGF0YSBpcyBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cbiAqXG4gKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcbiAqIGl0IGEgdWludDhBcnJheSB3ZSBuZWVkIHRvIHN1cHByZXNzIHRoZSB0eXBlIGNoZWNrOlxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyID0gZnVuY3Rpb24oYmIpIHtcbiAgdmFyIG9sZF9idWZfc2l6ZSA9IGJiLmNhcGFjaXR5KCk7XG5cbiAgLy8gRW5zdXJlIHdlIGRvbid0IGdyb3cgYmV5b25kIHdoYXQgZml0cyBpbiBhbiBpbnQuXG4gIGlmIChvbGRfYnVmX3NpemUgJiAweEMwMDAwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy4nKTtcbiAgfVxuXG4gIHZhciBuZXdfYnVmX3NpemUgPSBvbGRfYnVmX3NpemUgPDwgMTtcbiAgdmFyIG5iYiA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcbiAgbmJiLnNldFBvc2l0aW9uKG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gIG5iYi5ieXRlcygpLnNldChiYi5ieXRlcygpLCBuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICByZXR1cm4gbmJiO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEFkZHMgb24gb2Zmc2V0LCByZWxhdGl2ZSB0byB3aGVyZSBpdCB3aWxsIGJlIHdyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9mZnNldCBUaGUgb2Zmc2V0IHRvIGFkZC5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHRoaXMucHJlcChmbGF0YnVmZmVycy5TSVpFT0ZfSU5ULCAwKTsgLy8gRW5zdXJlIGFsaWdubWVudCBpcyBhbHJlYWR5IGRvbmUuXG4gIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogU3RhcnQgZW5jb2RpbmcgYSBuZXcgb2JqZWN0IGluIHRoZSBidWZmZXIuICBVc2VycyB3aWxsIG5vdCB1c3VhbGx5IG5lZWQgdG9cbiAqIGNhbGwgdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgZ2VuZXJhdGUgaGVscGVyIG1ldGhvZHNcbiAqIHRoYXQgY2FsbCB0aGlzIG1ldGhvZCBpbnRlcm5hbGx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1maWVsZHNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3QgPSBmdW5jdGlvbihudW1maWVsZHMpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwpIHtcbiAgICB0aGlzLnZ0YWJsZSA9IFtdO1xuICB9XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IG51bWZpZWxkcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xuICAgIHRoaXMudnRhYmxlW2ldID0gMDsgLy8gVGhpcyB3aWxsIHB1c2ggYWRkaXRpb25hbCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgfVxuICB0aGlzLmlzTmVzdGVkID0gdHJ1ZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggb2ZmIHdyaXRpbmcgdGhlIG9iamVjdCB0aGF0IGlzIHVuZGVyIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IHRvIHRoZSBvYmplY3QgaW5zaWRlIGBkYXRhQnVmZmVyYFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwgfHwgIXRoaXMuaXNOZXN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3QnKTtcbiAgfVxuXG4gIHRoaXMuYWRkSW50MzIoMCk7XG4gIHZhciB2dGFibGVsb2MgPSB0aGlzLm9mZnNldCgpO1xuXG4gIC8vIFRyaW0gdHJhaWxpbmcgemVyb2VzLlxuICB2YXIgaSA9IHRoaXMudnRhYmxlX2luX3VzZSAtIDE7XG4gIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7fVxuICB2YXIgdHJpbW1lZF9zaXplID0gaSArIDE7XG5cbiAgLy8gV3JpdGUgb3V0IHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUuXG4gICAgdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVtpXSAhPSAwID8gdnRhYmxlbG9jIC0gdGhpcy52dGFibGVbaV0gOiAwKTtcbiAgfVxuXG4gIHZhciBzdGFuZGFyZF9maWVsZHMgPSAyOyAvLyBUaGUgZmllbGRzIGJlbG93OlxuICB0aGlzLmFkZEludDE2KHZ0YWJsZWxvYyAtIHRoaXMub2JqZWN0X3N0YXJ0KTtcbiAgdmFyIGxlbiA9ICh0cmltbWVkX3NpemUgKyBzdGFuZGFyZF9maWVsZHMpICogZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUO1xuICB0aGlzLmFkZEludDE2KGxlbik7XG5cbiAgLy8gU2VhcmNoIGZvciBhbiBleGlzdGluZyB2dGFibGUgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIGV4aXN0aW5nX3Z0YWJsZSA9IDA7XG4gIHZhciB2dDEgPSB0aGlzLnNwYWNlO1xub3V0ZXJfbG9vcDpcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMudnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2dDIgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgaWYgKGxlbiA9PSB0aGlzLmJiLnJlYWRJbnQxNih2dDIpKSB7XG4gICAgICBmb3IgKHZhciBqID0gZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUOyBqIDwgbGVuOyBqICs9IGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVCkge1xuICAgICAgICBpZiAodGhpcy5iYi5yZWFkSW50MTYodnQxICsgaikgIT0gdGhpcy5iYi5yZWFkSW50MTYodnQyICsgaikpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcl9sb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGlzdGluZ192dGFibGUgPSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpc3RpbmdfdnRhYmxlKSB7XG4gICAgLy8gRm91bmQgYSBtYXRjaDpcbiAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2M7XG5cbiAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXG4gICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UsIGV4aXN0aW5nX3Z0YWJsZSAtIHZ0YWJsZWxvYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gbWF0Y2g6XG4gICAgLy8gQWRkIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCB2dGFibGUgdG8gdGhlIGxpc3Qgb2YgdnRhYmxlcy5cbiAgICB0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKTtcblxuICAgIC8vIFBvaW50IHRhYmxlIHRvIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2MsIHRoaXMub2Zmc2V0KCkgLSB2dGFibGVsb2MpO1xuICB9XG5cbiAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuICByZXR1cm4gdnRhYmxlbG9jO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEZpbmFsaXplIGEgYnVmZmVyLCBwb2l0aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHJvb3RfdGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2ZpbGVfaWRlbnRpZmllclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpemVfcHJlZml4XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIG9wdF9zaXplX3ByZWZpeCkge1xuICB2YXIgc2l6ZV9wcmVmaXggPSBvcHRfc2l6ZV9wcmVmaXggPyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEggOiAwO1xuICBpZiAob3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICAgIHZhciBmaWxlX2lkZW50aWZpZXIgPSBvcHRfZmlsZV9pZGVudGlmaWVyO1xuICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICtcbiAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XG4gICAgaWYgKGZpbGVfaWRlbnRpZmllci5sZW5ndGggIT0gZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy53cml0ZUludDgoZmlsZV9pZGVudGlmaWVyLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArIHNpemVfcHJlZml4KTtcbiAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XG4gIGlmIChzaXplX3ByZWZpeCkge1xuICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XG4gIH1cbiAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKTtcbn07XG5cbi8qKlxuICogRmluYWxpemUgYSBzaXplIHByZWZpeGVkIGJ1ZmZlciwgcG9pbnRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gcm9vdF90YWJsZVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZmlsZV9pZGVudGlmaWVyXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaFNpemVQcmVmaXhlZCA9IGZ1bmN0aW9uIChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XG4gIHRoaXMuZmluaXNoKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIHRydWUpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcbiAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkID0gZnVuY3Rpb24odGFibGUsIGZpZWxkKSB7XG4gIHZhciB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xuICB2YXIgdnRhYmxlX3N0YXJ0ID0gdGFibGVfc3RhcnQgLSB0aGlzLmJiLnJlYWRJbnQzMih0YWJsZV9zdGFydCk7XG4gIHZhciBvayA9IHRoaXMuYmIucmVhZEludDE2KHZ0YWJsZV9zdGFydCArIGZpZWxkKSAhPSAwO1xuXG4gIC8vIElmIHRoaXMgZmFpbHMsIHRoZSBjYWxsZXIgd2lsbCBzaG93IHdoYXQgZmllbGQgbmVlZHMgdG8gYmUgc2V0LlxuICBpZiAoIW9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmllbGQgJyArIGZpZWxkICsgJyBtdXN0IGJlIHNldCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbmV3IGFycmF5L3ZlY3RvciBvZiBvYmplY3RzLiAgVXNlcnMgdXN1YWxseSB3aWxsIG5vdCBjYWxsXG4gKiB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBjcmVhdGUgYSBzdGFydC9lbmRcbiAqIG1ldGhvZCBmb3IgdmVjdG9yIHR5cGVzIGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbGVtX3NpemUgVGhlIHNpemUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IG51bV9lbGVtcyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGFsaWdubWVudCBUaGUgYWxpZ25tZW50IG9mIHRoZSBhcnJheVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3RvciA9IGZ1bmN0aW9uKGVsZW1fc2l6ZSwgbnVtX2VsZW1zLCBhbGlnbm1lbnQpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gbnVtX2VsZW1zO1xuICB0aGlzLnByZXAoZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTtcbiAgdGhpcy5wcmVwKGFsaWdubWVudCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTsgLy8gSnVzdCBpbiBjYXNlIGFsaWdubWVudCA+IGludC5cbn07XG5cbi8qKlxuICogRmluaXNoIG9mZiB0aGUgY3JlYXRpb24gb2YgYW4gYXJyYXkgYW5kIGFsbCBpdHMgZWxlbWVudHMuIFRoZSBhcnJheSBtdXN0IGJlXG4gKiBjcmVhdGVkIHdpdGggYHN0YXJ0VmVjdG9yYC5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBuZXdseSBjcmVhdGVkIGFycmF5XG4gKiBzdGFydHMuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmVuZFZlY3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKTtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG59O1xuLy8vIEBlbmRjb25kXG5cbi8qKlxuICogRW5jb2RlIHRoZSBzdHJpbmcgYHNgIGluIHRoZSBidWZmZXIgdXNpbmcgVVRGLTguIElmIGEgVWludDhBcnJheSBpcyBwYXNzZWRcbiAqIGluc3RlYWQgb2YgYSBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gY29udGFpbiB2YWxpZCBVVEYtOCBlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHZhciB1dGY4ID0gcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdXRmOCA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG5cbiAgICAgIC8vIERlY29kZSBVVEYtMTZcbiAgICAgIHZhciBhID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYSA8IDB4RDgwMCB8fCBhID49IDB4REMwMCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGIgPSBzLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmNvZGUgVVRGLThcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgIHV0ZjgucHVzaChjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwLFxuICAgICAgICAgICAgICAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1dGY4LnB1c2goKChjb2RlUG9pbnQgPj4gNikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIHV0ZjgucHVzaCgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFkZEludDgoMCk7XG4gIHRoaXMuc3RhcnRWZWN0b3IoMSwgdXRmOC5sZW5ndGgsIDEpO1xuICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdXRmOC5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdXRmOFtpXTtcbiAgfVxuICByZXR1cm4gdGhpcy5lbmRWZWN0b3IoKTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEJ5dGVCdWZmZXIgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGJ5dGVzIChgVWludDhBcnJheWApLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5ieXRlc18gPSBieXRlcztcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucG9zaXRpb25fID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCBhbGxvY2F0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBzaXplLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlX3NpemVcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZSA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZV9zaXplKSk7XG59O1xuXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdW5kZXJseWluZyBgVWludDhBcnJheWAuXG4gKlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbl87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdGhpcy5wb3NpdGlvbl8gPSBwb3NpdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBjYXBhY2l0eS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkVWludDgob2Zmc2V0KSA8PCAyNCA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVpbnQxNihvZmZzZXQpIDw8IDE2ID4+IDE2O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDJdIDw8IDE2IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPDwgMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCkgPj4+IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiBuZXcgZmxhdGJ1ZmZlcnMuTG9uZyh0aGlzLnJlYWRJbnQzMihvZmZzZXQpLCB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkxvbmcodGhpcy5yZWFkVWludDMyKG9mZnNldCksIHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyWzBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0MzJbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyW2ZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID8gMCA6IDFdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0NjRbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPSB2YWx1ZSA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+IDI0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlLmxvdyk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgdmFsdWUubG93KTtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCArIDQsIHZhbHVlLmhpZ2gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICBmbGF0YnVmZmVycy5mbG9hdDMyWzBdID0gdmFsdWU7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGZsYXRidWZmZXJzLmludDMyWzBdKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgZmxhdGJ1ZmZlcnMuZmxvYXQ2NFswXSA9IHZhbHVlO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcbiAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXG4gKiBzdGFydCBvZiBhIHRoZSByb290IHZ0YWJsZSkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmJ5dGVzXy5sZW5ndGggPCB0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgK1xuICAgICAgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ZsYXRCdWZmZXJzOiBCeXRlQnVmZmVyIGlzIHRvbyBzaG9ydCB0byBjb250YWluIGFuIGlkZW50aWZpZXIuJyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICsgaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIExvb2sgdXAgYSBmaWVsZCBpbiB0aGUgdnRhYmxlLCByZXR1cm4gYW4gb2Zmc2V0IGludG8gdGhlIG9iamVjdCwgb3IgMCBpZiB0aGVcbiAqIGZpZWxkIGlzIG5vdCBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYl9wb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2dGFibGVfb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldCA9IGZ1bmN0aW9uKGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xuICB2YXIgdnRhYmxlID0gYmJfcG9zIC0gdGhpcy5yZWFkSW50MzIoYmJfcG9zKTtcbiAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5UYWJsZX0gdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLlRhYmxlfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3VuaW9uID0gZnVuY3Rpb24odCwgb2Zmc2V0KSB7XG4gIHQuYmJfcG9zID0gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgdC5iYiA9IHRoaXM7XG4gIHJldHVybiB0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBKYXZhU2NyaXB0IHN0cmluZyBmcm9tIFVURi04IGRhdGEgc3RvcmVkIGluc2lkZSB0aGUgRmxhdEJ1ZmZlci5cbiAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxuICpcbiAqIFRvIGF2b2lkIHRoZSBjb252ZXJzaW9uIHRvIFVURi0xNiwgcGFzcyBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTIGFzXG4gKiB0aGUgXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHRvXG4gKiBhbmQgZnJvbSBVVEYtMTYgd2hlbiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyXG4gKiBGbGF0QnVmZmVyIGxhdGVyIG9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9fSBvcHRfZW5jb2RpbmcgRGVmYXVsdHMgdG8gVVRGMTZfU1RSSU5HXG4gKiBAcmV0dXJucyB7c3RyaW5nfCFVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XG4gIG9mZnNldCArPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuXG4gIHZhciBsZW5ndGggPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBpID0gMDtcblxuICBvZmZzZXQgKz0gZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVDtcblxuICBpZiAob3B0X2VuY29kaW5nID09PSBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgfVxuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGNvZGVQb2ludDtcblxuICAgIC8vIERlY29kZSBVVEYtOFxuICAgIHZhciBhID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICBpZiAoYSA8IDB4QzApIHtcbiAgICAgIGNvZGVQb2ludCA9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgIGlmIChhIDwgMHhFMCkge1xuICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICgoYSAmIDB4MUYpIDw8IDYpIHxcbiAgICAgICAgICAoYiAmIDB4M0YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICBpZiAoYSA8IDB4RjApIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICAgKChhICYgMHgwRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChjICYgMHgzRik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICAgIGNvZGVQb2ludCA9XG4gICAgICAgICAgICAoKGEgJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKChiICYgMHgzRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYyAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChkICYgMHgzRik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmNvZGUgVVRGLTE2XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAoY29kZVBvaW50ICYgKCgxIDw8IDEwKSAtIDEpKSArIDB4REMwMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHJlbGF0aXZlIG9mZnNldCBzdG9yZWQgYXQgXCJvZmZzZXRcIlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdGFydCBvZiBkYXRhIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3RvciA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQ7IC8vIGRhdGEgc3RhcnRzIGFmdGVyIHRoZSBsZW5ndGhcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3Igd2hvc2Ugb2Zmc2V0IGlzIHN0b3JlZCBhdCBcIm9mZnNldFwiIGluIHRoaXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faGFzX2lkZW50aWZpZXIgPSBmdW5jdGlvbihpZGVudCkge1xuICBpZiAoaWRlbnQubGVuZ3RoICE9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgaWYgKGlkZW50LmNoYXJDb2RlQXQoaSkgIT0gdGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgKyBpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcblxuLy8gRXhwb3J0cyBmb3IgTm9kZS5qcyBhbmQgUmVxdWlyZUpTXG5leHBvcnQgeyBmbGF0YnVmZmVycyB9O1xuXG4vLy8gQGVuZGNvbmRcbi8vLyBAfVxuIiwgIi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHsgZmxhdGJ1ZmZlcnMgfSBmcm9tICdmbGF0YnVmZmVycyc7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gQXR0cmlidXRlVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgSU5UID0gMixcbiAgICBTVFJJTkcgPSAzLFxuICAgIFRFTlNPUiA9IDQsXG4gICAgR1JBUEggPSA1LFxuICAgIEZMT0FUUyA9IDYsXG4gICAgSU5UUyA9IDcsXG4gICAgU1RSSU5HUyA9IDgsXG4gICAgVEVOU09SUyA9IDksXG4gICAgR1JBUEhTID0gMTAsXG4gICAgU1BBUlNFX1RFTlNPUiA9IDExLFxuICAgIFNQQVJTRV9URU5TT1JTID0gMTIsXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBEaW1lbnNpb25WYWx1ZVR5cGUge1xuICAgIFVOS05PV04gPSAwLFxuICAgIFZBTFVFID0gMSxcbiAgICBQQVJBTSA9IDIsXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBUZW5zb3JEYXRhVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgVUlOVDggPSAyLFxuICAgIElOVDggPSAzLFxuICAgIFVJTlQxNiA9IDQsXG4gICAgSU5UMTYgPSA1LFxuICAgIElOVDMyID0gNixcbiAgICBJTlQ2NCA9IDcsXG4gICAgU1RSSU5HID0gOCxcbiAgICBCT09MID0gOSxcbiAgICBGTE9BVDE2ID0gMTAsXG4gICAgRE9VQkxFID0gMTEsXG4gICAgVUlOVDMyID0gMTIsXG4gICAgVUlOVDY0ID0gMTMsXG4gICAgQ09NUExFWDY0ID0gMTQsXG4gICAgQ09NUExFWDEyOCA9IDE1LFxuICAgIEJGTE9BVDE2ID0gMTYsXG4gICAgRkxPQVQ4RTRNM0ZOID0gMTcsXG4gICAgRkxPQVQ4RTRNM0ZOVVogPSAxOCxcbiAgICBGTE9BVDhFNU0yID0gMTksXG4gICAgRkxPQVQ4RTVNMkZOVVogPSAyMCxcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIE5vZGVUeXBlIHtcbiAgICBQcmltaXRpdmUgPSAwLFxuICAgIEZ1c2VkID0gMSxcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIFR5cGVJbmZvVmFsdWUge1xuICAgIE5PTkUgPSAwLFxuICAgIHRlbnNvcl90eXBlID0gMSxcbiAgICBzZXF1ZW5jZV90eXBlID0gMixcbiAgICBtYXBfdHlwZSA9IDMsXG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNoYXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTaGFwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2hhcGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNoYXBlKTogU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTaGFwZSk6IFNoYXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25cbiAgICAgKi9cbiAgICBkaW0oaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb24pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbiB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbigpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1MZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBkaW1PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEaW1WZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNoYXBlLnN0YXJ0U2hhcGUoYnVpbGRlcik7XG4gICAgICBTaGFwZS5hZGREaW0oYnVpbGRlciwgZGltT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTaGFwZS5lbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBEaW1lbnNpb24ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBEaW1lbnNpb24ge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb24pOiBEaW1lbnNpb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uKTogRGltZW5zaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlfG51bGxcbiAgICAgKi9cbiAgICB2YWx1ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1lbnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIHZhbHVlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkZW5vdGF0aW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERlbm90YXRpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRlbm90YXRpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kRGltZW5zaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVEaW1lbnNpb24oXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgRGltZW5zaW9uLnN0YXJ0RGltZW5zaW9uKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uLmFkZFZhbHVlKGJ1aWxkZXIsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIERpbWVuc2lvbi5hZGREZW5vdGF0aW9uKGJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvbi5lbmREaW1lbnNpb24oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRGltZW5zaW9uVmFsdWUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IERpbWVuc2lvblZhbHVlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNEaW1lbnNpb25WYWx1ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uVmFsdWUpOiBEaW1lbnNpb25WYWx1ZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uVmFsdWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb25WYWx1ZT0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvblZhbHVlKTogRGltZW5zaW9uVmFsdWUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uVmFsdWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZVxuICAgICAqL1xuICAgIGRpbVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KVxuICAgICAgICA6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGRpbVZhbHVlKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZGltUGFyYW0oKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkaW1QYXJhbShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGRpbVBhcmFtKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZSBkaW1UeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ4KDAsIGRpbVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBkaW1WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1WYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1WYWx1ZTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDEsIGRpbVZhbHVlLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbVBhcmFtT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVBhcmFtKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVBhcmFtT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZGltUGFyYW1PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIGRpbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLFxuICAgICAgZGltVmFsdWU6IGZsYXRidWZmZXJzLkxvbmcsXG4gICAgICBkaW1QYXJhbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5zdGFydERpbWVuc2lvblZhbHVlKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltVHlwZShidWlsZGVyLCBkaW1UeXBlKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVZhbHVlKGJ1aWxkZXIsIGRpbVZhbHVlKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVBhcmFtKGJ1aWxkZXIsIGRpbVBhcmFtT2Zmc2V0KTtcbiAgICAgIHJldHVybiBEaW1lbnNpb25WYWx1ZS5lbmREaW1lbnNpb25WYWx1ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yVHlwZUFuZFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JUeXBlQW5kU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3JUeXBlQW5kU2hhcGUpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvclR5cGVBbmRTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvclR5cGVBbmRTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShcbiAgICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLFxuICAgICAgb2JqPzogVGVuc29yVHlwZUFuZFNoYXBlLFxuICAgICk6IFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3JUeXBlQW5kU2hhcGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZWxlbVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IC8qKiAgKi8gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KVxuICAgICAgICA6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlfG51bGxcbiAgICAgKi9cbiAgICBzaGFwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKCkpLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIGVsZW1UeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEVsZW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwgZWxlbVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzaGFwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzaGFwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHNoYXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yVHlwZUFuZFNoYXBlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIGVsZW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLFxuICAgICAgc2hhcGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXIpO1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLmFkZEVsZW1UeXBlKGJ1aWxkZXIsIGVsZW1UeXBlKTtcbiAgICAgIFRlbnNvclR5cGVBbmRTaGFwZS5hZGRTaGFwZShidWlsZGVyLCBzaGFwZU9mZnNldCk7XG4gICAgICByZXR1cm4gVGVuc29yVHlwZUFuZFNoYXBlLmVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNYXBUeXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE1hcFR5cGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTWFwVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgTWFwVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNNYXBUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNYXBUeXBlKTogTWFwVHlwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTWFwVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1hcFR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTWFwVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTWFwVHlwZSk6IE1hcFR5cGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTWFwVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGVcbiAgICAgKi9cbiAgICBrZXlUeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgdmFsdWVUeXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0TWFwVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSBrZXlUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEtleVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2V5VHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIGtleVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZVR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHZhbHVlVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRNYXBUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVNYXBUeXBlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIGtleVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICB2YWx1ZVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTWFwVHlwZS5zdGFydE1hcFR5cGUoYnVpbGRlcik7XG4gICAgICBNYXBUeXBlLmFkZEtleVR5cGUoYnVpbGRlciwga2V5VHlwZSk7XG4gICAgICBNYXBUeXBlLmFkZFZhbHVlVHlwZShidWlsZGVyLCB2YWx1ZVR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIE1hcFR5cGUuZW5kTWFwVHlwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTZXF1ZW5jZVR5cGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2VxdWVuY2VUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2VxdWVuY2VUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXF1ZW5jZVR5cGUpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlcXVlbmNlVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlcXVlbmNlVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NlcXVlbmNlVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2VxdWVuY2VUeXBlKTogU2VxdWVuY2VUeXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlcXVlbmNlVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGxcbiAgICAgKi9cbiAgICBlbGVtVHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNlcXVlbmNlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGVsZW1UeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEVsZW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZWxlbVR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2VxdWVuY2VUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTZXF1ZW5jZVR5cGUuc3RhcnRTZXF1ZW5jZVR5cGUoYnVpbGRlcik7XG4gICAgICBTZXF1ZW5jZVR5cGUuYWRkRWxlbVR5cGUoYnVpbGRlciwgZWxlbVR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNlcXVlbmNlVHlwZS5lbmRTZXF1ZW5jZVR5cGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRWRnZUVuZCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBFZGdlRW5kXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBFZGdlRW5kIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNyY0FyZ0luZGV4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZHN0QXJnSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBzcmNfYXJnX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBkc3RfYXJnX2luZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUVkZ2VFbmQoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgbm9kZV9pbmRleDogbnVtYmVyLFxuICAgICAgc3JjX2FyZ19pbmRleDogbnVtYmVyLFxuICAgICAgZHN0X2FyZ19pbmRleDogbnVtYmVyLFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnByZXAoNCwgMTIpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKGRzdF9hcmdfaW5kZXgpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKHNyY19hcmdfaW5kZXgpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKG5vZGVfaW5kZXgpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIub2Zmc2V0KCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTm9kZUVkZ2Uge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE5vZGVFZGdlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGVFZGdlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNOb2RlRWRnZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZUVkZ2UpOiBOb2RlRWRnZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZUVkZ2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZUVkZ2UoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGVFZGdlKTogTm9kZUVkZ2Uge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZUVkZ2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmRcbiAgICAgKi9cbiAgICBpbnB1dEVkZ2VzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQoKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiAxMixcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0RWRnZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQ9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZFxuICAgICAqL1xuICAgIG91dHB1dEVkZ2VzKFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCxcbiAgICApOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogMTIsXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRFZGdlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUVkZ2UoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlSW5kZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwgbm9kZUluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dEVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0RWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGlucHV0RWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEyLCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3V0cHV0RWRnZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0RWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBvdXRwdXRFZGdlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPdXRwdXRFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEyLCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmROb2RlRWRnZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTm9kZUVkZ2UoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgbm9kZUluZGV4OiBudW1iZXIsXG4gICAgICBpbnB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBvdXRwdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBOb2RlRWRnZS5zdGFydE5vZGVFZGdlKGJ1aWxkZXIpO1xuICAgICAgTm9kZUVkZ2UuYWRkTm9kZUluZGV4KGJ1aWxkZXIsIG5vZGVJbmRleCk7XG4gICAgICBOb2RlRWRnZS5hZGRJbnB1dEVkZ2VzKGJ1aWxkZXIsIGlucHV0RWRnZXNPZmZzZXQpO1xuICAgICAgTm9kZUVkZ2UuYWRkT3V0cHV0RWRnZXMoYnVpbGRlciwgb3V0cHV0RWRnZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIE5vZGVFZGdlLmVuZE5vZGVFZGdlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE5vZGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTm9kZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc05vZGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGUpOiBOb2RlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlKTogTm9kZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc2luY2VWZXJzaW9uKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBvcFR5cGUoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZVxuICAgICAqL1xuICAgIHR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXMoXG4gICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50cyhpbmRleDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRBcmdDb3VudHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEludDMyQXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50c0FycmF5KCk6IEludDMyQXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IG5ldyBJbnQzMkFycmF5KFxuICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgaW1wbGljaXRJbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5O1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbXBsaWNpdElucHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgxMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHNpbmNlVmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTaW5jZVZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2luY2VWZXJzaW9uOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBzaW5jZVZlcnNpb24sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluZGV4OiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMig0LCBpbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3BUeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9wVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcFR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBvcFR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSB0eXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDYsIHR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBpbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOSwgb3V0cHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBhdHRyaWJ1dGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEF0dHJpYnV0ZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgYXR0cmlidXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEwLCBhdHRyaWJ1dGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQXR0cmlidXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRBdHRyaWJ1dGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0QXJnQ291bnRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0QXJnQ291bnRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0QXJnQ291bnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTEsIGlucHV0QXJnQ291bnRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxudW1iZXI+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW10gfCBVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQzMihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRBcmdDb3VudHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW1wbGljaXRJbnB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW1wbGljaXRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMiwgaW1wbGljaXRJbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbXBsaWNpdElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbXBsaWNpdElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE5vZGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU5vZGUoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHNpbmNlVmVyc2lvbjogbnVtYmVyLFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9wVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSxcbiAgICAgIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBhdHRyaWJ1dGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBpbnB1dEFyZ0NvdW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTm9kZS5zdGFydE5vZGUoYnVpbGRlcik7XG4gICAgICBOb2RlLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgTm9kZS5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkU2luY2VWZXJzaW9uKGJ1aWxkZXIsIHNpbmNlVmVyc2lvbik7XG4gICAgICBOb2RlLmFkZEluZGV4KGJ1aWxkZXIsIGluZGV4KTtcbiAgICAgIE5vZGUuYWRkT3BUeXBlKGJ1aWxkZXIsIG9wVHlwZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZFR5cGUoYnVpbGRlciwgdHlwZSk7XG4gICAgICBOb2RlLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShidWlsZGVyLCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkT3V0cHV0cyhidWlsZGVyLCBvdXRwdXRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkQXR0cmlidXRlcyhidWlsZGVyLCBhdHRyaWJ1dGVzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkSW5wdXRBcmdDb3VudHMoYnVpbGRlciwgaW5wdXRBcmdDb3VudHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbXBsaWNpdElucHV0cyhidWlsZGVyLCBpbXBsaWNpdElucHV0c09mZnNldCk7XG4gICAgICByZXR1cm4gTm9kZS5lbmROb2RlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFZhbHVlSW5mbyB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFZhbHVlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBWYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFZhbHVlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNWYWx1ZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFZhbHVlSW5mbyk6IFZhbHVlSW5mbyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVmFsdWVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBWYWx1ZUluZm8pOiBWYWx1ZUluZm8ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgdHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFZhbHVlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgdHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRWYWx1ZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVZhbHVlSW5mbyhcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVmFsdWVJbmZvLnN0YXJ0VmFsdWVJbmZvKGJ1aWxkZXIpO1xuICAgICAgVmFsdWVJbmZvLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBWYWx1ZUluZm8uYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBWYWx1ZUluZm8uYWRkVHlwZShidWlsZGVyLCB0eXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBWYWx1ZUluZm8uZW5kVmFsdWVJbmZvKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFR5cGVJbmZvIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUeXBlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVHlwZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVHlwZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFR5cGVJbmZvKTogVHlwZUluZm8ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1R5cGVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUeXBlSW5mbyk6IFR5cGVJbmZvIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZVxuICAgICAqL1xuICAgIHZhbHVlVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuVGFibGUgb2JqXG4gICAgICogQHJldHVybnMgP2ZsYXRidWZmZXJzLlRhYmxlXG4gICAgICovXG4gICAgdmFsdWU8VCBleHRlbmRzIGZsYXRidWZmZXJzLlRhYmxlPihvYmo6IFQpOiBUIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdW5pb24ob2JqLCB0aGlzLmJiX3BvcyArIG9mZnNldCkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUeXBlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRlbm90YXRpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGVub3RhdGlvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZGVub3RhdGlvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUgdmFsdWVUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDgoMSwgdmFsdWVUeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCB2YWx1ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUeXBlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVHlwZUluZm8oXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdmFsdWVUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUsXG4gICAgICB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBUeXBlSW5mby5zdGFydFR5cGVJbmZvKGJ1aWxkZXIpO1xuICAgICAgVHlwZUluZm8uYWRkRGVub3RhdGlvbihidWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0KTtcbiAgICAgIFR5cGVJbmZvLmFkZFZhbHVlVHlwZShidWlsZGVyLCB2YWx1ZVR5cGUpO1xuICAgICAgVHlwZUluZm8uYWRkVmFsdWUoYnVpbGRlciwgdmFsdWVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFR5cGVJbmZvLmVuZFR5cGVJbmZvKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE9wZXJhdG9yU2V0SWQge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBPcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRvclNldElkXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE9wZXJhdG9yU2V0SWQpOiBPcGVyYXRvclNldElkIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNPcGVyYXRvclNldElkKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBPcGVyYXRvclNldElkKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmcgfCBudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvbWFpbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb21haW4oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZG9tYWluT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgdmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgxLCB2ZXJzaW9uLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kT3BlcmF0b3JTZXRJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlT3BlcmF0b3JTZXRJZChcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE9wZXJhdG9yU2V0SWQuc3RhcnRPcGVyYXRvclNldElkKGJ1aWxkZXIpO1xuICAgICAgT3BlcmF0b3JTZXRJZC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE9wZXJhdG9yU2V0SWQuYWRkVmVyc2lvbihidWlsZGVyLCB2ZXJzaW9uKTtcbiAgICAgIHJldHVybiBPcGVyYXRvclNldElkLmVuZE9wZXJhdG9yU2V0SWQoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogVGVuc29yIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1RlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yKTogVGVuc29yIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFRlbnNvcik6IFRlbnNvciB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmcgfCBudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmcgfCBudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltcyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KVxuICAgICAgICA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZGF0YVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgcmF3RGF0YShpbmRleDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDgodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICByYXdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBVaW50OEFycmF5XG4gICAgICovXG4gICAgcmF3RGF0YUFycmF5KCk6IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIHN0cmluZ0RhdGEoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdHJpbmdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoNik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkaW1zT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUgZGF0YVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGF0YVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBkYXRhVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHJhd0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUmF3RGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNCwgcmF3RGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW10gfCBVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMSwgZGF0YS5sZW5ndGgsIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ4KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRSYXdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMSwgbnVtRWxlbXMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHN0cmluZ0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3RyaW5nRGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgc3RyaW5nRGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0cmluZ0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3RyaW5nRGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFRlbnNvci5zdGFydFRlbnNvcihidWlsZGVyKTtcbiAgICAgIFRlbnNvci5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRGF0YVR5cGUoYnVpbGRlciwgZGF0YVR5cGUpO1xuICAgICAgVGVuc29yLmFkZFJhd0RhdGEoYnVpbGRlciwgcmF3RGF0YU9mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkU3RyaW5nRGF0YShidWlsZGVyLCBzdHJpbmdEYXRhT2Zmc2V0KTtcbiAgICAgIHJldHVybiBUZW5zb3IuZW5kVGVuc29yKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNwYXJzZVRlbnNvciB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTcGFyc2VUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNwYXJzZVRlbnNvcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3BhcnNlVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTcGFyc2VUZW5zb3IpOiBTcGFyc2VUZW5zb3Ige1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdmFsdWVzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSkuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbFxuICAgICAqL1xuICAgIGluZGljZXMob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvciB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKS5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBkaW1zKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpXG4gICAgICAgIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1zTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTcGFyc2VUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIHZhbHVlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5kaWNlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbmRpY2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBpbmRpY2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1zT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRpbXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLkxvbmc+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5Mb25nW10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBkYXRhLmxlbmd0aCwgOCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDY0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU3BhcnNlVGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTcGFyc2VUZW5zb3IoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgdmFsdWVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBpbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNwYXJzZVRlbnNvci5zdGFydFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRWYWx1ZXMoYnVpbGRlciwgdmFsdWVzT2Zmc2V0KTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRJbmRpY2VzKGJ1aWxkZXIsIGluZGljZXNPZmZzZXQpO1xuICAgICAgU3BhcnNlVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICByZXR1cm4gU3BhcnNlVGVuc29yLmVuZFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBBdHRyaWJ1dGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzQXR0cmlidXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBBdHRyaWJ1dGUpOiBBdHRyaWJ1dGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEF0dHJpYnV0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEF0dHJpYnV0ZT0gb2JqXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogQXR0cmlidXRlKTogQXR0cmlidXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEF0dHJpYnV0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZyB8IG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlXG4gICAgICovXG4gICAgdHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGYoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaSgpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBzKCk6IHN0cmluZyB8IG51bGw7XG4gICAgcyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIHMob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKS5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbFxuICAgICAqL1xuICAgIGcob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGggfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSkuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBmbG9hdHMoaW5kZXg6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEZsb2F0MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZmxvYXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBGbG9hdDMyQXJyYXlcbiAgICAgKi9cbiAgICBmbG9hdHNBcnJheSgpOiBGbG9hdDMyQXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlcixcbiAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpbnRzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KVxuICAgICAgICA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW50c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgc3RyaW5ncyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5O1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN0cmluZ3NMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yXG4gICAgICovXG4gICAgdGVuc29ycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICB0ZW5zb3JzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGhcbiAgICAgKi9cbiAgICBncmFwaHMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGggfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZ3JhcGhzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0QXR0cmlidXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMTMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigyLCB0eXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBmXG4gICAgICovXG4gICAgc3RhdGljIGFkZEYoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZjogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkRmxvYXQzMigzLCBmLCAwLjApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBpXG4gICAgICovXG4gICAgc3RhdGljIGFkZEkoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDQsIGksIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0T2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIHRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBnT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZmxvYXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEZsb2F0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBmbG9hdHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBmbG9hdHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW10gfCBVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRGbG9hdDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW50c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGludHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg5LCBpbnRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUludHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdHJpbmdzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN0cmluZ3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3RyaW5nc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEwLCBzdHJpbmdzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3RyaW5nc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdHJpbmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHRlbnNvcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVGVuc29ycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0ZW5zb3JzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTEsIHRlbnNvcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVUZW5zb3JzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFRlbnNvcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBocyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMiwgZ3JhcGhzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEdyYXBoc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEF0dHJpYnV0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlQXR0cmlidXRlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLFxuICAgICAgZjogbnVtYmVyLFxuICAgICAgaTogZmxhdGJ1ZmZlcnMuTG9uZyxcbiAgICAgIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGZsb2F0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgaW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc3RyaW5nc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdGVuc29yc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZ3JhcGhzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEF0dHJpYnV0ZS5zdGFydEF0dHJpYnV0ZShidWlsZGVyKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFR5cGUoYnVpbGRlciwgdHlwZSk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRihidWlsZGVyLCBmKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRJKGJ1aWxkZXIsIGkpO1xuICAgICAgQXR0cmlidXRlLmFkZFMoYnVpbGRlciwgc09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkVChidWlsZGVyLCB0T2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRHKGJ1aWxkZXIsIGdPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEZsb2F0cyhidWlsZGVyLCBmbG9hdHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEludHMoYnVpbGRlciwgaW50c09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkU3RyaW5ncyhidWlsZGVyLCBzdHJpbmdzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRUZW5zb3JzKGJ1aWxkZXIsIHRlbnNvcnNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEdyYXBocyhidWlsZGVyLCBncmFwaHNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5lbmRBdHRyaWJ1dGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgR3JhcGgge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEdyYXBoIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNHcmFwaChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogR3JhcGgpOiBHcmFwaCB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgR3JhcGgoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBHcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEdyYXBoKTogR3JhcGgge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgR3JhcGgoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvclxuICAgICAqL1xuICAgIGluaXRpYWxpemVycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGluaXRpYWxpemVyc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mb1xuICAgICAqL1xuICAgIG5vZGVBcmdzKFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvLFxuICAgICk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVBcmdzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVcbiAgICAgKi9cbiAgICBub2RlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG1heE5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZVxuICAgICAqL1xuICAgIG5vZGVFZGdlcyhcbiAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlLFxuICAgICk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UoKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUVkZ2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5O1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzcGFyc2VJbml0aWFsaXplcnMoXG4gICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNwYXJzZUluaXRpYWxpemVyc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5pdGlhbGl6ZXJzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluaXRpYWxpemVycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBpbml0aWFsaXplcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5pdGlhbGl6ZXJzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVBcmdzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVBcmdzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbm9kZUFyZ3NPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2Rlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIG5vZGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9kZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbWF4Tm9kZUluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1heE5vZGVJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBtYXhOb2RlSW5kZXg6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDMsIG1heE5vZGVJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVFZGdlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlRWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCBub2RlRWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlRWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUVkZ2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgaW5wdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvdXRwdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIG91dHB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNwYXJzZUluaXRpYWxpemVycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10sXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVHcmFwaChcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBpbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIG5vZGVBcmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgbWF4Tm9kZUluZGV4OiBudW1iZXIsXG4gICAgICBub2RlRWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEdyYXBoLnN0YXJ0R3JhcGgoYnVpbGRlcik7XG4gICAgICBHcmFwaC5hZGRJbml0aWFsaXplcnMoYnVpbGRlciwgaW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVBcmdzKGJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVzKGJ1aWxkZXIsIG5vZGVzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE1heE5vZGVJbmRleChidWlsZGVyLCBtYXhOb2RlSW5kZXgpO1xuICAgICAgR3JhcGguYWRkTm9kZUVkZ2VzKGJ1aWxkZXIsIG5vZGVFZGdlc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE91dHB1dHMoYnVpbGRlciwgb3V0cHV0c09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRTcGFyc2VJbml0aWFsaXplcnMoYnVpbGRlciwgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBHcmFwaC5lbmRHcmFwaChidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNb2RlbCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTW9kZWwge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIE1vZGVsXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc01vZGVsKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNb2RlbCk6IE1vZGVsIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNb2RlbCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1vZGVsPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNb2RlbChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTW9kZWwpOiBNb2RlbCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNb2RlbCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpclZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWRcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydChcbiAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZCgpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydExlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcHJvZHVjZXJOYW1lKCk6IHN0cmluZyB8IG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIHByb2R1Y2VyVmVyc2lvbigpOiBzdHJpbmcgfCBudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBtb2RlbFZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGxcbiAgICAgKi9cbiAgICBncmFwaChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCgpKS5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoRG9jU3RyaW5nKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZ3JhcGhEb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBncmFwaERvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0TW9kZWwoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCg5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgaXJWZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZElyVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpclZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgwLCBpclZlcnNpb24sIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3BzZXRJbXBvcnRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3BzZXRJbXBvcnQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3BzZXRJbXBvcnRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBvcHNldEltcG9ydE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU9wc2V0SW1wb3J0VmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE9wc2V0SW1wb3J0VmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHByb2R1Y2VyTmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9kdWNlck5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgcHJvZHVjZXJOYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgcHJvZHVjZXJOYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBwcm9kdWNlclZlcnNpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDMsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBtb2RlbFZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTW9kZWxWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDUsIG1vZGVsVmVyc2lvbiwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBncmFwaE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhEb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhEb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhEb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBncmFwaERvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRNb2RlbChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTW9kZWwoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgaXJWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nLFxuICAgICAgb3BzZXRJbXBvcnRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHByb2R1Y2VyTmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIG1vZGVsVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZyxcbiAgICAgIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZ3JhcGhPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGdyYXBoRG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE1vZGVsLnN0YXJ0TW9kZWwoYnVpbGRlcik7XG4gICAgICBNb2RlbC5hZGRJclZlcnNpb24oYnVpbGRlciwgaXJWZXJzaW9uKTtcbiAgICAgIE1vZGVsLmFkZE9wc2V0SW1wb3J0KGJ1aWxkZXIsIG9wc2V0SW1wb3J0T2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZFByb2R1Y2VyTmFtZShidWlsZGVyLCBwcm9kdWNlck5hbWVPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCk7XG4gICAgICBNb2RlbC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZE1vZGVsVmVyc2lvbihidWlsZGVyLCBtb2RlbFZlcnNpb24pO1xuICAgICAgTW9kZWwuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaChidWlsZGVyLCBncmFwaE9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaERvY1N0cmluZyhidWlsZGVyLCBncmFwaERvY1N0cmluZ09mZnNldCk7XG4gICAgICByZXR1cm4gTW9kZWwuZW5kTW9kZWwoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEtlcm5lbENyZWF0ZUluZm9zPSBvYmpcbiAgICAgKiBAcmV0dXJucyBLZXJuZWxDcmVhdGVJbmZvc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogS2VybmVsQ3JlYXRlSW5mb3MpOiBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgS2VybmVsQ3JlYXRlSW5mb3MoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBLZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoXG4gICAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcixcbiAgICAgIG9iaj86IEtlcm5lbENyZWF0ZUluZm9zLFxuICAgICk6IEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEtlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzKGluZGV4OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kaWNlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBVaW50MzJBcnJheVxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzQXJyYXkoKTogVWludDMyQXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAga2VybmVsRGVmSGFzaGVzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IHRoaXMuYmIhLnJlYWRVaW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KVxuICAgICAgICA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAga2VybmVsRGVmSGFzaGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVJbmRpY2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVJbmRpY2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbm9kZUluZGljZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBrZXJuZWxEZWZIYXNoZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2VybmVsRGVmSGFzaGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbERlZkhhc2hlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGtlcm5lbERlZkhhc2hlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG5vZGVJbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBrZXJuZWxEZWZIYXNoZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3Muc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyKTtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLmFkZE5vZGVJbmRpY2VzKGJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0KTtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLmFkZEtlcm5lbERlZkhhc2hlcyhidWlsZGVyLCBrZXJuZWxEZWZIYXNoZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEtlcm5lbENyZWF0ZUluZm9zLmVuZEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTdWJHcmFwaFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFN1YkdyYXBoU2Vzc2lvblN0YXRlKTogU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKFxuICAgICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsXG4gICAgICBvYmo/OiBTdWJHcmFwaFNlc3Npb25TdGF0ZSxcbiAgICApOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTdWJHcmFwaFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBncmFwaElkKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZ3JhcGhJZChvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGdyYXBoSWQob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGxcbiAgICAgKi9cbiAgICBzZXNzaW9uU3RhdGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSgpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoSWRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaElkT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZ3JhcGhJZE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc2Vzc2lvblN0YXRlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzZXNzaW9uU3RhdGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIGJ1aWxkZXIucmVxdWlyZWRGaWVsZChvZmZzZXQsIDQpOyAvLyBncmFwaF9pZFxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgZ3JhcGhJZE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZS5hZGRHcmFwaElkKGJ1aWxkZXIsIGdyYXBoSWRPZmZzZXQpO1xuICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUuYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldCk7XG4gICAgICByZXR1cm4gU3ViR3JhcGhTZXNzaW9uU3RhdGUuZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU2Vzc2lvblN0YXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1Nlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2Vzc2lvblN0YXRlKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlc3Npb25TdGF0ZSk6IFNlc3Npb25TdGF0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvc3xudWxsXG4gICAgICovXG4gICAga2VybmVscyhcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzKFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGUsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQga2VybmVsc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRLZXJuZWxzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBrZXJuZWxzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXNzaW9uU3RhdGUoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAga2VybmVsc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNlc3Npb25TdGF0ZS5zdGFydFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICAgIFNlc3Npb25TdGF0ZS5hZGRLZXJuZWxzKGJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQpO1xuICAgICAgU2Vzc2lvblN0YXRlLmFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhidWlsZGVyLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNlc3Npb25TdGF0ZS5lbmRTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEluZmVyZW5jZVNlc3Npb249IG9ialxuICAgICAqIEByZXR1cm5zIEluZmVyZW5jZVNlc3Npb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogSW5mZXJlbmNlU2Vzc2lvbik6IEluZmVyZW5jZVNlc3Npb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBJbmZlcmVuY2VTZXNzaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0luZmVyZW5jZVNlc3Npb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEluZmVyZW5jZVNlc3Npb24pOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVySGFzSWRlbnRpZmllcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGJiLl9faGFzX2lkZW50aWZpZXIoJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgb3J0VmVyc2lvbigpOiBzdHJpbmcgfCBudWxsO1xuICAgIG9ydFZlcnNpb24ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBvcnRWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWx8bnVsbFxuICAgICAqL1xuICAgIG1vZGVsKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwoKSkuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbFxuICAgICAqL1xuICAgIHNlc3Npb25TdGF0ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcnRWZXJzaW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9ydFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG9ydFZlcnNpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG1vZGVsT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbW9kZWxPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNlc3Npb25TdGF0ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgc2Vzc2lvblN0YXRlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuZmluaXNoKG9mZnNldCwgJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5maW5pc2gob2Zmc2V0LCAnT1JUTScsIHRydWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG9ydFZlcnNpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5zdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcik7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZE9ydFZlcnNpb24oYnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldCk7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZE1vZGVsKGJ1aWxkZXIsIG1vZGVsT2Zmc2V0KTtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldCk7XG4gICAgICByZXR1cm4gSW5mZXJlbmNlU2Vzc2lvbi5lbmRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmFzUHJvbWlzZX0uXHJcbiAqIEB0eXBlZGVmIGFzUHJvbWlzZUNhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEFkZGl0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIGZyb20gYSBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge2FzUHJvbWlzZUNhbGxiYWNrfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gY3R4IEZ1bmN0aW9uIGNvbnRleHRcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgRnVuY3Rpb24gYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBQcm9taXNpZmllZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgvKiwgdmFyYXJncyAqLykge1xyXG4gICAgdmFyIHBhcmFtcyAgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIG9mZnNldCAgPSAwLFxyXG4gICAgICAgIGluZGV4ICAgPSAyLFxyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLyosIHZhcmFyZ3MgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXJyb3IsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsgcmV0dXJuIG5hbWU7IH0sXG4gICAgICAgICAgICBzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlOiBmYWxzZSB3b3VsZCBhY2N1cmF0ZWx5IHByZXNlcnZlIHRoZSBiZWhhdmlvciBvZlxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBidXQgSSdtIGd1ZXNzaW5nIHRoYXQgd2FzIG5vdCBpbnRlbnRpb25hbC5cbiAgICAgICAgICAgIC8vIEZvciBhbiBhY3R1YWwgZXJyb3Igc3ViY2xhc3MsIHRoaXMgcHJvcGVydHkgd291bGRcbiAgICAgICAgICAgIC8vIGJlIGNvbmZpZ3VyYWJsZS5cbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoc3RhcnQgPT09IGVuZCkgeyAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICB2YXIgbmF0aXZlQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgICAgIHJldHVybiBuYXRpdmVCdWZmZXJcbiAgICAgICAgICAgID8gbmF0aXZlQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICA6IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIiwgIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xuIiwgIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKCdwcm90b2J1ZmpzL21pbmltYWwnKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlcixcbiAgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsXG4gICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbJ2RlZmF1bHQnXSB8fCAoJHByb3RvYnVmLnJvb3RzWydkZWZhdWx0J10gPSB7fSk7XG5cbiRyb290Lm9ubnggPSAoZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTmFtZXNwYWNlIG9ubnguXG4gICAqIEBleHBvcnRzIG9ubnhcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgdmFyIG9ubnggPSB7fTtcblxuICAvKipcbiAgICogVmVyc2lvbiBlbnVtLlxuICAgKiBAbmFtZSBvbm54LlZlcnNpb25cbiAgICogQGVudW0ge251bWJlcn1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9TVEFSVF9WRVJTSU9OPTAgX1NUQVJUX1ZFUlNJT04gdmFsdWVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxN18xMF8xMD0xIElSX1ZFUlNJT05fMjAxN18xMF8xMCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE3XzEwXzMwPTIgSVJfVkVSU0lPTl8yMDE3XzEwXzMwIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTdfMTFfMz0zIElSX1ZFUlNJT05fMjAxN18xMV8zIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfMV8yMj00IElSX1ZFUlNJT05fMjAxOV8xXzIyIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfM18xOD01IElSX1ZFUlNJT05fMjAxOV8zXzE4IHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfOV8xOT02IElSX1ZFUlNJT05fMjAxOV85XzE5IHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMjBfNV84PTcgSVJfVkVSU0lPTl8yMDIwXzVfOCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDIxXzdfMzA9OCBJUl9WRVJTSU9OXzIwMjFfN18zMCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTj05IElSX1ZFUlNJT04gdmFsdWVcbiAgICovXG4gIG9ubnguVmVyc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzBdID0gJ19TVEFSVF9WRVJTSU9OJyldID0gMDtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMV0gPSAnSVJfVkVSU0lPTl8yMDE3XzEwXzEwJyldID0gMTtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMl0gPSAnSVJfVkVSU0lPTl8yMDE3XzEwXzMwJyldID0gMjtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbM10gPSAnSVJfVkVSU0lPTl8yMDE3XzExXzMnKV0gPSAzO1xuICAgIHZhbHVlc1sodmFsdWVzQnlJZFs0XSA9ICdJUl9WRVJTSU9OXzIwMTlfMV8yMicpXSA9IDQ7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzVdID0gJ0lSX1ZFUlNJT05fMjAxOV8zXzE4JyldID0gNTtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNl0gPSAnSVJfVkVSU0lPTl8yMDE5XzlfMTknKV0gPSA2O1xuICAgIHZhbHVlc1sodmFsdWVzQnlJZFs3XSA9ICdJUl9WRVJTSU9OXzIwMjBfNV84JyldID0gNztcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbOF0gPSAnSVJfVkVSU0lPTl8yMDIxXzdfMzAnKV0gPSA4O1xuICAgIHZhbHVlc1sodmFsdWVzQnlJZFs5XSA9ICdJUl9WRVJTSU9OJyldID0gOTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KSgpO1xuXG4gIG9ubnguQXR0cmlidXRlUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYW4gQXR0cmlidXRlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElBdHRyaWJ1dGVQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBBdHRyaWJ1dGVQcm90byBuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3JlZkF0dHJOYW1lXSBBdHRyaWJ1dGVQcm90byByZWZBdHRyTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEF0dHJpYnV0ZVByb3RvIGRvY1N0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlfG51bGx9IFt0eXBlXSBBdHRyaWJ1dGVQcm90byB0eXBlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2ZdIEF0dHJpYnV0ZVByb3RvIGZcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtpXSBBdHRyaWJ1dGVQcm90byBpXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtzXSBBdHRyaWJ1dGVQcm90byBzXG4gICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbdF0gQXR0cmlidXRlUHJvdG8gdFxuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ10gQXR0cmlidXRlUHJvdG8gZ1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG98bnVsbH0gW3NwYXJzZVRlbnNvcl0gQXR0cmlidXRlUHJvdG8gc3BhcnNlVGVuc29yXG4gICAgICogQHByb3BlcnR5IHtvbm54LklUeXBlUHJvdG98bnVsbH0gW3RwXSBBdHRyaWJ1dGVQcm90byB0cFxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Zsb2F0c10gQXR0cmlidXRlUHJvdG8gZmxvYXRzXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtpbnRzXSBBdHRyaWJ1dGVQcm90byBpbnRzXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48VWludDhBcnJheT58bnVsbH0gW3N0cmluZ3NdIEF0dHJpYnV0ZVByb3RvIHN0cmluZ3NcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUZW5zb3JQcm90bz58bnVsbH0gW3RlbnNvcnNdIEF0dHJpYnV0ZVByb3RvIHRlbnNvcnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPnxudWxsfSBbZ3JhcGhzXSBBdHRyaWJ1dGVQcm90byBncmFwaHNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTcGFyc2VUZW5zb3JQcm90bz58bnVsbH0gW3NwYXJzZVRlbnNvcnNdIEF0dHJpYnV0ZVByb3RvIHNwYXJzZVRlbnNvcnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUeXBlUHJvdG8+fG51bGx9IFt0eXBlUHJvdG9zXSBBdHRyaWJ1dGVQcm90byB0eXBlUHJvdG9zXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEF0dHJpYnV0ZVByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIEF0dHJpYnV0ZVByb3RvLlxuICAgICAqIEBpbXBsZW1lbnRzIElBdHRyaWJ1dGVQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLmZsb2F0cyA9IFtdO1xuICAgICAgdGhpcy5pbnRzID0gW107XG4gICAgICB0aGlzLnN0cmluZ3MgPSBbXTtcbiAgICAgIHRoaXMudGVuc29ycyA9IFtdO1xuICAgICAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgICAgIHRoaXMuc3BhcnNlVGVuc29ycyA9IFtdO1xuICAgICAgdGhpcy50eXBlUHJvdG9zID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gbmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5uYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVQcm90byByZWZBdHRyTmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHJlZkF0dHJOYW1lXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUucmVmQXR0ck5hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGRvY1N0cmluZy5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gdHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGV9IHR5cGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50eXBlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGYuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVQcm90byBpLlxuICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBpXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuaSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVQcm90byBzLlxuICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHNcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIHQuXG4gICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yUHJvdG98bnVsbHx1bmRlZmluZWR9IHRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGcuXG4gICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gZ1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gc3BhcnNlVGVuc29yLlxuICAgICAqIEBtZW1iZXIge29ubnguSVNwYXJzZVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSBzcGFyc2VUZW5zb3JcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zcGFyc2VUZW5zb3IgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gdHAuXG4gICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB0cFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGZsb2F0cy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gZmxvYXRzXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZmxvYXRzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGludHMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gaW50c1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmludHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gc3RyaW5ncy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48VWludDhBcnJheT59IHN0cmluZ3NcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zdHJpbmdzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIHRlbnNvcnMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPn0gdGVuc29yc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRlbnNvcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gZ3JhcGhzLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPn0gZ3JhcGhzXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZ3JhcGhzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIHNwYXJzZVRlbnNvcnMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVNwYXJzZVRlbnNvclByb3RvPn0gc3BhcnNlVGVuc29yc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnNwYXJzZVRlbnNvcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gdHlwZVByb3Rvcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVHlwZVByb3RvPn0gdHlwZVByb3Rvc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnR5cGVQcm90b3MgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBdHRyaWJ1dGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG99IG1lc3NhZ2UgQXR0cmlidXRlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UuZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdmJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgNSA9Ki8gMjEpLmZsb2F0KG1lc3NhZ2UuZik7XG4gICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2knKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLyAyNCkuaW50NjQobWVzc2FnZS5pKTtcbiAgICAgIGlmIChtZXNzYWdlLnMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncycpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovIDM0KS5ieXRlcyhtZXNzYWdlLnMpO1xuICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd0JykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UudCwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLyA0MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZycpKVxuICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZywgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLyA1MCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAhPSBudWxsICYmIG1lc3NhZ2UuZmxvYXRzLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovIDU4KS5mb3JrKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mbG9hdHMubGVuZ3RoOyArK2kpIHdyaXRlci5mbG9hdChtZXNzYWdlLmZsb2F0c1tpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki8gNjYpLmZvcmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2kpIHdyaXRlci5pbnQ2NChtZXNzYWdlLmludHNbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLyA3NCkuYnl0ZXMobWVzc2FnZS5zdHJpbmdzW2ldKTtcbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLmVuY29kZShtZXNzYWdlLnRlbnNvcnNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTAsIHdpcmVUeXBlIDIgPSovIDgyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGhzICE9IG51bGwgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaHNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovIDkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RvY1N0cmluZycpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLyAxMDYpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICBpZiAobWVzc2FnZS50cCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd0cCcpKVxuICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS50cCwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8gMTE0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZVByb3RvcyAhPSBudWxsICYmIG1lc3NhZ2UudHlwZVByb3Rvcy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UudHlwZVByb3Rvc1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTUsIHdpcmVUeXBlIDIgPSovIDEyMikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3R5cGUnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMCwgd2lyZVR5cGUgMCA9Ki8gMTYwKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncmVmQXR0ck5hbWUnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMSwgd2lyZVR5cGUgMiA9Ki8gMTcwKS5zdHJpbmcobWVzc2FnZS5yZWZBdHRyTmFtZSk7XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnc3BhcnNlVGVuc29yJykpXG4gICAgICAgICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKFxuICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yLFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjIsIHdpcmVUeXBlIDIgPSovIDE3OCkuZm9yaygpLFxuICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29ycyAhPSBudWxsICYmIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JzW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMywgd2lyZVR5cGUgMiA9Ki8gMTg2KS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMToge1xuICAgICAgICAgICAgbWVzc2FnZS5yZWZBdHRyTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZiA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgbWVzc2FnZS5pID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICBtZXNzYWdlLnMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHAgPSAkcm9vdC5vbm54LlR5cGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5mbG9hdHMgJiYgbWVzc2FnZS5mbG9hdHMubGVuZ3RoKSkgbWVzc2FnZS5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIG1lc3NhZ2UuZmxvYXRzLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIG1lc3NhZ2UuZmxvYXRzLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgODoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnRzICYmIG1lc3NhZ2UuaW50cy5sZW5ndGgpKSBtZXNzYWdlLmludHMgPSBbXTtcbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIG1lc3NhZ2UuaW50cy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmludHMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmluZ3MgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aCkpIG1lc3NhZ2Uuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTA6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudGVuc29ycyAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKSkgbWVzc2FnZS50ZW5zb3JzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnRlbnNvcnMucHVzaCgkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZ3JhcGhzICYmIG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aCkpIG1lc3NhZ2UuZ3JhcGhzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmdyYXBocy5wdXNoKCRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIzOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnNwYXJzZVRlbnNvcnMgJiYgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aCkpIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLnB1c2goJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGVQcm90b3MgJiYgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aCkpIG1lc3NhZ2UudHlwZVByb3RvcyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS50eXBlUHJvdG9zLnB1c2goJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYW4gQXR0cmlidXRlUHJvdG8gbWVzc2FnZS5cbiAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpIHJldHVybiAnbmFtZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncmVmQXR0ck5hbWUnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnJlZkF0dHJOYW1lKSkgcmV0dXJuICdyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSkgcmV0dXJuICdkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKVxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3R5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWQnO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2YnKSlcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmYgIT09ICdudW1iZXInKSByZXR1cm4gJ2Y6IG51bWJlciBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaScpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkpICYmXG4gICAgICAgICAgIShtZXNzYWdlLmkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkuaGlnaCkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gJ2k6IGludGVnZXJ8TG9uZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncycpKVxuICAgICAgICBpZiAoISgobWVzc2FnZS5zICYmIHR5cGVvZiBtZXNzYWdlLnMubGVuZ3RoID09PSAnbnVtYmVyJykgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zKSkpXG4gICAgICAgICAgcmV0dXJuICdzOiBidWZmZXIgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3QnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLnQpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndC4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZycpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5nKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2cuJyArIGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc3BhcnNlVGVuc29yJykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS5zcGFyc2VUZW5zb3IpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc3BhcnNlVGVuc29yLicgKyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnRwICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHAnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50cCk7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuICd0cC4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5mbG9hdHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdmbG9hdHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdHMpKSByZXR1cm4gJ2Zsb2F0czogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mbG9hdHNbaV0gIT09ICdudW1iZXInKSByZXR1cm4gJ2Zsb2F0czogbnVtYmVyW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaW50cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2ludHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnRzKSkgcmV0dXJuICdpbnRzOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRzW2ldKSAmJlxuICAgICAgICAgICAgIShtZXNzYWdlLmludHNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50c1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0uaGlnaCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc3RyaW5ncycpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnN0cmluZ3MpKSByZXR1cm4gJ3N0cmluZ3M6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uuc3RyaW5nc1tpXSAmJiB0eXBlb2YgbWVzc2FnZS5zdHJpbmdzW2ldLmxlbmd0aCA9PT0gJ251bWJlcicpIHx8XG4gICAgICAgICAgICAgICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nc1tpXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ3N0cmluZ3M6IGJ1ZmZlcltdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0ZW5zb3JzJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudGVuc29ycykpIHJldHVybiAndGVuc29yczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudGVuc29yc1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3RlbnNvcnMuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ncmFwaHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdncmFwaHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ncmFwaHMpKSByZXR1cm4gJ2dyYXBoczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmdyYXBoc1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2dyYXBocy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzcGFyc2VUZW5zb3JzJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3BhcnNlVGVuc29ycykpIHJldHVybiAnc3BhcnNlVGVuc29yczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3NwYXJzZVRlbnNvcnMuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlUHJvdG9zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHlwZVByb3RvcycpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnR5cGVQcm90b3MpKSByZXR1cm4gJ3R5cGVQcm90b3M6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndHlwZVByb3Rvcy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG9cbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICBpZiAob2JqZWN0LnJlZkF0dHJOYW1lICE9IG51bGwpIG1lc3NhZ2UucmVmQXR0ck5hbWUgPSBTdHJpbmcob2JqZWN0LnJlZkF0dHJOYW1lKTtcbiAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVU5ERUZJTkVEJzpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ZMT0FUJzpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lOVCc6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTVFJJTkcnOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVEVOU09SJzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dSQVBIJzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NQQVJTRV9URU5TT1InOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUWVBFX1BST1RPJzpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRTJzpcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lOVFMnOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU1RSSU5HUyc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURU5TT1JTJzpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dSQVBIUyc6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NQQVJTRV9URU5TT1JTJzpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVFlQRV9QUk9UT1MnOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mICE9IG51bGwpIG1lc3NhZ2UuZiA9IE51bWJlcihvYmplY3QuZik7XG4gICAgICBpZiAob2JqZWN0LmkgIT0gbnVsbClcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuaSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaSA9PT0gJ3N0cmluZycpIG1lc3NhZ2UuaSA9IHBhcnNlSW50KG9iamVjdC5pLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaSA9PT0gJ251bWJlcicpIG1lc3NhZ2UuaSA9IG9iamVjdC5pO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09ICdvYmplY3QnKVxuICAgICAgICAgIG1lc3NhZ2UuaSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaS5sb3cgPj4+IDAsIG9iamVjdC5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICBpZiAob2JqZWN0LnMgIT0gbnVsbClcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QucywgKG1lc3NhZ2UucyA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zKSkpLCAwKTtcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0LnMubGVuZ3RoID49IDApIG1lc3NhZ2UucyA9IG9iamVjdC5zO1xuICAgICAgaWYgKG9iamVjdC50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudCAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8udDogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmcgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5nICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmcpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5zcGFyc2VUZW5zb3IgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zcGFyc2VUZW5zb3IgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8uc3BhcnNlVGVuc29yOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvcik7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnRwICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHAgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkF0dHJpYnV0ZVByb3RvLnRwOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS50cCA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnRwKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxvYXRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZmxvYXRzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5mbG9hdHM6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZmxvYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmZsb2F0cy5sZW5ndGg7ICsraSkgbWVzc2FnZS5mbG9hdHNbaV0gPSBOdW1iZXIob2JqZWN0LmZsb2F0c1tpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmludHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnRzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5pbnRzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoJHV0aWwuTG9uZykgKG1lc3NhZ2UuaW50c1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pbnRzW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09ICdzdHJpbmcnKSBtZXNzYWdlLmludHNbaV0gPSBwYXJzZUludChvYmplY3QuaW50c1tpXSwgMTApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50c1tpXSA9PT0gJ251bWJlcicpIG1lc3NhZ2UuaW50c1tpXSA9IG9iamVjdC5pbnRzW2ldO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50c1tpXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmludHNbaV0ubG93ID4+PiAwLCBvYmplY3QuaW50c1tpXS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5zdHJpbmdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5ncykpIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc3RyaW5nc1tpXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKFxuICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nc1tpXSxcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uuc3RyaW5nc1tpXSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdHJpbmdzW2ldKSkpLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIGlmIChvYmplY3Quc3RyaW5nc1tpXS5sZW5ndGggPj0gMCkgbWVzc2FnZS5zdHJpbmdzW2ldID0gb2JqZWN0LnN0cmluZ3NbaV07XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnRlbnNvcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50ZW5zb3JzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnRlbnNvcnNbaV0gIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UudGVuc29yc1tpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudGVuc29yc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZ3JhcGhzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZ3JhcGhzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZ3JhcGhzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmdyYXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmdyYXBoc1tpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmdyYXBoc1tpXSA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ncmFwaHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnNwYXJzZVRlbnNvcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zcGFyc2VUZW5zb3JzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3BhcnNlVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvcnNbaV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnNbaV0gPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnR5cGVQcm90b3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50eXBlUHJvdG9zKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudHlwZVByb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGVQcm90b3NbaV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3NbaV0gPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmZsb2F0cyA9IFtdO1xuICAgICAgICBvYmplY3QuaW50cyA9IFtdO1xuICAgICAgICBvYmplY3Quc3RyaW5ncyA9IFtdO1xuICAgICAgICBvYmplY3QudGVuc29ycyA9IFtdO1xuICAgICAgICBvYmplY3QuZ3JhcGhzID0gW107XG4gICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3JzID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QuZiA9IDA7XG4gICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKSBvYmplY3QucyA9ICcnO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvYmplY3QucyA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSkgb2JqZWN0LnMgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnMpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC50ID0gbnVsbDtcbiAgICAgICAgb2JqZWN0LmcgPSBudWxsO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICAgIG9iamVjdC50cCA9IG51bGw7XG4gICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJ1VOREVGSU5FRCcgOiAwO1xuICAgICAgICBvYmplY3QucmVmQXR0ck5hbWUgPSAnJztcbiAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKSBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdmJykpXG4gICAgICAgIG9iamVjdC5mID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmYpID8gU3RyaW5nKG1lc3NhZ2UuZikgOiBtZXNzYWdlLmY7XG4gICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaScpKVxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaSA9PT0gJ251bWJlcicpIG9iamVjdC5pID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaSkgOiBtZXNzYWdlLmk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvYmplY3QuaSA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaSlcbiAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmkubG93ID4+PiAwLCBtZXNzYWdlLmkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgIDogbWVzc2FnZS5pO1xuICAgICAgaWYgKG1lc3NhZ2UucyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3MnKSlcbiAgICAgICAgb2JqZWN0LnMgPVxuICAgICAgICAgIG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZ1xuICAgICAgICAgICAgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UucywgMCwgbWVzc2FnZS5zLmxlbmd0aClcbiAgICAgICAgICAgIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXlcbiAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnMpXG4gICAgICAgICAgICAgIDogbWVzc2FnZS5zO1xuICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3QnKSlcbiAgICAgICAgb2JqZWN0LnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudCwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZycpKVxuICAgICAgICBvYmplY3QuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmcsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UuZmxvYXRzICYmIG1lc3NhZ2UuZmxvYXRzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZmxvYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5mbG9hdHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmZsb2F0c1tqXSA9XG4gICAgICAgICAgICBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZmxvYXRzW2pdKSA/IFN0cmluZyhtZXNzYWdlLmZsb2F0c1tqXSkgOiBtZXNzYWdlLmZsb2F0c1tqXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmludHMgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50c1tqXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBvYmplY3QuaW50c1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludHNbal0pIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9iamVjdC5pbnRzW2pdID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaW50c1tqXSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnRzW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5pbnRzW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5ncyAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5zdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5zdHJpbmdzW2pdID1cbiAgICAgICAgICAgIG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZ1xuICAgICAgICAgICAgICA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdzW2pdLCAwLCBtZXNzYWdlLnN0cmluZ3Nbal0ubGVuZ3RoKVxuICAgICAgICAgICAgICA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5XG4gICAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ3Nbal0pXG4gICAgICAgICAgICAgICAgOiBtZXNzYWdlLnN0cmluZ3Nbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JzICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnRlbnNvcnNbal0gPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudGVuc29yc1tqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ncmFwaHMgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5ncmFwaHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmdyYXBocy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QuZ3JhcGhzW2pdID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZ3JhcGhzW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKSBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICBpZiAobWVzc2FnZS50cCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3RwJykpXG4gICAgICAgIG9iamVjdC50cCA9ICRyb290Lm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudHAsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZVByb3RvcyAmJiBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zW2pdID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udG9PYmplY3QobWVzc2FnZS50eXBlUHJvdG9zW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0eXBlJykpXG4gICAgICAgIG9iamVjdC50eXBlID1cbiAgICAgICAgICBvcHRpb25zLmVudW1zID09PSBTdHJpbmdcbiAgICAgICAgICAgID8gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW21lc3NhZ2UudHlwZV0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG1lc3NhZ2UudHlwZVxuICAgICAgICAgICAgICA6ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVttZXNzYWdlLnR5cGVdXG4gICAgICAgICAgICA6IG1lc3NhZ2UudHlwZTtcbiAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncmVmQXR0ck5hbWUnKSlcbiAgICAgICAgb2JqZWN0LnJlZkF0dHJOYW1lID0gbWVzc2FnZS5yZWZBdHRyTmFtZTtcbiAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NwYXJzZVRlbnNvcicpKVxuICAgICAgICBvYmplY3Quc3BhcnNlVGVuc29yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnNwYXJzZVRlbnNvciwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JzICYmIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvcnNbal0gPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIEF0dHJpYnV0ZVByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguQXR0cmlidXRlUHJvdG8nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVUeXBlIGVudW0uXG4gICAgICogQG5hbWUgb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlXG4gICAgICogQGVudW0ge251bWJlcn1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVU5ERUZJTkVEPTAgVU5ERUZJTkVEIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSU5UPTIgSU5UIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklORz0zIFNUUklORyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1I9NCBURU5TT1IgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gR1JBUEg9NSBHUkFQSCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUEFSU0VfVEVOU09SPTExIFNQQVJTRV9URU5TT1IgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9QUk9UTz0xMyBUWVBFX1BST1RPIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUUz02IEZMT0FUUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlRTPTcgSU5UUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkdTPTggU1RSSU5HUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1JTPTkgVEVOU09SUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBHUkFQSFM9MTAgR1JBUEhTIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNQQVJTRV9URU5TT1JTPTEyIFNQQVJTRV9URU5TT1JTIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfUFJPVE9TPTE0IFRZUEVfUFJPVE9TIHZhbHVlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LFxuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzBdID0gJ1VOREVGSU5FRCcpXSA9IDA7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMV0gPSAnRkxPQVQnKV0gPSAxO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzJdID0gJ0lOVCcpXSA9IDI7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbM10gPSAnU1RSSU5HJyldID0gMztcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs0XSA9ICdURU5TT1InKV0gPSA0O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzVdID0gJ0dSQVBIJyldID0gNTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxMV0gPSAnU1BBUlNFX1RFTlNPUicpXSA9IDExO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzEzXSA9ICdUWVBFX1BST1RPJyldID0gMTM7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNl0gPSAnRkxPQVRTJyldID0gNjtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs3XSA9ICdJTlRTJyldID0gNztcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs4XSA9ICdTVFJJTkdTJyldID0gODtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs5XSA9ICdURU5TT1JTJyldID0gOTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxMF0gPSAnR1JBUEhTJyldID0gMTA7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTJdID0gJ1NQQVJTRV9URU5TT1JTJyldID0gMTI7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTRdID0gJ1RZUEVfUFJPVE9TJyldID0gMTQ7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gQXR0cmlidXRlUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5WYWx1ZUluZm9Qcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFZhbHVlSW5mb1Byb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gVmFsdWVJbmZvUHJvdG8gbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0eXBlXSBWYWx1ZUluZm9Qcm90byB0eXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gVmFsdWVJbmZvUHJvdG8gZG9jU3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFZhbHVlSW5mb1Byb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVZhbHVlSW5mb1Byb3RvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvbm54LklWYWx1ZUluZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZhbHVlSW5mb1Byb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZUluZm9Qcm90byBuYW1lLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLm5hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFZhbHVlSW5mb1Byb3RvIHR5cGUuXG4gICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBWYWx1ZUluZm9Qcm90by5wcm90b3R5cGUudHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZUluZm9Qcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmFsdWVJbmZvUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgVmFsdWVJbmZvUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVJbmZvUHJvdG8ocHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBWYWx1ZUluZm9Qcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBWYWx1ZUluZm9Qcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnbmFtZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovIDEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAndHlwZScpKVxuICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS50eXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RvY1N0cmluZycpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovIDI2KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvKCk7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSkgcmV0dXJuICduYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3R5cGUuJyArIGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKSByZXR1cm4gJ2RvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvKCk7XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3QudHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QudHlwZSA9IG51bGw7XG4gICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSlcbiAgICAgICAgb2JqZWN0LnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnR5cGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgVmFsdWVJbmZvUHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBWYWx1ZUluZm9Qcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBWYWx1ZUluZm9Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5WYWx1ZUluZm9Qcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBWYWx1ZUluZm9Qcm90bztcbiAgfSkoKTtcblxuICBvbm54Lk5vZGVQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIE5vZGVQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBpbnRlcmZhY2UgSU5vZGVQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW2lucHV0XSBOb2RlUHJvdG8gaW5wdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtvdXRwdXRdIE5vZGVQcm90byBvdXRwdXRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gTm9kZVByb3RvIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbb3BUeXBlXSBOb2RlUHJvdG8gb3BUeXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gTm9kZVByb3RvIGRvbWFpblxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPnxudWxsfSBbYXR0cmlidXRlXSBOb2RlUHJvdG8gYXR0cmlidXRlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gTm9kZVByb3RvIGRvY1N0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBOb2RlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBOb2RlUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSU5vZGVQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBpbnB1dC5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gaW5wdXRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBvdXRwdXQuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IG91dHB1dFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUub3V0cHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBuYW1lLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUubmFtZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogTm9kZVByb3RvIG9wVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG9wVHlwZVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUub3BUeXBlID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBOb2RlUHJvdG8gZG9tYWluLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTm9kZVByb3RvLnByb3RvdHlwZS5kb21haW4gPSAnJztcblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBhdHRyaWJ1dGUuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTm9kZVByb3RvLnByb3RvdHlwZS5hdHRyaWJ1dGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogTm9kZVByb3RvIGRvY1N0cmluZy5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE5vZGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgTm9kZVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IE5vZGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE5vZGVQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk5vZGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgTm9kZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLmlucHV0W2ldKTtcbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5zdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ29wVHlwZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovIDM0KS5zdHJpbmcobWVzc2FnZS5vcFR5cGUpO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLyA1MCkuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb21haW4nKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLyA1OCkuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBOb2RlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5Ob2RlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIE5vZGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE5vZGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgTm9kZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk5vZGVQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKSBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmlucHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm91dHB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICBtZXNzYWdlLm9wVHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSkgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlLnB1c2goJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIE5vZGVQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbnB1dCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmlucHV0KSkgcmV0dXJuICdpbnB1dDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlucHV0W2ldKSkgcmV0dXJuICdpbnB1dDogc3RyaW5nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0JykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uub3V0cHV0KSkgcmV0dXJuICdvdXRwdXQ6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKSkgcmV0dXJuICdvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSkgcmV0dXJuICduYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnb3BUeXBlJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5vcFR5cGUpKSByZXR1cm4gJ29wVHlwZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvbWFpbicpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSkgcmV0dXJuICdkb21haW46IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdhdHRyaWJ1dGUnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGUpKSByZXR1cm4gJ2F0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkobWVzc2FnZS5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdhdHRyaWJ1dGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpIHJldHVybiAnZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAqL1xuICAgIE5vZGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54Lk5vZGVQcm90bykgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTm9kZVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmlucHV0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuaW5wdXQpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk5vZGVQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnB1dC5sZW5ndGg7ICsraSkgbWVzc2FnZS5pbnB1dFtpXSA9IFN0cmluZyhvYmplY3QuaW5wdXRbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5vdXRwdXQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vdXRwdXQpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk5vZGVQcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkgbWVzc2FnZS5vdXRwdXRbaV0gPSBTdHJpbmcob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3Qub3BUeXBlICE9IG51bGwpIG1lc3NhZ2Uub3BUeXBlID0gU3RyaW5nKG9iamVjdC5vcFR5cGUpO1xuICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbCkgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmF0dHJpYnV0ZSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYXR0cmlidXRlW2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVtpXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYXR0cmlidXRlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbCkgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTm9kZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54Lk5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIE5vZGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0Lm5hbWUgPSAnJztcbiAgICAgICAgb2JqZWN0Lm9wVHlwZSA9ICcnO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICAgIG9iamVjdC5kb21haW4gPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2opIG9iamVjdC5pbnB1dFtqXSA9IG1lc3NhZ2UuaW5wdXRbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraikgb2JqZWN0Lm91dHB1dFtqXSA9IG1lc3NhZ2Uub3V0cHV0W2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICBpZiAobWVzc2FnZS5vcFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcFR5cGUnKSkgb2JqZWN0Lm9wVHlwZSA9IG1lc3NhZ2Uub3BUeXBlO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICYmIG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QobWVzc2FnZS5hdHRyaWJ1dGVbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvbWFpbicpKSBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIE5vZGVQcm90byB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgTm9kZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTm9kZVByb3RvXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguTm9kZVByb3RvJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5vZGVQcm90bztcbiAgfSkoKTtcblxuICBvbm54LlRyYWluaW5nSW5mb1Byb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVHJhaW5pbmdJbmZvUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbaW5pdGlhbGl6YXRpb25dIFRyYWluaW5nSW5mb1Byb3RvIGluaXRpYWxpemF0aW9uXG4gICAgICogQHByb3BlcnR5IHtvbm54LklHcmFwaFByb3RvfG51bGx9IFthbGdvcml0aG1dIFRyYWluaW5nSW5mb1Byb3RvIGFsZ29yaXRobVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtpbml0aWFsaXphdGlvbkJpbmRpbmddIFRyYWluaW5nSW5mb1Byb3RvIGluaXRpYWxpemF0aW9uQmluZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFt1cGRhdGVCaW5kaW5nXSBUcmFpbmluZ0luZm9Qcm90byB1cGRhdGVCaW5kaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRyYWluaW5nSW5mb1Byb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVHJhaW5pbmdJbmZvUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWluaW5nSW5mb1Byb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICB0aGlzLnVwZGF0ZUJpbmRpbmcgPSBbXTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBpbml0aWFsaXphdGlvblxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemF0aW9uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRyYWluaW5nSW5mb1Byb3RvIGFsZ29yaXRobS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBhbGdvcml0aG1cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS5hbGdvcml0aG0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVHJhaW5pbmdJbmZvUHJvdG8gaW5pdGlhbGl6YXRpb25CaW5kaW5nLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gaW5pdGlhbGl6YXRpb25CaW5kaW5nXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUcmFpbmluZ0luZm9Qcm90by5wcm90b3R5cGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRyYWluaW5nSW5mb1Byb3RvIHVwZGF0ZUJpbmRpbmcuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fSB1cGRhdGVCaW5kaW5nXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUcmFpbmluZ0luZm9Qcm90by5wcm90b3R5cGUudXBkYXRlQmluZGluZyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRyYWluaW5nSW5mb1Byb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90byBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYWluaW5nSW5mb1Byb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UcmFpbmluZ0luZm9Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpbml0aWFsaXphdGlvbicpKVxuICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24sIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnYWxnb3JpdGhtJykpXG4gICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5hbGdvcml0aG0sIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLyAyNikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS51cGRhdGVCaW5kaW5nICE9IG51bGwgJiYgbWVzc2FnZS51cGRhdGVCaW5kaW5nLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlQmluZGluZ1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8gMzQpLmZvcmsoKSxcbiAgICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVHJhaW5pbmdJbmZvUHJvdG99IG1lc3NhZ2UgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvKCk7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXphdGlvbiA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nICYmIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aCkpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudXBkYXRlQmluZGluZyAmJiBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoKSkgbWVzc2FnZS51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXphdGlvbicpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5pbml0aWFsaXphdGlvbik7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdpbml0aWFsaXphdGlvbi4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdhbGdvcml0aG0nKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KG1lc3NhZ2UuYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2FsZ29yaXRobS4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXphdGlvbkJpbmRpbmcnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpKSByZXR1cm4gJ2luaXRpYWxpemF0aW9uQmluZGluZzogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2luaXRpYWxpemF0aW9uQmluZGluZy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZUJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd1cGRhdGVCaW5kaW5nJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudXBkYXRlQmluZGluZykpIHJldHVybiAndXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudXBkYXRlQmluZGluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkobWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndXBkYXRlQmluZGluZy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmluaXRpYWxpemF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuaW5pdGlhbGl6YXRpb24gIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uaW5pdGlhbGl6YXRpb246IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmluaXRpYWxpemF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuYWxnb3JpdGhtICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYWxnb3JpdGhtICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UcmFpbmluZ0luZm9Qcm90by5hbGdvcml0aG06IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmFsZ29yaXRobSA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5hbGdvcml0aG0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcpKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uaW5pdGlhbGl6YXRpb25CaW5kaW5nOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmdbaV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbkJpbmRpbmc6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoXG4gICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudXBkYXRlQmluZGluZykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnVwZGF0ZUJpbmRpbmcpKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC51cGRhdGVCaW5kaW5nW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnVwZGF0ZUJpbmRpbmdbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgb2JqZWN0LnVwZGF0ZUJpbmRpbmcgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbiA9IG51bGw7XG4gICAgICAgIG9iamVjdC5hbGdvcml0aG0gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXphdGlvbicpKVxuICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb24gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXphdGlvbiwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdhbGdvcml0aG0nKSlcbiAgICAgICAgb2JqZWN0LmFsZ29yaXRobSA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmFsZ29yaXRobSwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgJiYgbWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KFxuICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmdbal0sXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51cGRhdGVCaW5kaW5nICYmIG1lc3NhZ2UudXBkYXRlQmluZGluZy5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnVwZGF0ZUJpbmRpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnVwZGF0ZUJpbmRpbmdbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS51cGRhdGVCaW5kaW5nW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgVHJhaW5pbmdJbmZvUHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBUcmFpbmluZ0luZm9Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UcmFpbmluZ0luZm9Qcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmFpbmluZ0luZm9Qcm90bztcbiAgfSkoKTtcblxuICBvbm54Lk1vZGVsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBNb2RlbFByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJTW9kZWxQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2lyVmVyc2lvbl0gTW9kZWxQcm90byBpclZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gTW9kZWxQcm90byBvcHNldEltcG9ydFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtwcm9kdWNlck5hbWVdIE1vZGVsUHJvdG8gcHJvZHVjZXJOYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3Byb2R1Y2VyVmVyc2lvbl0gTW9kZWxQcm90byBwcm9kdWNlclZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBNb2RlbFByb3RvIGRvbWFpblxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW21vZGVsVmVyc2lvbl0gTW9kZWxQcm90byBtb2RlbFZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBNb2RlbFByb3RvIGRvY1N0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ3JhcGhdIE1vZGVsUHJvdG8gZ3JhcGhcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbbWV0YWRhdGFQcm9wc10gTW9kZWxQcm90byBtZXRhZGF0YVByb3BzXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVHJhaW5pbmdJbmZvUHJvdG8+fG51bGx9IFt0cmFpbmluZ0luZm9dIE1vZGVsUHJvdG8gdHJhaW5pbmdJbmZvXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JRnVuY3Rpb25Qcm90bz58bnVsbH0gW2Z1bmN0aW9uc10gTW9kZWxQcm90byBmdW5jdGlvbnNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTW9kZWxQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIE1vZGVsUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSU1vZGVsUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb2RlbFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgIHRoaXMubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgdGhpcy50cmFpbmluZ0luZm8gPSBbXTtcbiAgICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBpclZlcnNpb24uXG4gICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGlyVmVyc2lvblxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5pclZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCBmYWxzZSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBvcHNldEltcG9ydC5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPn0gb3BzZXRJbXBvcnRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUub3BzZXRJbXBvcnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBwcm9kdWNlck5hbWUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9kdWNlck5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUucHJvZHVjZXJOYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbFByb3RvIHByb2R1Y2VyVmVyc2lvbi5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb2R1Y2VyVmVyc2lvblxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5wcm9kdWNlclZlcnNpb24gPSAnJztcblxuICAgIC8qKlxuICAgICAqIE1vZGVsUHJvdG8gZG9tYWluLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBtb2RlbFZlcnNpb24uXG4gICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IG1vZGVsVmVyc2lvblxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5tb2RlbFZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCBmYWxzZSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbFByb3RvIGdyYXBoLlxuICAgICAqIEBtZW1iZXIge29ubnguSUdyYXBoUHJvdG98bnVsbHx1bmRlZmluZWR9IGdyYXBoXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmdyYXBoID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE1vZGVsUHJvdG8gbWV0YWRhdGFQcm9wcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IG1ldGFkYXRhUHJvcHNcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUubWV0YWRhdGFQcm9wcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbFByb3RvIHRyYWluaW5nSW5mby5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVHJhaW5pbmdJbmZvUHJvdG8+fSB0cmFpbmluZ0luZm9cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUudHJhaW5pbmdJbmZvID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIE1vZGVsUHJvdG8gZnVuY3Rpb25zLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklGdW5jdGlvblByb3RvPn0gZnVuY3Rpb25zXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmZ1bmN0aW9ucyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1vZGVsUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IE1vZGVsUHJvdG8ocHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgTW9kZWxQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpclZlcnNpb24nKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLyA4KS5pbnQ2NChtZXNzYWdlLmlyVmVyc2lvbik7XG4gICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncHJvZHVjZXJOYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLnN0cmluZyhtZXNzYWdlLnByb2R1Y2VyTmFtZSk7XG4gICAgICBpZiAobWVzc2FnZS5wcm9kdWNlclZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncHJvZHVjZXJWZXJzaW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLnN0cmluZyhtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbik7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9tYWluJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8gMzQpLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnbW9kZWxWZXJzaW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMCA9Ki8gNDApLmludDY0KG1lc3NhZ2UubW9kZWxWZXJzaW9uKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLyA1MCkuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2dyYXBoJykpXG4gICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaCwgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLyA1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0W2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLyA2NikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5tZXRhZGF0YVByb3BzICE9IG51bGwgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDIgPSovIDExNCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS50cmFpbmluZ0luZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mb1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDIgPSovIDE2MikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbnMgIT0gbnVsbCAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5GdW5jdGlvblByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyNSwgd2lyZVR5cGUgMiA9Ki8gMjAyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgTW9kZWxQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIE1vZGVsUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTW9kZWxQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSkgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydC5wdXNoKCRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgbWVzc2FnZS5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKSkgbWVzc2FnZS5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHMucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50cmFpbmluZ0luZm8gJiYgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoKSkgbWVzc2FnZS50cmFpbmluZ0luZm8gPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhaW5pbmdJbmZvLnB1c2goJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI1OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZ1bmN0aW9ucyAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpKSBtZXNzYWdlLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbnMucHVzaCgkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lyVmVyc2lvbicpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbikgJiZcbiAgICAgICAgICAhKG1lc3NhZ2UuaXJWZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbi5oaWdoKSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAnaXJWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcHNldEltcG9ydCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSkgcmV0dXJuICdvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkobWVzc2FnZS5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ29wc2V0SW1wb3J0LicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncHJvZHVjZXJOYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcm9kdWNlck5hbWUpKSByZXR1cm4gJ3Byb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3Byb2R1Y2VyVmVyc2lvbicpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uKSkgcmV0dXJuICdwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb21haW4nKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpIHJldHVybiAnZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UubW9kZWxWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbW9kZWxWZXJzaW9uJykpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uKSAmJlxuICAgICAgICAgICEoXG4gICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiAmJlxuICAgICAgICAgICAgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmxvdykgJiZcbiAgICAgICAgICAgICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1vZGVsVmVyc2lvbi5oaWdoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAnbW9kZWxWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKSByZXR1cm4gJ2RvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGgnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZ3JhcGgpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnZ3JhcGguJyArIGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ21ldGFkYXRhUHJvcHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5tZXRhZGF0YVByb3BzKSkgcmV0dXJuICdtZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdtZXRhZGF0YVByb3BzLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudHJhaW5pbmdJbmZvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHJhaW5pbmdJbmZvJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudHJhaW5pbmdJbmZvKSkgcmV0dXJuICd0cmFpbmluZ0luZm86IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHJhaW5pbmdJbmZvW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndHJhaW5pbmdJbmZvLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZnVuY3Rpb25zJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZnVuY3Rpb25zKSkgcmV0dXJuICdmdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnkobWVzc2FnZS5mdW5jdGlvbnNbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdmdW5jdGlvbnMuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguTW9kZWxQcm90b30gTW9kZWxQcm90b1xuICAgICAqL1xuICAgIE1vZGVsUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5Nb2RlbFByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Nb2RlbFByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmlyVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICBpZiAoJHV0aWwuTG9uZykgKG1lc3NhZ2UuaXJWZXJzaW9uID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmlyVmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSAnc3RyaW5nJykgbWVzc2FnZS5pclZlcnNpb24gPSBwYXJzZUludChvYmplY3QuaXJWZXJzaW9uLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSAnbnVtYmVyJykgbWVzc2FnZS5pclZlcnNpb24gPSBvYmplY3QuaXJWZXJzaW9uO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmlyVmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC5pclZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgIGlmIChvYmplY3Qub3BzZXRJbXBvcnQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vcHNldEltcG9ydCkpIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5vcHNldEltcG9ydC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm9wc2V0SW1wb3J0W2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydFtpXSA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm9wc2V0SW1wb3J0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5wcm9kdWNlck5hbWUgIT0gbnVsbCkgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSBTdHJpbmcob2JqZWN0LnByb2R1Y2VyTmFtZSk7XG4gICAgICBpZiAob2JqZWN0LnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsKSBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiA9IFN0cmluZyhvYmplY3QucHJvZHVjZXJWZXJzaW9uKTtcbiAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgaWYgKG9iamVjdC5tb2RlbFZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLm1vZGVsVmVyc2lvbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5tb2RlbFZlcnNpb24pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gJ3N0cmluZycpIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gcGFyc2VJbnQob2JqZWN0Lm1vZGVsVmVyc2lvbiwgMTApO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gJ251bWJlcicpIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gb2JqZWN0Lm1vZGVsVmVyc2lvbjtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5tb2RlbFZlcnNpb24gPT09ICdvYmplY3QnKVxuICAgICAgICAgIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gbmV3ICR1dGlsLkxvbmdCaXRzKFxuICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbi5sb3cgPj4+IDAsXG4gICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uLmhpZ2ggPj4+IDAsXG4gICAgICAgICAgKS50b051bWJlcigpO1xuICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbCkgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICBpZiAob2JqZWN0LmdyYXBoICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZ3JhcGggIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmdyYXBoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QubWV0YWRhdGFQcm9wcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm1ldGFkYXRhUHJvcHMpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5tZXRhZGF0YVByb3BzW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChvYmplY3QubWV0YWRhdGFQcm9wc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudHJhaW5pbmdJbmZvKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudHJhaW5pbmdJbmZvKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5Nb2RlbFByb3RvLnRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS50cmFpbmluZ0luZm8gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudHJhaW5pbmdJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHJhaW5pbmdJbmZvW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by50cmFpbmluZ0luZm86IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UudHJhaW5pbmdJbmZvW2ldID0gJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC50cmFpbmluZ0luZm9baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZ1bmN0aW9ucykpIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZ1bmN0aW9uc1tpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zW2ldID0gJHJvb3Qub25ueC5GdW5jdGlvblByb3RvLmZyb21PYmplY3Qob2JqZWN0LmZ1bmN0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBNb2RlbFByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5Nb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICBvYmplY3QudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgIG9iamVjdC5mdW5jdGlvbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICAgIG9iamVjdC5wcm9kdWNlck5hbWUgPSAnJztcbiAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9ICcnO1xuICAgICAgICBvYmplY3QuZG9tYWluID0gJyc7XG4gICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0Lm1vZGVsVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSAnJztcbiAgICAgICAgb2JqZWN0LmdyYXBoID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lyVmVyc2lvbicpKVxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaXJWZXJzaW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgICBvYmplY3QuaXJWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaXJWZXJzaW9uKSA6IG1lc3NhZ2UuaXJWZXJzaW9uO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaXJWZXJzaW9uKVxuICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaXJWZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS5pclZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdwcm9kdWNlck5hbWUnKSlcbiAgICAgICAgb2JqZWN0LnByb2R1Y2VyTmFtZSA9IG1lc3NhZ2UucHJvZHVjZXJOYW1lO1xuICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncHJvZHVjZXJWZXJzaW9uJykpXG4gICAgICAgIG9iamVjdC5wcm9kdWNlclZlcnNpb24gPSBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbjtcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvbWFpbicpKSBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdtb2RlbFZlcnNpb24nKSlcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLm1vZGVsVmVyc2lvbikgOiBtZXNzYWdlLm1vZGVsVmVyc2lvbjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPVxuICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLm1vZGVsVmVyc2lvbilcbiAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLm1vZGVsVmVyc2lvbi5sb3cgPj4+IDAsIG1lc3NhZ2UubW9kZWxWZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICA6IG1lc3NhZ2UubW9kZWxWZXJzaW9uO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGgnKSlcbiAgICAgICAgb2JqZWN0LmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnRbal0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChtZXNzYWdlLm9wc2V0SW1wb3J0W2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wc1tqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChtZXNzYWdlLm1ldGFkYXRhUHJvcHNbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudHJhaW5pbmdJbmZvICYmIG1lc3NhZ2UudHJhaW5pbmdJbmZvLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnRyYWluaW5nSW5mb1tqXSA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS50cmFpbmluZ0luZm9bal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICYmIG1lc3NhZ2UuZnVuY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZnVuY3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmZ1bmN0aW9uc1tqXSA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by50b09iamVjdChtZXNzYWdlLmZ1bmN0aW9uc1tqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIE1vZGVsUHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTW9kZWxQcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguTW9kZWxQcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2RlbFByb3RvO1xuICB9KSgpO1xuXG4gIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2tleV0gU3RyaW5nU3RyaW5nRW50cnlQcm90byBrZXlcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdmFsdWVdIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3RyaW5nU3RyaW5nRW50cnlQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGtleS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGtleVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS5rZXkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdmFsdWUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS52YWx1ZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAna2V5JykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd2YWx1ZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5zdHJpbmcobWVzc2FnZS52YWx1ZSk7XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2tleScpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uua2V5KSkgcmV0dXJuICdrZXk6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS52YWx1ZSkpIHJldHVybiAndmFsdWU6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmtleSAhPSBudWxsKSBtZXNzYWdlLmtleSA9IFN0cmluZyhvYmplY3Qua2V5KTtcbiAgICAgIGlmIChvYmplY3QudmFsdWUgIT0gbnVsbCkgbWVzc2FnZS52YWx1ZSA9IFN0cmluZyhvYmplY3QudmFsdWUpO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IG1lc3NhZ2UgU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmtleSA9ICcnO1xuICAgICAgICBvYmplY3QudmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2tleScpKSBvYmplY3Qua2V5ID0gbWVzc2FnZS5rZXk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIG9iamVjdC52YWx1ZSA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvO1xuICB9KSgpO1xuXG4gIG9ubnguVGVuc29yQW5ub3RhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3RlbnNvck5hbWVdIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXSBUZW5zb3JBbm5vdGF0aW9uIHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yQW5ub3RhdGlvbi5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICogQGltcGxlbWVudHMgSVRlbnNvckFubm90YXRpb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW5zb3JBbm5vdGF0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRlbnNvck5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yQW5ub3RhdGlvbi5wcm90b3R5cGUudGVuc29yTmFtZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gcXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLnByb3RvdHlwZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JBbm5vdGF0aW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgVGVuc29yQW5ub3RhdGlvbihwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvckFubm90YXRpb24gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd0ZW5zb3JOYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLnRlbnNvck5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAhPSBudWxsICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb259IG1lc3NhZ2UgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbigpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0ZW5zb3JOYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZW5zb3JOYW1lKSkgcmV0dXJuICd0ZW5zb3JOYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3F1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSkgcmV0dXJuICdxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbikgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbigpO1xuICAgICAgaWYgKG9iamVjdC50ZW5zb3JOYW1lICE9IG51bGwpIG1lc3NhZ2UudGVuc29yTmFtZSA9IFN0cmluZyhvYmplY3QudGVuc29yTmFtZSk7XG4gICAgICBpZiAob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChcbiAgICAgICAgICAgIG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBtZXNzYWdlIFRlbnNvckFubm90YXRpb25cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIG9iamVjdC50ZW5zb3JOYW1lID0gJyc7XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndGVuc29yTmFtZScpKSBvYmplY3QudGVuc29yTmFtZSA9IG1lc3NhZ2UudGVuc29yTmFtZTtcbiAgICAgIGlmIChtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgJiYgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChcbiAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tqXSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yQW5ub3RhdGlvbiB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgVGVuc29yQW5ub3RhdGlvbi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UZW5zb3JBbm5vdGF0aW9uJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRlbnNvckFubm90YXRpb247XG4gIH0pKCk7XG5cbiAgb25ueC5HcmFwaFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgR3JhcGhQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBpbnRlcmZhY2UgSUdyYXBoUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fG51bGx9IFtub2RlXSBHcmFwaFByb3RvIG5vZGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gR3JhcGhQcm90byBuYW1lXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fG51bGx9IFtpbml0aWFsaXplcl0gR3JhcGhQcm90byBpbml0aWFsaXplclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVNwYXJzZVRlbnNvclByb3RvPnxudWxsfSBbc3BhcnNlSW5pdGlhbGl6ZXJdIEdyYXBoUHJvdG8gc3BhcnNlSW5pdGlhbGl6ZXJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBHcmFwaFByb3RvIGRvY1N0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbaW5wdXRdIEdyYXBoUHJvdG8gaW5wdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW291dHB1dF0gR3JhcGhQcm90byBvdXRwdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW3ZhbHVlSW5mb10gR3JhcGhQcm90byB2YWx1ZUluZm9cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUZW5zb3JBbm5vdGF0aW9uPnxudWxsfSBbcXVhbnRpemF0aW9uQW5ub3RhdGlvbl0gR3JhcGhQcm90byBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdyYXBoUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHcmFwaFByb3RvLlxuICAgICAqIEBpbXBsZW1lbnRzIElHcmFwaFByb3RvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gR3JhcGhQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLm5vZGUgPSBbXTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgIHRoaXMuc3BhcnNlSW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICB0aGlzLnZhbHVlSW5mbyA9IFtdO1xuICAgICAgdGhpcy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byBub2RlLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fSBub2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm5vZGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byBuYW1lLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5uYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFByb3RvIGluaXRpYWxpemVyLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUZW5zb3JQcm90bz59IGluaXRpYWxpemVyXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemVyID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEdyYXBoUHJvdG8gc3BhcnNlSW5pdGlhbGl6ZXIuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVNwYXJzZVRlbnNvclByb3RvPn0gc3BhcnNlSW5pdGlhbGl6ZXJcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgR3JhcGhQcm90by5wcm90b3R5cGUuc3BhcnNlSW5pdGlhbGl6ZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgR3JhcGhQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFByb3RvIGlucHV0LlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IGlucHV0XG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEdyYXBoUHJvdG8gb3V0cHV0LlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IG91dHB1dFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5vdXRwdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byB2YWx1ZUluZm8uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPn0gdmFsdWVJbmZvXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnZhbHVlSW5mbyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFByb3RvIHF1YW50aXphdGlvbkFubm90YXRpb24uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvckFubm90YXRpb24+fSBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnF1YW50aXphdGlvbkFubm90YXRpb24gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgR3JhcGhQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaFByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR3JhcGhQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkdyYXBoUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvfSBtZXNzYWdlIEdyYXBoUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5Ob2RlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uubm9kZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnbmFtZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemVyICE9IG51bGwgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6ZXJbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki8gODIpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMSwgd2lyZVR5cGUgMiA9Ki8gOTApLmZvcmsoKSxcbiAgICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXRbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEyLCB3aXJlVHlwZSAyID0qLyA5OCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZUluZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlSW5mb1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovIDEwNikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDIgPSovIDExNCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxNSwgd2lyZVR5cGUgMiA9Ki8gMTIyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHcmFwaFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguR3JhcGhQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgR3JhcGhQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIEdyYXBoUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEdyYXBoUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguR3JhcGhQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSkgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpKSBtZXNzYWdlLmluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemVyLnB1c2goJHJvb3Qub25ueC5UZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyICYmIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoKSkgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5wdXNoKCRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm91dHB1dC5wdXNoKCRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMzoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSkgbWVzc2FnZS52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvLnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkpXG4gICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLnB1c2goJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHJldHVybnMge29ubnguR3JhcGhQcm90b30gR3JhcGhQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgR3JhcGhQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgR3JhcGhQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgR3JhcGhQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbm9kZScpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm5vZGUpKSByZXR1cm4gJ25vZGU6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk5vZGVQcm90by52ZXJpZnkobWVzc2FnZS5ub2RlW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnbm9kZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSkgcmV0dXJuICduYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXplcicpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmluaXRpYWxpemVyKSkgcmV0dXJuICdpbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemVyW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnaW5pdGlhbGl6ZXIuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NwYXJzZUluaXRpYWxpemVyJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIpKSByZXR1cm4gJ3NwYXJzZUluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdzcGFyc2VJbml0aWFsaXplci4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSkgcmV0dXJuICdkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lucHV0JykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKSByZXR1cm4gJ2lucHV0OiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdpbnB1dC4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ291dHB1dCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm91dHB1dCkpIHJldHVybiAnb3V0cHV0OiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ291dHB1dC4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnZhbHVlSW5mbyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlSW5mbycpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnZhbHVlSW5mbykpIHJldHVybiAndmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlSW5mb1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3ZhbHVlSW5mby4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdxdWFudGl6YXRpb25Bbm5vdGF0aW9uJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpIHJldHVybiAncXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAncXVhbnRpemF0aW9uQW5ub3RhdGlvbi4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvXG4gICAgICovXG4gICAgR3JhcGhQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkdyYXBoUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkdyYXBoUHJvdG8oKTtcbiAgICAgIGlmIChvYmplY3Qubm9kZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm5vZGUpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ub2RlW2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLm5vZGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2Uubm9kZVtpXSA9ICRyb290Lm9ubnguTm9kZVByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXplcikpIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemVyW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnNwYXJzZUluaXRpYWxpemVyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXIpKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKSBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnB1dCkpIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmlucHV0W2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qub3V0cHV0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3V0cHV0KSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3V0cHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3V0cHV0W2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5vdXRwdXRbaV0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3Qob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudmFsdWVJbmZvKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVJbmZvKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVJbmZvW2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS52YWx1ZUluZm9baV0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlSW5mb1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24pKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb25baV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEdyYXBoUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LkdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgR3JhcGhQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgb2JqZWN0LmluaXRpYWxpemVyID0gW107XG4gICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgIG9iamVjdC52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICYmIG1lc3NhZ2Uubm9kZS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXplciAmJiBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplcltqXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXplcltqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSkgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QuaW5wdXRbal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5wdXRbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0Lm91dHB1dFtqXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS5vdXRwdXRbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICYmIG1lc3NhZ2UudmFsdWVJbmZvLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QudmFsdWVJbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnZhbHVlSW5mb1tqXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS52YWx1ZUluZm9bal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiAmJiBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdID0gJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KFxuICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXJbal0gPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXJbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBHcmFwaFByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgR3JhcGhQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIEdyYXBoUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBHcmFwaFByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgJy9vbm54LkdyYXBoUHJvdG8nO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JhcGhQcm90bztcbiAgfSkoKTtcblxuICBvbm54LlRlbnNvclByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcnxMb25nPnxudWxsfSBbZGltc10gVGVuc29yUHJvdG8gZGltc1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtkYXRhVHlwZV0gVGVuc29yUHJvdG8gZGF0YVR5cGVcbiAgICAgKiBAcHJvcGVydHkge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR8bnVsbH0gW3NlZ21lbnRdIFRlbnNvclByb3RvIHNlZ21lbnRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtmbG9hdERhdGFdIFRlbnNvclByb3RvIGZsb2F0RGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2ludDMyRGF0YV0gVGVuc29yUHJvdG8gaW50MzJEYXRhXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48VWludDhBcnJheT58bnVsbH0gW3N0cmluZ0RhdGFdIFRlbnNvclByb3RvIHN0cmluZ0RhdGFcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2ludDY0RGF0YV0gVGVuc29yUHJvdG8gaW50NjREYXRhXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIFRlbnNvclByb3RvIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBUZW5zb3JQcm90byBkb2NTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3Jhd0RhdGFdIFRlbnNvclByb3RvIHJhd0RhdGFcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbZXh0ZXJuYWxEYXRhXSBUZW5zb3JQcm90byBleHRlcm5hbERhdGFcbiAgICAgKiBAcHJvcGVydHkge29ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9ufG51bGx9IFtkYXRhTG9jYXRpb25dIFRlbnNvclByb3RvIGRhdGFMb2NhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2RvdWJsZURhdGFdIFRlbnNvclByb3RvIGRvdWJsZURhdGFcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW3VpbnQ2NERhdGFdIFRlbnNvclByb3RvIHVpbnQ2NERhdGFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUZW5zb3JQcm90by5cbiAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVuc29yUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgdGhpcy5kaW1zID0gW107XG4gICAgICB0aGlzLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgdGhpcy5pbnQzMkRhdGEgPSBbXTtcbiAgICAgIHRoaXMuc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgdGhpcy5pbnQ2NERhdGEgPSBbXTtcbiAgICAgIHRoaXMuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICB0aGlzLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgIHRoaXMudWludDY0RGF0YSA9IFtdO1xuICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGRpbXMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gZGltc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRpbXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gZGF0YVR5cGUuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBkYXRhVHlwZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRhdGFUeXBlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIHNlZ21lbnQuXG4gICAgICogQG1lbWJlciB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudHxudWxsfHVuZGVmaW5lZH0gc2VnbWVudFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnNlZ21lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gZmxvYXREYXRhLlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdERhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5mbG9hdERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gaW50MzJEYXRhLlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBpbnQzMkRhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5pbnQzMkRhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gc3RyaW5nRGF0YS5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48VWludDhBcnJheT59IHN0cmluZ0RhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5zdHJpbmdEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGludDY0RGF0YS5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBpbnQ2NERhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5pbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gbmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5uYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBUZW5zb3JQcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIHJhd0RhdGEuXG4gICAgICogQG1lbWJlciB7VWludDhBcnJheX0gcmF3RGF0YVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnJhd0RhdGEgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gZXh0ZXJuYWxEYXRhLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gZXh0ZXJuYWxEYXRhXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGRhdGFMb2NhdGlvbi5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbn0gZGF0YUxvY2F0aW9uXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZGF0YUxvY2F0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGRvdWJsZURhdGEuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGRvdWJsZURhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kb3VibGVEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIHVpbnQ2NERhdGEuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gdWludDY0RGF0YVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnVpbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZW5zb3JQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBUZW5zb3JQcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpIHtcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsraSkgd3JpdGVyLmludDY0KG1lc3NhZ2UuZGltc1tpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RhdGFUeXBlJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8gMTYpLmludDMyKG1lc3NhZ2UuZGF0YVR5cGUpO1xuICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdzZWdtZW50JykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5lbmNvZGUoXG4gICAgICAgICAgbWVzc2FnZS5zZWdtZW50LFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLmZvcmsoKSxcbiAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovIDM0KS5mb3JrKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoOyArK2kpIHdyaXRlci5mbG9hdChtZXNzYWdlLmZsb2F0RGF0YVtpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmludDMyRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoOyArK2kpIHdyaXRlci5pbnQzMihtZXNzYWdlLmludDMyRGF0YVtpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovIDUwKS5ieXRlcyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pO1xuICAgICAgaWYgKG1lc3NhZ2UuaW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNywgd2lyZVR5cGUgMiA9Ki8gNTgpLmZvcmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsraSkgd3JpdGVyLmludDY0KG1lc3NhZ2UuaW50NjREYXRhW2ldKTtcbiAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki8gNjYpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdyYXdEYXRhJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOSwgd2lyZVR5cGUgMiA9Ki8gNzQpLmJ5dGVzKG1lc3NhZ2UucmF3RGF0YSk7XG4gICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLyA4MikuZm9yaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGg7ICsraSkgd3JpdGVyLmRvdWJsZShtZXNzYWdlLmRvdWJsZURhdGFbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLyA5MCkuZm9yaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGg7ICsraSkgd3JpdGVyLnVpbnQ2NChtZXNzYWdlLnVpbnQ2NERhdGFbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9jU3RyaW5nJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTIsIHdpcmVUeXBlIDIgPSovIDk4KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovIDEwNikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZGF0YUxvY2F0aW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDAgPSovIDExMikuaW50MzIobWVzc2FnZS5kYXRhTG9jYXRpb24pO1xuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvKCk7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKSBtZXNzYWdlLmRpbXMgPSBbXTtcbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmRpbXMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGFUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZmxvYXREYXRhICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkpIG1lc3NhZ2UuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLmZsb2F0RGF0YS5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmZsb2F0RGF0YS5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW50MzJEYXRhICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkpIG1lc3NhZ2UuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLmludDMyRGF0YS5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmludDMyRGF0YS5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5nRGF0YSAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKSkgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnN0cmluZ0RhdGEucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmludDY0RGF0YSAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpKSBtZXNzYWdlLmludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMikgbWVzc2FnZS5pbnQ2NERhdGEucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICB9IGVsc2UgbWVzc2FnZS5pbnQ2NERhdGEucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMjoge1xuICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICBtZXNzYWdlLnJhd0RhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEzOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmV4dGVybmFsRGF0YSAmJiBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGgpKSBtZXNzYWdlLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGEucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxNDoge1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkpIG1lc3NhZ2UuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMikgbWVzc2FnZS5kb3VibGVEYXRhLnB1c2gocmVhZGVyLmRvdWJsZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmRvdWJsZURhdGEucHVzaChyZWFkZXIuZG91YmxlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudWludDY0RGF0YSAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSkgbWVzc2FnZS51aW50NjREYXRhID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLnVpbnQ2NERhdGEucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIG1lc3NhZ2UudWludDY0RGF0YS5wdXNoKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVGVuc29yUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RpbXMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kaW1zKSkgcmV0dXJuICdkaW1zOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldKSAmJlxuICAgICAgICAgICAgIShtZXNzYWdlLmRpbXNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0uaGlnaCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kYXRhVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RhdGFUeXBlJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0YVR5cGUpKSByZXR1cm4gJ2RhdGFUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnNlZ21lbnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzZWdtZW50JykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeShtZXNzYWdlLnNlZ21lbnQpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc2VnbWVudC4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5mbG9hdERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdmbG9hdERhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdERhdGEpKSByZXR1cm4gJ2Zsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mbG9hdERhdGFbaV0gIT09ICdudW1iZXInKSByZXR1cm4gJ2Zsb2F0RGF0YTogbnVtYmVyW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaW50MzJEYXRhJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW50MzJEYXRhKSkgcmV0dXJuICdpbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDMyRGF0YVtpXSkpIHJldHVybiAnaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3N0cmluZ0RhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJpbmdEYXRhKSkgcmV0dXJuICdzdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIChtZXNzYWdlLnN0cmluZ0RhdGFbaV0gJiYgdHlwZW9mIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXS5sZW5ndGggPT09ICdudW1iZXInKSB8fFxuICAgICAgICAgICAgICAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdzdHJpbmdEYXRhOiBidWZmZXJbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbnQ2NERhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnQ2NERhdGEpKSByZXR1cm4gJ2ludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0pICYmXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YVtpXSAmJlxuICAgICAgICAgICAgICAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0ubG93KSAmJlxuICAgICAgICAgICAgICAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0uaGlnaClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ2ludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKSByZXR1cm4gJ25hbWU6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpIHJldHVybiAnZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3Jhd0RhdGEnKSlcbiAgICAgICAgaWYgKCEoKG1lc3NhZ2UucmF3RGF0YSAmJiB0eXBlb2YgbWVzc2FnZS5yYXdEYXRhLmxlbmd0aCA9PT0gJ251bWJlcicpIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucmF3RGF0YSkpKVxuICAgICAgICAgIHJldHVybiAncmF3RGF0YTogYnVmZmVyIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmV4dGVybmFsRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2V4dGVybmFsRGF0YScpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmV4dGVybmFsRGF0YSkpIHJldHVybiAnZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnZXh0ZXJuYWxEYXRhLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZGF0YUxvY2F0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZGF0YUxvY2F0aW9uJykpXG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5kYXRhTG9jYXRpb24pIHtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdkYXRhTG9jYXRpb246IGVudW0gdmFsdWUgZXhwZWN0ZWQnO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvdWJsZURhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kb3VibGVEYXRhKSkgcmV0dXJuICdkb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kb3VibGVEYXRhW2ldICE9PSAnbnVtYmVyJykgcmV0dXJuICdkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndWludDY0RGF0YScpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnVpbnQ2NERhdGEpKSByZXR1cm4gJ3VpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0pICYmXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gJiZcbiAgICAgICAgICAgICAgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudWludDY0RGF0YVtpXS5sb3cpICYmXG4gICAgICAgICAgICAgICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0uaGlnaClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ3VpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmRpbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW1zKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmRpbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoJHV0aWwuTG9uZykgKG1lc3NhZ2UuZGltc1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kaW1zW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09ICdzdHJpbmcnKSBtZXNzYWdlLmRpbXNbaV0gPSBwYXJzZUludChvYmplY3QuZGltc1tpXSwgMTApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gJ251bWJlcicpIG1lc3NhZ2UuZGltc1tpXSA9IG9iamVjdC5kaW1zW2ldO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmRpbXNbaV0ubG93ID4+PiAwLCBvYmplY3QuZGltc1tpXS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kYXRhVHlwZSAhPSBudWxsKSBtZXNzYWdlLmRhdGFUeXBlID0gb2JqZWN0LmRhdGFUeXBlIHwgMDtcbiAgICAgIGlmIChvYmplY3Quc2VnbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNlZ21lbnQgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLnNlZ21lbnQ6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZnJvbU9iamVjdChvYmplY3Quc2VnbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsb2F0RGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZsb2F0RGF0YSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5mbG9hdERhdGEubGVuZ3RoOyArK2kpIG1lc3NhZ2UuZmxvYXREYXRhW2ldID0gTnVtYmVyKG9iamVjdC5mbG9hdERhdGFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5pbnQzMkRhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnQzMkRhdGEpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50MzJEYXRhLmxlbmd0aDsgKytpKSBtZXNzYWdlLmludDMyRGF0YVtpXSA9IG9iamVjdC5pbnQzMkRhdGFbaV0gfCAwO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5zdHJpbmdEYXRhKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5nRGF0YSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc3RyaW5nRGF0YVtpXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKFxuICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YVtpXSxcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdHJpbmdEYXRhW2ldKSkpLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIGlmIChvYmplY3Quc3RyaW5nRGF0YVtpXS5sZW5ndGggPj0gMCkgbWVzc2FnZS5zdHJpbmdEYXRhW2ldID0gb2JqZWN0LnN0cmluZ0RhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmludDY0RGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmludDY0RGF0YSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uaW50NjREYXRhOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmludDY0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmludDY0RGF0YVtpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pbnQ2NERhdGFbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSAnc3RyaW5nJykgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBwYXJzZUludChvYmplY3QuaW50NjREYXRhW2ldLCAxMCk7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnQ2NERhdGFbaV0gPT09ICdudW1iZXInKSBtZXNzYWdlLmludDY0RGF0YVtpXSA9IG9iamVjdC5pbnQ2NERhdGFbaV07XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnQ2NERhdGFbaV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMoXG4gICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbaV0ubG93ID4+PiAwLFxuICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhW2ldLmhpZ2ggPj4+IDAsXG4gICAgICAgICAgICApLnRvTnVtYmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgaWYgKG9iamVjdC5yYXdEYXRhICE9IG51bGwpXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnJhd0RhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUoXG4gICAgICAgICAgICBvYmplY3QucmF3RGF0YSxcbiAgICAgICAgICAgIChtZXNzYWdlLnJhd0RhdGEgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucmF3RGF0YSkpKSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0LnJhd0RhdGEubGVuZ3RoID49IDApIG1lc3NhZ2UucmF3RGF0YSA9IG9iamVjdC5yYXdEYXRhO1xuICAgICAgaWYgKG9iamVjdC5leHRlcm5hbERhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5leHRlcm5hbERhdGEpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZXh0ZXJuYWxEYXRhW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5leHRlcm5hbERhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9iamVjdC5kYXRhTG9jYXRpb24pIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXRhTG9jYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IG9iamVjdC5kYXRhTG9jYXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RFRkFVTFQnOlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFWFRFUk5BTCc6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmRvdWJsZURhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kb3VibGVEYXRhKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZG91YmxlRGF0YS5sZW5ndGg7ICsraSkgbWVzc2FnZS5kb3VibGVEYXRhW2ldID0gTnVtYmVyKG9iamVjdC5kb3VibGVEYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudWludDY0RGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnVpbnQ2NERhdGEpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLnVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UudWludDY0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSAobWVzc2FnZS51aW50NjREYXRhW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LnVpbnQ2NERhdGFbaV0pKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSAnc3RyaW5nJykgbWVzc2FnZS51aW50NjREYXRhW2ldID0gcGFyc2VJbnQob2JqZWN0LnVpbnQ2NERhdGFbaV0sIDEwKTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09ICdudW1iZXInKSBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSBvYmplY3QudWludDY0RGF0YVtpXTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKFxuICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YVtpXS5sb3cgPj4+IDAsXG4gICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhW2ldLmhpZ2ggPj4+IDAsXG4gICAgICAgICAgICApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvclByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICBvYmplY3QuZmxvYXREYXRhID0gW107XG4gICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgb2JqZWN0LnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgb2JqZWN0LmludDY0RGF0YSA9IFtdO1xuICAgICAgICBvYmplY3QuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICBvYmplY3QudWludDY0RGF0YSA9IFtdO1xuICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QuZGF0YVR5cGUgPSAwO1xuICAgICAgICBvYmplY3Quc2VnbWVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5uYW1lID0gJyc7XG4gICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpIG9iamVjdC5yYXdEYXRhID0gJyc7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KSBvYmplY3QucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QucmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9ICcnO1xuICAgICAgICBvYmplY3QuZGF0YUxvY2F0aW9uID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJ0RFRkFVTFQnIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRpbXMgJiYgbWVzc2FnZS5kaW1zLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGltc1tqXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbXNbal0pIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9iamVjdC5kaW1zW2pdID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGltc1tqXSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kaW1zW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5kaW1zW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZGF0YVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkYXRhVHlwZScpKSBvYmplY3QuZGF0YVR5cGUgPSBtZXNzYWdlLmRhdGFUeXBlO1xuICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NlZ21lbnQnKSlcbiAgICAgICAgb2JqZWN0LnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudG9PYmplY3QobWVzc2FnZS5zZWdtZW50LCBvcHRpb25zKTtcbiAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAmJiBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5mbG9hdERhdGFbal0gPVxuICAgICAgICAgICAgb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmZsb2F0RGF0YVtqXSkgPyBTdHJpbmcobWVzc2FnZS5mbG9hdERhdGFbal0pIDogbWVzc2FnZS5mbG9hdERhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsraikgb2JqZWN0LmludDMyRGF0YVtqXSA9IG1lc3NhZ2UuaW50MzJEYXRhW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5zdHJpbmdEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5zdHJpbmdEYXRhW2pdID1cbiAgICAgICAgICAgIG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZ1xuICAgICAgICAgICAgICA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdEYXRhW2pdLCAwLCBtZXNzYWdlLnN0cmluZ0RhdGFbal0ubGVuZ3RoKVxuICAgICAgICAgICAgICA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5XG4gICAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ0RhdGFbal0pXG4gICAgICAgICAgICAgICAgOiBtZXNzYWdlLnN0cmluZ0RhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgJiYgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50NjREYXRhW2pdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pbnQ2NERhdGFbal0pIDogbWVzc2FnZS5pbnQ2NERhdGFbal07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqZWN0LmludDY0RGF0YVtqXSA9XG4gICAgICAgICAgICAgIG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZ1xuICAgICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmludDY0RGF0YVtqXSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnQ2NERhdGFbal0ubG93ID4+PiAwLCBtZXNzYWdlLmludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICA6IG1lc3NhZ2UuaW50NjREYXRhW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICBpZiAobWVzc2FnZS5yYXdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncmF3RGF0YScpKVxuICAgICAgICBvYmplY3QucmF3RGF0YSA9XG4gICAgICAgICAgb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nXG4gICAgICAgICAgICA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5yYXdEYXRhLCAwLCBtZXNzYWdlLnJhd0RhdGEubGVuZ3RoKVxuICAgICAgICAgICAgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheVxuICAgICAgICAgICAgICA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UucmF3RGF0YSlcbiAgICAgICAgICAgICAgOiBtZXNzYWdlLnJhd0RhdGE7XG4gICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICYmIG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmRvdWJsZURhdGFbal0gPVxuICAgICAgICAgICAgb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmRvdWJsZURhdGFbal0pID8gU3RyaW5nKG1lc3NhZ2UuZG91YmxlRGF0YVtqXSkgOiBtZXNzYWdlLmRvdWJsZURhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICYmIG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnVpbnQ2NERhdGFbal0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS51aW50NjREYXRhW2pdKSA6IG1lc3NhZ2UudWludDY0RGF0YVtqXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvYmplY3QudWludDY0RGF0YVtqXSA9XG4gICAgICAgICAgICAgIG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZ1xuICAgICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnVpbnQ2NERhdGFbal0pXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICAgID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UudWludDY0RGF0YVtqXS5sb3cgPj4+IDAsIG1lc3NhZ2UudWludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKVxuICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlLnVpbnQ2NERhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSkgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmV4dGVybmFsRGF0YVtqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChtZXNzYWdlLmV4dGVybmFsRGF0YVtqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkYXRhTG9jYXRpb24nKSlcbiAgICAgICAgb2JqZWN0LmRhdGFMb2NhdGlvbiA9XG4gICAgICAgICAgb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nXG4gICAgICAgICAgICA/ICRyb290Lm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW21lc3NhZ2UuZGF0YUxvY2F0aW9uXSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbWVzc2FnZS5kYXRhTG9jYXRpb25cbiAgICAgICAgICAgICAgOiAkcm9vdC5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblttZXNzYWdlLmRhdGFMb2NhdGlvbl1cbiAgICAgICAgICAgIDogbWVzc2FnZS5kYXRhTG9jYXRpb247XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFRlbnNvclByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVGVuc29yUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVGVuc29yUHJvdG8nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEYXRhVHlwZSBlbnVtLlxuICAgICAqIEBuYW1lIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVcbiAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ9MSBGTE9BVCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UOD0yIFVJTlQ4IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDg9MyBJTlQ4IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQxNj00IFVJTlQxNiB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQxNj01IElOVDE2IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDMyPTYgSU5UMzIgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSU5UNjQ9NyBJTlQ2NCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkc9OCBTVFJJTkcgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQk9PTD05IEJPT0wgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQxNj0xMCBGTE9BVDE2IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERPVUJMRT0xMSBET1VCTEUgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDMyPTEyIFVJTlQzMiB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UNjQ9MTMgVUlOVDY0IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IENPTVBMRVg2ND0xNCBDT01QTEVYNjQgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDEyOD0xNSBDT01QTEVYMTI4IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJGTE9BVDE2PTE2IEJGTE9BVDE2IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUOEU0TTNGTj0xNyBGTE9BVDhFNE0zRk4gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTRNM0ZOVVo9MTggRkxPQVQ4RTRNM0ZOVVogdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTVNMj0xOSBGTE9BVDhFNU0yIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUOEU1TTJGTlVaPTIwIEZMT0FUOEU1TTJGTlVaIHZhbHVlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8uRGF0YVR5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgICAgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFswXSA9ICdVTkRFRklORUQnKV0gPSAwO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzFdID0gJ0ZMT0FUJyldID0gMTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsyXSA9ICdVSU5UOCcpXSA9IDI7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbM10gPSAnSU5UOCcpXSA9IDM7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNF0gPSAnVUlOVDE2JyldID0gNDtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs1XSA9ICdJTlQxNicpXSA9IDU7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNl0gPSAnSU5UMzInKV0gPSA2O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzddID0gJ0lOVDY0JyldID0gNztcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs4XSA9ICdTVFJJTkcnKV0gPSA4O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzldID0gJ0JPT0wnKV0gPSA5O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzEwXSA9ICdGTE9BVDE2JyldID0gMTA7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTFdID0gJ0RPVUJMRScpXSA9IDExO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzEyXSA9ICdVSU5UMzInKV0gPSAxMjtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxM10gPSAnVUlOVDY0JyldID0gMTM7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTRdID0gJ0NPTVBMRVg2NCcpXSA9IDE0O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzE1XSA9ICdDT01QTEVYMTI4JyldID0gMTU7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTZdID0gJ0JGTE9BVDE2JyldID0gMTY7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTddID0gJ0ZMT0FUOEU0TTNGTicpXSA9IDE3O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzE4XSA9ICdGTE9BVDhFNE0zRk5VWicpXSA9IDE4O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzE5XSA9ICdGTE9BVDhFNU0yJyldID0gMTk7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMjBdID0gJ0ZMT0FUOEU1TTJGTlVaJyldID0gMjA7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICBUZW5zb3JQcm90by5TZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvZiBhIFNlZ21lbnQuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICogQGludGVyZmFjZSBJU2VnbWVudFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbYmVnaW5dIFNlZ21lbnQgYmVnaW5cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2VuZF0gU2VnbWVudCBlbmRcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VnbWVudC5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZWdtZW50LlxuICAgICAgICogQGltcGxlbWVudHMgSVNlZ21lbnRcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIFNlZ21lbnQocHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlZ21lbnQgYmVnaW4uXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gYmVnaW5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTZWdtZW50LnByb3RvdHlwZS5iZWdpbiA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VnbWVudCBlbmQuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gZW5kXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgU2VnbWVudC5wcm90b3R5cGUuZW5kID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IFNlZ21lbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50IGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VnbWVudCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBTZWdtZW50LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2JlZ2luJykpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLyA4KS5pbnQ2NChtZXNzYWdlLmJlZ2luKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZW5kICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VuZCcpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8gMTYpLmludDY0KG1lc3NhZ2UuZW5kKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlZ21lbnQgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fSBtZXNzYWdlIFNlZ21lbnQgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgU2VnbWVudC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICovXG4gICAgICBTZWdtZW50LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZpZXMgYSBTZWdtZW50IG1lc3NhZ2UuXG4gICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnYmVnaW4nKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4pICYmXG4gICAgICAgICAgICAhKG1lc3NhZ2UuYmVnaW4gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iZWdpbi5oaWdoKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ2JlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbmQnKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZW5kKSAmJlxuICAgICAgICAgICAgIShtZXNzYWdlLmVuZCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQuaGlnaCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZCc7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICovXG4gICAgICBTZWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KSByZXR1cm4gb2JqZWN0O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQoKTtcbiAgICAgICAgaWYgKG9iamVjdC5iZWdpbiAhPSBudWxsKVxuICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSAobWVzc2FnZS5iZWdpbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5iZWdpbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5iZWdpbiA9PT0gJ3N0cmluZycpIG1lc3NhZ2UuYmVnaW4gPSBwYXJzZUludChvYmplY3QuYmVnaW4sIDEwKTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSAnbnVtYmVyJykgbWVzc2FnZS5iZWdpbiA9IG9iamVjdC5iZWdpbjtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIG1lc3NhZ2UuYmVnaW4gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmJlZ2luLmxvdyA+Pj4gMCwgb2JqZWN0LmJlZ2luLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChvYmplY3QuZW5kICE9IG51bGwpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmVuZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5lbmQpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZW5kID09PSAnc3RyaW5nJykgbWVzc2FnZS5lbmQgPSBwYXJzZUludChvYmplY3QuZW5kLCAxMCk7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09ICdudW1iZXInKSBtZXNzYWdlLmVuZCA9IG9iamVjdC5lbmQ7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5lbmQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmVuZC5sb3cgPj4+IDAsIG9iamVjdC5lbmQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFNlZ21lbnQgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gbWVzc2FnZSBTZWdtZW50XG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgb2JqZWN0LmJlZ2luID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICB9IGVsc2Ugb2JqZWN0LmJlZ2luID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJzAnIDogMDtcbiAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICBvYmplY3QuZW5kID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICB9IGVsc2Ugb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmVnaW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdiZWdpbicpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5iZWdpbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5iZWdpbikgOiBtZXNzYWdlLmJlZ2luO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9XG4gICAgICAgICAgICAgIG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZ1xuICAgICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmJlZ2luKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmJlZ2luLmxvdyA+Pj4gMCwgbWVzc2FnZS5iZWdpbi5oaWdoID4+PiAwKS50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICA6IG1lc3NhZ2UuYmVnaW47XG4gICAgICAgIGlmIChtZXNzYWdlLmVuZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2VuZCcpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5lbmQgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmVuZCkgOiBtZXNzYWdlLmVuZDtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvYmplY3QuZW5kID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZW5kKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmVuZC5sb3cgPj4+IDAsIG1lc3NhZ2UuZW5kLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5lbmQ7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIHRoaXMgU2VnbWVudCB0byBKU09OLlxuICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFNlZ21lbnRcbiAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UZW5zb3JQcm90by5TZWdtZW50JztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZWdtZW50O1xuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhTG9jYXRpb24gZW51bS5cbiAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblxuICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERFRkFVTFQ9MCBERUZBVUxUIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEVYVEVSTkFMPTEgRVhURVJOQUwgdmFsdWVcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5EYXRhTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgICAgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFswXSA9ICdERUZBVUxUJyldID0gMDtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxXSA9ICdFWFRFUk5BTCcpXSA9IDE7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gVGVuc29yUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5TcGFyc2VUZW5zb3JQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFNwYXJzZVRlbnNvclByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge29ubnguSVRlbnNvclByb3RvfG51bGx9IFt2YWx1ZXNdIFNwYXJzZVRlbnNvclByb3RvIHZhbHVlc1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yUHJvdG98bnVsbH0gW2luZGljZXNdIFNwYXJzZVRlbnNvclByb3RvIGluZGljZXNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2RpbXNdIFNwYXJzZVRlbnNvclByb3RvIGRpbXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3BhcnNlVGVuc29yUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTcGFyc2VUZW5zb3JQcm90by5cbiAgICAgKiBAaW1wbGVtZW50cyBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVNwYXJzZVRlbnNvclByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3BhcnNlVGVuc29yUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgdGhpcy5kaW1zID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BhcnNlVGVuc29yUHJvdG8gdmFsdWVzLlxuICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSB2YWx1ZXNcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLnByb3RvdHlwZS52YWx1ZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3BhcnNlVGVuc29yUHJvdG8gaW5kaWNlcy5cbiAgICAgKiBAbWVtYmVyIHtvbm54LklUZW5zb3JQcm90b3xudWxsfHVuZGVmaW5lZH0gaW5kaWNlc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8ucHJvdG90eXBlLmluZGljZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3BhcnNlVGVuc29yUHJvdG8gZGltcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBkaW1zXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUuZGltcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNwYXJzZVRlbnNvclByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBTcGFyc2VUZW5zb3JQcm90byBpbnN0YW5jZVxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNwYXJzZVRlbnNvclByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90b30gbWVzc2FnZSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAndmFsdWVzJykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UudmFsdWVzLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovIDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5kaWNlcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpbmRpY2VzJykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UuaW5kaWNlcywgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLyAxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLmZvcmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpIHdyaXRlci5pbnQ2NChtZXNzYWdlLmRpbXNbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90b30gbWVzc2FnZSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5kaWNlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSkgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLmRpbXMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICB9IGVsc2UgbWVzc2FnZS5kaW1zLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5TcGFyc2VUZW5zb3JQcm90b30gU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlcycpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudmFsdWVzKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3ZhbHVlcy4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbmRpY2VzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaW5kaWNlcycpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5kaWNlcyk7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdpbmRpY2VzLicgKyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1zJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltcykpIHJldHVybiAnZGltczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXSkgJiZcbiAgICAgICAgICAgICEobWVzc2FnZS5kaW1zW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldLmhpZ2gpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAnZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguU3BhcnNlVGVuc29yUHJvdG99IFNwYXJzZVRlbnNvclByb3RvXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bykgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8oKTtcbiAgICAgIGlmIChvYmplY3QudmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVzICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5TcGFyc2VUZW5zb3JQcm90by52YWx1ZXM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuaW5kaWNlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluZGljZXMgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlNwYXJzZVRlbnNvclByb3RvLmluZGljZXM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmluZGljZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LmluZGljZXMpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kaW1zKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGltcykpIHRocm93IFR5cGVFcnJvcignLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmRpbXNbaV0gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZGltc1tpXSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSAnc3RyaW5nJykgbWVzc2FnZS5kaW1zW2ldID0gcGFyc2VJbnQob2JqZWN0LmRpbXNbaV0sIDEwKTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09ICdudW1iZXInKSBtZXNzYWdlLmRpbXNbaV0gPSBvYmplY3QuZGltc1tpXTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1zW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbXNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBtZXNzYWdlIFNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBTcGFyc2VUZW5zb3JQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIG9iamVjdC5kaW1zID0gW107XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QudmFsdWVzID0gbnVsbDtcbiAgICAgICAgb2JqZWN0LmluZGljZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWVzJykpXG4gICAgICAgIG9iamVjdC52YWx1ZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIGlmIChtZXNzYWdlLmluZGljZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbmRpY2VzJykpXG4gICAgICAgIG9iamVjdC5pbmRpY2VzID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLmluZGljZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5kaW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytqKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kaW1zW2pdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG9iamVjdC5kaW1zW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZGltc1tqXSkgOiBtZXNzYWdlLmRpbXNbal07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqZWN0LmRpbXNbal0gPVxuICAgICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgICA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1zW2pdKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbXNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmRpbXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlLmRpbXNbal07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFNwYXJzZVRlbnNvclByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguU3BhcnNlVGVuc29yUHJvdG8nO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3BhcnNlVGVuc29yUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5UZW5zb3JTaGFwZVByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yU2hhcGVQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj58bnVsbH0gW2RpbV0gVGVuc29yU2hhcGVQcm90byBkaW1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yU2hhcGVQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvclNoYXBlUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW5zb3JTaGFwZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuZGltID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVuc29yU2hhcGVQcm90byBkaW0uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPn0gZGltXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclNoYXBlUHJvdG8ucHJvdG90eXBlLmRpbSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclNoYXBlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG99IG1lc3NhZ2UgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgIGlmIChtZXNzYWdlLmRpbSAhPSBudWxsICYmIG1lc3NhZ2UuZGltLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuZGltW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfSBtZXNzYWdlIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRlbnNvclNoYXBlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRpbSAmJiBtZXNzYWdlLmRpbS5sZW5ndGgpKSBtZXNzYWdlLmRpbSA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5kaW0ucHVzaCgkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kaW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW0nKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kaW0pKSByZXR1cm4gJ2RpbTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkobWVzc2FnZS5kaW1baV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdkaW0uJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90b1xuICAgICAqL1xuICAgIFRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmRpbSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmRpbSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRpbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVtpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UuZGltW2ldID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KG9iamVjdC5kaW1baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmRpbSA9IFtdO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltICYmIG1lc3NhZ2UuZGltLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZGltID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmRpbVtqXSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udG9PYmplY3QobWVzc2FnZS5kaW1bal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBUZW5zb3JTaGFwZVByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgJy9vbm54LlRlbnNvclNoYXBlUHJvdG8nO1xuICAgIH07XG5cbiAgICBUZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBEaW1lbnNpb24uXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgKiBAaW50ZXJmYWNlIElEaW1lbnNpb25cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2RpbVZhbHVlXSBEaW1lbnNpb24gZGltVmFsdWVcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkaW1QYXJhbV0gRGltZW5zaW9uIGRpbVBhcmFtXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZGVub3RhdGlvbl0gRGltZW5zaW9uIGRlbm90YXRpb25cbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGltZW5zaW9uLlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRGltZW5zaW9uLlxuICAgICAgICogQGltcGxlbWVudHMgSURpbWVuc2lvblxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIERpbWVuc2lvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGltZW5zaW9uIGRpbVZhbHVlLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd8bnVsbHx1bmRlZmluZWR9IGRpbVZhbHVlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUuZGltVmFsdWUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIERpbWVuc2lvbiBkaW1QYXJhbS5cbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfHVuZGVmaW5lZH0gZGltUGFyYW1cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kaW1QYXJhbSA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGltZW5zaW9uIGRlbm90YXRpb24uXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRlbm90YXRpb25cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kZW5vdGF0aW9uID0gJyc7XG5cbiAgICAgIC8vIE9uZU9mIGZpZWxkIG5hbWVzIGJvdW5kIHRvIHZpcnR1YWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgLyoqXG4gICAgICAgKiBEaW1lbnNpb24gdmFsdWUuXG4gICAgICAgKiBAbWVtYmVyIHtcImRpbVZhbHVlXCJ8XCJkaW1QYXJhbVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpbWVuc2lvbi5wcm90b3R5cGUsICd2YWx1ZScsIHtcbiAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigoJG9uZU9mRmllbGRzID0gWydkaW1WYWx1ZScsICdkaW1QYXJhbSddKSksXG4gICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKSxcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgRGltZW5zaW9uIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gRGltZW5zaW9uIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihwcm9wZXJ0aWVzKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICBpZiAobWVzc2FnZS5kaW1WYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkaW1WYWx1ZScpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki8gOCkuaW50NjQobWVzc2FnZS5kaW1WYWx1ZSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmRpbVBhcmFtICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RpbVBhcmFtJykpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLyAxOCkuc3RyaW5nKG1lc3NhZ2UuZGltUGFyYW0pO1xuICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2Rlbm90YXRpb24nKSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovIDI2KS5zdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICovXG4gICAgICBEaW1lbnNpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLmRpbVBhcmFtID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICBtZXNzYWdlLmRlbm90YXRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYSBEaW1lbnNpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFZlcmlmaWVzIGEgRGltZW5zaW9uIG1lc3NhZ2UuXG4gICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBEaW1lbnNpb24udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmRpbVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZGltVmFsdWUnKSkge1xuICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZSkgJiZcbiAgICAgICAgICAgICEobWVzc2FnZS5kaW1WYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbVZhbHVlLmhpZ2gpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAnZGltVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1QYXJhbScpKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpIHJldHVybiAndmFsdWU6IG11bHRpcGxlIHZhbHVlcyc7XG4gICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRpbVBhcmFtKSkgcmV0dXJuICdkaW1QYXJhbTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZGVub3RhdGlvbicpKVxuICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSkgcmV0dXJuICdkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIERpbWVuc2lvbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbikgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbigpO1xuICAgICAgICBpZiAob2JqZWN0LmRpbVZhbHVlICE9IG51bGwpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmRpbVZhbHVlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbVZhbHVlKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVZhbHVlID09PSAnc3RyaW5nJykgbWVzc2FnZS5kaW1WYWx1ZSA9IHBhcnNlSW50KG9iamVjdC5kaW1WYWx1ZSwgMTApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09ICdudW1iZXInKSBtZXNzYWdlLmRpbVZhbHVlID0gb2JqZWN0LmRpbVZhbHVlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGltVmFsdWUubG93ID4+PiAwLCBvYmplY3QuZGltVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgaWYgKG9iamVjdC5kaW1QYXJhbSAhPSBudWxsKSBtZXNzYWdlLmRpbVBhcmFtID0gU3RyaW5nKG9iamVjdC5kaW1QYXJhbSk7XG4gICAgICAgIGlmIChvYmplY3QuZGVub3RhdGlvbiAhPSBudWxsKSBtZXNzYWdlLmRlbm90YXRpb24gPSBTdHJpbmcob2JqZWN0LmRlbm90YXRpb24pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRGltZW5zaW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gbWVzc2FnZSBEaW1lbnNpb25cbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmRlbm90YXRpb24gPSAnJztcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1WYWx1ZScpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbVZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG9iamVjdC5kaW1WYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbVZhbHVlKSA6IG1lc3NhZ2UuZGltVmFsdWU7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqZWN0LmRpbVZhbHVlID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGltVmFsdWUpXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICAgID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZGltVmFsdWUubG93ID4+PiAwLCBtZXNzYWdlLmRpbVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5kaW1WYWx1ZTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdkaW1WYWx1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1QYXJhbScpKSB7XG4gICAgICAgICAgb2JqZWN0LmRpbVBhcmFtID0gbWVzc2FnZS5kaW1QYXJhbTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdkaW1QYXJhbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2Rlbm90YXRpb24nKSkgb2JqZWN0LmRlbm90YXRpb24gPSBtZXNzYWdlLmRlbm90YXRpb247XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIHRoaXMgRGltZW5zaW9uIHRvIEpTT04uXG4gICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgRGltZW5zaW9uXG4gICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24nO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIERpbWVuc2lvbjtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIFRlbnNvclNoYXBlUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5UeXBlUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBUeXBlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUeXBlUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklUZW5zb3J8bnVsbH0gW3RlbnNvclR5cGVdIFR5cGVQcm90byB0ZW5zb3JUeXBlXG4gICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JU2VxdWVuY2V8bnVsbH0gW3NlcXVlbmNlVHlwZV0gVHlwZVByb3RvIHNlcXVlbmNlVHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5UeXBlUHJvdG8uSU1hcHxudWxsfSBbbWFwVHlwZV0gVHlwZVByb3RvIG1hcFR5cGVcbiAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklPcHRpb25hbHxudWxsfSBbb3B0aW9uYWxUeXBlXSBUeXBlUHJvdG8gb3B0aW9uYWxUeXBlXG4gICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yfG51bGx9IFtzcGFyc2VUZW5zb3JUeXBlXSBUeXBlUHJvdG8gc3BhcnNlVGVuc29yVHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBUeXBlUHJvdG8gZGVub3RhdGlvblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBUeXBlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUeXBlUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVR5cGVQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gVHlwZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlUHJvdG8gdGVuc29yVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx8dW5kZWZpbmVkfSB0ZW5zb3JUeXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS50ZW5zb3JUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byBzZXF1ZW5jZVR5cGUuXG4gICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlfG51bGx8dW5kZWZpbmVkfSBzZXF1ZW5jZVR5cGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8ucHJvdG90eXBlLnNlcXVlbmNlVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlUHJvdG8gbWFwVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JTWFwfG51bGx8dW5kZWZpbmVkfSBtYXBUeXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS5tYXBUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byBvcHRpb25hbFR5cGUuXG4gICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsfG51bGx8dW5kZWZpbmVkfSBvcHRpb25hbFR5cGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8ucHJvdG90eXBlLm9wdGlvbmFsVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlUHJvdG8gc3BhcnNlVGVuc29yVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yfG51bGx8dW5kZWZpbmVkfSBzcGFyc2VUZW5zb3JUeXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS5zcGFyc2VUZW5zb3JUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byBkZW5vdGF0aW9uLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZGVub3RhdGlvblxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFR5cGVQcm90by5wcm90b3R5cGUuZGVub3RhdGlvbiA9ICcnO1xuXG4gICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyIHtcInRlbnNvclR5cGVcInxcInNlcXVlbmNlVHlwZVwifFwibWFwVHlwZVwifFwib3B0aW9uYWxUeXBlXCJ8XCJzcGFyc2VUZW5zb3JUeXBlXCJ8dW5kZWZpbmVkfSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUeXBlUHJvdG8ucHJvdG90eXBlLCAndmFsdWUnLCB7XG4gICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKFxuICAgICAgICAoJG9uZU9mRmllbGRzID0gWyd0ZW5zb3JUeXBlJywgJ3NlcXVlbmNlVHlwZScsICdtYXBUeXBlJywgJ29wdGlvbmFsVHlwZScsICdzcGFyc2VUZW5zb3JUeXBlJ10pLFxuICAgICAgKSxcbiAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHlwZVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZVByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHlwZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3RlbnNvclR5cGUnKSlcbiAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmVuY29kZShcbiAgICAgICAgICBtZXNzYWdlLnRlbnNvclR5cGUsXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpLFxuICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3NlcXVlbmNlVHlwZScpKVxuICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbmNvZGUoXG4gICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUsXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLyAzNCkuZm9yaygpLFxuICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdtYXBUeXBlJykpXG4gICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC5lbmNvZGUobWVzc2FnZS5tYXBUeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkZW5vdGF0aW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki8gNTApLnN0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdzcGFyc2VUZW5zb3JUeXBlJykpXG4gICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci5lbmNvZGUoXG4gICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlLFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki8gNjYpLmZvcmsoKSxcbiAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLm9wdGlvbmFsVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdvcHRpb25hbFR5cGUnKSlcbiAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZW5jb2RlKFxuICAgICAgICAgIG1lc3NhZ2Uub3B0aW9uYWxUeXBlLFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOSwgd2lyZVR5cGUgMiA9Ki8gNzQpLmZvcmsoKSxcbiAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUeXBlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFR5cGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFR5cGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVHlwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgbWVzc2FnZS5tYXBUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICBtZXNzYWdlLm9wdGlvbmFsVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGVub3RhdGlvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVHlwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVHlwZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBUeXBlUHJvdG8gbWVzc2FnZS5cbiAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVHlwZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndGVuc29yVHlwZScpKSB7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeShtZXNzYWdlLnRlbnNvclR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICd0ZW5zb3JUeXBlLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc2VxdWVuY2VUeXBlJykpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpIHJldHVybiAndmFsdWU6IG11bHRpcGxlIHZhbHVlcyc7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudmVyaWZ5KG1lc3NhZ2Uuc2VxdWVuY2VUeXBlKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc2VxdWVuY2VUeXBlLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ21hcFR5cGUnKSkge1xuICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSkgcmV0dXJuICd2YWx1ZTogbXVsdGlwbGUgdmFsdWVzJztcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAudmVyaWZ5KG1lc3NhZ2UubWFwVHlwZSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ21hcFR5cGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5vcHRpb25hbFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcHRpb25hbFR5cGUnKSkge1xuICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSkgcmV0dXJuICd2YWx1ZTogbXVsdGlwbGUgdmFsdWVzJztcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnkobWVzc2FnZS5vcHRpb25hbFR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdvcHRpb25hbFR5cGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc3BhcnNlVGVuc29yVHlwZScpKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKSByZXR1cm4gJ3ZhbHVlOiBtdWx0aXBsZSB2YWx1ZXMnO1xuICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci52ZXJpZnkobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc3BhcnNlVGVuc29yVHlwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkZW5vdGF0aW9uJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSkgcmV0dXJuICdkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAqL1xuICAgIFR5cGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90bykgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LnRlbnNvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50ZW5zb3JUeXBlICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UudGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KG9iamVjdC50ZW5zb3JUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Quc2VxdWVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2VxdWVuY2VUeXBlICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UeXBlUHJvdG8uc2VxdWVuY2VUeXBlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5mcm9tT2JqZWN0KG9iamVjdC5zZXF1ZW5jZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5tYXBUeXBlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubWFwVHlwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLm1hcFR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLm1hcFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAuZnJvbU9iamVjdChvYmplY3QubWFwVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9wdGlvbmFsVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm9wdGlvbmFsVHlwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLm9wdGlvbmFsVHlwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3B0aW9uYWxUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZnJvbU9iamVjdChvYmplY3Qub3B0aW9uYWxUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Quc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLnNwYXJzZVRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZnJvbU9iamVjdChvYmplY3Quc3BhcnNlVGVuc29yVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmRlbm90YXRpb24gIT0gbnVsbCkgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUeXBlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvfSBtZXNzYWdlIFR5cGVQcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgVHlwZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmRlbm90YXRpb24gPSAnJztcbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvclR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0ZW5zb3JUeXBlJykpIHtcbiAgICAgICAgb2JqZWN0LnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QobWVzc2FnZS50ZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKSBvYmplY3QudmFsdWUgPSAndGVuc29yVHlwZSc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzZXF1ZW5jZVR5cGUnKSkge1xuICAgICAgICBvYmplY3Quc2VxdWVuY2VUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudG9PYmplY3QobWVzc2FnZS5zZXF1ZW5jZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdzZXF1ZW5jZVR5cGUnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ21hcFR5cGUnKSkge1xuICAgICAgICBvYmplY3QubWFwVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC50b09iamVjdChtZXNzYWdlLm1hcFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdtYXBUeXBlJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkZW5vdGF0aW9uJykpIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NwYXJzZVRlbnNvclR5cGUnKSkge1xuICAgICAgICBvYmplY3Quc3BhcnNlVGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci50b09iamVjdChtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdzcGFyc2VUZW5zb3JUeXBlJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm9wdGlvbmFsVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ29wdGlvbmFsVHlwZScpKSB7XG4gICAgICAgIG9iamVjdC5vcHRpb25hbFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC50b09iamVjdChtZXNzYWdlLm9wdGlvbmFsVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLm9uZW9mcykgb2JqZWN0LnZhbHVlID0gJ29wdGlvbmFsVHlwZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFR5cGVQcm90byB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVHlwZVByb3RvXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVHlwZVByb3RvJztcbiAgICB9O1xuXG4gICAgVHlwZVByb3RvLlRlbnNvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBUZW5zb3IuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvclxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2VsZW1UeXBlXSBUZW5zb3IgZWxlbVR5cGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfSBbc2hhcGVdIFRlbnNvciBzaGFwZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUZW5zb3IuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvci5cbiAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIFRlbnNvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGVuc29yIGVsZW1UeXBlLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBlbGVtVHlwZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIFRlbnNvci5wcm90b3R5cGUuZWxlbVR5cGUgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRlbnNvciBzaGFwZS5cbiAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclNoYXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IHNoYXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgVGVuc29yLnByb3RvdHlwZS5zaGFwZSA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG5ldyBUZW5zb3IgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3IgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgVGVuc29yLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcn0gbWVzc2FnZSBUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgVGVuc29yLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VsZW1UeXBlJykpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLyA4KS5pbnQzMihtZXNzYWdlLmVsZW1UeXBlKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnc2hhcGUnKSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uuc2hhcGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3IgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yfSBtZXNzYWdlIFRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBUZW5zb3IuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhIFRlbnNvciBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFRlbnNvci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICovXG4gICAgICBUZW5zb3IuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3IgbWVzc2FnZS5cbiAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAqL1xuICAgICAgVGVuc29yLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2VsZW1UeXBlJykpXG4gICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbGVtVHlwZSkpIHJldHVybiAnZWxlbVR5cGU6IGludGVnZXIgZXhwZWN0ZWQnO1xuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NoYXBlJykpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc2hhcGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdzaGFwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBUZW5zb3IgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICovXG4gICAgICBUZW5zb3IuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IpIHJldHVybiBvYmplY3Q7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcigpO1xuICAgICAgICBpZiAob2JqZWN0LmVsZW1UeXBlICE9IG51bGwpIG1lc3NhZ2UuZWxlbVR5cGUgPSBvYmplY3QuZWxlbVR5cGUgfCAwO1xuICAgICAgICBpZiAob2JqZWN0LnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zaGFwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5zaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvciBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBtZXNzYWdlIFRlbnNvclxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICovXG4gICAgICBUZW5zb3IudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gMDtcbiAgICAgICAgICBvYmplY3Quc2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZWxlbVR5cGUnKSkgb2JqZWN0LmVsZW1UeXBlID0gbWVzc2FnZS5lbGVtVHlwZTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzaGFwZScpKVxuICAgICAgICAgIG9iamVjdC5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChtZXNzYWdlLnNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgdGhpcyBUZW5zb3IgdG8gSlNPTi5cbiAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICovXG4gICAgICBUZW5zb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFRlbnNvclxuICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAqL1xuICAgICAgVGVuc29yLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVHlwZVByb3RvLlRlbnNvcic7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVGVuc29yO1xuICAgIH0pKCk7XG5cbiAgICBUeXBlUHJvdG8uU2VxdWVuY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgU2VxdWVuY2UuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBpbnRlcmZhY2UgSVNlcXVlbmNlXG4gICAgICAgKiBAcHJvcGVydHkge29ubnguSVR5cGVQcm90b3xudWxsfSBbZWxlbVR5cGVdIFNlcXVlbmNlIGVsZW1UeXBlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNlcXVlbmNlLlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZXF1ZW5jZS5cbiAgICAgICAqIEBpbXBsZW1lbnRzIElTZXF1ZW5jZVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBTZXF1ZW5jZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VxdWVuY2UgZWxlbVR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtvbm54LklUeXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IGVsZW1UeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS5wcm90b3R5cGUuZWxlbVR5cGUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgU2VxdWVuY2UgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNlcXVlbmNlfSBTZXF1ZW5jZSBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlKHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VxdWVuY2UgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlfSBtZXNzYWdlIFNlcXVlbmNlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VsZW1UeXBlJykpXG4gICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZWxlbVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTZXF1ZW5jZSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5TZXF1ZW5jZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU2VxdWVuY2V9IG1lc3NhZ2UgU2VxdWVuY2UgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgU2VxdWVuY2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhIFNlcXVlbmNlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TZXF1ZW5jZX0gU2VxdWVuY2VcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgU2VxdWVuY2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU2VxdWVuY2UgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFZlcmlmaWVzIGEgU2VxdWVuY2UgbWVzc2FnZS5cbiAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdlbGVtVHlwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBTZXF1ZW5jZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UpIHJldHVybiBvYmplY3Q7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKCk7XG4gICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmVsZW1UeXBlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLlNlcXVlbmNlLmVsZW1UeXBlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZWxlbVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTZXF1ZW5jZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5TZXF1ZW5jZX0gbWVzc2FnZSBTZXF1ZW5jZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIG9iamVjdC5lbGVtVHlwZSA9IG51bGw7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZWxlbVR5cGUnKSlcbiAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLmVsZW1UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgdGhpcyBTZXF1ZW5jZSB0byBKU09OLlxuICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAqL1xuICAgICAgU2VxdWVuY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFNlcXVlbmNlXG4gICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVHlwZVByb3RvLlNlcXVlbmNlJztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZXF1ZW5jZTtcbiAgICB9KSgpO1xuXG4gICAgVHlwZVByb3RvLk1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBNYXAuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBpbnRlcmZhY2UgSU1hcFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2tleVR5cGVdIE1hcCBrZXlUeXBlXG4gICAgICAgKiBAcHJvcGVydHkge29ubnguSVR5cGVQcm90b3xudWxsfSBbdmFsdWVUeXBlXSBNYXAgdmFsdWVUeXBlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1hcC5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTWFwLlxuICAgICAgICogQGltcGxlbWVudHMgSU1hcFxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklNYXA9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gTWFwKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXAga2V5VHlwZS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0ga2V5VHlwZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIE1hcC5wcm90b3R5cGUua2V5VHlwZSA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFwIHZhbHVlVHlwZS5cbiAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdmFsdWVUeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZVR5cGUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgTWFwIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU1hcD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIE1hcC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChwcm9wZXJ0aWVzKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE1hcCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5NYXAudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklNYXB9IG1lc3NhZ2UgTWFwIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIE1hcC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2tleVR5cGUnKSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovIDgpLmludDMyKG1lc3NhZ2Uua2V5VHlwZSk7XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd2YWx1ZVR5cGUnKSlcbiAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNYXAgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uTWFwLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JTWFwfSBtZXNzYWdlIE1hcCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBNYXAuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhIE1hcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIE1hcC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uua2V5VHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYSBNYXAgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIE1hcC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBWZXJpZmllcyBhIE1hcCBtZXNzYWdlLlxuICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBNYXAudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdrZXlUeXBlJykpXG4gICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5rZXlUeXBlKSkgcmV0dXJuICdrZXlUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkJztcbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWVUeXBlJykpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS52YWx1ZVR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICd2YWx1ZVR5cGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgTWFwIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uTWFwfSBNYXBcbiAgICAgICAqL1xuICAgICAgTWFwLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwKSByZXR1cm4gb2JqZWN0O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAoKTtcbiAgICAgICAgaWYgKG9iamVjdC5rZXlUeXBlICE9IG51bGwpIG1lc3NhZ2Uua2V5VHlwZSA9IG9iamVjdC5rZXlUeXBlIHwgMDtcbiAgICAgICAgaWYgKG9iamVjdC52YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlVHlwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLk1hcC52YWx1ZVR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UudmFsdWVUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QudmFsdWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTWFwIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5NYXB9IG1lc3NhZ2UgTWFwXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIE1hcC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICBvYmplY3Qua2V5VHlwZSA9IDA7XG4gICAgICAgICAgb2JqZWN0LnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5VHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2tleVR5cGUnKSkgb2JqZWN0LmtleVR5cGUgPSBtZXNzYWdlLmtleVR5cGU7XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlVHlwZScpKVxuICAgICAgICAgIG9iamVjdC52YWx1ZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnZhbHVlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIHRoaXMgTWFwIHRvIEpTT04uXG4gICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAqL1xuICAgICAgTWFwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBNYXBcbiAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgKi9cbiAgICAgIE1hcC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgJy9vbm54LlR5cGVQcm90by5NYXAnO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIE1hcDtcbiAgICB9KSgpO1xuXG4gICAgVHlwZVByb3RvLk9wdGlvbmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvZiBhbiBPcHRpb25hbC5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGludGVyZmFjZSBJT3B0aW9uYWxcbiAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFtlbGVtVHlwZV0gT3B0aW9uYWwgZWxlbVR5cGVcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgT3B0aW9uYWwuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcHRpb25hbC5cbiAgICAgICAqIEBpbXBsZW1lbnRzIElPcHRpb25hbFxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBPcHRpb25hbChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9uYWwgZWxlbVR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtvbm54LklUeXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IGVsZW1UeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5wcm90b3R5cGUuZWxlbVR5cGUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWwgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBPcHRpb25hbCBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IE9wdGlvbmFsKHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgT3B0aW9uYWwgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uT3B0aW9uYWwudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsfSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIE9wdGlvbmFsLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VsZW1UeXBlJykpXG4gICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZWxlbVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcHRpb25hbCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JT3B0aW9uYWx9IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgT3B0aW9uYWwuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhbiBPcHRpb25hbCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uT3B0aW9uYWx9IE9wdGlvbmFsXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIE9wdGlvbmFsLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhbiBPcHRpb25hbCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5PcHRpb25hbH0gT3B0aW9uYWxcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgT3B0aW9uYWwuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZpZXMgYW4gT3B0aW9uYWwgbWVzc2FnZS5cbiAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBPcHRpb25hbC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdlbGVtVHlwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW4gT3B0aW9uYWwgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBPcHRpb25hbFxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKSByZXR1cm4gb2JqZWN0O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbCgpO1xuICAgICAgICBpZiAob2JqZWN0LmVsZW1UeXBlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbGVtVHlwZSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlR5cGVQcm90by5PcHRpb25hbC5lbGVtVHlwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LmVsZW1UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIE9wdGlvbmFsIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBtZXNzYWdlIE9wdGlvbmFsXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIE9wdGlvbmFsLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmVsZW1UeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKVxuICAgICAgICAgIG9iamVjdC5lbGVtVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZWxlbVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wdGlvbmFsIHRvIEpTT04uXG4gICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgT3B0aW9uYWxcbiAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAqL1xuICAgICAgT3B0aW9uYWwuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UeXBlUHJvdG8uT3B0aW9uYWwnO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIE9wdGlvbmFsO1xuICAgIH0pKCk7XG5cbiAgICBUeXBlUHJvdG8uU3BhcnNlVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvZiBhIFNwYXJzZVRlbnNvci5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGludGVyZmFjZSBJU3BhcnNlVGVuc29yXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZWxlbVR5cGVdIFNwYXJzZVRlbnNvciBlbGVtVHlwZVxuICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx9IFtzaGFwZV0gU3BhcnNlVGVuc29yIHNoYXBlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNwYXJzZVRlbnNvci5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgU3BhcnNlVGVuc29yLlxuICAgICAgICogQGltcGxlbWVudHMgSVNwYXJzZVRlbnNvclxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gU3BhcnNlVGVuc29yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTcGFyc2VUZW5zb3IgZWxlbVR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGVsZW1UeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgU3BhcnNlVGVuc29yLnByb3RvdHlwZS5lbGVtVHlwZSA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3BhcnNlVGVuc29yIHNoYXBlLlxuICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfHVuZGVmaW5lZH0gc2hhcGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IucHJvdG90eXBlLnNoYXBlID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IFNwYXJzZVRlbnNvciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IFNwYXJzZVRlbnNvciBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VUZW5zb3IocHJvcGVydGllcyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTcGFyc2VUZW5zb3IgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yfSBtZXNzYWdlIFNwYXJzZVRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZWxlbVR5cGUnKSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovIDgpLmludDMyKG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdzaGFwZScpKVxuICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobWVzc2FnZS5zaGFwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLyAxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNwYXJzZVRlbnNvciBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yfSBTcGFyc2VUZW5zb3JcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgU3BhcnNlVGVuc29yLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYSBTcGFyc2VUZW5zb3IgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcn0gU3BhcnNlVGVuc29yXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBWZXJpZmllcyBhIFNwYXJzZVRlbnNvciBtZXNzYWdlLlxuICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZWxlbVR5cGUnKSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVsZW1UeXBlKSkgcmV0dXJuICdlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc2hhcGUnKSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkobWVzc2FnZS5zaGFwZSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3NoYXBlLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIFNwYXJzZVRlbnNvciBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcn0gU3BhcnNlVGVuc29yXG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcikgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yKCk7XG4gICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbCkgbWVzc2FnZS5lbGVtVHlwZSA9IG9iamVjdC5lbGVtVHlwZSB8IDA7XG4gICAgICAgIGlmIChvYmplY3Quc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNoYXBlICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAwO1xuICAgICAgICAgIG9iamVjdC5zaGFwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKSBvYmplY3QuZWxlbVR5cGUgPSBtZXNzYWdlLmVsZW1UeXBlO1xuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NoYXBlJykpXG4gICAgICAgICAgb2JqZWN0LnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyB0aGlzIFNwYXJzZVRlbnNvciB0byBKU09OLlxuICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgU3BhcnNlVGVuc29yXG4gICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yJztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTcGFyc2VUZW5zb3I7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBUeXBlUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5PcGVyYXRvclNldElkUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYW4gT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gT3BlcmF0b3JTZXRJZFByb3RvIGRvbWFpblxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW3ZlcnNpb25dIE9wZXJhdG9yU2V0SWRQcm90byB2ZXJzaW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE9wZXJhdG9yU2V0SWRQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcGVyYXRvclNldElkUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSU9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRvclNldElkUHJvdG8gZG9tYWluLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS5kb21haW4gPSAnJztcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdG9yU2V0SWRQcm90byB2ZXJzaW9uLlxuICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSB2ZXJzaW9uXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS52ZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0b3JTZXRJZFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklPcGVyYXRvclNldElkUHJvdG99IG1lc3NhZ2UgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9tYWluJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3ZlcnNpb24nKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLyAxNikuaW50NjQobWVzc2FnZS52ZXJzaW9uKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb21haW4nKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpIHJldHVybiAnZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb24nKSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uKSAmJlxuICAgICAgICAgICEobWVzc2FnZS52ZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uLmhpZ2gpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICd2ZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bygpO1xuICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbCkgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICBpZiAob2JqZWN0LnZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLnZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gJ3N0cmluZycpIG1lc3NhZ2UudmVyc2lvbiA9IHBhcnNlSW50KG9iamVjdC52ZXJzaW9uLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gJ251bWJlcicpIG1lc3NhZ2UudmVyc2lvbiA9IG9iamVjdC52ZXJzaW9uO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnZlcnNpb24gPT09ICdvYmplY3QnKVxuICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IG1lc3NhZ2UgT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5kb21haW4gPSAnJztcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICBvYmplY3QudmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9tYWluJykpIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd2ZXJzaW9uJykpXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52ZXJzaW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnZlcnNpb24pIDogbWVzc2FnZS52ZXJzaW9uO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb2JqZWN0LnZlcnNpb24gPVxuICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnZlcnNpb24pXG4gICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS52ZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICA6IG1lc3NhZ2UudmVyc2lvbjtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgT3BlcmF0b3JTZXRJZFByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5PcGVyYXRvclNldElkUHJvdG8nO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3BlcmF0b3JTZXRJZFByb3RvO1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBPcGVyYXRvclN0YXR1cyBlbnVtLlxuICAgKiBAbmFtZSBvbm54Lk9wZXJhdG9yU3RhdHVzXG4gICAqIEBlbnVtIHtudW1iZXJ9XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFWFBFUklNRU5UQUw9MCBFWFBFUklNRU5UQUwgdmFsdWVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUQUJMRT0xIFNUQUJMRSB2YWx1ZVxuICAgKi9cbiAgb25ueC5PcGVyYXRvclN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzBdID0gJ0VYUEVSSU1FTlRBTCcpXSA9IDA7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzFdID0gJ1NUQUJMRScpXSA9IDE7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSkoKTtcblxuICBvbm54LkZ1bmN0aW9uUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBGdW5jdGlvblByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJRnVuY3Rpb25Qcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBGdW5jdGlvblByb3RvIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtpbnB1dF0gRnVuY3Rpb25Qcm90byBpbnB1dFxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW291dHB1dF0gRnVuY3Rpb25Qcm90byBvdXRwdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFthdHRyaWJ1dGVdIEZ1bmN0aW9uUHJvdG8gYXR0cmlidXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JQXR0cmlidXRlUHJvdG8+fG51bGx9IFthdHRyaWJ1dGVQcm90b10gRnVuY3Rpb25Qcm90byBhdHRyaWJ1dGVQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSU5vZGVQcm90bz58bnVsbH0gW25vZGVdIEZ1bmN0aW9uUHJvdG8gbm9kZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEZ1bmN0aW9uUHJvdG8gZG9jU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPnxudWxsfSBbb3BzZXRJbXBvcnRdIEZ1bmN0aW9uUHJvdG8gb3BzZXRJbXBvcnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBGdW5jdGlvblByb3RvIGRvbWFpblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBGdW5jdGlvblByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRnVuY3Rpb25Qcm90by5cbiAgICAgKiBAaW1wbGVtZW50cyBJRnVuY3Rpb25Qcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JRnVuY3Rpb25Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgdGhpcy5pbnB1dCA9IFtdO1xuICAgICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICB0aGlzLm5vZGUgPSBbXTtcbiAgICAgIHRoaXMub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvblByb3RvIG5hbWUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLm5hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gaW5wdXQuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGlucHV0XG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gb3V0cHV0LlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBvdXRwdXRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUub3V0cHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gYXR0cmlidXRlLlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBhdHRyaWJ1dGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuYXR0cmlidXRlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gYXR0cmlidXRlUHJvdG8uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlUHJvdG9cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuYXR0cmlidXRlUHJvdG8gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb25Qcm90byBub2RlLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fSBub2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLm5vZGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb25Qcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvblByb3RvIG9wc2V0SW1wb3J0LlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fSBvcHNldEltcG9ydFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5vcHNldEltcG9ydCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvblByb3RvIGRvbWFpbi5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5kb21haW4gPSAnJztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRnVuY3Rpb25Qcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklGdW5jdGlvblByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguRnVuY3Rpb25Qcm90b30gRnVuY3Rpb25Qcm90byBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5GdW5jdGlvblByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JRnVuY3Rpb25Qcm90b30gbWVzc2FnZSBGdW5jdGlvblByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBGdW5jdGlvblByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8gMzQpLnN0cmluZyhtZXNzYWdlLmlucHV0W2ldKTtcbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5zdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki8gNTApLnN0cmluZyhtZXNzYWdlLmF0dHJpYnV0ZVtpXSk7XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5Ob2RlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uubm9kZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLyA1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLyA2Nikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0W2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLyA3NCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9tYWluJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTAsIHdpcmVUeXBlIDIgPSovIDgyKS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gIT0gbnVsbCAmJiBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVQcm90b1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovIDkwKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBGdW5jdGlvblByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LkZ1bmN0aW9uUHJvdG99IEZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKSBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmlucHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm91dHB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKSBtZXNzYWdlLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gJiYgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpKSBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLnB1c2goJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSkgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkpIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQucHVzaCgkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgRnVuY3Rpb25Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54LkZ1bmN0aW9uUHJvdG99IEZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS5cbiAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKSByZXR1cm4gJ25hbWU6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lucHV0JykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKSByZXR1cm4gJ2lucHV0OiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuaW5wdXRbaV0pKSByZXR1cm4gJ2lucHV0OiBzdHJpbmdbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5vdXRwdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvdXRwdXQnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKSByZXR1cm4gJ291dHB1dDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pKSByZXR1cm4gJ291dHB1dDogc3RyaW5nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnYXR0cmlidXRlJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuYXR0cmlidXRlKSkgcmV0dXJuICdhdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuYXR0cmlidXRlW2ldKSkgcmV0dXJuICdhdHRyaWJ1dGU6IHN0cmluZ1tdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnYXR0cmlidXRlUHJvdG8nKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGVQcm90bykpIHJldHVybiAnYXR0cmlidXRlUHJvdG86IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkobWVzc2FnZS5hdHRyaWJ1dGVQcm90b1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2F0dHJpYnV0ZVByb3RvLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25vZGUnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ub2RlKSkgcmV0dXJuICdub2RlOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8udmVyaWZ5KG1lc3NhZ2Uubm9kZVtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ25vZGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpIHJldHVybiAnZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcHNldEltcG9ydCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSkgcmV0dXJuICdvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkobWVzc2FnZS5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ29wc2V0SW1wb3J0LicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9tYWluJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb21haW4pKSByZXR1cm4gJ2RvbWFpbjogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRnVuY3Rpb25Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5GdW5jdGlvblByb3RvfSBGdW5jdGlvblByb3RvXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8oKTtcbiAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKSBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgaWYgKG9iamVjdC5pbnB1dCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5GdW5jdGlvblByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKSBtZXNzYWdlLmlucHV0W2ldID0gU3RyaW5nKG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm91dHB1dCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dHB1dCkpIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkgbWVzc2FnZS5vdXRwdXRbaV0gPSBTdHJpbmcob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmF0dHJpYnV0ZSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmF0dHJpYnV0ZS5sZW5ndGg7ICsraSkgbWVzc2FnZS5hdHRyaWJ1dGVbaV0gPSBTdHJpbmcob2JqZWN0LmF0dHJpYnV0ZVtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuYXR0cmlidXRlUHJvdG8pKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVQcm90byA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5hdHRyaWJ1dGVQcm90by5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmF0dHJpYnV0ZVByb3RvW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVQcm90b1tpXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYXR0cmlidXRlUHJvdG9baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5vZGUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5ub2RlKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5GdW5jdGlvblByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uubm9kZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5ub2RlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9kZVtpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLm5vZGVbaV0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ub2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbCkgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICBpZiAob2JqZWN0Lm9wc2V0SW1wb3J0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3BzZXRJbXBvcnQpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkZ1bmN0aW9uUHJvdG8ub3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vcHNldEltcG9ydFtpXSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkZ1bmN0aW9uUHJvdG8ub3BzZXRJbXBvcnQ6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KG9iamVjdC5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LkZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICBvYmplY3Qubm9kZSA9IFtdO1xuICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICAgIG9iamVjdC5kb21haW4gPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraikgb2JqZWN0LmlucHV0W2pdID0gbWVzc2FnZS5pbnB1dFtqXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0Lm91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytqKSBvYmplY3Qub3V0cHV0W2pdID0gbWVzc2FnZS5vdXRwdXRbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraikgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9IG1lc3NhZ2UuYXR0cmlidXRlW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5ub2RlID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5ub2RlW2pdID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8udG9PYmplY3QobWVzc2FnZS5ub2RlW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKSBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkge1xuICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5vcHNldEltcG9ydFtqXSA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uub3BzZXRJbXBvcnRbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9tYWluJykpIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICYmIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5hdHRyaWJ1dGVQcm90byA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVByb3RvW2pdID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgRnVuY3Rpb25Qcm90byB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBGdW5jdGlvblByb3RvXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5GdW5jdGlvblByb3RvJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZ1bmN0aW9uUHJvdG87XG4gIH0pKCk7XG5cbiAgcmV0dXJuIG9ubng7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBmbGF0YnVmZmVycyB9IGZyb20gJ2ZsYXRidWZmZXJzJztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgb25ueHJ1bnRpbWUgfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQgeyBvbm54IH0gZnJvbSAnLi9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubngnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3InO1xuXG4vLyBjaGVjayB0aGUgaW5wdXRzIHNoYXBlIGJlZm9yZSBydW5uaW5nIGFuIE9QLlxuLy8gcmV0dXJuIHRydWUgd2hlbiB0aGUgaW5wdXRzIHBhc3MgdGhlIGNoZWNrXG4vLyByZXR1cm4gZmFsc2Ugd2hlbiB0aGUgaW5wdXRzIGRvIG5vdCBmaXQgdGhlIHJlcXVpcmVtZW50XG4vLyB0aHJvdyBleGNlcHRpb24gd2hlbiBmYXRhbCBlcnJvciBvciBub3QgaW1wbGVtZW50ZWRcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lucHV0c1NoYXBlKGlucHV0czogVGVuc29yW10sIC4uLmV4cGVjdGVkRGltZW5zaW9uczogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gZXhwZWN0ZWREaW1lbnNpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaW5wdXRzW2ldLmRpbXMgfHwgaW5wdXRzW2ldLmRpbXMubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbnNbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBhbmQgYXNzZXJ0cyBlcnJvciBtZXNzYWdlIGlmIGNvbmRpdGlvbiBpcyB1bm1ldC5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZXhwcjogYm9vbGVhbiwgbXNnOiAoKSA9PiBzdHJpbmcpIHtcbiAgaWYgKCFleHByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogbXNnKCkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheVV0aWwge1xuICAvKipcbiAgICogVmVyaWZpZXMgaWYgMiBpbnB1dCBhcnJheXMgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50cy5cbiAgICogQHBhcmFtIG4xIEFycmF5IDFcbiAgICogQHBhcmFtIG4yIEFycmF5IDJcbiAgICogQHJldHVybnMgV2hldGhlciB0aGVzZSAyIGFyZSBlcXVhbFxuICAgKi9cbiAgc3RhdGljIGFycmF5c0VxdWFsKFxuICAgIG4xOlxuICAgICAgfCByZWFkb25seSBudW1iZXJbXVxuICAgICAgfCBJbnQ4QXJyYXlcbiAgICAgIHwgVWludDhBcnJheVxuICAgICAgfCBJbnQxNkFycmF5XG4gICAgICB8IFVpbnQxNkFycmF5XG4gICAgICB8IEludDMyQXJyYXlcbiAgICAgIHwgVWludDMyQXJyYXlcbiAgICAgIHwgVWludDhDbGFtcGVkQXJyYXlcbiAgICAgIHwgRmxvYXQzMkFycmF5XG4gICAgICB8IEZsb2F0NjRBcnJheSxcbiAgICBuMjpcbiAgICAgIHwgcmVhZG9ubHkgbnVtYmVyW11cbiAgICAgIHwgSW50OEFycmF5XG4gICAgICB8IFVpbnQ4QXJyYXlcbiAgICAgIHwgSW50MTZBcnJheVxuICAgICAgfCBVaW50MTZBcnJheVxuICAgICAgfCBJbnQzMkFycmF5XG4gICAgICB8IFVpbnQzMkFycmF5XG4gICAgICB8IFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgICB8IEZsb2F0MzJBcnJheVxuICAgICAgfCBGbG9hdDY0QXJyYXksXG4gICkge1xuICAgIGlmIChuMS5sZW5ndGggIT09IG4yLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4xLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogRml4IHRoZSBpbnB1dCBzaGFwZXMgZm9yIE1hdE11bCBvcGVyYXRpb24gaWYgdGhleSBuZWVkIGZpeGluZ1xuICAgKiBAcGFyYW0gZGltc0EgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGRpbXNCIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgcHJlcHJvY2Vzc2VkIGlucHV0IHNoYXBlcyBhcyByZXF1aXJlZCBieSBPTk5YIHNwZWNpZmljYXRpb25zXG4gICAqL1xuICBzdGF0aWMgcHJlcHJvY2Vzc0lucHV0U2hhcGVzKFxuICAgIGRpbXNBOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFtyZWFkb25seSBudW1iZXJbXSwgcmVhZG9ubHkgbnVtYmVyW11dIHtcbiAgICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgMS1ELCBpdCBpcyBwcm9tb3RlZCB0byBhIG1hdHJpeCBieSBwcmVwZW5kaW5nXG4gICAgLy8gYSAxIHRvIGl0cyBkaW1lbnNpb25zLiBBZnRlciBtYXRyaXggbXVsdGlwbGljYXRpb24gdGhlIHByZXBlbmRlZCAxIGlzXG4gICAgLy8gcmVtb3ZlZC5cbiAgICBjb25zdCBhID0gZGltc0EubGVuZ3RoID09PSAxID8gWzEsIGRpbXNBWzBdXSA6IGRpbXNBO1xuXG4gICAgLy8gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyAxLUQsIGl0IGlzIHByb21vdGVkIHRvIGEgbWF0cml4IGJ5IGFwcGVuZGluZ1xuICAgIC8vIGEgMSB0byBpdHMgZGltZW5zaW9ucy4gQWZ0ZXIgbWF0cml4IG11bHRpcGxpY2F0aW9uIHRoZSBhcHBlbmRlZCAxIGlzXG4gICAgLy8gcmVtb3ZlZC5cbiAgICBjb25zdCBiID0gZGltc0IubGVuZ3RoID09PSAxID8gW2RpbXNCWzBdLCAxXSA6IGRpbXNCO1xuXG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIG91dHB1dCBzaGFwZSBjb21wdXRlZCBmb3IgTWF0TXVsIG9wZXJhdGlvbiBpZiBpdCBuZWVkcyBmaXhpbmdcbiAgICogQHBhcmFtIG91dHB1dFNoYXBlIFRoZSBjb21wdXRlZCBvdXRwdXRTaGFwZS4gU2hvdWxkIGJlIGFuIGFycmF5IChhdGxlYXN0IG9mIGxlbmd0aCAyKSBvZiBwb3NpdGl2ZSBpbnRlZ2Vycy5cbiAgICogVGhpcyB3aWxsIGJlIG11dGF0ZWQuXG4gICAqIEBwYXJhbSBhUmFuayBUaGUgcmFuayBvZiB0ZW5zb3IgQS5cbiAgICogQHBhcmFtIGJSYW5rIFRoZSByYW5rIG9mIHRlbnNvciBCLlxuICAgKi9cbiAgc3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUob3V0cHV0U2hhcGU6IG51bWJlcltdLCBhUmFuazogbnVtYmVyLCBiUmFuazogbnVtYmVyKSB7XG4gICAgLy8gUmVtb3ZlIHByZXBlbmRlZCBkaW1lbnNpb24gaWYgZmlyc3QgaW5wdXQgaXMgMWRcbiAgICBpZiAoYVJhbmsgPT09IDEpIHtcbiAgICAgIC8vIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuc2xpY2UoMCwgb3V0cHV0U2hhcGUubGVuZ3RoIC0gMikuY29uY2F0KG91dHB1dFNoYXBlLnNsaWNlKG91dHB1dFNoYXBlLmxlbmd0aCAtIDEpKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShvdXRwdXRTaGFwZS5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFwcGVuZGVkIGRpbWVuc2lvbiBpZiBzZWNvbmQgaW5wdXQgaXMgMWRcbiAgICBpZiAoYlJhbmsgPT09IDEpIHtcbiAgICAgIG91dHB1dFNoYXBlLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHJldHVybnMgVGhlIGV4cGVjdGVkIHNoYXBlIG9mIHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCBpZiBOL0FcbiAgICovXG4gIHN0YXRpYyBjYWxjTWF0TXVsU2hhcGUoYTogW251bWJlciwgbnVtYmVyXSwgYjogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBhWzFdICE9PSBiWzBdID8gdW5kZWZpbmVkIDogW2FbMF0sIGJbMV1dO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBicm9hZGNhc3RpbmcgMiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBpc01hdE11bCBXaGV0aGVyIHRoZSBvcGVyYXRpb24gaXMgTWF0TXVsXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY1NoYXBlKFxuICAgIGFkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBiZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgaXNNYXRNdWwgPSBmYWxzZSxcbiAgKTogcmVhZG9ubHkgbnVtYmVyW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGFyYW5rID0gYWRpbXMubGVuZ3RoO1xuICAgIGNvbnN0IGJyYW5rID0gYmRpbXMubGVuZ3RoO1xuICAgIGlmIChhcmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJkaW1zO1xuICAgIH1cbiAgICBpZiAoYnJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBhZGltcztcbiAgICB9XG4gICAgY29uc3QgY3JhbmsgPSBNYXRoLm1heChhZGltcy5sZW5ndGgsIGJkaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgY2RpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihjcmFuayk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxhc3QgMiBkaW1lbnNpb24gaWYgaXQgaXMgTWF0TXVsXG4gICAgaWYgKGlzTWF0TXVsKSB7XG4gICAgICBpZiAoYXJhbmsgPCAyIHx8IGJyYW5rIDwgMikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgY1NoYXBlTWF0TXVsID0gTWF0TXVsVXRpbC5jYWxjTWF0TXVsU2hhcGUoXG4gICAgICAgIFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSxcbiAgICAgICAgW2JkaW1zW2JyYW5rIC0gMl0sIGJkaW1zW2JyYW5rIC0gMV1dLFxuICAgICAgKTtcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGFMZW4gPSBhcmFuayAtIGkgPCAwID8gMSA6IGFkaW1zW2FyYW5rIC0gaV07XG4gICAgICBjb25zdCBiTGVuID0gYnJhbmsgLSBpIDwgMCA/IDEgOiBiZGltc1ticmFuayAtIGldO1xuXG4gICAgICBpZiAoYUxlbiAhPT0gYkxlbiAmJiBhTGVuID4gMSAmJiBiTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY2RpbXNbY3JhbmsgLSBpXSA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjZGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgaW5kaWNlcyBvZiBhIGJyb2FkY2FzdGVkIHRlbnNvciwgY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBpbmRpY2VzXG4gICAqIEBwYXJhbSBicm9hZGNhc3RlZEluZGljZXMgVGhlIGdpdmVuIGluZGljZXMgb2YgdGhlIGJyb2FkY2FzdGVkIHRlbnNvci5cbiAgICogQHBhcmFtIG9yaWdpbmFsU2hhcGUgVGhlIG9yaWdpbmFsIHNoYXBlIG9mIHRoZSB0ZW5zb3IgYmVmb3JlIGJyb2FkY2FzXG4gICAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIGluZGljZXMgdGhhdCBtYXBzIHRvIHRoZSBvcmlnaW5hbCB0ZW5zb3IuXG4gICAqL1xuICBzdGF0aWMgaW5kZXgoYnJvYWRjYXN0ZWRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgb3JpZ2luYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgLy8gTk9URSAxOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBicm9hZGNhc3RlZEluZGljZXMgaXMgdmFsaWQuIGllLiBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZVxuICAgIC8vIGxlbmd0aCBhcyB0aGUgYnJvYWRjYXN0ZWQgc2hhcGUsIGFuZCBmb3IgZWFjaCBkaW1lbnNpb24gdGhlIGluZGV4IHNob3VsZFxuICAgIC8vIG5vdCBiZSBvdXQgb2YgcmFuZ2UuXG4gICAgY29uc3Qgb3JpZ2luYWxJbmRpY2VzID0gbmV3IEFycmF5KG9yaWdpbmFsU2hhcGUubGVuZ3RoKTtcbiAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChicm9hZGNhc3RlZEluZGljZXMsIG9yaWdpbmFsU2hhcGUsIG9yaWdpbmFsSW5kaWNlcyk7XG4gICAgcmV0dXJuIG9yaWdpbmFsSW5kaWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgaW5kaWNlcyBvZiBhIGJyb2FkY2FzdGVkIHRlbnNvciwgY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBpbmRpY2VzXG4gICAqIEBwYXJhbSBicm9hZGNhc3RlZEluZGljZXMgVGhlIGdpdmVuIGluZGljZXMgb2YgdGhlIGJyb2FkY2FzdGVkIHRlbnNvci5cbiAgICogQHBhcmFtIG9yaWdpbmFsU2hhcGUgVGhlIG9yaWdpbmFsIHNoYXBlIG9mIHRoZSB0ZW5zb3IgYmVmb3JlIGJyb2FkY2FzdFxuICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRpY2VzIFRoZSBtYXBwaW5nIG9mIGJyb2FkY2FzdGVkSW5kaWNlcyB0byB0aGUgb3JpZ2luYWxJbmRpY2VzIChvdXRwdXQgcGFyYW1ldGVyIC0gd2lsbCBiZVxuICAgKiAgICAgbXV0YXRlZCkuXG4gICAqL1xuICBzdGF0aWMgZmlsbEluZGV4KGJyb2FkY2FzdGVkSW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIG9yaWdpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvcmlnaW5hbEluZGljZXM6IG51bWJlcltdKSB7XG4gICAgLy8gTk9URSAxOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBicm9hZGNhc3RlZEluZGljZXMgaXMgdmFsaWQuIGllLiBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG4gICAgLy8gYnJvYWRjYXN0ZWQgc2hhcGUsIGFuZCBmb3IgZWFjaCBkaW1lbnNpb24gdGhlIGluZGV4IHNob3VsZCBub3QgYmUgb3V0IG9mIHJhbmdlLlxuICAgIC8vIE5PVEUgMjogd2UgYXNzdW1lIHRoZSBwYXJhbWV0ZXIgb3JpZ2luYWxJbmRpY2VzIGhhcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG9yaWdpbmFsU2hhcGVcbiAgICBjb25zdCBkaW1PZmZzZXQgPSBicm9hZGNhc3RlZEluZGljZXMubGVuZ3RoIC0gb3JpZ2luYWxTaGFwZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBicm9hZGNhc3RlZEluZGljZXNbZGltT2Zmc2V0ICsgaV0gJSBvcmlnaW5hbFNoYXBlW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSBicm9hZGNhc3Rpbmcgb3BlcmF0aW9uIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBUaGUgaW5wdXQgdGVuc29yIEFcbiAgICogQHBhcmFtIGIgVGhlIGlucHV0IHRlbnNvciBCXG4gICAqIEBwYXJhbSBvcCBUaGUgb3BlcmF0b3IgbGFtYmRhIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBpbnBsYWNlIFdoZXRoZXIgdG8gd3JpdGUgdGhlIHJlc3VsdCBiYWNrIHRvIEEuXG4gICAqIEByZXR1cm5zIFRoZSByZXN1bHQgdGVuc29yLCBvciB1bmRlZmluZWQgaWYgaW5wdXQgbm90IGJyb2FkY2FzdGFibGUuXG4gICAqL1xuICBzdGF0aWMgY2FsYyhcbiAgICBhOiBUZW5zb3IsXG4gICAgYjogVGVuc29yLFxuICAgIG9wOiAoYTogc3RyaW5nIHwgbnVtYmVyLCBiOiBzdHJpbmcgfCBudW1iZXIpID0+IHN0cmluZyB8IG51bWJlcixcbiAgICBpbnBsYWNlOiBib29sZWFuLFxuICAgIHJlc3VsdFR5cGU/OiBUZW5zb3IuRGF0YVR5cGUsXG4gICk6IFRlbnNvciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhLmRpbXMsIGIuZGltcyk7XG5cbiAgICBpZiAob3V0cHV0U2hhcGUpIHtcbiAgICAgIGlmIChpbnBsYWNlICYmICFTaGFwZVV0aWwuYXJlRXF1YWwob3V0cHV0U2hhcGUsIGEuZGltcykpIHtcbiAgICAgICAgLy8gQiBpcyBub3QgYnJvYWRjYXN0YWJsZSB0byBBLCBmYWlsZWQgdG8gY2FsY3VsYXRlIGlucGxhY2UuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBjID0gaW5wbGFjZSA/IGEgOiBuZXcgVGVuc29yKG91dHB1dFNoYXBlLCByZXN1bHRUeXBlIHx8IGEudHlwZSk7XG5cbiAgICAgIC8vIGJvdGggaW5wdXRzIGFyZSBzY2FsYXJzXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGMuc2V0KFtdLCBvcChhLmdldChbXSkgYXMgbnVtYmVyLCBiLmdldChbXSkgYXMgbnVtYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0bGVhc3Qgb25lIGlucHV0IGlzIGEgbm9uLXNjYWxhclxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNBID0gbmV3IEFycmF5KGEuZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNCID0gbmV3IEFycmF5KGIuZGltcy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmFsQTogc3RyaW5nIHwgbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHZhbEI6IHN0cmluZyB8IG51bWJlciA9IDA7XG4gICAgICAgIGxldCBpc0FTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzQlNjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoYS5kaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHZhbEEgPSBhLmdldChbXSkgYXMgbnVtYmVyO1xuICAgICAgICAgIGlzQVNjYWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIuZGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YWxCID0gYi5nZXQoW10pIGFzIG51bWJlcjtcbiAgICAgICAgICBpc0JTY2FsYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN0OiBudW1iZXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgLy8gdHJhdmVyc2FsIGluZGljZXNcbiAgICAgICAgICByZXN0ID0gaTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gb3V0cHV0U2hhcGUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIG91dHB1dEluZGljZXNbal0gPSByZXN0ICUgb3V0cHV0U2hhcGVbal07XG4gICAgICAgICAgICByZXN0ID0gTWF0aC5mbG9vcihyZXN0IC8gb3V0cHV0U2hhcGVbal0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNBU2NhbGFyKSB7XG4gICAgICAgICAgICAvLyBtYXAgb3V0cHV0SW5kaWNlcyAod2hpY2ggaXMgYWN0dWFsbHkgYnJvYWRjYXN0ZWQpIHRvIHRoZSBvcmlnaW5hbEluZGljZXNcbiAgICAgICAgICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KG91dHB1dEluZGljZXMsIGEuZGltcywgb3JpZ2luYWxJbmRpY2VzQSk7XG4gICAgICAgICAgICB2YWxBID0gYS5nZXQob3JpZ2luYWxJbmRpY2VzQSkgYXMgbnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzQlNjYWxhcikge1xuICAgICAgICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgob3V0cHV0SW5kaWNlcywgYi5kaW1zLCBvcmlnaW5hbEluZGljZXNCKTtcbiAgICAgICAgICAgIHZhbEIgPSBiLmdldChvcmlnaW5hbEluZGljZXNCKSBhcyBudW1iZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYy5zZXQob3V0cHV0SW5kaWNlcywgb3AodmFsQSwgdmFsQikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgYnJvYWRjYXN0ZWQgZGltcyBpbiBpbnB1dCBzaGFwZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3V0cHV0IHNoYXBlLlxuICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHJldHVybnMgdGhlIGJyb2FkY2FzdGVkIGRpbXMuXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gb3V0cHV0U2hhcGUgVGhlIG91dHB1dCBzaGFwZVxuICAgKiBAcmV0dXJucyBUaGUgYnJvYWRjYXN0ZWQgZGltcyBpbiBpbnB1dCBzaGFwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgY29uc3QgaW5SYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZGltczogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgIGNvbnN0IGEgPSBpbnB1dFNoYXBlW2RpbV0gfHwgMTtcbiAgICAgIGNvbnN0IGIgPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxufVxuXG4vLyBjb3B5IGFycmF5IGhlbHBlclxuLy8gbWltaWNzIG1lbWNweSBhcyBtdWNoIGFzIHBvc3NpYmxlXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDb3B5SGVscGVyKFxuICB0YXJnZXQ6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gIHNvdXJjZTogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgc291cmNlSW5kZXg6IG51bWJlcixcbiAgYmxvY2tTaXplOiBudW1iZXIsXG4pIHtcbiAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICB9XG4gIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgfVxuXG4gIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdID0gc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdHJhbnNMZWZ0OiBib29sZWFuLFxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJvdG9VdGlsIHtcbiAgc3RhdGljIHRlbnNvckRhdGFUeXBlRnJvbVByb3RvKFxuICAgIHR5cGVQcm90bzogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSB8IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICk6IFRlbnNvci5EYXRhVHlwZSB7XG4gICAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgICByZXR1cm4gJ2ludDgnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgICByZXR1cm4gJ2ludDE2JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICAgIHJldHVybiAndWludDE2JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0NjQnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuXG4gICAgICAvLyBGb3IgSU5UNjQvVUlOVDY0LCByZWR1Y2UgdGhlaXIgdmFsdWUgdG8gMzItYml0cy5cbiAgICAgIC8vIFNob3VsZCB0aHJvdyBleGNlcHRpb24gd2hlbiBvdmVyZmxvd1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICAgIHJldHVybiAndWludDMyJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlUHJvdG9dfWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSh0eXBlOiBzdHJpbmcpOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4O1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODtcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MO1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjtcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjtcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI7XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ7XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HO1xuICAgICAgY2FzZSAnaW50NjQnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDtcbiAgICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGVuc29yRGltc0Zyb21Qcm90byhkaW1zOiBBcnJheTxudW1iZXIgfCBMb25nPik6IG51bWJlcltdIHtcbiAgICAvLyBnZXQgcmlkIG9mIExvbmcgdHlwZSBmb3IgZGltc1xuICAgIHJldHVybiBkaW1zLm1hcCgoZCkgPT4gKExvbmcuaXNMb25nKGQpID8gZC50b051bWJlcigpIDogZCkpO1xuICB9XG5cbiAgc3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh2YWx1ZVR5cGU6IG9ubnguVHlwZVByb3RvLklUZW5zb3IpOiBHcmFwaC5WYWx1ZVR5cGUge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW5zb3JUeXBlOiBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odmFsdWVUeXBlLmVsZW1UeXBlISksXG4gICAgICBzaGFwZTogeyBkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byh2YWx1ZVR5cGUuc2hhcGUhLmRpbSEubWFwKChkKSA9PiBkLmRpbVZhbHVlISkpIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdCh0ZW5zb3I6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKSB7XG4gICAgY29uc3QgZGltcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVuc29yLmRpbXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHRlbnNvci5kaW1zKGkpISkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChub2RlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzKGkpISk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMb25nVXRpbCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGdldCBhIG51bWJlciBmcm9tIGxvbmcgdHlwZSBvZiBkYXRhIGZvciBhdHRyaWJ1dGUsIGRpbSwgYW5kIGlyIHZlcnNpb24sXG4gIC8vIHdoaWNoIHZhbHVlcyBhcmUgc2lnbmVkIGludGVnZXJzLlxuICAvLyBUbyBtYWtlIGl0IG1vcmUgZ2VuZXJpYywgYWRkIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBjb252ZXJ0IHRvIGEgdW5zaWduZWQgbnVtYmVyLlxuICBzdGF0aWMgbG9uZ1RvTnVtYmVyKG46IExvbmcgfCBmbGF0YnVmZmVycy5Mb25nIHwgbnVtYmVyLCB1bnNpZ25lZD86IGJvb2xlYW4pIHtcbiAgICBpZiAoTG9uZy5pc0xvbmcobikpIHtcbiAgICAgIHJldHVybiBuLnRvTnVtYmVyKCk7XG4gICAgfSBlbHNlIGlmIChuIGluc3RhbmNlb2YgZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgcmV0dXJuIExvbmcuZnJvbVZhbHVlKHsgbG93OiBuLmxvdywgaGlnaDogbi5oaWdoLCB1bnNpZ25lZDogdW5zaWduZWQgPz8gZmFsc2UgfSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgc3RhdGljIGlzTG9uZyhuOiB1bmtub3duKSB7XG4gICAgcmV0dXJuIExvbmcuaXNMb25nKG4pIHx8IG4gaW5zdGFuY2VvZiBmbGF0YnVmZmVycy5Mb25nO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGBheGlzYCBpbmNsdXNpdmVcbiAgc3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgYXhpcywgZGltcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gYGF4aXNgIGV4Y2x1c2l2ZVxuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgc3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIC8vIHNhZmV0eSBjaGVjayBhcyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgbXVsdGlwbGUgb3RoZXIgbWV0aG9kcyByZXF1aXJpbmcgc2l6ZS5cbiAgICAgIC8vIHNpemUgY2Fubm90IGJlIDAgb3IgbmVnYXRpdmUuXG4gICAgICBpZiAoZGltc1tpXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICdjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBkaW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIHN0YXRpYyBjb21wdXRlU3RyaWRlcyhkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbMV07XG4gICAgfVxuICAgIGNvbnN0IHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMV0gPSAxO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gZGltc1tyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogZGltc1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGVzO1xuICB9XG5cbiAgc3RhdGljIHRyYW5zcG9zZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCBjb3B5ID0gZGltcy5zbGljZSgpO1xuICAgIHJldHVybiBjb3B5LnJldmVyc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBpbmRpY2VzVG9PZmZzZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBheGlzID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpczsgKytpKSB7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlc1tpXSAqIGluZGljZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgb2Zmc2V0VG9JbmRpY2VzKG9mZnNldDogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gc3RyaWRlcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbb2Zmc2V0ICogc3RyaWRlc1swXV07XG4gICAgfVxuICAgIGNvbnN0IGluZGljZXM6IG51bWJlcltdID0gbmV3IEFycmF5KHN0cmlkZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpbmRpY2VzW2ldID0gTWF0aC5mbG9vcihvZmZzZXQgLyBzdHJpZGVzW2ldKTtcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICB9XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdID0gb2Zmc2V0O1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIG5vcm1haWx6ZSBheGlzIG9mIHJhbmdlIFstciwgcikgaW50byBbMCwgcikuXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplQXhpcyhheGlzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayAmJiBheGlzID49IHRlbnNvclJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiBheGlzIDwgMCA/IGF4aXMgKyB0ZW5zb3JSYW5rIDogYXhpcztcbiAgfVxuXG4gIHN0YXRpYyBub3JtYWxpemVBeGVzKGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuaykpO1xuICB9XG5cbiAgLy8gSW5jcmVtZW50IGFuIGluZGV4IGludG8gYSB0ZW5zb3IgKGluIGxleGljb2dyYXBoaWNcbiAgLy8gb3JkZXJpbmcpLCB3cmFwcGluZyBhcm91bmQgdGhlIHNwZWNpZmllZCB1cHBlcl9ib3VuZC5cbiAgLyoqXG4gICAqIEluY3JlbWVudCBhbiBpbmRleCBpbnRvIGEgdGVuc29yIChpbiBsZXhpY29ncmFwaGljIG9yZGVyaW5nKSwgd3JhcHBpbmcgYXJvdW5kIHRoZSBzcGVjaWZpZWQgdXBwZXJfYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCBHaXZlbiBpbmRleCB0byBpbmNyZW1lbnQgKFdpbGwgYmUgbXV0YXRlZClcbiAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvciBmb3Igd2hpY2ggdGhlIGdpdmVuIGluZGV4IGNvcnJlc3BvbmRzIHRvXG4gICAqIEBwYXJhbSBheGlzVG9JbmNyZW1lbnRPbiBUaGUgMS1pbmRleGVkIGF4aXMgdG8gaW5jcmVtZW50IG9uLiBJZiB1bmRlZmluZWQsIGF4aXNUb0luY3JlbWVudE9uID09IHJhbmtcbiAgICovXG4gIHN0YXRpYyBpbmNyZW1lbnRJbmRleChpbmRleDogbnVtYmVyW10sIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzVG9JbmNyZW1lbnRPbj86IG51bWJlcikge1xuICAgIGlmIChkaW1zLmxlbmd0aCA9PT0gMCB8fCBpbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yJyk7XG4gICAgfVxuICAgIGlmIChheGlzVG9JbmNyZW1lbnRPbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBheGlzVG9JbmNyZW1lbnRPbiA9IGRpbXMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXhpc1RvSW5jcmVtZW50T24gPD0gMCB8fCBheGlzVG9JbmNyZW1lbnRPbiA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgayA9IGF4aXNUb0luY3JlbWVudE9uIC0gMTsgayA+PSAwOyAtLWspIHtcbiAgICAgIGluZGV4W2tdKys7XG4gICAgICBpZiAoaW5kZXhba10gPCBkaW1zW2tdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXhba10gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIG5ldyBkaW1lbnNpb25zIGFycmF5IGJhc2VkIG9uIHRoZSB2YWx1ZXMgaW4gdGhlICdvcmlnaW5hbERpbWVuc2lvbnMnIGFuZCAnc2hhcGUnIGFycmF5XG4gICAqIFVzZWQgaW4gUmVzaGFwZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxEaW1zIE9yaWdpbmFsIFNoYXBlIGFycmF5XG4gICAqIEBwYXJhbSBzaGFwZUhpbnRzIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIHRvIGNvbXB1dGUgdGhlIG5ldyBkaW1lbnNpb25zXG4gICAqIEZvciBleGFtcGxlOlxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFswLC0xXSB3aWxsIHJldHVybiBbMiwyXVxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFs0XSB3aWxsIHJldHVybiBbNF1cbiAgICogb3JpZ2luYWxEaW1zID0gWzIsMl0gYW5kIHNoYXBlSGludHMgPSBbNV0gd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9PcGVyYXRvcnMubWQjUmVzaGFwZVxuICAgKi9cblxuICBzdGF0aWMgY2FsY3VsYXRlUmVzaGFwZWREaW1zKG9yaWdpbmFsRGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlSGludHM6IEFycmF5TGlrZTxudW1iZXI+KTogbnVtYmVyW10ge1xuICAgIC8vIHJlc2hhcGUgdG8gYSBTY2FsYXIgVGVuc29yXG4gICAgaWYgKHNoYXBlSGludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAob3JpZ2luYWxEaW1zLmxlbmd0aCA9PT0gMCB8fCBTaGFwZVV0aWwuc2l6ZShvcmlnaW5hbERpbXMpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlc2hhcGUgdG8gYSBzY2FsYXIgVGVuc29yJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbkRpbXMgPSBzaGFwZUhpbnRzLmxlbmd0aDtcbiAgICBjb25zdCByZXNoYXBlZERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihuRGltcyk7XG4gICAgbGV0IHVua25vd25EaW1lbnNpb24gPSAtMTtcbiAgICBsZXQgbmV3VGVuc29yU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRGltczsgaSsrKSB7XG4gICAgICBpZiAoc2hhcGVIaW50c1tpXSA8IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2Fubm90IGJlIGxlc3MgdGhhbiAtMScpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlSGludHNbaV0gPT09IC0xKSB7XG4gICAgICAgIGlmICh1bmtub3duRGltZW5zaW9uICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMScpO1xuICAgICAgICB9XG4gICAgICAgIHVua25vd25EaW1lbnNpb24gPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNoYXBlSGludHNbaV0gPT09IDApIHtcbiAgICAgICAgICBpZiAoaSA+PSBvcmlnaW5hbERpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBkaW1lbnNpb24gd2l0aCB2YWx1ZSB6ZXJvIGV4Y2VlZHMgdGhlIGRpbWVuc2lvbiBzaXplIG9mIHRoZSBpbnB1dCB0ZW5zb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzaGFwZWREaW1zW2ldID0gb3JpZ2luYWxEaW1zW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2hhcGVkRGltc1tpXSA9IHNoYXBlSGludHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbmV3VGVuc29yU2l6ZSAqPSByZXNoYXBlZERpbXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkVGVuc29yU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG9yaWdpbmFsRGltcyk7XG4gICAgaWYgKHVua25vd25EaW1lbnNpb24gIT09IC0xKSB7XG4gICAgICBpZiAob2xkVGVuc29yU2l6ZSAlIG5ld1RlbnNvclNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7XG4gICAgICAgICAgICBvcmlnaW5hbERpbXNcbiAgICAgICAgICB9XSBPdXRwdXQgc2hhcGU6IFske3NoYXBlSGludHN9XWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXNoYXBlZERpbXNbdW5rbm93bkRpbWVuc2lvbl0gPSBvbGRUZW5zb3JTaXplIC8gbmV3VGVuc29yU2l6ZTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgc2l6ZXMgZnJvbSBvcmlnaW5hbERpbXMgYW5kIHJlc2hhcGVkRGltcyBtYXRjaFxuICAgIGVsc2Uge1xuICAgICAgaWYgKG5ld1RlbnNvclNpemUgIT09IG9sZFRlbnNvclNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzaGFwZWREaW1zIGFuZCBvcmlnaW5hbERpbXMgZG9uJ3QgaGF2ZSBtYXRjaGluZyBzaXplc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2hhcGVkRGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhIGdpdmVuIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRpY2VzIGluIHRoZSBQZXJtIGFycmF5XG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXG4gICAqIEBwYXJhbSBhIEFycmF5IHRvIGJlIHNvcnRlZCBzdWNoIGFzIGRpbXMgb3Igc3RyaWRlc1xuICAgKiBAcGFyYW0gcGVybSBQZXJtIGdpdmVuOyBpZiBudWxsIGEgd2lsbCBiZSByZXZlcnNlZFxuICAgKi9cbiAgc3RhdGljIHNvcnRCYXNlZE9uUGVybShhOiByZWFkb25seSBudW1iZXJbXSwgcGVybT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChwZXJtKSB7XG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIGdpdmVuIHNoYXBlIGFjY29yZGluZyB0byB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGRpbXMgc2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBwYWRkZWRcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgcGFkU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHBhZDogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIHJldHVybiBkaW1zLm1hcCgodiwgaSkgPT4gdiArIHBhZFtpXSArIHBhZFtpICsgcmFua10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHR3byBzaGFwZXMgYXJlIGlkZW50aWNhbFxuICAgKiBAcGFyYW0gc2hhcGUxXG4gICAqIEBwYXJhbSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGUyW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGdpdmVuIGBkaW1zYCBvciBgc2hhcGVgIGlzIHZhbGlkIGluIE9OTlguanMgY29udGV4dCBhbmQgcmV0dXJucyBkYXRhIHNpemVcbiAgICogQHBhcmFtIGRpbXMgLSBpbnB1dCBgZGltc2AgdGhhdCBuZWVkcyB0byBiZSBjaGVja2VkXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChkaW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuJyk7XG4gICAgfVxuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGltcykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMCB8fCBuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBuO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSBmbGF0dGVuKHgsIGF4aXMpXG4gICAqIEBwYXJhbSBkaW1zIC0gc2hhcGUgb2YgaW5wdXQgdGVuc29yXG4gICAqIEBwYXJhbSBheGlzIC0gZmxhdHRlbiBheGlzLCBpbiB0aGUgcmFuZ2UgWy1yLCByXVxuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW5TaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgYXhpcyArPSBkaW1zLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgdG90YWwgPSBkaW1zLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGltcy5zbGljZShheGlzKS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW3RvdGFsIC8gcmlnaHQsIHJpZ2h0XTtcblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHNxdWVlemUoeCwgYXhlcylcbiAgICogQHBhcmFtIGRpbXMgLSBzaGFwZSBvZiBpbnB1dCB0ZW5zb3JcbiAgICogQHBhcmFtIGF4ZXMgLSBzcXVlZXplIGF4ZXNcbiAgICovXG4gIHN0YXRpYyBzcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGRpbXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5TcXVlZXplTGlzdCA9IGF4ZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgaWYgKGluU3F1ZWV6ZUxpc3QgJiYgZGltc1tpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxdWVlemUgYW4gYXhpcyBvZiBzaXplIGRpZmZlcmVudCB0aGFuIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChheGVzLmxlbmd0aCA9PT0gMCAmJiBkaW1zW2ldID4gMSkgfHwgKGF4ZXMubGVuZ3RoID4gMCAmJiAhaW5TcXVlZXplTGlzdCkpIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKGRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHVuc3F1ZWV6ZSh4LCBheGVzKVxuICAgKiBAcGFyYW0gZGltcyAtIHNoYXBlIG9mIGlucHV0IHRlbnNvclxuICAgKiBAcGFyYW0gYXhlcyAtIHVuc3F1ZWV6ZSBheGVzXG4gICAqL1xuICBzdGF0aWMgdW5zcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW1zLmxlbmd0aCArIGF4ZXMubGVuZ3RoKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGFycmF5IGVsZW1lbnRzIHRvIDBcbiAgICBvdXRwdXREaW1zLmZpbGwoMCk7XG5cbiAgICAvLyBzZXQgYWxsIGF4ZXMgaW5kaWNlcyB0byAxIGluIG91dHB1dERpbXMgYW5kIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhlc1tpXSwgb3V0cHV0RGltcy5sZW5ndGgpO1xuICAgICAgaWYgKGF4aXMgPj0gb3V0cHV0RGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhbiBvdXQgb2YgcmFuZ2UgYXhpc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXREaW1zW2F4aXNdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYSBkdXBsaWNhdGUgYXhpc1wiKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0RGltc1theGlzXSA9IDE7XG4gICAgfVxuXG4gICAgLy8gZmlsbCBpbiB0aGUgemVybyBlbnRyaWVzIG9mIG91dHB1dERpbXMgd2l0aCB0aGUgaW5wdXQgdGVuc29yJ3Mgc2hhcGVcbiAgICBsZXQgaW5wdXREaW1zSXRlcmF0b3IgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0RGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG91dHB1dERpbXNbaV0gPT09IDApIHtcbiAgICAgICAgb3V0cHV0RGltc1tpXSA9IGRpbXNbaW5wdXREaW1zSXRlcmF0b3IrK107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrIGFzc2VydGlvbi4gJ2lucHV0RGltc0l0ZXJhdG9yJ1xuICAgIC8vIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mICdkaW1zJ1xuICAgIGlmIChpbnB1dERpbXNJdGVyYXRvciAhPT0gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIHVuc3F1ZWV6ZWQgZGltZW5zaW9uIGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG59XG5cbi8vIGJ1bmNoIG9mIGhlbHBlciBtZXRob2RzIHRoYXQgZG8gYSB2YXJpZXR5IG9mIG1hdGggb3BlcmF0aW9uc1xuZXhwb3J0IGNsYXNzIE1hdGhVdGlsIHtcbiAgLy8geSA9ICh4KngpICsgeVxuICBzdGF0aWMgc3FyKFxuICAgIHRhcmdldDogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBzb3VyY2U6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgICBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyLFxuICApIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSArPSBNYXRoLnBvdyhzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdLCAyKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gYXggKyB5XG4gIHN0YXRpYyBheHB5KFxuICAgIHRhcmdldDogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBzb3VyY2U6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgICBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyLFxuICAgIGFscGhhOiBudW1iZXIsXG4gICkge1xuICAgIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdICs9IGFscGhhICogc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gcG93KHgsIGIpXG4gIHN0YXRpYyBwb3d4KFxuICAgIHRhcmdldDogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBzb3VyY2U6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgICBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyLFxuICAgIGI6IG51bWJlcixcbiAgKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBNYXRoLnBvdyhzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0geCAqIHlcbiAgc3RhdGljIG11bChcbiAgICB0YXJnZXQ6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgc291cmNlOiBudW1iZXJbXSB8IFRlbnNvci5OdW1iZXJUeXBlLFxuICAgIHRhcmdldEluZGV4OiBudW1iZXIsXG4gICAgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICBibG9ja1NpemU6IG51bWJlcixcbiAgKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdICogdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNwbGl0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIG5ldyBTaGFwZXMgZnJvbSBleGlzdGluZyBvbmUgYW5kIHRoZSBzcGxpdHMgZ2l2ZW4gYWxvbmcgdGhlIGF4aXMgcHJvdmlkZXNcbiAgICogQHBhcmFtIGRpbXMgU2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBzcGxpdHRlZCBpbnRvIHR3byBvciBtb3JlIFNoYXBlc1xuICAgKiBAcGFyYW0gYXhpcyBUaGUgZGltZW5zaW9uIGFsb25nIHdoaWNoIHRoZSBUZW5zb3Igd2lsbCBiZSBzcGxpdFxuICAgKiBAcGFyYW0gc3BsaXRzIE9mZnNldHMgZm9yIHRoZSBzdGFydCBvZiBlYWNoIHNwbGl0XG4gICAqL1xuICBzdGF0aWMgc3BsaXRTaGFwZShcbiAgICBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBheGlzOiBudW1iZXIsXG4gICAgc3BsaXQ6IG51bWJlcltdLFxuICAgIG51bU91dHB1dHM/OiBudW1iZXIsXG4gICk6IFtudW1iZXJbXVtdLCBudW1iZXJbXV0ge1xuICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICghbnVtT3V0cHV0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgJ3NwbGl0JyBhdHRyaWJ1dGUgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgIH1cbiAgICAgIFNwbGl0VXRpbC5kZXRlcm1pbmVTcGxpdChkaW1zW2F4aXNdLCBudW1PdXRwdXRzLCBzcGxpdCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFswXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0c1tpIC0gMV0gKyBzcGxpdFtpIC0gMV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcGUgPSBkaW1zLnNsaWNlKCk7XG4gICAgICBzaGFwZVtheGlzXSA9IHNwbGl0W2ldO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gW3NoYXBlcywgb2Zmc2V0c107XG4gIH1cblxuICBzdGF0aWMgZGV0ZXJtaW5lU3BsaXQobnVtRWxlbWVudHNBbG9uZ0F4aXM6IG51bWJlciwgbnVtT3V0cHV0czogbnVtYmVyLCBzcGxpdDogbnVtYmVyW10pIHtcbiAgICAvLyBJZiAnc3BsaXQnIGlzIG5vdCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlIG5lZWQgdG8gcGFydGl0aW9uIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWxseSBhbW9uZyB0aGUgb3V0cHV0c1xuICAgIGlmIChudW1FbGVtZW50c0Fsb25nQXhpcyAlIG51bU91dHB1dHMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0cycpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU91dHB1dHM7ICsraSkge1xuICAgICAgc3BsaXQucHVzaChudW1FbGVtZW50c0Fsb25nQXhpcyAvIG51bU91dHB1dHMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVkdWNlVXRpbCB7XG4gIC8qKlxuICAgKiBQZXJmb3JtIHJlZHVjZSBvcGVyYXRpb25zIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0ga2VlcGRpbXMgSWYgc2V0IHRvIHRydWUsIHRoZSBheGVzIHdoaWNoIGFyZSByZWR1Y2VkIGFyZSBsZWZ0IGluIHRoZVxuICAgKiAgICByZXN1bHQgYXMgZGltZW5zaW9ucyB3aXRoIHNpemUgb25lLlxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZShcbiAgICBhOiBUZW5zb3IsXG4gICAgYXhlczogbnVtYmVyW10sXG4gICAga2VlcGRpbXM6IGJvb2xlYW4sXG4gICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsXG4gICAgb3AyOiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcixcbiAgKTogVGVuc29yIHtcbiAgICBjb25zdCBkaW1zID0gYS5kaW1zLnNsaWNlKDApO1xuICAgIC8vIGlmIGF4ZXMgaXMgbm90IHNldCwgcGVyZm9ybSByZWR1Y2Ugb24gYWxsIGF4ZXNcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRpbXMuZm9yRWFjaCgoX2QsIGluZCkgPT4gYXhlcy5wdXNoKGluZCkpO1xuICAgIH1cbiAgICAvLyBnZXQgYSB0ZW1wb3JhcnkgYnJvYWRjYXN0YWJsZSBvdXRwdXQgc2hhcGVcbiAgICBjb25zdCBvdXRwdXREaW1zID0gUmVkdWNlVXRpbC5jYWxjUmVkdWNlU2hhcGUoZGltcywgYXhlcywgdHJ1ZSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggdGhlIG91dHB1dCBhbmQgY2FsY3VsYXRlIHJlc3VsdCBvbmUgYnkgb25lXG4gICAgY29uc3Qgc2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dERpbXMpO1xuICAgIGNvbnN0IHkgPSBuZXcgVGVuc29yKG91dHB1dERpbXMsIGEudHlwZSk7XG4gICAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhvdXRwdXREaW1zKTtcbiAgICBjb25zdCBpbnB1dFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZGltcyk7XG4gICAgY29uc3QgaW5kaWNlc1kgPSBuZXcgQXJyYXkoZGltcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gU2hhcGVVdGlsLm9mZnNldFRvSW5kaWNlcyhpLCBzdHJpZGVzKTtcbiAgICAgIC8vIG1hcCBpbmRleFxuICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgoaW5kaWNlcywgZGltcywgaW5kaWNlc1kpO1xuICAgICAgeS5zZXQoXG4gICAgICAgIGluZGljZXMsXG4gICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgICAgICBhLm51bWJlckRhdGEsXG4gICAgICAgICAgYXhlcyxcbiAgICAgICAgICBkaW1zLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgU2hhcGVVdGlsLmluZGljZXNUb09mZnNldChpbmRpY2VzWSwgaW5wdXRTdHJpZGVzKSxcbiAgICAgICAgICBvcDEsXG4gICAgICAgICAgb3AyLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoa2VlcGRpbXMpIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBrZWVwZGltcyA9PSAwLCBjYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlXG4gICAgICByZXR1cm4gbmV3IFRlbnNvcihcbiAgICAgICAgUmVkdWNlVXRpbC5jYWxjUmVkdWNlU2hhcGUoZGltcywgYXhlcywga2VlcGRpbXMpLFxuICAgICAgICB5LnR5cGUsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB5LmRhdGEsXG4gICAgICAgIHkuZGF0YUlkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSByZWR1Y2Ugb3BlcmF0aW9ucyBvbiB0aGUgc3BlY2lmaWMgb3BlcmF0b3Igb24gc3BlY2lmaWMgYXhlc1xuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0gZGltcyBUaGUgaW5wdXQgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0gY3VyQXhpc0luZCBJbmRleCBpbiBheGVzIHNwZWNpZnlpbmcgdGhlIGN1cnJlbnQgZGltZW5zaW9uIGFsb25nXG4gICAqICAgICAgd2hpY2ggdGhlIHRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIHBvcyBUaGUgY3VycmVudCBpbmRleCBvZiBlbGVtZW50IHRvIHBlcmZvcm0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBvcDEgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgb24gZWFjaCBlbGVtZW50IGluIHRoZSB0ZW5zb3JcbiAgICogQHBhcmFtIG9wMiBUaGUgb3BlcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBiZXR3ZWVuIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlQnlBeGlzKFxuICAgIGlucHV0OiBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBheGVzOiBudW1iZXJbXSxcbiAgICBkaW1zOiBudW1iZXJbXSxcbiAgICBjdXJBeGlzSW5kOiBudW1iZXIsXG4gICAgcG9zOiBudW1iZXIsXG4gICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsXG4gICAgb3AyOiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcixcbiAgKTogbnVtYmVyIHtcbiAgICBsZXQgcmVzID0gMDtcbiAgICBpZiAoY3VyQXhpc0luZCA+PSBheGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG9wMShpbnB1dFtwb3NdKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGF4ZXNbY3VyQXhpc0luZF07XG4gICAgY29uc3Qgc3RlcCA9IGF4aXMgPj0gZGltcy5sZW5ndGggPyAxIDogU2hhcGVVdGlsLnNpemUoZGltcy5zbGljZShheGlzICsgMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc1theGlzXTsgaSsrKSB7XG4gICAgICByZXMgPVxuICAgICAgICBpID09PSAwXG4gICAgICAgICAgPyBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VCeUF4aXMoaW5wdXQsIGF4ZXMsIGRpbXMsIGN1ckF4aXNJbmQgKyAxLCBwb3MsIG9wMSwgb3AyKVxuICAgICAgICAgIDogb3AyKHJlcywgUmVkdWNlVXRpbC5jYWxjUmVkdWNlQnlBeGlzKGlucHV0LCBheGVzLCBkaW1zLCBjdXJBeGlzSW5kICsgMSwgcG9zLCBvcDEsIG9wMikpO1xuICAgICAgcG9zICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSBvZiBhIHJlZHVjZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb25cbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGtlZXBkaW1zIElmIHNldCB0byB0cnVlLCB0aGUgYXhlcyB3aGljaCBhcmUgcmVkdWNlZCBhcmUgbGVmdCBpbiB0aGVcbiAgICogICAgcmVzdWx0IGFzIGRpbWVuc2lvbnMgd2l0aCBzaXplIG9uZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZWVwRGltczogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gZGltcy5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dERpbXNbYXhlc1tpXV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0RGltc1theGVzW2ldXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXREaW1zLmZpbHRlcigoZGltKSA9PiBkaW0gIT09IDApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgKSB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IGRpbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWxhdGlvbnMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICkge1xuICAgIGlmICghYXV0b1BhZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYWRzLmxlbmd0aCAhPT0gMiAqIChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmlkZXMubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgIFBvb2xDb252VXRpbC5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgICAgaW5wdXREaW1zW2RpbSArIDJdLFxuICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgIGRpbGF0aW9uc1tkaW1dLFxuICAgICAgICBrZXJuZWxTaGFwZVtkaW1dLFxuICAgICAgICBwYWRzLFxuICAgICAgICBkaW0sXG4gICAgICAgIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICBhdXRvUGFkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICAgIGlucHV0RGltcyxcbiAgICAgIG91dHB1dERpbXMsXG4gICAgICBzdHJpZGVzLFxuICAgICAgZGlsYXRpb25zLFxuICAgICAga2VybmVsU2hhcGUsXG4gICAgICBwYWRzLFxuICAgICAgYXV0b1BhZCxcbiAgICApO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcbiAgICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChcbiAgICAgICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXG4gICAgICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgICAgICBkaWxhdGlvbnNbZGltXSxcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXG4gICAgICAgICAgICBwYWRzLFxuICAgICAgICAgICAgZGltLFxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgIGluU2l6ZTogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyLFxuICAgIGRpbGF0aW9uOiBudW1iZXIsXG4gICAga2VybmVsOiBudW1iZXIsXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgcGFkVGFpbEluZGV4OiBudW1iZXIsXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSBhdXRvUGFkID09PSAnU0FNRV9MT1dFUicgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTUlOX0NMSVAgPSAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuZXhwb3J0IGNvbnN0IE1BWF9DTElQID0gMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVXRmOFN0cmluZyhidWZmZXI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEd1aWQgfSBmcm9tICdndWlkLXR5cGVzY3JpcHQnO1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5cbmltcG9ydCB7IG9ubnhydW50aW1lIH0gZnJvbSAnLi9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHsgb25ueCB9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7IGRlY29kZVV0ZjhTdHJpbmcsIFByb3RvVXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi91dGlsJztcblxuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUZW5zb3Ige1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheTtcbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgdWludDE2OiBVaW50MTZBcnJheTtcbiAgICBpbnQzMjogSW50MzJBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcblxuICBleHBvcnQgdHlwZSBTdHJpbmdUeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXTtcbiAgZXhwb3J0IHR5cGUgQm9vbGVhblR5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Jvb2wnXTtcbiAgZXhwb3J0IHR5cGUgSW50ZWdlclR5cGUgPVxuICAgIHwgVGVuc29yLkRhdGFUeXBlTWFwWydpbnQ4J11cbiAgICB8IFRlbnNvci5EYXRhVHlwZU1hcFsndWludDgnXVxuICAgIHwgVGVuc29yLkRhdGFUeXBlTWFwWydpbnQxNiddXG4gICAgfCBUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQxNiddXG4gICAgfCBUZW5zb3IuRGF0YVR5cGVNYXBbJ2ludDMyJ11cbiAgICB8IFRlbnNvci5EYXRhVHlwZU1hcFsndWludDMyJ107XG4gIGV4cG9ydCB0eXBlIEZsb2F0VHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnZmxvYXQzMiddIHwgVGVuc29yLkRhdGFUeXBlTWFwWydmbG9hdDY0J107XG4gIGV4cG9ydCB0eXBlIE51bWJlclR5cGUgPSBCb29sZWFuVHlwZSB8IEludGVnZXJUeXBlIHwgRmxvYXRUeXBlO1xuXG4gIGV4cG9ydCB0eXBlIElkID0gR3VpZDtcbn1cblxudHlwZSBUZW5zb3JEYXRhID0gVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV07XG5cbnR5cGUgRGF0YVByb3ZpZGVyID0gKGlkOiBUZW5zb3IuSWQpID0+IFRlbnNvckRhdGE7XG50eXBlIEFzeW5jRGF0YVByb3ZpZGVyID0gKGlkOiBUZW5zb3IuSWQpID0+IFByb21pc2U8VGVuc29yRGF0YT47XG5cbmV4cG9ydCBjbGFzcyBUZW5zb3Ige1xuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHRlbnNvciBkYXRhXG4gICAqL1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhIHtcbiAgICBpZiAodGhpcy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhUHJvdmlkZXIhKHRoaXMuZGF0YUlkKTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIG9mIGRhdGEgcHJvdmlkZWQgYnkgdGhlIERhdGEgUHJvdmlkZXIgaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIGRpbXMgb2YgdGhpcyBUZW5zb3IuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBTVFJJTkdcbiAgICovXG4gIGdldCBzdHJpbmdEYXRhKCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIHR5cGUgaXMgbm90IHN0cmluZycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLlN0cmluZ1R5cGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIGludGVnZXIgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6IChVSU5UOCwgSU5UOCwgVUlOVDE2LFxuICAgKiBJTlQxNiwgSU5UMzIsIFVJTlQzMiwgQk9PTClcbiAgICovXG4gIGdldCBpbnRlZ2VyRGF0YSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5JbnRlZ2VyVHlwZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIGZsb2F0IHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAoRkxPQVQsIERPVUJMRSlcbiAgICovXG4gIGdldCBmbG9hdERhdGEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLkZsb2F0VHlwZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIG51bWJlciB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzogKFVJTlQ4LCBJTlQ4LCBVSU5UMTYsXG4gICAqIElOVDE2LCBJTlQzMiwgVUlOVDMyLCBCT09MLCBGTE9BVCwgRE9VQkxFKVxuICAgKi9cbiAgZ2V0IG51bWJlckRhdGEoKSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLk51bWJlclR5cGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R5cGUgY2Fubm90IGJlIG5vbi1udW1iZXIgKHN0cmluZyknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdmFsdWUgb2YgYW4gZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kaWNlc1xuICAgKi9cbiAgZ2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV1bbnVtYmVyXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXMsIHRoaXMuc3RyaWRlcyldO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB2YWx1ZSBvZiBhbiBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRpY2VzXG4gICAqL1xuICBzZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIHZhbHVlOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXVtudW1iZXJdKSB7XG4gICAgdGhpcy5kYXRhW1NoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoaW5kaWNlcywgdGhpcy5zdHJpZGVzKV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgdGVuc29yIGRhdGEgYXN5bmNocm9ub3VzbHlcbiAgICovXG4gIGFzeW5jIGdldERhdGEoKTogUHJvbWlzZTxUZW5zb3JEYXRhPiB7XG4gICAgaWYgKHRoaXMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jYWNoZSA9IGF3YWl0IHRoaXMuYXN5bmNEYXRhUHJvdmlkZXIhKHRoaXMuZGF0YUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRlbnNvclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcblxuICBwcml2YXRlIF9zdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIGdldCB0aGUgc3RyaWRlcyBmb3IgZWFjaCBkaW1lbnNpb25cbiAgICovXG4gIGdldCBzdHJpZGVzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAoIXRoaXMuX3N0cmlkZXMpIHtcbiAgICAgIHRoaXMuX3N0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlkZXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvclxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHR5cGUgb2YgdGhlIHRlbnNvclxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBUZW5zb3IuRGF0YVR5cGUsXG4gICAgcHJpdmF0ZSBkYXRhUHJvdmlkZXI/OiBEYXRhUHJvdmlkZXIsXG4gICAgcHJpdmF0ZSBhc3luY0RhdGFQcm92aWRlcj86IEFzeW5jRGF0YVByb3ZpZGVyLFxuICAgIHByaXZhdGUgY2FjaGU/OiBUZW5zb3JEYXRhLFxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgZGF0YSBJRCB0aGF0IHVzZWQgdG8gbWFwIHRvIGEgdGVuc29yIGRhdGFcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZGF0YUlkOiBHdWlkID0gR3VpZC5jcmVhdGUoKSxcbiAgKSB7XG4gICAgdGhpcy5zaXplID0gU2hhcGVVdGlsLnZhbGlkYXRlRGltc0FuZENhbGNTaXplKGRpbXMpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgZW1wdHkgPSBkYXRhUHJvdmlkZXIgPT09IHVuZGVmaW5lZCAmJiBhc3luY0RhdGFQcm92aWRlciA9PT0gdW5kZWZpbmVkICYmIGNhY2hlID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNhY2hlLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklucHV0IGRpbXMgZG9lc24ndCBtYXRjaCBkYXRhIGxlbmd0aC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAoIUFycmF5LmlzQXJyYXkoY2FjaGUpIHx8ICFjYWNoZS5ldmVyeSgoaSkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IEFycmF5PHN0cmluZz4oc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgaWYgKCEoY2FjaGUgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZSBzaG91bGQgYmUgdHlwZSAke2NvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzaXplICogc2l6ZW9mKHR5cGUpKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNyZWF0ZVZpZXcoYnVmLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW5zb3IgZnJvbSBhIE9OTlggVGVuc29yIG9iamVjdFxuICAgKiBAcGFyYW0gdGVuc29yUHJvdG8gdGhlIE9OTlggVGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbVByb3RvKHRlbnNvclByb3RvOiBvbm54LklUZW5zb3JQcm90byk6IFRlbnNvciB7XG4gICAgaWYgKCF0ZW5zb3JQcm90bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odGVuc29yUHJvdG8uZGF0YVR5cGUhKTtcbiAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odGVuc29yUHJvdG8uZGltcyEpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICB0ZW5zb3JQcm90by5zdHJpbmdEYXRhIS5mb3JFYWNoKChzdHIsIGkpID0+IHtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IGRlY29kZVV0ZjhTdHJpbmcoc3RyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0ZW5zb3JQcm90by5yYXdEYXRhICYmXG4gICAgICB0eXBlb2YgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgIHRlbnNvclByb3RvLnJhd0RhdGEuYnVmZmVyLFxuICAgICAgICB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVPZmZzZXQsXG4gICAgICAgIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemVvZlByb3RvKHRlbnNvclByb3RvLmRhdGFUeXBlISk7XG4gICAgICBjb25zdCBsZW5ndGggPSB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggLyBlbGVtZW50U2l6ZTtcblxuICAgICAgaWYgKHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCAlIGVsZW1lbnRTaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBidWZmZXIgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YURlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IHJlYWRQcm90byhkYXRhU291cmNlLCB0ZW5zb3JQcm90by5kYXRhVHlwZSEsIGkgKiBlbGVtZW50U2l6ZSk7XG4gICAgICAgIGRhdGFEZXN0W2ldID0gbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9wdWxhdGUgdmFsdWUgZnJvbSBhcnJheVxuICAgICAgbGV0IGFycmF5OiBBcnJheTxudW1iZXIgfCBMb25nPjtcbiAgICAgIHN3aXRjaCAodGVuc29yUHJvdG8uZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uZmxvYXREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uaW50MzJEYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uaW50NjREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmRvdWJsZURhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8udWludDY0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biBoZXJlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNwZWNpZmljIGVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJheSA9PT0gbnVsbCB8fCBhcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBvcHVsYXRlIGRhdGEgZnJvbSBhIHRlbnNvcnByb3RvIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5kYXRhO1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhlbGVtZW50KSkge1xuICAgICAgICAgIGRhdGFbaV0gPSBsb25nVG9OdW1iZXIoZWxlbWVudCwgdGVuc29yUHJvdG8uZGF0YVR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbaV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBuZXcgVGVuc29yIGZyb20gcmF3IGRhdGFcbiAgICogQHBhcmFtIGRhdGEgdGhlIHJhdyBkYXRhIG9iamVjdC4gU2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5IGZvciAnc3RyaW5nJyB0ZW5zb3IsIGFuZCB0aGUgY29ycmVzcG9uZGluZyB0eXBlZCBhcnJheVxuICAgKiBmb3Igb3RoZXIgdHlwZXMgb2YgdGVuc29yLlxuICAgKiBAcGFyYW0gZGltcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0YShkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXSwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHR5cGU6IFRlbnNvci5EYXRhVHlwZSkge1xuICAgIHJldHVybiBuZXcgVGVuc29yKGRpbXMsIHR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT3J0VGVuc29yKG9ydFRlbnNvcjogb3J0RmJzLlRlbnNvcikge1xuICAgIGlmICghb3J0VGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3InKTtcbiAgICB9XG4gICAgY29uc3QgZGltcyA9IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChvcnRUZW5zb3IpO1xuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8ob3J0VGVuc29yLmRhdGFUeXBlKCkpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ydFRlbnNvci5zdHJpbmdEYXRhTGVuZ3RoKCk7IGkrKykge1xuICAgICAgICB2YWx1ZS5kYXRhW2ldID0gb3J0VGVuc29yLnN0cmluZ0RhdGEoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSAmJlxuICAgICAgdHlwZW9mIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgPT09ICdudW1iZXInICYmXG4gICAgICBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpID4gMFxuICAgICkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSEuYnVmZmVyLFxuICAgICAgICBvcnRUZW5zb3IucmF3RGF0YUFycmF5KCkhLmJ5dGVPZmZzZXQsXG4gICAgICAgIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCksXG4gICAgICApO1xuICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBzaXplb2ZQcm90byhvcnRUZW5zb3IuZGF0YVR5cGUoKSk7XG4gICAgICBjb25zdCBsZW5ndGggPSBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpIC8gZWxlbWVudFNpemU7XG5cbiAgICAgIGlmIChvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpICUgZWxlbWVudFNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhRGVzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gcmVhZFByb3RvKGRhdGFTb3VyY2UsIG9ydFRlbnNvci5kYXRhVHlwZSgpLCBpICogZWxlbWVudFNpemUpO1xuICAgICAgICBkYXRhRGVzdFtpXSA9IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplb2YodHlwZTogVGVuc29yLkRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgY2FzZSAnaW50OCc6XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgY2FzZSAndWludDMyJzpcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7dHlwZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplb2ZQcm90byh0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHwgb3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlXX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWaWV3KGRhdGFCdWZmZXI6IEFycmF5QnVmZmVyLCB0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgcmV0dXJuIG5ldyAoZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGRhdGF2aWV3Q29uc3RydWN0b3IodHlwZTogVGVuc29yLkRhdGFUeXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biB0byBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlY2lmaWVkIGVycm9yJyk7XG4gIH1cbn1cblxuLy8gY29udmVydCBhIGxvbmcgbnVtYmVyIHRvIGEgMzItYml0IGludGVnZXIgKGNhc3QtZG93bilcbmZ1bmN0aW9uIGxvbmdUb051bWJlcihpOiBMb25nLCB0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHwgb3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgLy8gSU5UNjQsIFVJTlQzMiwgVUlOVDY0XG4gIGlmICh0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0IHx8IHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5JTlQ2NCkge1xuICAgIGlmIChpLmdyZWF0ZXJUaGFuT3JFcXVhbCgyMTQ3NDgzNjQ4KSB8fCBpLmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW50NjQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMiB8fFxuICAgIHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5VSU5UMzIgfHxcbiAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NCB8fFxuICAgIHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5VSU5UNjRcbiAgKSB7XG4gICAgaWYgKGkuZ3JlYXRlclRoYW5PckVxdWFsKDQyOTQ5NjcyOTYpIHx8IGkubGVzc1RoYW4oMCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG5vdCBhIExPTkcgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG5cbiAgcmV0dXJuIGkudG9OdW1iZXIoKTtcbn1cblxuLy8gcmVhZCBvbmUgdmFsdWUgZnJvbSBUZW5zb3JQcm90b1xuZnVuY3Rpb24gcmVhZFByb3RvKFxuICB2aWV3OiBEYXRhVmlldyxcbiAgdHlwZTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSB8IG9ydEZicy5UZW5zb3JEYXRhVHlwZSxcbiAgYnl0ZU9mZnNldDogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQ4KGJ5dGVPZmZzZXQpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICByZXR1cm4gdmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgIHJldHVybiBsb25nVG9OdW1iZXIoXG4gICAgICAgIExvbmcuZnJvbUJpdHModmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSksIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCB0cnVlKSwgZmFsc2UpLFxuICAgICAgICB0eXBlLFxuICAgICAgKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIGxvbmdUb051bWJlcihcbiAgICAgICAgTG9uZy5mcm9tQml0cyh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKSwgdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIHRydWUpLCB0cnVlKSxcbiAgICAgICAgdHlwZSxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlYWQgZnJvbSBEYXRhVmlldyBmb3IgdHlwZSAke29ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdHlwZV19YCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiByZXByZXNlbnQgYSB2ZXJzaW9uIGlycmVsZXZhbnQgYWJzdHJhY3Rpb24gb2YgZm9yIEdMU0wgc291cmNlIGNvZGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHbHNsIHtcbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBhdHRyaWJ1dGU6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFyeWluZ1ZlcnRleDogc3RyaW5nO1xuICByZWFkb25seSB2YXJ5aW5nRnJhZzogc3RyaW5nO1xuICByZWFkb25seSB0ZXh0dXJlMkQ6IHN0cmluZztcbiAgcmVhZG9ubHkgb3V0cHV0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dHB1dERlY2xhcmF0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEdMU0xfRVNfMl8wOiBHbHNsID0ge1xuICB2ZXJzaW9uOiAnJyxcbiAgYXR0cmlidXRlOiAnYXR0cmlidXRlJyxcbiAgdmFyeWluZ1ZlcnRleDogJ3ZhcnlpbmcnLFxuICB2YXJ5aW5nRnJhZzogJ3ZhcnlpbmcnLFxuICB0ZXh0dXJlMkQ6ICd0ZXh0dXJlMkQnLFxuICBvdXRwdXQ6ICdnbF9GcmFnQ29sb3InLFxuICBvdXRwdXREZWNsYXJhdGlvbjogJycsXG59O1xuY29uc3QgR0xTTF9FU18zXzA6IEdsc2wgPSB7XG4gIHZlcnNpb246ICcjdmVyc2lvbiAzMDAgZXMnLFxuICBhdHRyaWJ1dGU6ICdpbicsXG4gIHZhcnlpbmdWZXJ0ZXg6ICdvdXQnLFxuICB2YXJ5aW5nRnJhZzogJ2luJyxcbiAgdGV4dHVyZTJEOiAndGV4dHVyZScsXG4gIG91dHB1dDogJ291dHB1dENvbG9yJyxcbiAgb3V0cHV0RGVjbGFyYXRpb246ICdvdXQgdmVjNCBvdXRwdXRDb2xvcjsnLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsc2wodmVyc2lvbjogMSB8IDIpIHtcbiAgcmV0dXJuIHZlcnNpb24gPT09IDEgPyBHTFNMX0VTXzJfMCA6IEdMU0xfRVNfM18wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGV4U2hhZGVyU291cmNlKHZlcnNpb246IDEgfCAyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAke2dsc2wuYXR0cmlidXRlfSB2ZWMzIHBvc2l0aW9uO1xuICAgICAgJHtnbHNsLmF0dHJpYnV0ZX0gdmVjMiB0ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICR7Z2xzbC52YXJ5aW5nVmVydGV4fSB2ZWMyIFRleENvb3JkcztcblxuICAgICAgdm9pZCBtYWluKClcbiAgICAgIHtcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xuICAgICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnU2hhZGVyUHJlYW1ibGUodmVyc2lvbjogMSB8IDIpOiBzdHJpbmcge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbCh2ZXJzaW9uKTtcbiAgcmV0dXJuIGAke2dsc2wudmVyc2lvbn1cbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICR7Z2xzbC52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XG4gICAgJHtnbHNsLm91dHB1dERlY2xhcmF0aW9ufVxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICAvLyBDdXN0b20gdmVjdG9yIHR5cGVzIHRvIGhhbmRsZSBoaWdoZXIgZGltZW5hbGl0aWVzLlxuICAgIHN0cnVjdCBpdmVjNVxuICAgIHtcbiAgICAgIGludCB4O1xuICAgICAgaW50IHk7XG4gICAgICBpbnQgejtcbiAgICAgIGludCB3O1xuICAgICAgaW50IHU7XG4gICAgfTtcblxuICAgIHN0cnVjdCBpdmVjNlxuICAgIHtcbiAgICAgIGludCB4O1xuICAgICAgaW50IHk7XG4gICAgICBpbnQgejtcbiAgICAgIGludCB3O1xuICAgICAgaW50IHU7XG4gICAgICBpbnQgdjtcbiAgICB9O1xuXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xuICAgIH1cblxuICAgIGA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RnJhZ1NoYWRlck1haW4odmVyc2lvbjogMSB8IDIsIG91dHB1dFNoYXBlTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbCh2ZXJzaW9uKTtcbiAgcmV0dXJuIGBcbiAgdm9pZCBtYWluKCkge1xuICAgIGludCBpbmRpY2VzWyR7b3V0cHV0U2hhcGVMZW5ndGh9XTtcbiAgICB0b1ZlYyhUZXhDb29yZHMsIGluZGljZXMpO1xuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcbiAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgfVxuICBgO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG4vKipcbiAqIExheW91dCBpbmZvIGlzIHVzZWQgZm9yIG1hcHBpbmcgbi1kaW1lbnNpb25hbCBhcnJheSB0byAyRCB0ZXh0dXJlc1xuICogVGhlIGxheW91dCBpcyBjcmVhdGVkIGJ5IHRoZSBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kgYmFzZWQgb25cbiAqIHRoZSBUZW5zb3IncyBkaW1lbnNpb25zIGFuZCBzdHJpZGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dCB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHZhbHVlIHRoYXQgZW5jb2RlZCBpbiBhIHNpbmdsZSBwaXhlbFxuICAgKi9cbiAgY2hhbm5lbHM6IDEgfCAyIHwgMyB8IDQ7XG4gIC8qKlxuICAgKiB3aGV0aGVyIGluIHBhY2tlZCBtb2RlIG9yIG5vdFxuICAgKi9cbiAgaXNQYWNrZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogdGhlIG5vcm1hbGl6ZWQgc2hhcGVcbiAgICovXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIHRoZSBzdHJpZGUgb2YgZWFjaCBkaW1lbnNpb25zLCBjYWxjdWxhdGVkIGFjY29yZGluZyB0byBzaGFwZVxuICAgKi9cbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiB0aGUgb3JpZ2luYWwgc2hhcGUoZGltcykgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdGVuc29yXG4gICAqL1xuICB1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcblxuICByZXZlcnNlZFdIPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZURhdGEgZXh0ZW5kcyBUZXh0dXJlTGF5b3V0IHtcbiAgdGVuc29yOiBUZW5zb3I7XG4gIHRleHR1cmU6IFdlYkdMVGV4dHVyZTtcbn1cblxuZXhwb3J0IGVudW0gVGV4dHVyZVR5cGUge1xuICB1bnBhY2tlZCwgLy8gPC0tIG5vcm1hbCB1bnBhY2tlZCB0ZXh0dXJlXG4gIHVucGFja2VkUmV2ZXJzZWQsIC8vIDwtLSB1bnBhY2tlZCB0ZXh0dXJlIHVzZWQgaW4gb2xkIE9OTlguanMgaW1wbGVtZW50YXRpb24gKGRlcHJlY2F0ZWQpXG4gIHBhY2tlZCwgLy8gPC0tIG5vcm1hbCBwYWNrZWQgdGV4dHVyZVxuICBkb3dubG9hZFVpbnQ4QXNGbG9hdCwgLy8gPC0tIE9OTFkgdXNlZCBpbiB0ZXh0dXJlIGRvd25sb2FkaW5nIGZvciBpT1MgZGV2aWNlc1xuICBwYWNrZWRMYXN0RGltZW5zaW9uLCAvLyA8LS0gT05MWSB1c2VkIGluIG9sZCBPTk5YLmpzIENvbnYgaW1wbGVtZW50YXRpb24gZm9yIGlucHV0IFcgKGRlcHJlY2F0ZWQpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGlkPzogVGVuc29yLklkO1xuICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgdHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVZhcmlhYmxlIHtcbiAgdHlwZTogJ2Zsb2F0JyB8ICdpbnQnO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFycmF5TGVuZ3RoPzogbnVtYmVyO1xuICBkYXRhOiBudW1iZXIgfCBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBBIHNldCBvZiBtZXRhZGF0YSBvZiBhIHNoYWRlciBwcm9ncmFtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1NZXRhZGF0YSB7XG4gIC8qKlxuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvZ3JhbS4gdXNlZCBmb3IgZGVidWdnaW5nIGFuZCBwcm9maWxpbmdcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIHRleHR1cmUgdHlwZXMgZm9yIGVhY2ggaW5wdXRcbiAgICovXG4gIGlucHV0VHlwZXM6IFRleHR1cmVUeXBlW107XG4gIC8qKlxuICAgKiBuYW1lcyBvZiBlYWNoIGlucHV0XG4gICAqL1xuICBpbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIGFydGlmYWN0IGNhY2hlXG4gICAqL1xuICBjYWNoZUhpbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBQcm9ncmFtSW5mb0xvYWRlciBhbGxvd3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mb0xvYWRlciBleHRlbmRzIFByb2dyYW1NZXRhZGF0YSB7XG4gIC8qKlxuICAgKiBhIGZ1bmN0aW9uIHRvIGdldCB0aGUgcHJvZ3JhbSBpbmZvXG4gICAqL1xuICBnZXQoKTogUHJvZ3JhbUluZm87XG59XG5cbi8qKlxuICogQSBzZXQgb2YgZGF0YSB0aGF0IHJlcHJlc2VudCBhIHNoYWRlciBwcm9ncmFtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbUluZm8gZXh0ZW5kcyBQcm9ncmFtTWV0YWRhdGEge1xuICAvKipcbiAgICogaW5mb3JtYXRpb24gb2YgdW5pZm9ybSB2YXJpYWJsZXNcbiAgICovXG4gIHZhcmlhYmxlcz86IFByb2dyYW1WYXJpYWJsZVtdO1xuICAvKipcbiAgICogdGVuc29yIGluZm8gZm9yIG91dHB1dFxuICAgKi9cbiAgb3V0cHV0OiBUZW5zb3JJbmZvO1xuICAvKipcbiAgICogdGhlIHNoYWRlcidzIHByb2Nlc3Npbmcgc291cmNlIGNvZGVcbiAgICovXG4gIHNoYWRlclNvdXJjZTogc3RyaW5nO1xuICAvKipcbiAgICogd2hldGhlciB0aGUgc2hhZGVyIHNvdXJjZSBjb250YWlucyBhIGN1c3RvbWl6ZWQgbWFpbiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgaGFzTWFpbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGVJbmZvIHtcbiAgdHlwZTogJ2Zsb2F0JyB8ICdpbnQnO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFycmF5TGVuZ3RoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1WYXJpYWJsZSB7XG4gIHR5cGU6ICdmbG9hdCcgfCAnaW50JztcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbiAgZGF0YTogbnVtYmVyIHwgbnVtYmVyW107XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gb2YgdW5pZm9ybXMgdGhhdCBzaGFkZXIgdXNlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFVuaWZvcm1JbmZvIHtcbiAgdHlwZTogJ3NhbXBsZXIyRCcgfCBWYXJpYWJsZUluZm9bJ3R5cGUnXTtcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmlmb3JtTG9jYXRpb24gZXh0ZW5kcyBVbmlmb3JtSW5mbyB7XG4gIGxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBBcnRpZmFjdCBpcyB0aGUgcmVzdWx0IG9mIGNvbXBpbGF0aW9uXG4gKiBJdCBkb2VzIG5vdCBjb250YWluIGlucHV0IG9mIG91dHB1dCBkYXRhXG4gKiBIb3dldmVyIGFueXRoaW5nIHRoYXQgY291bGQgYmUgcnVuIGFzIGEgXCJwcm9ncmFtXCJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdCB7XG4gIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbztcbiAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICB1bmlmb3JtTG9jYXRpb25zOiBVbmlmb3JtTG9jYXRpb25bXTtcbiAgYXR0cmliTG9jYXRpb25zOiB7IHBvc2l0aW9uOiBudW1iZXI7IHRleHR1cmVDb29yZDogbnVtYmVyIH07XG59XG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQXJ0aWZhY3Qge1xuICB0eXBlIFVuaWZvcm1Mb2NhdGlvbnMgPSBBcnRpZmFjdFsndW5pZm9ybUxvY2F0aW9ucyddO1xuICB0eXBlIEF0dHJpYkxvY2F0aW9ucyA9IEFydGlmYWN0WydhdHRyaWJMb2NhdGlvbnMnXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmlmb3JtRGF0YSB7XG4gIFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfCBudW1iZXJbXTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vLi4vdXRpbCc7XG4vKipcbiAqIEdpdmVuIGEgbm9uIFJHQkEgc2hhcGUgY2FsY3VsYXRlIHRoZSBSIHZlcnNpb25cbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZGltZW5zaW9ucyBhcmUgbXVsdGlwbGVzIG9mIGdpdmVuIGNoYW5uZWxzXG4gKiBOT1RFOiBpdCBpcyBhbHdheXMgdGhlIGxhc3QgZGltIHRoYXQgZ2V0cyBwYWNrZWQuXG4gKiBAcGFyYW0gdW5wYWNrZWRTaGFwZSBvcmlnaW5hbCBzaGFwZSB0byBjcmVhdGUgYSBwYWNrZWQgdmVyc2lvbiBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrZWRTaGFwZSh1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgY29uc3QgbGVuID0gdW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gIHJldHVybiB1bnBhY2tlZFNoYXBlLnNsaWNlKDAsIGxlbiAtIDEpLmNvbmNhdCh1bnBhY2tlZFNoYXBlW2xlbiAtIDFdIC8gNCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXBlYXRlZFRyeShcbiAgY2hlY2tGbjogKCkgPT4gYm9vbGVhbixcbiAgZGVsYXlGbiA9IChfY291bnRlcjogbnVtYmVyKSA9PiAwLFxuICBtYXhDb3VudGVyPzogbnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHRyeUNvdW50ID0gMDtcblxuICAgIGNvbnN0IHRyeUZuID0gKCkgPT4ge1xuICAgICAgaWYgKGNoZWNrRm4oKSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5Q291bnQrKztcblxuICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBkZWxheUZuKHRyeUNvdW50KTtcblxuICAgICAgaWYgKG1heENvdW50ZXIgIT0gbnVsbCAmJiB0cnlDb3VudCA+PSBtYXhDb3VudGVyKSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KHRyeUZuLCBuZXh0QmFja29mZik7XG4gICAgfTtcblxuICAgIHRyeUZuKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGFuIGlucHV0IHNhbXBsZXIgbmFtZS5cbiAqIEBwYXJhbSBzYW1wbGVyTmFtZSBOYW1lIG9mIHRoZSBzYW1wbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQodHlwZW9mIHNhbXBsZXJOYW1lICE9PSAndW5kZWZpbmVkJyAmJiBzYW1wbGVyTmFtZS5sZW5ndGggIT09IDAsICgpID0+ICdlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZScpO1xuICByZXR1cm4gJ2dldCcgKyBzYW1wbGVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNhbXBsZXJOYW1lLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGFuIGlucHV0IHNhbXBsZXIgbmFtZSBhdCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0gc2FtcGxlck5hbWUgTmFtZSBvZiB0aGUgc2FtcGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKHNhbXBsZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQodHlwZW9mIHNhbXBsZXJOYW1lICE9PSAndW5kZWZpbmVkJyAmJiBzYW1wbGVyTmFtZS5sZW5ndGggIT09IDAsICgpID0+ICdlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZScpO1xuICByZXR1cm4gJ2dldCcgKyBzYW1wbGVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNhbXBsZXJOYW1lLnNsaWNlKDEpICsgJ0F0T3V0Q29vcmRzJztcbn1cblxuLyoqIFJldHVybnMgYSBuZXcgaW5wdXQgc2hhcGUgKGEgY29weSkgdGhhdCBoYXMgYSBzcXVlZXplZCBsb2dpY2FsIHNoYXBlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWVlemVJbnB1dFNoYXBlKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzcXVlZXplZFNoYXBlOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgLy8gRGVlcCBjb3B5LlxuICBsZXQgbmV3SW5wdXRTaGFwZTogbnVtYmVyW10gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpKTtcbiAgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVkU2hhcGU7XG4gIHJldHVybiBuZXdJbnB1dFNoYXBlO1xufVxuXG4vKiogUmV0dXJucyBhIGxpc3Qgb2Ygc3F1ZWV6ZWQgcGFyYW1ldGVycyBmb3Igc2hhZGVyIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtczogc3RyaW5nW10sIGtlcHREaW1zOiBudW1iZXJbXSk6IHN0cmluZyB7XG4gIHJldHVybiBrZXB0RGltcy5tYXAoKGQpID0+IHBhcmFtc1tkXSkuam9pbignLCAnKTtcbn1cblxuLyoqIFJldHVybnMgdGhlIGRhdGEgdHlwZSBmb3IgZGlmZmVyZW50IHJhbmtzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gJ2ludCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiAnaXZlYzInO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICByZXR1cm4gJ2l2ZWMzJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgcmV0dXJuICdpdmVjNCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNSkge1xuICAgIHJldHVybiAnaXZlYzUnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDYpIHtcbiAgICByZXR1cm4gJ2l2ZWM2JztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xDaGFubmVscyhyYW5rID0gNik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZ2V0R2xDaGFubmVscyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZlY0NoYW5uZWxzKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyKTogc3RyaW5nW10ge1xuICByZXR1cm4gZ2V0R2xDaGFubmVscyhyYW5rKS5tYXAoKGQpID0+IGAke25hbWV9LiR7ZH1gKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5uZWxzKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyKTogc3RyaW5nW10ge1xuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIGdldFZlY0NoYW5uZWxzKG5hbWUsIHJhbmspO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrRnJvbUNoYW5uZWwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xuICAgICAgcmV0dXJuIG1vZENvb3JkID09IDAgPyBmcmFnLnIgOiBmcmFnLmc7XG4gICAgfVxuXG4gICAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XG4gICAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XG4gICAgfVxuICBgO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgZ2V0Q2hhbm5lbHMgfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCBwYWNrUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAncGFjaycsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZF0sXG59O1xuXG5jb25zdCBjcmVhdGVQYWNrUHJvZ3JhbUluZm8gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAvLyBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlIHdvbid0IGNoYW5nZSBvdXRwdXQgcmFuay4gTmVlZCB0byB2ZXJpZnkgYnkgcnVubmluZyB0ZXN0c1xuICBjb25zdCBvdXRwdXRSYW5rID0gaW5wdXQuZGltcy5sZW5ndGg7XG5cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRSYW5rKTtcbiAgY29uc3QgY2hhbm5lbHMgPSBnZXRDaGFubmVscygncmMnLCBvdXRwdXRSYW5rKTtcbiAgY29uc3Qgc2V0dXAgPSBnZXRTZXR1cChvdXRwdXRSYW5rLCBjaGFubmVscywgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDJdLCBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV0pO1xuXG4gIGxldCByZXZlcnNlZElucHV0V0g7XG4gIGlmIChpbnB1dFJhbmsgPT09IDApIHtcbiAgICByZXZlcnNlZElucHV0V0ggPSBbMSwgMV07XG4gIH0gZWxzZSBpZiAoaW5wdXRSYW5rID09PSAxKSB7XG4gICAgcmV2ZXJzZWRJbnB1dFdIID0gW2lucHV0U2hhcGVbMF0sIDFdO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2VkSW5wdXRXSCA9IFtpbnB1dFNoYXBlW291dHB1dFJhbmsgLSAxXSwgaW5wdXRTaGFwZVtvdXRwdXRSYW5rIC0gMl1dO1xuICB9XG4gIGNvbnN0IG91dE9mQm91bmRzQ29uZGl0aW9uID0gZ2V0T3V0T2ZCb3VuZHNDb25kaXRpb24ob3V0cHV0UmFuaywgcmV2ZXJzZWRJbnB1dFdILCBjaGFubmVscyk7XG4gIGNvbnN0IG91dHB1dCA9IGdldE91dHB1dChpbnB1dFNoYXBlLCBjaGFubmVscyk7XG5cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtjb29yZHNEYXRhVHlwZX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICAgIGlmKCR7b3V0T2ZCb3VuZHNDb25kaXRpb259KSB7XG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQoMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7c2V0dXB9XG5cbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCgke291dHB1dH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYWNrUHJvZ3JhbU1ldGFkYXRhLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgb3V0cHV0OiB7IGRpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvTG9hZGVyID0+ICh7XG4gIC4uLnBhY2tQcm9ncmFtTWV0YWRhdGEsXG4gIGdldDogKCkgPT4gY3JlYXRlUGFja1Byb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0KSxcbn0pO1xuXG4vKipcbiAqIGNoZWNrIG91dHB1dCBjb29yZGluYXRlIGxvY2F0aW9uIGFuZCByZXR1cm4gZmFsc2UgaWYgaXQgaXMgb3V0c2lkZSBpbnB1dCdzIHdpZHRoL2hlaWdodCBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBnZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihyYW5rOiBudW1iZXIsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZGltczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMCkge1xuICAgIHJldHVybiAnZmFsc2UnO1xuICB9XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGByYyA+ICR7c2hhcGVbMF19YDtcbiAgfVxuXG4gIGxldCBjb25kID0gJyc7XG4gIGZvciAobGV0IGkgPSByYW5rIC0gMjsgaSA8IHJhbms7IGkrKykge1xuICAgIGNvbmQgKz0gYCR7ZGltc1tpXX0gPj0gJHtzaGFwZVtpIC0gcmFuayArIDJdfWA7XG4gICAgaWYgKGkgPCByYW5rIC0gMSkge1xuICAgICAgY29uZCArPSAnfHwnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25kO1xufVxuXG4vKipcbiAqIGNvZGUgc25pcHBldCB0byBzYW1wbGUgaW5wdXQgdGV4dHVyZSB3aXRoIG91dHB1dCBjb29yZGluYXRlc1xuICovXG5mdW5jdGlvbiBnZXRPdXRwdXQoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgaWYgKHJhbmsgPT09IDApIHtcbiAgICByZXR1cm4gJ2dldEEoKSwgMCwgMCwgMCc7XG4gIH1cblxuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBgZ2V0QShyYyksXG4gICAgICAgICAgICByYyArIDEgPj0gJHtzaGFwZVswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcbiAgICAgICAgICAgIDAsIDBgO1xuICB9XG5cbiAgY29uc3QgY29vcmQwMCA9ICdyLCBjJztcbiAgY29uc3QgY29vcmQwMSA9ICdyLCBjcDEnO1xuICBjb25zdCBjb29yZDEwID0gJ3JwMSwgYyc7XG4gIGNvbnN0IGNvb3JkMTEgPSAncnAxLCBjcDEnO1xuICBsZXQgRCA9ICcnO1xuICBpZiAocmFuayA+IDIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAyOyArK2kpIHtcbiAgICAgIEQgPSBEICsgYCR7ZGltc1tpXX0sYDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBnZXRBKCR7RH0ke2Nvb3JkMDB9KSxcbiAgICAgICAgICByRWRnZSA/IDAuIDogZ2V0QSgke0R9JHtjb29yZDEwfSksXG4gICAgICAgICAgY0VkZ2UgPyAwLiA6IGdldEEoJHtEfSR7Y29vcmQwMX0pLFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKCR7RH0ke2Nvb3JkMTF9KWA7XG59XG5cbi8qKlxuICogY29kZSBzbmlwcGV0IHRvIHNldHVwIDQgY29vcmRpbmF0ZXMgYW5kIGVkZ2UgY29uZGl0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRTZXR1cChyYW5rOiBudW1iZXIsIGRpbXM6IHN0cmluZ1tdLCByb3dzOiBudW1iZXIsIGNvbHM6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAwIHx8IHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLy8gcmFuayA+PSAyIGZvciB3aWR0aCtoZWlnaHQgcGFjay5cbiAgZWxzZSB7XG4gICAgY29uc3Qgc2V0dXAgPSBgXG4gICAgaW50IHIgPSAke2RpbXNbcmFuayAtIDJdfTtcbiAgICBpbnQgYyA9ICR7ZGltc1tyYW5rIC0gMV19O1xuICAgIGludCBycDEgPSAke2RpbXNbcmFuayAtIDJdfSArIDE7XG4gICAgaW50IGNwMSA9ICR7ZGltc1tyYW5rIC0gMV19ICsgMTtcbiAgICBib29sIHJFZGdlID0gcnAxID49ICR7Y29sc307XG4gICAgYm9vbCBjRWRnZSA9IGNwMSA+PSAke3Jvd3N9O1xuICAgIGA7XG4gICAgcmV0dXJuIHNldHVwO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IHVucGFja0Zyb21DaGFubmVsIH0gZnJvbSAnLi9wYWNraW5nLXV0aWxzJztcblxuY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbU1ldGFkYXRhID0gKG91dHB1dFNoYXBlM0Q6IHJlYWRvbmx5IG51bWJlcltdKSA9PiAoe1xuICBuYW1lOiAnUmVzaGFwZSAocGFja2VkKScsXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgY2FjaGVIaW50OiBgJHtvdXRwdXRTaGFwZTNEfWAsXG59KTtcblxuY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm8gPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQzRDogVGVuc29yLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBvdXRwdXRTaGFwZTNEOiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZTNEID0gaW5wdXQzRC5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlM0QgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gIGxldCBtYWluTG9vcCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGxldCBvdXRwdXRDb29yZHMgPSAnJztcbiAgICBzd2l0Y2ggKGkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IHJjOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KTsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnksIHJjLnorMSk7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnorMSk7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICR7b3V0cHV0Q29vcmRzfVxuICAgICAgICAke2kgPiAwID8gJ2lmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpeycgOiAnJ31cbiAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSBnZXRGbGF0dGVuZWRJbmRleChvdXRwdXRDb29yZHMpO1xuXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcblxuICAgICAgICAgIHJlc3VsdFske2l9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcblxuICAgICAgICAke2kgPiAwID8gJ30nIDogJyd9XG4gICAgICBgO1xuICB9XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcblxuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldFJlc2hhcGVkSW5wdXRDb29yZHMoaW5wdXRTaGFwZTNEKX1cbiAgICAgICR7Z2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc3F1ZWV6ZWRPdXRwdXRTaGFwZSl9XG4gICAgICAke3VucGFja0Zyb21DaGFubmVsKCl9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcblxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XG4gICAgICAgIGludCByb3dzID0gJHtzcXVlZXplZE91dHB1dFNoYXBlWzJdfTtcbiAgICAgICAgaW50IGNvbHMgPSAke3NxdWVlemVkT3V0cHV0U2hhcGVbMV19O1xuXG4gICAgICAgICR7bWFpbkxvb3B9XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogc3F1ZWV6ZWRPdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQzRC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICAgIGhhc01haW46IHRydWUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQzRDogVGVuc29yLFxuICBvdXRwdXRTaGFwZTNEOiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtTWV0YWRhdGEob3V0cHV0U2hhcGUzRCk7XG4gIHJldHVybiB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0M0QsIG1ldGFkYXRhLCBvdXRwdXRTaGFwZTNEKSB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NEaW1zM0Qoc2hhcGU6IEFycmF5TGlrZTxudW1iZXI+KTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbMSwgMSwgMV07XG4gIH1cbiAgLy8gVE9ETzogc3F1ZWV6ZSBvdGhlciBzaGFwZXMgdG8gMkQgY2FzZVxuICBsZXQgYmF0Y2ggPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aCAtIDI7ICsraSkge1xuICAgIGJhdGNoICo9IHNoYXBlW2ldO1xuICB9XG4gIHJldHVybiBbYmF0Y2gsIHNoYXBlLmxlbmd0aCA+IDEgPyBzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSA6IDEsIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdXTtcbn1cblxuLy8gRm9yIHBhY2tlZCByZXNoYXBlLCB3ZSBuZWVkIHRvIHJlLWFycmFuZ2UgdGV4ZWwgZGF0YSBmb3Igb3V0cHV0IHNoYXBlLlxuLy8gT3VyIHBhY2sgaXMgZGVzaWduZWQgdG8gcGFjayBhIDJ4MiB0aWxlIGluIGxhc3QgaCBhbmQgdyBkaW1lbnNpb24sIHNvXG4vLyBmb3IgdGhlIHJlc2hhcGVkIG5ldyB0ZW5zb3IsIHdlIGp1c3QgbmVlZCB0byByZS1hcnJhbmdlIHRoZSBsYXN0IGggYW5kXG4vLyB3IGRpbWVuc2lvbi4gRm9yIGFueSBzaGFwZSB0aGF0IGlzIG5vdCBpbiAzRCwgaS5lLiBbYmF0Y2gsIFcsIEhdLCB3ZVxuLy8gZmlyc3QgY29udmVydCBpdCB0byAzRCBieSBjb2xsYXBzaW5nIG90aGVyIGRpbWVuc2lvbiB0byBiYXRjaCBkaW0sIHRoZW5cbi8vIHByb2Nlc3Mgd2l0aCB0aGUgbGFzdCB0d28gZGltZW5zaW9ucy5cbi8vIE5vdGU6IHdlIG9ubHkgbmVlZCB0aGUgc2hhcGUgdGVuc29yIHRvIGNhbGN1bGF0ZSBvdXRwdXQgc2hhcGUsIHNvIHRoZVxuLy8gY29udGVudCBpbiBzaGFwZSB0ZW5zb3IgaXMgbmV2ZXIgdXBsb2FkZWQgdG8gR1BVLiBJdCBpcyBhbHdheXMga2VwdCBpbiBDUFUuXG4vLyBUT0RPOiBvcHRpbWl6ZSB0aGUgYWxnb3JpdGhtIC0tIGluIHNvbWUgY2FzZXMsIGlmIHRoZSBsYXN0IHR3byBkaW1zIGFyZVxuLy8gdGhlIHNhbWUgYmV0d2VlbiBpbnB1dCBzaGFwZSBhbmQgb3V0cHV0IHNoYXBlLCB0aGUgcGFja2VkIHJlc2hhcGUgY2FuIGJlXG4vLyB0cmVhdGVkIGFzIG5vLW9wLlxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzaGFwZUNoZWFwKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCByZXNoYXBlZERpbXM6IHJlYWRvbmx5IG51bWJlcltdKSB7XG4gIGxldCBpc0NoZWFwUmVzaGFwZSA9IGZhbHNlO1xuICBpZiAoZGltcy5sZW5ndGggPT09IDAgfHwgcmVzaGFwZWREaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIHNjYWxhclxuICAgIGlzQ2hlYXBSZXNoYXBlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaW1zLmxlbmd0aCA8IDIgfHwgcmVzaGFwZWREaW1zLmxlbmd0aCA8IDIpIHtcbiAgICAvLyAxRFxuICAgIGlzQ2hlYXBSZXNoYXBlID0gZGltc1tkaW1zLmxlbmd0aCAtIDFdID09PSByZXNoYXBlZERpbXNbcmVzaGFwZWREaW1zLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIC8vIDJEICtcbiAgICBpc0NoZWFwUmVzaGFwZSA9XG4gICAgICBkaW1zW2RpbXMubGVuZ3RoIC0gMV0gPT09IHJlc2hhcGVkRGltc1tyZXNoYXBlZERpbXMubGVuZ3RoIC0gMV0gJiZcbiAgICAgIGRpbXNbZGltcy5sZW5ndGggLSAyXSA9PT0gcmVzaGFwZWREaW1zW3Jlc2hhcGVkRGltcy5sZW5ndGggLSAyXTtcbiAgfVxuXG4gIHJldHVybiBpc0NoZWFwUmVzaGFwZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaGFwZWRJbnB1dENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gIGNvbnN0IGNvb3JkcyA9IFsnYicsICdyJywgJ2MnXTtcbiAgY29uc3QgaW5kZXggPSAnaW5kZXgnO1xuICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzW2ldfSA9ICR7aW5kZXh9IC8gJHtzdHJpZGV9YDtcbiAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxXG4gICAgICAgICAgPyBgaW50ICR7Y29vcmRzW2kgKyAxXX0gPSAke2luZGV4fSAtICR7Y29vcmRzW2ldfSAqICR7c3RyaWRlfWBcbiAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1tpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICB9KVxuICAgIC5qb2luKCcnKTtcblxuICByZXR1cm4gYFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xuICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoc2hhcGUpO1xuXG4gIHJldHVybiBgXG4gIGludCBnZXRGbGF0dGVuZWRJbmRleChpdmVjMyBjb29yZHMpIHtcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcbiAgICByZXR1cm4gY29vcmRzLnggKiAke3N0cmlkZXNbMF19ICsgY29vcmRzLnogKiAke3N0cmlkZXNbMV19ICsgY29vcmRzLnk7XG4gIH1cbmA7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBUZXh0dXJlRGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVBc1VpbnQ4ID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEgPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLWNvcmUvYmxvYi9tYXN0ZXIvc3JjL2tlcm5lbHMvd2ViZ2wvZW5jb2RlX2Zsb2F0X2dwdS50c1xuICAgKi9cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XG4gICAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XG5cbiAgICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xuICAgICAgcmV0dXJuICh2YWwgPCAxLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjApID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGhpZ2hwIHZlYzQgZW5jb2RlQXNVaW50OChoaWdocCBmbG9hdCB2KSB7XG4gICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcbiAgICAgIH1cblxuICAgICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XG5cbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xuICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xuICAgICAgfVxuXG4gICAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xuXG4gICAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xuICAgICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcblxuICAgICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XG4gICAgICBtIC09IGNbMl0gLyAxMjguMDtcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XG4gICAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xuICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xuXG4gICAgICBoaWdocCBmbG9hdCBlYmlhcyA9IGUgKyAxMjcuMDtcbiAgICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xuICAgICAgY1syXSArPSBmbG9vcihlYmlhcykgKiAxMjguMDtcblxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XG5cbiAgICAgIHJldHVybiBjIC8gMjU1LjA7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgZmxvYXQgdmFsdWUgPSAke2dsc2wudGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcbiAgICAgICR7Z2xzbC5vdXRwdXR9ID0gZW5jb2RlQXNVaW50OCh2YWx1ZSk7XG4gICAgfWA7XG4gIGNvbnN0IHByb2dyYW1JbmZvID0ge1xuICAgIG5hbWU6ICdVaW50OEVuY29kZScsXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnRlbnNvci50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbiAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIuZXhlY3V0ZVByb2dyYW0ocHJvZ3JhbUluZm8sIFtpbnB1dC50ZW5zb3JdKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGdldENvb3Jkc0RhdGFUeXBlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBnZXRDaGFubmVscywgdW5wYWNrRnJvbUNoYW5uZWwgfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCB1bnBhY2tQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICd1bnBhY2snLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnBhY2tlZF0sXG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCByYW5rID0gaW5wdXQuZGltcy5sZW5ndGg7XG5cbiAgY29uc3QgY2hhbm5lbHMgPSBnZXRDaGFubmVscygncmMnLCByYW5rKTtcbiAgY29uc3QgaW5uZXJEaW1zID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICBjb25zdCB1bnBhY2tDaGFubmVsID0gdW5wYWNrRnJvbUNoYW5uZWwoKTtcbiAgY29uc3QgaXNTY2FsYXIgPSBpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMDtcbiAgY29uc3Qgc291cmNlQ29vcmRzID0gaXNTY2FsYXIgPyAnJyA6IGdldFNvdXJjZUNvb3JkcyhyYW5rLCBjaGFubmVscyk7XG4gIGNvbnN0IGNvb3JkcyA9IHJhbmsgPD0gMSA/ICdyYycgOiBgdmVjMigke2lubmVyRGltcy5qb2luKCcsJyl9KWA7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgLy8gU2FtcGxlIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGNvb3JkcyB0byBnZXQgdGhlIHJnYmEgY2hhbm5lbCB2YWx1ZS5cbiAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QSgke3NvdXJjZUNvb3Jkc30pO1xuXG4gICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7Y29vcmRzfSksIDAsIDAsIDApO1xuICAgICB9XG4gICBgO1xuXG4gIHJldHVybiB7XG4gICAgLi4udW5wYWNrUHJvZ3JhbU1ldGFkYXRhLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgb3V0cHV0OiB7IGRpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiAoe1xuICAuLi51bnBhY2tQcm9ncmFtTWV0YWRhdGEsXG4gIGdldDogKCkgPT4gY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXQpLFxufSk7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhyYW5rOiBudW1iZXIsIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gJ3JjJztcbiAgfVxuXG4gIGxldCBjb29yZHMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyBpKyspIHtcbiAgICBjb29yZHMgKz0gZGltc1tpXTtcbiAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICBjb29yZHMgKz0gJywnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVuY29kZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDogRmxvYXQzMkFycmF5O1xuICAgIGJ5dGU6IFVpbnQ4QXJyYXk7XG4gICAgaW50OiBVaW50MzJBcnJheTtcbiAgfVxuICBleHBvcnQgdHlwZSBEYXRhVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xuICB0eXBlIERhdGFBcnJheVR5cGUgPSBEYXRhVHlwZU1hcFtEYXRhVHlwZV07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRW5jb2RlclVzYWdlIHtcbiAgRGVmYXVsdCA9IDAsXG4gIFVwbG9hZE9ubHksXG4gIERvd25sb2FkNEJ5dGVzQXNGbG9hdDMyLFxufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgbWFwcGluZyBkYXRhIHR5cGVzIHRvIHRleHR1cmUgdGV4bGV0c1xuICogRW5jb2RpbmcgbWVhbnMgaG93IGEgRmxvYXQzMiBpcyBtYXBwZWQgdG8gMSBvciA0IGNoYW5uZWxzIGZvciBlYWNoIHRleGxldFxuICogRGVjb2RpbmcgbWVhbnMgaG93IGEgdGV4bGV0J3MgY2hhbm5lbHMgYXJlIG1hcHBlZCB0byBhIHJlc3VsdGluZyBGbG9hdDMyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemU6IG51bWJlcjtcbiAgZW5jb2RlKHNyYzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCB0ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlO1xuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGU7XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZTtcbn1cbi8qKlxuICogV2ViR0wyIGRhdGEgZW5jb2RlclxuICogVXNlcyBSMzJGIGFzIHRoZSBmb3JtYXQgZm9yIHRleGxldFxuICovXG5leHBvcnQgY2xhc3MgUmVkRmxvYXQzMkRhdGFFbmNvZGVyIGltcGxlbWVudHMgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IoZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSkge1xuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLlIzMkY7XG4gICAgICB0aGlzLmZvcm1hdCA9IGdsLlJFRDtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxzID09PSA0KSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTMyRjtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtjaGFubmVsc31gKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlKHNyYzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCB0ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBsZXQgcmVzdWx0OiBGbG9hdDMyQXJyYXk7XG4gICAgbGV0IHNvdXJjZTogRmxvYXQzMkFycmF5O1xuICAgIGlmIChzcmMuY29uc3RydWN0b3IgIT09IEZsb2F0MzJBcnJheSkge1xuICAgICAgTG9nZ2VyLndhcm5pbmcoJ0VuY29kZXInLCAnZGF0YSB3YXMgbm90IG9mIHR5cGUgRmxvYXQzMjsgY3JlYXRpbmcgbmV3IEZsb2F0MzJBcnJheScpO1xuICAgICAgc291cmNlID0gbmV3IEZsb2F0MzJBcnJheShzcmMpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZVNpemUgKiB0aGlzLmNoYW5uZWxTaXplID4gc3JjLmxlbmd0aCkge1xuICAgICAgTG9nZ2VyLndhcm5pbmcoJ0VuY29kZXInLCAnU291cmNlIGRhdGEgdG9vIHNtYWxsLiBBbGxvY2F0aW5nIGxhcmdlciBhcnJheScpO1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuYWxsb2NhdGUodGV4dHVyZVNpemUgKiB0aGlzLmNoYW5uZWxTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBzb3VyY2UuZm9yRWFjaCgodiwgaSkgPT4gKHJlc3VsdFtpXSA9IHYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0KTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmNoYW5uZWxTaXplID09PSAxKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSAoYnVmZmVyIGFzIEZsb2F0MzJBcnJheSkuZmlsdGVyKChfdmFsdWUsIGluZGV4KSA9PiBpbmRleCAlIDQgPT09IDApLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgZGF0YVNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuLyoqXG4gKiBEYXRhIGVuY29kZXIgZm9yIFdlYkdMIDEgd2l0aCBzdXBwb3J0IGZvciBmbG9hdGluZyBwb2ludCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBSR0JBRmxvYXREYXRhRW5jb2RlciBpbXBsZW1lbnRzIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSwgdGV4dHVyZVR5cGU/OiBudW1iZXIpIHtcbiAgICBpZiAoY2hhbm5lbHMgIT09IDEgJiYgY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IHRleHR1cmVUeXBlIHx8IGdsLkZMT0FUO1xuICB9XG4gIGVuY29kZShzcmM6IEZsb2F0MzJBcnJheSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgbGV0IGRlc3QgPSBzcmM7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdFbmNvZGVyJywgJ0V4cGxvZGluZyBpbnRvIGEgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBkZXN0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgc3JjLmZvckVhY2goKHYsIGkpID0+IChkZXN0W2kgKiA0XSA9IHYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplICogNCk7XG4gIH1cbiAgZGVjb2RlKGJ1ZmZlcjogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCBkYXRhU2l6ZTogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5jaGFubmVsU2l6ZSA9PT0gMSkge1xuICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gKGJ1ZmZlciBhcyBGbG9hdDMyQXJyYXkpLmZpbHRlcigoX3ZhbHVlLCBpbmRleCkgPT4gaW5kZXggJSA0ID09PSAwKS5zdWJhcnJheSgwLCBkYXRhU2l6ZSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVpbnQ4RGF0YUVuY29kZXIgaW1wbGVtZW50cyBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZSA9IDQ7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSkge1xuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLkFMUEhBO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5BTFBIQTsgLy8gbm90IHRlc3RlZFxuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgfSBlbHNlIGlmIChjaGFubmVscyA9PT0gNCkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICB0aGlzLmZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtjaGFubmVsc31gKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlKHNyYzogVWludDhBcnJheSwgX3RleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpO1xuICB9XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUgKiB0aGlzLmNoYW5uZWxTaXplKTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheSgwLCBkYXRhU2l6ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke2J1ZmZlci5jb25zdHJ1Y3Rvcn1gKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHsgVGV4dHVyZUxheW91dFN0cmF0ZWd5LCBXaWR0aEhlaWdodFByZWZzIH0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQgeyBUZXh0dXJlTGF5b3V0LCBUZXh0dXJlVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSA9IChcbiAgdGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLFxuKTogVGV4dHVyZUxheW91dCA9PiB7XG4gIGNvbnN0IGNoYW5uZWwgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWQgfHwgdGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWQgPyAxIDogNDtcbiAgY29uc3QgaXNQYWNrZWQgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkO1xuICBjb25zdCByZXZlcnNlV0ggPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZCB8fCB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkO1xuICBjb25zdCBicmVha0F4aXMgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiA/IHNoYXBlLmxlbmd0aCAtIDEgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHVucGFja2VkU2hhcGUgPVxuICAgIHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXG4gICAgICA/IHNoYXBlLm1hcCgoZCwgaSkgPT4gKGkgPT09IHNoYXBlLmxlbmd0aCAtIDEgPyBkICogNCA6IGQpKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGUsIGNoYW5uZWwsIHVucGFja2VkU2hhcGUsIHtcbiAgICBpc1BhY2tlZCxcbiAgICByZXZlcnNlV0gsXG4gICAgYnJlYWtBeGlzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQgPSAoXG4gIHRleHR1cmVMYXlvdXRTdHJhdGVneTogVGV4dHVyZUxheW91dFN0cmF0ZWd5LFxuICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZSxcbik6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGUsIHRleHR1cmVUeXBlKTtcbiAgcmV0dXJuIFtsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHRdO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBUZXh0dXJlTGF5b3V0IG9iamVjdCBmcm9tIHNoYXBlLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSA9IChcbiAgdGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgY2hhbm5lbHM6IDEgfCA0ID0gMSxcbiAgdW5wYWNrZWRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMsXG4pOiBUZXh0dXJlTGF5b3V0ID0+IHtcbiAgY29uc3QgaXNQYWNrZWQgPSAhIShwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZCk7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRleHR1cmVMYXlvdXRTdHJhdGVneS5jb21wdXRlVGV4dHVyZVdIKGlzUGFja2VkID8gdW5wYWNrZWRTaGFwZSB8fCBzaGFwZSA6IHNoYXBlLCBwcmVmcyk7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gIGxldCBpbmZlcnJlZERpbXMgPSBzaGFwZS5zbGljZSgwKTtcbiAgaWYgKHJhbmsgPT09IDApIHtcbiAgICBpbmZlcnJlZERpbXMgPSBbMV07XG4gIH1cbiAgaWYgKGNoYW5uZWxzID09PSAxKSB7XG4gICAgLy8gdW5wYWNrZWRTaGFwZSB3aWxsIHRha2UgYHNoYXBlYCBhbmQgbm90IGBpbmZlcnJlZERpbXNgIHNvIGFzIHRvIGNyZWF0ZSBhIHNjYWxhciBUZW5zb3IgaWYgbmVlZCBiZVxuICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgfSBlbHNlIGlmIChpc1BhY2tlZCkge1xuICAgIGlmIChjaGFubmVscyAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIHBhY2tlZCB0ZXh0dXJlIG11c3QgYmUgNC1jaGFubmVsJyk7XG4gICAgfVxuICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgICBpZiAocmFuayA+IDApIHtcbiAgICAgIGluZmVycmVkRGltc1tyYW5rIC0gMV0gPSBNYXRoLmNlaWwoaW5mZXJyZWREaW1zW3JhbmsgLSAxXSAvIDIpO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDEpIHtcbiAgICAgIGluZmVycmVkRGltc1tyYW5rIC0gMl0gPSBNYXRoLmNlaWwoaW5mZXJyZWREaW1zW3JhbmsgLSAyXSAvIDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghdW5wYWNrZWRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5wYWNrZWQgc2hhcGUgaXMgbmVlZGVkIHdoZW4gdXNpbmcgY2hhbm5lbHMgPiAxJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgY2hhbm5lbHMsXG4gICAgaXNQYWNrZWQsXG4gICAgc2hhcGU6IGluZmVycmVkRGltcyxcbiAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW5mZXJyZWREaW1zKSxcbiAgICB1bnBhY2tlZFNoYXBlLFxuICAgIHJldmVyc2VkV0g6IHByZWZzICYmIHByZWZzLnJldmVyc2VXSCxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi8uLi9iYWNrZW5kJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQgeyBjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL29wcy9wYWNrJztcbmltcG9ydCB7IGNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyLCBpc1Jlc2hhcGVDaGVhcCwgcHJvY2Vzc0RpbXMzRCB9IGZyb20gJy4vb3BzL3Jlc2hhcGUtcGFja2VkJztcbmltcG9ydCB7IGVuY29kZUFzVWludDggfSBmcm9tICcuL29wcy91aW50OC1lbmNvZGUnO1xuaW1wb3J0IHsgY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL29wcy91bnBhY2snO1xuaW1wb3J0IHsgV2ViR0xTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4vc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7IEVuY29kZXJVc2FnZSB9IGZyb20gJy4vdGV4dHVyZS1kYXRhLWVuY29kZXInO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0LFxuICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlLFxuICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlLFxufSBmcm9tICcuL3RleHR1cmUtbGF5b3V0JztcbmltcG9ydCB7IEFydGlmYWN0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFRleHR1cmVEYXRhLCBUZXh0dXJlTGF5b3V0LCBUZXh0dXJlVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleSA9IChcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvIHwgUHJvZ3JhbUluZm9Mb2FkZXIsXG4gIGlucHV0VGV4dHVyZURhdGFzOiBUZXh0dXJlRGF0YVtdLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaW5wdXRzID0gaW5wdXRUZXh0dXJlRGF0YXNcbiAgICAubWFwKCh0ZXh0dXJlKSA9PiBgJHt0ZXh0dXJlLnVucGFja2VkU2hhcGUuam9pbignLCcpfTske3RleHR1cmUud2lkdGh9eCR7dGV4dHVyZS5oZWlnaHR9YClcbiAgICAuam9pbignXycpO1xuICBsZXQga2V5ID0gcHJvZ3JhbUluZm8ubmFtZTtcbiAgaWYgKHByb2dyYW1JbmZvLmNhY2hlSGludCkge1xuICAgIGtleSArPSAnWycgKyBwcm9ncmFtSW5mby5jYWNoZUhpbnQgKyAnXSc7XG4gIH1cbiAga2V5ICs9ICc6JyArIGlucHV0cztcbiAgcmV0dXJuIGtleTtcbn07XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgcHJpdmF0ZSBwYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHByaXZhdGUgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXNzaW9uOiBXZWJHTFNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFt3aWR0aCwgaGVpZ2h0XVxuICAgKi9cbiAgY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksIHNoYXBlLCB0ZXh0dXJlVHlwZSk7XG4gIH1cblxuICBleGVjdXRlUHJvZ3JhbShwcm9ncmFtOiBQcm9ncmFtSW5mbyB8IFByb2dyYW1JbmZvTG9hZGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdKTogVGV4dHVyZURhdGEge1xuICAgIGlmIChpbnB1dHMubGVuZ3RoIDwgcHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7cHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLmlucHV0TmFtZXMubGVuZ3RoICE9PSBwcm9ncmFtLmlucHV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG5hbWVzIHNpemUgZG9lcyBub3QgbWF0Y2ggaW5wdXQgdHlwZXMnKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdGV4dHVyZSBpbmZvIGZvciBpbnB1dFxuICAgIGNvbnN0IGlucHV0VGV4dHVyZURhdGFzOiBUZXh0dXJlRGF0YVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtLmlucHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzW2ldID0gdGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1tpXSwgcHJvZ3JhbS5pbnB1dFR5cGVzW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleShwcm9ncmFtLCBpbnB1dFRleHR1cmVEYXRhcyk7XG4gICAgbGV0IGFydGlmYWN0ID0gdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGtleSk7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhcnRpZmFjdFxuICAgICAgPyBhcnRpZmFjdC5wcm9ncmFtSW5mb1xuICAgICAgOiB0eXBlb2YgKHByb2dyYW0gYXMgUHJvZ3JhbUluZm9Mb2FkZXIpLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IChwcm9ncmFtIGFzIFByb2dyYW1JbmZvTG9hZGVyKS5nZXQoKVxuICAgICAgICA6IChwcm9ncmFtIGFzIFByb2dyYW1JbmZvKTtcblxuICAgIC8vIGNyZWF0ZSB0ZXh0dXJlIGluZm8gZm9yIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dFRleHR1cmVMYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKFxuICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LFxuICAgICAgcHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICAgICBwcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGUsXG4gICAgKTtcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlRGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZURhdGEob3V0cHV0VGV4dHVyZUxheW91dCwgcHJvZ3JhbUluZm8ub3V0cHV0LnR5cGUpO1xuXG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZURhdGFzLCBvdXRwdXRUZXh0dXJlRGF0YSk7XG4gICAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBpbnB1dFRleHR1cmVEYXRhcywgb3V0cHV0VGV4dHVyZURhdGEpO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHJ1bihwcm9ncmFtOiBQcm9ncmFtSW5mb0xvYWRlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSk6IFRlbnNvciB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKHByb2dyYW0sIGlucHV0cyk7XG4gICAgcmV0dXJuIG91dHB1dFRleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHByaXZhdGUgcnVuUHJvZ3JhbShhcnRpZmFjdDogQXJ0aWZhY3QsIGlucHV0czogVGV4dHVyZURhdGFbXSwgb3V0cHV0OiBUZXh0dXJlRGF0YSk6IHZvaWQge1xuICAgIC8vIGlucHV0IHNob3VsZCBtYXRjaFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoISFpbnB1dHNbaV0uaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5pbnB1dFR5cGVzW2ldID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRbJHtpfV0gcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG91dHB1dCBzaG91bGQgbWF0Y2hcbiAgICBpZiAoISFvdXRwdXQuaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dHMsIG91dHB1dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZURhdGEgb2JqZWN0IGZyb20gYSB0ZW5zb3IuXG4gICAqIFVzYWdlID0gRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkuXG4gICAqIElmIGEgcmVsYXRlZCB0ZXh0dXJlIGRhdGEgaXMgZm91bmQgaW4gY2FjaGUsIHJldHVybnMgaXQ7XG4gICAqIE90aGVyd2lzZTpcbiAgICogICBDcmVhdGVzIGEgbmV3IHRleHR1cmUgbGF5b3V0IGlmIG5vdCBwcm92aWRlZDtcbiAgICogICBDcmVhdGVzIFdlYkdMVGV4dHVyZSB3aXRoIHRoZSBsYXlvdXQ7XG4gICAqICAgVXBsb2FkIHRlbnNvciBkYXRhIHRvIHRoZSB0ZXh0dXJlO1xuICAgKiAgIENyZWF0ZXMgYSB0ZXh0dXJlIGRhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3Igd2l0aCBkYXRhIHRvIHVwbG9hZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRPckNyZWF0ZVRleHR1cmVEYXRhKHRlbnNvcjogVGVuc29yLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUpIHtcbiAgICBsZXQgdGQgPSB0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpO1xuXG4gICAgaWYgKCF0ZCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0ZXh0dXJlIGRhdGEgaW4gZGlmZmVyZW50IHR5cGVcbiAgICAgIHRkID0gdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCB0ZXh0dXJlVHlwZSAhPT0gVGV4dHVyZVR5cGUucGFja2VkKTtcbiAgICAgIGlmICh0ZCkge1xuICAgICAgICBpZiAodGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhY2sodGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVucGFjayh0ZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRkKSB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgdGVuc29yLmRpbXMsIHRleHR1cmVUeXBlKTtcblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gMTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSA0O1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRlbnNvci5kaW1zO1xuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgLy8gcHJlLXByb2Nlc3NpbmcgZm9yIGtlcm5lbCBkYXRhIG9mIENvbnYuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPOiBjdXJyZW50bHkgdGhpcyBpcyBhIGhhY2tpbmcgdG8gb3ZlcndyaXRlIENvbnYncyB3ZWlnaHQuIFRoZSBjb3JyZWN0IHdheSB0byBkbyB0aGlzIHNob3VsZCBiZTpcbiAgICAgICAgICAvLyAxLiBpbXBsZW1lbnQgdGV4dHVyZSBiYXNlZCBjb25zdC1mb2xkaW5nXG4gICAgICAgICAgLy8gMi4gY3JlYXRlIGEgV2ViR0wgcHJvZ3JhbSBcInByZXByb2Nlc3NDb252V2VpZ2h0XCIgdG8gZG8gdGhlIHNhbWUgd29yayBhcyBiZWxvd1xuICAgICAgICAgIC8vIDMuIHJ1biB0aGUgcHJvZ3JhbSBiZWZvcmUgZG90UHJvZHVjdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VybmVsU2hhcGUgPSBbc2hhcGVbMF0sIE1hdGguY2VpbCgoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdKSAvIGNoYW5uZWxzKV07XG4gICAgICAgICAgY29uc3QgYWRqdXN0ZWRMYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LFxuICAgICAgICAgICAgYWRqdXN0ZWRLZXJuZWxTaGFwZSxcbiAgICAgICAgICAgIHRleHR1cmVUeXBlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGJ1ZmZlciA9IHRlbnNvci5udW1iZXJEYXRhO1xuICAgICAgICAgIGlmICgoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdKSAlIGNoYW5uZWxzICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBudW1GZWF0dXJlTWFwcyA9IHNoYXBlWzBdO1xuICAgICAgICAgICAgY29uc3Qgb2xkUm93U2l6ZSA9IHNoYXBlWzFdICogc2hhcGVbMl0gKiBzaGFwZVszXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Jvd1NpemUgPSBNYXRoLmNlaWwoKG9sZFJvd1NpemUgKiBncm91cCkgLyBjaGFubmVscykgKiBjaGFubmVscztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBudW1GZWF0dXJlTWFwcyAqIG5ld1Jvd1NpemU7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBudW1GZWF0dXJlTWFwczsgKytmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZE9mZnNldCA9IGYgKiBvbGRSb3dTaXplO1xuICAgICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmICogbmV3Um93U2l6ZSArIChmICUgZ3JvdXApICogb2xkUm93U2l6ZTtcbiAgICAgICAgICAgICAgYnVmZmVyLnNldCh0ZW5zb3IubnVtYmVyRGF0YS5zdWJhcnJheShvbGRPZmZzZXQsIG9sZE9mZnNldCArIG9sZFJvd1NpemUpLCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShhZGp1c3RlZExheW91dCwgdGVuc29yLnR5cGUsIGJ1ZmZlciwgdGVuc29yLCBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpIHtcbiAgICAgICAgY29uc3QgdW5wYWNrZWRUZXh0dXJlTGF5b3V0ID0gY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksIHRlbnNvci5kaW1zLCAxLCBbXSwge1xuICAgICAgICAgIHJldmVyc2VXSDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKFxuICAgICAgICAgIHVucGFja2VkVGV4dHVyZUxheW91dCxcbiAgICAgICAgICB0ZW5zb3IudHlwZSxcbiAgICAgICAgICB0ZW5zb3IubnVtYmVyRGF0YSxcbiAgICAgICAgICB0ZW5zb3IsXG4gICAgICAgICAgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHksXG4gICAgICAgICk7XG4gICAgICAgIHRkID0gdGhpcy5wYWNrKHVucGFja2VkVGV4dHVyZURhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGQgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGxheW91dCwgdGVuc29yLnR5cGUsIHRlbnNvci5udW1iZXJEYXRhLCB0ZW5zb3IsIEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRleHR1cmVEYXRhIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gZGF0YSBhbmQgYmluZCB0byB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBVc2FnZSA9IEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5LlxuICAgKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIGlzIGEgaGFjayBmb3IgQ29udiBpbXBsZW1lbnRhdGlvbi4gc2hvdWxkIHJlbW92ZSB0aGlzIGZ1bmN0aW9uLCBhZnRlciByZXdyaXRpbmcgQ29udlxuICAgKiBpbXBsZW1lbnRhdGlvbiBieSBHcmFwaC5UcmFuc2Zvcm1lclxuICAgKiBAcGFyYW0gZGF0YVR5cGUgdGhlIHRlbnNvciBkYXRhIHR5cGVcbiAgICogQHBhcmFtIGRhdGEgdGhlIGFjdHVhbCBkYXRhIHRvIHVwbG9hZFxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3IgdG8gYmluZC4gdGVuc29yJ3MgZGF0YSBpcyBpZ25vcmVkLlxuICAgKi9cbiAgY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0QmluZFRlbnNvcihcbiAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSxcbiAgICBkYXRhOiBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICB0ZW5zb3I6IFRlbnNvcixcbiAgKTogVGV4dHVyZURhdGEge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGxheW91dCwgZGF0YVR5cGUsIGRhdGEsIHRlbnNvciwgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlRGF0YShcbiAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSxcbiAgICBkYXRhPzogVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGVuc29yPzogVGVuc29yLFxuICAgIHVzYWdlPzogRW5jb2RlclVzYWdlLFxuICApOiBUZXh0dXJlRGF0YSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ0luZmVyZW5jZUhhbmRsZXInLCBgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeShsYXlvdXQpfV1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KGRhdGFUeXBlLCBsYXlvdXQsIGRhdGEsIHVzYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGxheW91dCwgZGF0YVR5cGUsIHRleHR1cmUsIHRlbnNvcik7XG4gIH1cblxuICByZXNoYXBlVW5wYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgIGNvbnN0IG5ld1RleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSB7XG4gICAgICBjaGFubmVsczogaW5wdXRURC5jaGFubmVscyxcbiAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICB3aWR0aDogaW5wdXRURC53aWR0aCxcbiAgICAgIC8vIGhhbmRsZSByZXNoYXBpbmcgaW50byBzY2FsYXIgVGVuc29yc1xuICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMocmVzaGFwZWREaW1zKSxcbiAgICAgIHVucGFja2VkU2hhcGU6IHJlc2hhcGVkRGltcyxcbiAgICB9O1xuICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gICAgcmV0dXJuIG5ld1RleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHJlc2hhcGVQYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUucGFja2VkKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByZXNoYXBlIGlzICdjaGVhcCdcbiAgICBpZiAoaXNSZXNoYXBlQ2hlYXAoaW5wdXQuZGltcywgcmVzaGFwZWREaW1zKSkge1xuICAgICAgY29uc3QgbmV3VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCA9IHtcbiAgICAgICAgY2hhbm5lbHM6IGlucHV0VEQuY2hhbm5lbHMsXG4gICAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBpbnB1dFRELndpZHRoLFxuICAgICAgICAvLyBoYW5kbGUgcmVzaGFwaW5nIGludG8gc2NhbGFyIFRlbnNvcnNcbiAgICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhyZXNoYXBlZERpbXMpLFxuICAgICAgICB1bnBhY2tlZFNoYXBlOiByZXNoYXBlZERpbXMsXG4gICAgICAgIGlzUGFja2VkOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gICAgICByZXR1cm4gbmV3VGV4dHVyZURhdGEudGVuc29yO1xuICAgIH1cblxuICAgIGNvbnN0IHNxdWVlemVkSW5wdXRTaGFwZSA9IHByb2Nlc3NEaW1zM0QoaW5wdXQuZGltcyk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRTaGFwZSA9IHByb2Nlc3NEaW1zM0QocmVzaGFwZWREaW1zKTtcblxuICAgIGNvbnN0IHNxdWVlemVkSW5wdXRUZW5zb3IgPSB0aGlzLnJlc2hhcGVQYWNrZWQoaW5wdXQsIHNxdWVlemVkSW5wdXRTaGFwZSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRUZW5zb3IgPSB0aGlzLnJ1bihcbiAgICAgIGNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKHRoaXMsIHNxdWVlemVkSW5wdXRUZW5zb3IsIHNxdWVlemVkT3V0cHV0U2hhcGUpLFxuICAgICAgW3NxdWVlemVkSW5wdXRUZW5zb3JdLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0VGVuc29yID0gdGhpcy5yZXNoYXBlUGFja2VkKHNxdWVlemVkT3V0cHV0VGVuc29yLCByZXNoYXBlZERpbXMpO1xuICAgIHJldHVybiBvdXRwdXRUZW5zb3I7XG4gIH1cblxuICBjYXN0KGlucHV0OiBUZW5zb3IsIHR5cGU6IFRlbnNvci5EYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGlucHV0VEQgYXMgVGV4dHVyZUxheW91dCwgdHlwZSwgaW5wdXRURC50ZXh0dXJlKTtcbiAgICByZXR1cm4gbmV3VGV4dHVyZURhdGEudGVuc29yO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKFxuICAgIGxheW91dDogVGV4dHVyZUxheW91dCxcbiAgICBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLFxuICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgICB0ZW5zb3I/OiBUZW5zb3IsXG4gICAgdGVuc29ySWQ/OiBUZW5zb3IuSWQsXG4gICkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSA9IHtcbiAgICAgIC4uLmxheW91dCxcbiAgICAgIHRlbnNvcjpcbiAgICAgICAgdGVuc29yIHx8XG4gICAgICAgIG5ldyBUZW5zb3IoXG4gICAgICAgICAgbGF5b3V0LnVucGFja2VkU2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGUsXG4gICAgICAgICAgKF9pZDogVGVuc29yLklkKSA9PiB0aGlzLnJlYWRUZXh0dXJlKHRleHR1cmVEYXRhKSxcbiAgICAgICAgICBhc3luYyAoX2lkOiBUZW5zb3IuSWQpID0+IHRoaXMucmVhZFRleHR1cmVBc3luYyh0ZXh0dXJlRGF0YSksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHRlbnNvcklkLFxuICAgICAgICApLFxuICAgICAgdGV4dHVyZSxcbiAgICB9O1xuICAgIHRoaXMuc2V0VGV4dHVyZURhdGEodGV4dHVyZURhdGEudGVuc29yLmRhdGFJZCwgdGV4dHVyZURhdGEsIGxheW91dC5pc1BhY2tlZCk7XG4gICAgcmV0dXJuIHRleHR1cmVEYXRhO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZDogVGVuc29yLklkLCBpc1BhY2tlZCA9IGZhbHNlKTogVGV4dHVyZURhdGEgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0ZW5zb3JJZClcbiAgICAgID8gdGhpcy5zZXNzaW9uLmdldFRleHR1cmVEYXRhKHRlbnNvcklkLCBpc1BhY2tlZClcbiAgICAgIDogaXNQYWNrZWRcbiAgICAgICAgPyB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKVxuICAgICAgICA6IHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCk7XG4gIH1cbiAgc2V0VGV4dHVyZURhdGEodGVuc29ySWQ6IFRlbnNvci5JZCwgdGQ6IFRleHR1cmVEYXRhLCBpc1BhY2tlZCA9IGZhbHNlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRlbnNvcklkKSkge1xuICAgICAgdGhpcy5zZXNzaW9uLnNldFRleHR1cmVEYXRhKHRlbnNvcklkLCB0ZCwgaXNQYWNrZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoaXNQYWNrZWQgPyB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgOiB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHRlbnNvcklkLCB0ZCk7XG4gICAgfVxuICB9XG4gIGlzVGV4dHVyZUxheW91dENhY2hlZCh0ZW5zb3I6IFRlbnNvciwgaXNQYWNrZWQgPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0VGV4dHVyZURhdGEodGVuc29yLmRhdGFJZCwgaXNQYWNrZWQpO1xuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0ZCkgPT4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkKSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHRkKSA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJlYWRUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBpZiAodGV4dHVyZURhdGEuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUZXh0dXJlKHRoaXMudW5wYWNrKHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KGVuY29kZUFzVWludDgodGhpcywgdGV4dHVyZURhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRUZXh0dXJlQXN5bmModGV4dHVyZURhdGE6IFRleHR1cmVEYXRhKTogUHJvbWlzZTxUZW5zb3IuTnVtYmVyVHlwZT4ge1xuICAgIGlmICh0ZXh0dXJlRGF0YS5pc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRleHR1cmVBc3luYyh0aGlzLnVucGFjayh0ZXh0dXJlRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdChlbmNvZGVBc1VpbnQ4KHRoaXMsIHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luYyh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIHBhY2soaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEge1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEYXRhID0gdGhpcy5leGVjdXRlUHJvZ3JhbShjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIodGhpcywgaW5wdXQudGVuc29yKSwgW2lucHV0LnRlbnNvcl0pO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHVucGFjayhpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKHRoaXMsIGlucHV0LnRlbnNvciksIFtpbnB1dC50ZW5zb3JdKTtcbiAgICByZXR1cm4gb3V0cHV0VGV4dHVyZURhdGE7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKG5hbWUpID0+IGAkeyh0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtuYW1lXX1gKVxuICAgICAgICAuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5ID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIGF0dHJpYnV0ZTogVCxcbik6IFQgJiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPT4gbmV3IEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwoYXR0cmlidXRlKSBhcyB1bmtub3duIGFzIFQgJiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBtb21lbnR1bTogbnVtYmVyO1xuICBzcGF0aWFsOiBudW1iZXI7XG59XG5cbmNvbnN0IGJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gIGlucHV0TmFtZXM6IFsnQScsICdTY2FsZScsICdCJywgJ01lYW4nLCAnVmFyaWFuY2UnXSxcbiAgaW5wdXRUeXBlczogW1xuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICBdLFxufTtcblxuZXhwb3J0IGNvbnN0IGJhdGNoTm9ybWFsaXphdGlvbjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5iYXRjaE5vcm1hbGl6YXRpb25Qcm9ncmFtTWV0YWRhdGEsXG4gICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZUJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksXG4gICAgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248QmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZXBzaWxvbiA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnZXBzaWxvbicsIDFlLTUpO1xuICBjb25zdCBtb21lbnR1bSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnbW9tZW50dW0nLCAwLjkpO1xuICBjb25zdCBzcGF0aWFsID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc3BhdGlhbCcsIDEpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgZXBzaWxvbiwgbW9tZW50dW0sIHNwYXRpYWwgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVCYXRjaE5vcm1hbGl6YXRpb25Qcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGNvbnN0IFtzY2FsZVdpZHRoLCBzY2FsZUhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBpbnB1dHNbMV0uZGltcyxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgdmVjMiBwb3NpdGlvbiA9IG9mZnNldFRvQ29vcmRzKGluZGljZXNbMV0sICR7c2NhbGVXaWR0aH0sICR7c2NhbGVIZWlnaHR9KTtcbiAgICBmbG9hdCBzY2FsZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShTY2FsZSwgcG9zaXRpb24pKTtcbiAgICBmbG9hdCBtZWFuID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KE1lYW4sIHBvc2l0aW9uKSk7XG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XG4gICAgZmxvYXQgYiA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShCLCBwb3NpdGlvbikpO1xuXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke2F0dHJpYnV0ZXMuZXBzaWxvbn0pKSApICsgYjtcbiAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4uYmF0Y2hOb3JtYWxpemF0aW9uUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgWCA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gIGNvbnN0IEIgPSBpbnB1dHNbMl07XG4gIGNvbnN0IG1lYW4gPSBpbnB1dHNbM107XG4gIGNvbnN0IHZhcl8gPSBpbnB1dHNbNF07XG5cbiAgLy8gaW5wdXQgc2hvdWxkIGF0bGVhc3QgaGF2ZSB0aHJlZSBkaW1lbnNpb25zIC0gTixDLGRpbTEsLi4uLGRpbW5cbiAgLy8gb3RoZXIgaW5wdXRzIGNhbiBoYXZlIG9ubHkgb25lIGRpbWVuc2lvbnNcbiAgaWYgKFxuICAgIFguZGltcy5sZW5ndGggPCAzIHx8XG4gICAgc2NhbGUuZGltcy5sZW5ndGggIT09IDEgfHxcbiAgICBCLmRpbXMubGVuZ3RoICE9PSAxIHx8XG4gICAgbWVhbi5kaW1zLmxlbmd0aCAhPT0gMSB8fFxuICAgIHZhcl8uZGltcy5sZW5ndGggIT09IDFcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChcbiAgICBzY2FsZS5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHxcbiAgICBCLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fFxuICAgIG1lYW4uZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8XG4gICAgdmFyXy5kaW1zWzBdICE9PSBYLmRpbXNbMV1cbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChcbiAgICAoWC50eXBlICE9PSAnZmxvYXQzMicgJiYgWC50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgKEIudHlwZSAhPT0gJ2Zsb2F0MzInICYmIEIudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgIChtZWFuLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBtZWFuLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAodmFyXy50eXBlICE9PSAnZmxvYXQzMicgJiYgdmFyXy50eXBlICE9PSAnZmxvYXQ2NCcpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlTGF5b3V0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBXZWJHTENvbnRleHQgfSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmV4cG9ydCBlbnVtIEZ1bmN0aW9uVHlwZSB7XG4gIFZhbHVlQmFzZWQsXG4gIFBvc2l0aW9uYWwsXG59XG5leHBvcnQgaW50ZXJmYWNlIEdsc2xGdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb25UeXBlPiB7XG4gIGJvZHk6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBUO1xufVxuZXhwb3J0IHR5cGUgR2xzbFZhbHVlRnVuY3Rpb24gPSBHbHNsRnVuY3Rpb248RnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQ+O1xuZXhwb3J0IGludGVyZmFjZSBHbHNsUG9zaXRpb25hbEZ1bmN0aW9uIGV4dGVuZHMgR2xzbEZ1bmN0aW9uPEZ1bmN0aW9uVHlwZS5Qb3NpdGlvbmFsPiB7XG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCBjbGFzcyBHbHNsQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCxcbiAgICBwdWJsaWMgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLFxuICAgIHB1YmxpYyBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sXG4gICAgcHVibGljIG91dHB1dFRleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICkge31cbn1cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7fVxuICBhYnN0cmFjdCBnZXRGdW5jdGlvbnMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfTtcbiAgYWJzdHJhY3QgZ2V0Q3VzdG9tVHlwZXMoKTogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbi8vIGFic3RyYWN0aW9uIHRvIHJlcHJlc2VudCBhIEdMU0wgbGlicmFyeSByb3V0aW5lIGFuZCBpdCdzIGRlcGVuZGVuY2llc1xuZXhwb3J0IGNsYXNzIEdsc2xMaWJSb3V0aW5lIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJvdXRpbmVCb2R5OiBzdHJpbmcsXG4gICAgcHVibGljIGRlcGVuZGVuY2llcz86IHN0cmluZ1tdLFxuICApIHt9XG59XG5cbi8vIGFic3RyYWN0aW9uIHRvIHJlcHJlc2VudCBhIEdMU0wgbGlicmFyeSByb3V0aW5lIGFuZCBpdCdzIGRlcGVuZGVuY2llcyBBUyBHUkFQSCBOb2Rlc1xuLy8gdGhpcyBsZXZlbCBvZiBhYnN0cmFjdGlvbiBpcyB1c2VkIHRvIHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBiZWZvcmUgZnJhZ21lbnQgc2hhZGUgaW5jbHVzaW9uXG5leHBvcnQgY2xhc3MgR2xzbExpYlJvdXRpbmVOb2RlIHtcbiAgZGVwZW5kZW5jaWVzOiBHbHNsTGliUm91dGluZU5vZGVbXTtcbiAgcm91dGluZUJvZHk6IHN0cmluZztcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyxcbiAgICByb3V0aW5lQm9keT86IHN0cmluZyxcbiAgICBkZXBlbmRlbmNpZXM/OiBHbHNsTGliUm91dGluZU5vZGVbXSxcbiAgKSB7XG4gICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJvdXRpbmVCb2R5KSB7XG4gICAgICB0aGlzLnJvdXRpbmVCb2R5ID0gcm91dGluZUJvZHk7XG4gICAgfVxuICB9XG4gIGFkZERlcGVuZGVuY3kobm9kZTogR2xzbExpYlJvdXRpbmVOb2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHRvcG9sb2dpY2FsbHkgc29ydCBHTFNMIGxpYnJhcnkgcm91dGluZXMgKGdyYXBoIG5vZGVzIGFic3RyYWN0aW9uKSBiZWZvcmUgc2hhZGVyIHNjcmlwdCBpbmNsdXNpb25cbmV4cG9ydCBjbGFzcyBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMge1xuICBzdGF0aWMgcmV0dXJuT3JkZXJlZE5vZGVzKG5vZGVzOiBHbHNsTGliUm91dGluZU5vZGVbXSk6IEdsc2xMaWJSb3V0aW5lTm9kZVtdIHtcbiAgICBpZiAoIW5vZGVzIHx8IG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICBjb25zdCBjeWNsZUNoZWNrID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgYWxyZWFkeVRyYXZlcnNlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxHbHNsTGliUm91dGluZU5vZGU+KCk7XG5cbiAgICB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyhub2RlcywgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlT3JkZXJlZE5vZGVzKFxuICAgIGdyYXBoTm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLFxuICAgIGN5Y2xlQ2hlY2s6IFNldDxzdHJpbmc+LFxuICAgIGFscmVhZHlUcmF2ZXJzZWQ6IFNldDxzdHJpbmc+LFxuICAgIHJlc3VsdDogR2xzbExpYlJvdXRpbmVOb2RlW10sXG4gICkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhOb2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5kZnNUcmF2ZXJzZShncmFwaE5vZGVzW2ldLCBjeWNsZUNoZWNrLCBhbHJlYWR5VHJhdmVyc2VkLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGRmc1RyYXZlcnNlKFxuICAgIHJvb3Q6IEdsc2xMaWJSb3V0aW5lTm9kZSxcbiAgICBjeWNsZUNoZWNrOiBTZXQ8c3RyaW5nPixcbiAgICBhbHJlYWR5VHJhdmVyc2VkOiBTZXQ8c3RyaW5nPixcbiAgICByZXN1bHQ6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLFxuICApIHtcbiAgICAvLyBpZiB0aGlzIHJvb3QgaGFzIGFscmVhZHkgYmVlbiB0cmF2ZXJzZWQgcmV0dXJuXG4gICAgaWYgKCFyb290IHx8IGFscmVhZHlUcmF2ZXJzZWQuaGFzKHJvb3QubmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjeWNsaWMgZGVwZW5kZW5jeSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgIGlmIChjeWNsZUNoZWNrLmhhcyhyb290Lm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBkZXRlY3RlZC4gQ2FuJ3QgdG9wb2xvZ2ljYWxseSBzb3J0IHJvdXRpbmVzIG5lZWRlZCBmb3Igc2hhZGVyLlwiKTtcbiAgICB9XG5cbiAgICAvLyBob2xkIHRoaXMgbm9kZSB0byBkZXRlY3QgY3ljbGVzIGlmIGFueVxuICAgIGN5Y2xlQ2hlY2suYWRkKHJvb3QubmFtZSk7XG5cbiAgICAvLyB0cmF2ZXJzZSBjaGlsZHJlbiBpbiBhIGRmcyBmYXNoaW9uXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gcm9vdC5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5kZnNUcmF2ZXJzZShkZXBlbmRlbmNpZXNbaV0sIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIHJlc3VsdCBob2xkZXJcbiAgICByZXN1bHQucHVzaChyb290KTtcblxuICAgIC8vIG1hcmsgdGhpcyBub2RlIGFzIHRyYXZlcnNlZCBzbyB0aGF0IHdlIGRvbid0IHRyYXZlcnNlIGZyb20gdGhpcyBhZ2FpblxuICAgIGFscmVhZHlUcmF2ZXJzZWQuYWRkKHJvb3QubmFtZSk7XG5cbiAgICAvLyByZWxlYXNlIHRoZSBob2xkXG4gICAgY3ljbGVDaGVjay5kZWxldGUocm9vdC5uYW1lKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBGdW5jdGlvblR5cGUsIEdsc2xWYWx1ZUZ1bmN0aW9uIH0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBZGQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2FkZF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSArIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgKyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xEaXYoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2Rpdl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAvIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xNdWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ211bF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAqIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgKiB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTdWIoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3N1Yl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLSB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xFcXVhbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZXF1YWxfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNChlcXVhbCh2MSwgdjIpKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xHcmVhdGVyKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdncmVhdGVyXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdChhID4gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxuICAgICAgdjEuZyA+IHYyLmcsXG4gICAgICB2MS5iID4gdjIuYixcbiAgICAgIHYxLmEgPiB2Mi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTGVzcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbGVzc18nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoYSA8IGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPCB2Mi5yICxcbiAgICAgICAgICAgICAgICB2MS5nIDwgdjIuZyxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcbiAgICAgICAgICAgICAgICB2MS5hIDwgdjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFuZCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnYW5kXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciAmJiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiAmJiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgJiYgYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE9yKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdvcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgfHwgYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgfHwgYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyB8fCBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hIHx8IGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xYb3IoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3hvcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgXl4gYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgXl4gYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hIF5eIGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQb3coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5CaW5hcnkoJ3BvdycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncHJlbHVfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgdjEuciA8IDAuMCA/IHYxLnIgKiB2Mi5yOiB2MS5yLFxuICAgICAgdjEuZyA8IDAuMCA/IHYxLmcgKiB2Mi5nOiB2MS5nLFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxuICAgICAgdjEuYSA8IDAuMCA/IHYxLmEgKiB2Mi5hOiB2MS5hXG4gICAgICApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5cbmZ1bmN0aW9uIGdsc2xCdWlsdGluQmluYXJ5KGZuYW1lOiBzdHJpbmcpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSBgJHtmbmFtZX1fYDtcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KGEsIGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KHYxLCB2Mik7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cblxuY29uc3QgY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSxcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IHRleHR1cmVUeXBlID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgPyBUZXh0dXJlVHlwZS5wYWNrZWQgOiBUZXh0dXJlVHlwZS51bnBhY2tlZDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgIGlucHV0TmFtZXM6IFsnQScsICdCJ10sXG4gICAgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlLCB0ZXh0dXJlVHlwZV0sXG4gICAgY2FjaGVIaW50OiBjYWNoZUtleSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0cywgZ2xzbEZ1bmMsIG91dHB1dFRlbnNvclR5cGUpLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm8gPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgdGV4dHVyZVR5cGUgPSBoYW5kbGVyLnNlc3Npb24ucGFjayA/IFRleHR1cmVUeXBlLnBhY2tlZCA6IFRleHR1cmVUeXBlLnVucGFja2VkO1xuICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3QgdXNlUGFja2VkVGV4dHVyZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuXG4gIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgZmFsc2UpO1xuICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcbiAgICB9XG4gICAgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVkU2hhcGU7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBhUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCA6IDE7XG4gICAgY29uc3QgYlJhbmsgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyBpbnB1dHNbMV0uZGltcy5sZW5ndGggOiAxO1xuICAgIGNvbnN0IGFCY2FzdCA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/ICdiY2FzdEluZGljZXNfQShpbmRpY2VzLCBhaW5kaWNlcyk7JyA6ICdhaW5kaWNlc1swXSA9IDA7JztcbiAgICBjb25zdCBiQmNhc3QgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyAnYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpOycgOiAnYmluZGljZXNbMF0gPSAwOyc7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gdXNlUGFja2VkVGV4dHVyZVxuICAgICAgPyBgXG4gICAgICAke2dsc2xGdW5jLmJvZHl9XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICB2ZWM0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2dsc2xGdW5jLm5hbWV9KGEsIGIpO1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1gXG4gICAgICA6IGBcbiAgICAgICR7Z2xzbEZ1bmMuYm9keX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtvdXRwdXRSYW5rfV0pIHtcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7YVJhbmt9XTtcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7YlJhbmt9XTtcbiAgICAgICAgJHthQmNhc3R9XG4gICAgICAgICR7YkJjYXN0fVxuICAgICAgICByZXR1cm4gJHtnbHNsRnVuYy5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XG4gICAgICB9YDtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgICAgaW5wdXROYW1lczogWydBJywgJ0InXSxcbiAgICAgIGlucHV0VHlwZXM6IFt0ZXh0dXJlVHlwZSwgdGV4dHVyZVR5cGVdLFxuICAgICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBvdXRwdXRUZW5zb3JUeXBlLCB0ZXh0dXJlVHlwZSB9LFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgaGFzTWFpbjogdXNlUGFja2VkVGV4dHVyZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7Z2xzbEZ1bmMuYm9keX1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IHYxID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgIHZlYzQgdjIgPSAke2dsc2wudGV4dHVyZTJEfShCLCBUZXhDb29yZHMpO1xuICAgICAgdmVjNCByZXN1bHQgPSAke2dsc2xGdW5jLm5hbWV9KHYxLCB2Mik7XG4gICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICB9XG4gICAgYDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGdsc2xGdW5jLm5hbWUsXG4gICAgaW5wdXROYW1lczogWydBJywgJ0InXSxcbiAgICBpbnB1dFR5cGVzOiBbdGV4dHVyZVR5cGUsIHRleHR1cmVUeXBlXSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXRzWzBdLmRpbXMsIHR5cGU6IG91dHB1dFRlbnNvclR5cGUsIHRleHR1cmVUeXBlIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICAgIGhhc01haW46IHRydWUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYWRkID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsQWRkKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGFuZCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEFuZCgpLCAnYm9vbCcpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGRpdiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbERpdigpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBlcXVhbCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEVxdWFsKCksICdib29sJyksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEdyZWF0ZXIoKSwgJ2Jvb2wnKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBsZXNzID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsTGVzcygpLCAnYm9vbCcpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbE11bCgpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBvciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbE9yKCksICdib29sJyksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgcG93ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsUG93KCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBSZWx1ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsUFJlbHUoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3Qgc3ViID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsU3ViKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHhvciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbFhvcigpLCAnYm9vbCcpLCBpbnB1dHMpLFxuXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBQcm90b1V0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IGNhc3Q6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248VGVuc29yLkRhdGFUeXBlPiA9IChcbiAgaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICB0bzogVGVuc29yLkRhdGFUeXBlLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICByZXR1cm4gW2hhbmRsZXIuY2FzdChpbnB1dHNbMF0sIHRvKV07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUZW5zb3IuRGF0YVR5cGU+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBUZW5zb3IuRGF0YVR5cGUgPT5cbiAgUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ3RvJykpO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhc3QgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSwgZ2V0R2xDaGFubmVscyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgQ29uY2F0QXR0cmlidXRlcyB9IGZyb20gJy4vY29uY2F0JztcbmltcG9ydCB7IGdldENoYW5uZWxzLCB1bnBhY2tGcm9tQ2hhbm5lbCB9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1NZXRhZGF0YSA9IChpbnB1dENvdW50OiBudW1iZXIsIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnQ29uY2F0IChwYWNrZWQpJyxcbiAgaW5wdXROYW1lczogQXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRDb3VudCB9LCAoX3YsIGkpID0+IGBYJHtpfWApLFxuICBpbnB1dFR5cGVzOiBBcnJheShpbnB1dENvdW50KS5maWxsKFRleHR1cmVUeXBlLnBhY2tlZCksXG4gIGNhY2hlSGludCxcbn0pO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mbyA9IChcbiAgaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBpZiAoYXhpcyA+PSBpbnB1dFNoYXBlLmxlbmd0aCB8fCBheGlzIDwgLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtcbiAgfVxuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gaW5wdXRTaGFwZS5sZW5ndGggKyBheGlzO1xuICB9XG4gIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3Igd2hpbGUgd2UgZG8gdGhhdFxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGF0YU5TaGFwZSA9IGlucHV0c1tpXS5kaW1zLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgYXhpc0luZGV4ID0gMDsgYXhpc0luZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7IGF4aXNJbmRleCsrKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICBpZiAoYXhpc0luZGV4ID09PSBheGlzKSB7XG4gICAgICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBjb29yZHMgPSBnZXRDaGFubmVscygnY29vcmRzJywgcmFuayk7XG4gIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuXG4gIGNvbnN0IHNoYXBlcyA9IGlucHV0cy5tYXAoKGkpID0+IGkuZGltcyk7XG4gIGNvbnN0IGNoYW5uZWxzID0gZ2V0R2xDaGFubmVscyhyYW5rKTtcbiAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBuZXcgQXJyYXkoc2hhcGVzLmxlbmd0aCAtIDEpO1xuXG4gIG9mZnNldHNbMF0gPSBzaGFwZXNbMF1bYXhpc107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIG9mZnNldHNbaV0gPSBvZmZzZXRzW2kgLSAxXSArIHNoYXBlc1tpXVtheGlzXTtcbiAgfVxuXG4gIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1theGlzXTtcbiAgY29uc3QgbGFzdENoYW5uZWxzID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICBjb25zdCBhbGxDaGFubmVscyA9IGNoYW5uZWxzLmpvaW4oKTtcblxuICBsZXQgZ2V0VmFsdWVTbmlwcGV0ID0gYGlmICgke2NoYW5uZWx9IDwgJHtvZmZzZXRzWzBdfSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFgwKCR7YWxsQ2hhbm5lbHN9KSwgdmVjMigke2xhc3RDaGFubmVscy5qb2luKCl9KSk7XG4gICAgICAgIH1gO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbaSAtIDFdO1xuICAgIGdldFZhbHVlU25pcHBldCArPSBgXG4gICAgICAgICAgICBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1tpXX0gICYmICR7Y2hhbm5lbH0gPj0gJHtvZmZzZXRzW2kgLSAxXX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgZ2V0WCR7aX0oJHtnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgICAgICB2ZWMyKCR7Z2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChsYXN0Q2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KX0pKTtcbiAgICAgICAgICAgIH1gO1xuICB9XG4gIGNvbnN0IGxhc3RJbmRleCA9IG9mZnNldHMubGVuZ3RoO1xuICBjb25zdCBzaGlmdCA9IG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgZ2V0VmFsdWVTbmlwcGV0ICs9IGBcbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICBnZXRYJHtsYXN0SW5kZXh9KCR7Z2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChjaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSksXG4gICAgICAgICAgICAgIHZlYzIoJHtnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGxhc3RDaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSkpO2A7XG5cbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICAke3VucGFja0NoYW5uZWx9XG4gICAgICAgICAgZmxvYXQgZ2V0VmFsdWUoJHtjaGFubmVscy5tYXAoKHgpID0+ICdpbnQgJyArIHgpfSkge1xuICAgICAgICAgICAgJHtnZXRWYWx1ZVNuaXBwZXR9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgJHtkdHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2NoYW5uZWxzW3JhbmsgLSAxXX07XG4gICAgICAgICAgICBjb29yZHMuJHtjaGFubmVsc1tyYW5rIC0gMV19ID0gY29vcmRzLiR7Y2hhbm5lbHNbcmFuayAtIDJdfTtcbiAgICAgICAgICAgIGNvb3Jkcy4ke2NoYW5uZWxzW3JhbmsgLSAyXX0gPSBsYXN0RGltO1xuXG4gICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoJHtjb29yZHN9KSwgMC4sIDAuLCAwLik7XG5cbiAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19ICsgMTtcbiAgICAgICAgICAgIGlmICgke2Nvb3Jkc1tyYW5rIC0gMV19IDwgJHtvdXRwdXRTaGFwZVtyYW5rIC0gMV19KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoJHtjb29yZHN9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDJdfSA9ICR7Y29vcmRzW3JhbmsgLSAyXX0gKyAxO1xuICAgICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAyXX0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19ID0gJHtjb29yZHNbcmFuayAtIDFdfSAtIDE7XG4gICAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDJdfSAmJlxuICAgICAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuXG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGgsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpO1xuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpIH07XG59O1xuXG5jb25zdCBnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0ID0gKGNoYW5uZWxzOiBzdHJpbmdbXSwgY2hhbm5lbDogc3RyaW5nLCBzaGlmdDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2hhbm5lbElkeCA9IGNoYW5uZWxzLmluZGV4T2YoY2hhbm5lbCk7XG4gIGNvbnN0IHJlcyA9IGNoYW5uZWxzLm1hcCgoYywgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA9PT0gY2hhbm5lbElkeCkge1xuICAgICAgcmV0dXJuIGAke2N9IC0gJHtzaGlmdH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzLmpvaW4oKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vY29uY2F0LXBhY2tlZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uY2F0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbmNhdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxDb25jYXRBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2sgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICAgIGlucHV0cyxcbiAgICApO1xuICAgIHJldHVybiBbb3V0cHV0XTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICAgIGlucHV0cyxcbiAgICApO1xuICAgIHJldHVybiBbb3V0cHV0XTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEgPSAoaW5wdXRDb3VudDogbnVtYmVyLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbmNhdCcsXG4gIGlucHV0TmFtZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0Q291bnQgfSwgKF92LCBpKSA9PiBgWCR7aX1gKSxcbiAgaW5wdXRUeXBlczogQXJyYXkoaW5wdXRDb3VudCkuZmlsbChUZXh0dXJlVHlwZS51bnBhY2tlZCksXG4gIGNhY2hlSGludCxcbn0pO1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1JbmZvID0gKFxuICBfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBpZiAoYXhpcyA+PSBpbnB1dFNoYXBlLmxlbmd0aCB8fCBheGlzIDwgLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtcbiAgfVxuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gaW5wdXRTaGFwZS5sZW5ndGggKyBheGlzO1xuICB9XG4gIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3Igd2hpbGUgd2UgZG8gdGhhdFxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGF0YU5TaGFwZSA9IGlucHV0c1tpXS5kaW1zLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgYXhpc0luZGV4ID0gMDsgYXhpc0luZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7IGF4aXNJbmRleCsrKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICBpZiAoYXhpc0luZGV4ID09PSBheGlzKSB7XG4gICAgICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplSW5Db25jYXRBeGlzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYXhpc107XG4gICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICB9XG5cbiAgbGV0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSAnJztcbiAgLy8gaW4gbW9zdCBjYXNlcyBsaW5lYXIgc2VhcmNoIGlzIHN1ZmZpY2llbnQsIGFzIGluIG1vc3Qgc2NlbmFyaW9zLCBvbmx5IDIgdGVuc29ycyBhcmUgY29uY2F0ZW5hdGVkXG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgNSkge1xuICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzQmluYXJ5U2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuICB9XG5cbiAgY29uc3QgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kID0gZ2V0RmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kKGlucHV0cy5sZW5ndGgsIHJhbmspO1xuICBjb25zdCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2QgPSBnZXRHZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2Qoc2l6ZUluQ29uY2F0QXhpcyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgJHtmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2R9XG4gICAgICAgICR7Z2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4TWV0aG9kfVxuICAgICAgICAke2dldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2R9XG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtheGlzfV0pO1xuXG4gICAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtheGlzfV0gPSBpbmRpY2VzWyR7YXhpc31dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xuICAgICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCwgYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gIHJldHVybiB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcy5heGlzKSB9O1xufTtcblxuY29uc3QgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0xpbmVhclNlYXJjaCA9IChzaXplSW5Db25jYXRBeGlzOiBudW1iZXJbXSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHNlYXJjaEF4aXMgPSBzaXplSW5Db25jYXRBeGlzLm1hcChcbiAgICAoc2l6ZSwgaSkgPT4gYGlmKGluZGV4PCR7c2l6ZX0pIHtyZXR1cm4gJHtpfTt9XG5gLFxuICApO1xuICByZXR1cm4gYGludCBnZXRUZXh0dXJlV2hlcmVEYXRhUmVzaWRlcyhpbnQgaW5kZXgpIHtcbiAgICAgICR7c2VhcmNoQXhpcy5qb2luKCcnKX1cbiAgICB9YDtcbn07XG5cbi8vIFRPRE86IEltcGxlbWVudCBCaW5hcnlTZWFyY2ggaW4gR0xTTFxuY29uc3QgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0JpbmFyeVNlYXJjaCA9IChzaXplSW5Db25jYXRBeGlzOiBudW1iZXJbXSk6IHN0cmluZyA9PlxuICBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuXG5jb25zdCBnZXRGZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2QgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcikgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0ZW5zb3JSYW5rfV0pIHtgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaCgnXFx0JyArIGBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSB7IHJldHVybiBfWCR7aX0oaW5kaWNlcyk7IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgIH1cbiAgfVxuICBjb2RlTGluZXMucHVzaCgnXFx0JyArICd9Jyk7XG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBnZXRHZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2QgPSAoc2l6ZUluQ29uY2F0QXhpczogbnVtYmVyW10pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gWydpbnQgZ2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4KGludCBpbmRleCkgeyddO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuICR7c2l6ZUluQ29uY2F0QXhpc1tpXX07IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSB7IHJldHVybiAke3NpemVJbkNvbmNhdEF4aXNbaV19OyB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKCdcXHQnICsgYGVsc2UgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuICR7c2l6ZUluQ29uY2F0QXhpc1tpXX07IH1gKTtcbiAgICB9XG4gIH1cbiAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyAnfScpO1xuXG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbmNhdEF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnKSB9KTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS50eXBlO1xuICBjb25zdCBpbnB1dERpbWVuc2lvbmFsaXR5ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuXG4gIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGNvbmNhdFxuICBpZiAoaW5wdXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgdHlwZXMgb2YgYWxsIGlucHV0cyBtYXRjaFxuICAgIGlmIChpbnB1dC50eXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dERpbWVuc2lvbmFsaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IE1BWF9DTElQLCBNSU5fQ0xJUCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgRnVuY3Rpb25UeXBlLCBHbHNsVmFsdWVGdW5jdGlvbiB9IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBYnMoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYWJzJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFjb3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYWNvcycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBc2luKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2FzaW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQXRhbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhdGFuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbENlaWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnY2VpbCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDb3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnY29zJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEVsdShhbHBoYTogbnVtYmVyKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2VsdSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGNvbnN0IGZsb2F0IGFscGhhID0gZmxvYXQoJHthbHBoYX0pO1xuXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYSA+PSAwLjAgPyBhOiAoZXhwKGEpIC0gMS4wKSAqIGFscGhhO1xuICB9XG4gIHZlYzQgJHtuYW1lfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoJHtuYW1lfV8odi54KSwgJHtuYW1lfV8odi55KSwgJHtuYW1lfV8odi56KSwgJHtuYW1lfV8odi53KSk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRXhwKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2V4cCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xGbG9vcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdmbG9vcicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDbGlwKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdjbGlwJztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHttaW59KTtcbiAgY29uc3QgZmxvYXQgbWF4ID0gZmxvYXQoJHttYXh9KTtcblxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsSWRlbnRpdHkoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2luZGVudGl0eSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbExlYWt5UmVsdShhbHBoYTogbnVtYmVyKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2xlYWt5UmVsdSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGNvbnN0IGZsb2F0IGFscGhhID0gZmxvYXQoJHthbHBoYX0pO1xuXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdmVjNCgke25hbWV9Xyh2LngpLCAke25hbWV9Xyh2LnkpLCAke25hbWV9Xyh2LnopLCAke25hbWV9Xyh2LncpKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xMb2coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnbG9nJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE5lZygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbmVnJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAtYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiAtdjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xOb3QoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ25vdCc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xuICB9XG4gIGJvb2wgJHtuYW1lfV8oYm9vbCBhKSB7XG4gICAgcmV0dXJuICFhO1xuICB9XG4gIHZlYzQgJHtuYW1lfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XG4gIH1cbiAgYnZlYzQgJHtuYW1lfV8oYnZlYzQgdikge1xuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnc2luJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFJlbHUoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3JlbHUnO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaWdtb2lkKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdzaWdtb2lkJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1hKSk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtdikpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNxcnQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnc3FydCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xUYW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgndGFuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFRhbmgoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3RhbmgnO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgYSA9IGNsYW1wKGEsIC0xMC4sIDEwLik7XG4gICAgYSA9IGV4cCgyLiphKTtcbiAgICByZXR1cm4gKGEgLSAxLikgLyAoYSArIDEuKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHYgPSBjbGFtcCh2LCAtMTAuLCAxMC4pO1xuICAgIHYgPSBleHAoMi4qdik7XG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmZ1bmN0aW9uIGdsc2xCdWlsdGluVW5hcnkobmFtZTogc3RyaW5nKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuICR7bmFtZX0oYSk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gJHtuYW1lfSh2KTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuXG4vLy8vL1xuLy8vLy9cbi8vLy8vXG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaW5wdXQ6IFRlbnNvcixcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB0ZXh0dXJlVHlwZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID8gVGV4dHVyZVR5cGUucGFja2VkIDogVGV4dHVyZVR5cGUudW5wYWNrZWQ7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGUgfSxcbiAgICBzaGFkZXJTb3VyY2U6IGBcbiAgICAgJHtnbHNsRnVuYy5ib2R5fVxuICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgdmVjNCB2ID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgICB2ID0gJHtnbHNsRnVuYy5uYW1lfV8odik7XG4gICAgICAgJHtnbHNsLm91dHB1dH0gPSB2O1xuICAgICB9XG4gICAgIGAsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICBjYWNoZUtleT86IHN0cmluZyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgdGV4dHVyZVR5cGUgPSBoYW5kbGVyLnNlc3Npb24ucGFjayA/IFRleHR1cmVUeXBlLnBhY2tlZCA6IFRleHR1cmVUeXBlLnVucGFja2VkO1xuICBjb25zdCBtZXRhZGF0YSA9IHsgbmFtZTogZ2xzbEZ1bmMubmFtZSwgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlXSwgaW5wdXROYW1lczogWydBJ10sIGNhY2hlSGludDogY2FjaGVLZXkgfTtcbiAgcmV0dXJuIHsgLi4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXQsIGdsc2xGdW5jKSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFicyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQWJzKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGFjb3MgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbEFjb3MoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQXNpbigpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBhdGFuID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xBdGFuKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGlwQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG1pbjogbnVtYmVyO1xuICByZWFkb25seSBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpbnB1dHNbMF0sXG4gICAgICBnbHNsQ2xpcChhdHRyaWJ1dGVzLm1pbiwgYXR0cmlidXRlcy5tYXgpLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICApLFxuICAgIGlucHV0cyxcbiAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNsaXBBdHRyaWJ1dGVzID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDbGlwQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIG1pbjogbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdtaW4nLCBNSU5fQ0xJUCksXG4gICAgbWF4OiBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21heCcsIE1BWF9DTElQKSxcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCBjbGlwVjExID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGhhbmRsZXIsIGlucHV0cyk7XG4gIHJldHVybiBjbGlwKGhhbmRsZXIsIFtpbnB1dHNbMF1dLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKFxuICAgIGlucHV0cy5sZW5ndGggPj0gMyAmJlxuICAgICghaGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzFdLmRhdGFJZCkgfHwgIWhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgY2xpcCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZCcpO1xuICB9XG5cbiAgY29uc3QgbWluID0gaW5wdXRzLmxlbmd0aCA+PSAzID8gaW5wdXRzWzFdLm51bWJlckRhdGFbMF0gOiBNSU5fQ0xJUDtcbiAgY29uc3QgbWF4ID0gaW5wdXRzLmxlbmd0aCA+PSAzID8gaW5wdXRzWzJdLm51bWJlckRhdGFbMF0gOiBNQVhfQ0xJUDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG1pbiwgbWF4IH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNlaWwgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbENlaWwoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgY29zID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xDb3MoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVsdUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhbHBoYTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZWx1ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogRWx1QXR0cmlidXRlcyk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xFbHUoYXR0cmlidXRlcy5hbHBoYSksIGF0dHJpYnV0ZXMuY2FjaGVLZXkpLFxuICAgIGlucHV0cyxcbiAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IEVsdUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYWxwaGE6IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAxLjApIH0pO1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xFeHAoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgZmxvb3IgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbEZsb29yKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xJZGVudGl0eSgpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVha3lSZWx1QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogTGVha3lSZWx1QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xMZWFreVJlbHUoYXR0cmlidXRlcy5hbHBoYSksIGF0dHJpYnV0ZXMuY2FjaGVLZXkpLFxuICAgIGlucHV0cyxcbiAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IExlYWt5UmVsdUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYWxwaGE6IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAxKSB9KTtcblxuZXhwb3J0IGNvbnN0IGxvZyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTG9nKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IG5lZyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTmVnKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IG5vdCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTm90KCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFJlbHUoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3Qgc2lnbW9pZCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsU2lnbW9pZCgpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBzaW4gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFNpbigpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xTcXJ0KCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHRhbiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsVGFuKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHRhbmggPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFRhbmgoKSksIGlucHV0cyksXG5dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHsgTUFYX0NMSVAsIE1JTl9DTElQIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBHbHNsVmFsdWVGdW5jdGlvbiB9IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG5pbXBvcnQgeyBnbHNsQ2xpcCwgZ2xzbFJlbHUsIGdsc2xTaWdtb2lkIH0gZnJvbSAnLi91bmFyeS1vcCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGFjdGl2YXRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgY2xpcE1pbj86IG51bWJlcjtcbiAgcmVhZG9ubHkgY2xpcE1heD86IG51bWJlcjtcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbkNhY2hlS2V5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSB7XG4gIGxldCBmdW5jOiBHbHNsVmFsdWVGdW5jdGlvbjtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24pIHtcbiAgICBjYXNlICdSZWx1JzpcbiAgICAgIGZ1bmMgPSBnbHNsUmVsdSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICBmdW5jID0gZ2xzbFNpZ21vaWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NsaXAnOlxuICAgICAgZnVuYyA9IGdsc2xDbGlwKGF0dHJpYnV0ZXMuY2xpcE1pbiEsIGF0dHJpYnV0ZXMuY2xpcE1heCEpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyBhY3RpdmF0aW9uRnVuY3Rpb246ICcnLCBhcHBseUFjdGl2YXRpb246ICcnIH07XG4gIH1cblxuICBjb25zdCBhY3RpdmF0aW9uTmFtZSA9IGZ1bmMubmFtZTtcbiAgY29uc3QgYWN0aXZhdGlvbkZ1bmN0aW9uID0gZnVuYy5ib2R5O1xuICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBgdmFsdWUgPSAke2FjdGl2YXRpb25OYW1lfV8odmFsdWUpO2A7XG4gIHJldHVybiB7IGFjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9uIH07XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0cmlidXRlKTogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb24gPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYWN0aXZhdGlvbicsICcnKTtcblxuICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgY29uc3QgW2NsaXBNaW4sIGNsaXBNYXhdID0gYXR0cmlidXRlcy5nZXRGbG9hdHMoJ2FjdGl2YXRpb25fcGFyYW1zJywgW01JTl9DTElQLCBNQVhfQ0xJUF0pO1xuICAgIHJldHVybiB7IGFjdGl2YXRpb24sIGNsaXBNYXgsIGNsaXBNaW4sIGFjdGl2YXRpb25DYWNoZUtleTogYCR7YWN0aXZhdGlvbn06JHtjbGlwTWlufSwke2NsaXBNYXh9YCB9O1xuICB9XG4gIHJldHVybiB7IGFjdGl2YXRpb24sIGFjdGl2YXRpb25DYWNoZUtleTogYWN0aXZhdGlvbiB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY2FsY3VsYXRlT3V0cHV0U2hhcGUsIENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jb252JztcbmltcG9ydCB7IGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZyk6IFByb2dyYW1NZXRhZGF0YSA9PiAoe1xuICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQmlhcyddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhc1xuICAgID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG4gICAgOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gZ2V0QmlhcyhvdXRwdXRfY2hhbm5lbCk7JyA6ICcnO1xuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgJ0dyb3VwZWRDb252JyxcbiAgICBgYXV0cFBhZDoke2F0dHJpYnV0ZXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke2F0dHJpYnV0ZXMuZGlsYXRpb25zfSwgZ3JvdXA6JHthdHRyaWJ1dGVzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVcbiAgICB9LCBwYWRzOiR7YXR0cmlidXRlcy5wYWRzfSwgc3RyaWRlczoke2F0dHJpYnV0ZXMuc3RyaWRlc31gLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhTaGFwZSwgd1NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHsgYWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb24gfSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfSwgJHthdHRyaWJ1dGVzLnN0cmlkZXNbMV19KTtcbiAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7YXR0cmlidXRlcy5wYWRzWzBdfSwgJHthdHRyaWJ1dGVzLnBhZHNbMV19KTtcbiAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gIHZvaWQgbWFpbigpIHtcbiAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICBpbnQgb3V0cHV0X2NoYW5uZWwgPSBjb29yZHMueTtcbiAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMuencgKiBzdHJpZGVzIC0gcGFkcztcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7b3V0cHV0Q2hhbm5lbHNQZXJHcm91cH07XG5cbiAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7d1NoYXBlWzFdfTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHt3U2hhcGVbMV19ICsgd0luQ2hhbm5lbDtcbiAgICAgIGZvciAoaW50IHdIZWlnaHQgPSAwOyB3SGVpZ2h0IDwgJHt3U2hhcGVbMl19OyB3SGVpZ2h0KyspIHtcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDAgfHwgeEhlaWdodCA+PSAke3hTaGFwZVsyXX0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaW50IHdXaWR0aCA9IDA7IHdXaWR0aCA8ICR7d1NoYXBlWzNdfTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzFdfTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMCB8fCB4V2lkdGggPj0gJHt4U2hhcGVbM119KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcbiAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhvdXRwdXRfY2hhbm5lbCwgd0luQ2hhbm5lbCwgd1dpZHRoLCB3SGVpZ2h0KTtcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgJHtwcm9jZXNzQmlhc31cbiAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQodmFsdWUsIC4wLCAuMCwgLjApO1xuICB9XG5gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzKSxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyB1bnBhY2tGcm9tQ2hhbm5lbCB9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1NZXRhZGF0YSA9IChjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0ltMkNvbCAocGFja2VkKScsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIHg6IFRlbnNvcixcbiAgdzogVGVuc29yLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB4c2hhcGUgPSB4LmRpbXM7XG4gIGNvbnN0IHdzaGFwZSA9IHcuZGltcztcbiAgY29uc3Qgcm93RGltID0gMjtcbiAgY29uc3QgY29sRGltID0gMztcbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgaW0yY29sU2hhcGUgPSBbd3NoYXBlWzFdICogd3NoYXBlWzJdICogd3NoYXBlWzNdLCBvdXRwdXRTaGFwZVsyXSAqIG91dHB1dFNoYXBlWzNdXTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IHdzaGFwZVsyXSAqIHdzaGFwZVszXTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgbGV0IHVucm9sbGVkID0gJyc7XG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDw9IDE7IGNvbCsrKSB7XG4gICAgICB1bnJvbGxlZCArPSBgXG4gICAgICAgICAgICBibG9ja0luZGV4ID0gcmMueCArICR7Y29sfTtcbiAgICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3Jvd307XG5cbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke2ltMmNvbFNoYXBlWzFdfSAmJiBwb3MgPCAke2ltMmNvbFNoYXBlWzBdfSkge1xuICAgICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoJHtvdXRwdXRTaGFwZVtyYW5rIC0gMV19KSkgKiAke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0gLVxuICAgICAgICAgICAgICAgICR7YXR0cmlidXRlcy5wYWRzWzBdfTtcbiAgICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXX0gKiAoaW1vZChwb3MsICR7a2VybmVsU2l6ZX0pIC8gJHt3c2hhcGVbMl19KTtcblxuICAgICAgICAgICAgICBpZihkMCA8ICR7eHNoYXBlW3Jvd0RpbV19ICYmIGQwID49IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gaW1vZChibG9ja0luZGV4LCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pICogJHthdHRyaWJ1dGVzLnN0cmlkZXNbMV19IC1cbiAgICAgICAgICAgICAgICAgICR7YXR0cmlidXRlcy5wYWRzWzFdfTtcbiAgICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7a2VybmVsU2l6ZX0pLCAke3dzaGFwZVsyXX0pO1xuXG4gICAgICAgICAgICAgICAgaWYoZDEgPCAke3hzaGFwZVtjb2xEaW1dfSAmJiBkMSA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgIGNoID0gaW50KGZsb2F0KHBvcykvICR7a2VybmVsU2l6ZX0uKTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJHtyb3cgKiAyICsgY29sfV0gPSBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgICAgICAgIGdldEEoMCwgY2gsIGludChpbm5lckRpbXMueCksXG4gICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBgO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7dW5wYWNrQ2hhbm5lbH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xuICAgICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XG4gICAgICAgICAgdmVjMiBpbm5lckRpbXM7XG4gICAgICAgICAgJHt1bnJvbGxlZH1cbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IGltMmNvbFNoYXBlLCB0eXBlOiB4LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICB4OiBUZW5zb3IsXG4gIHc6IFRlbnNvcixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtTWV0YWRhdGEoYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgeCwgdywgb3V0cHV0U2hhcGUsIGF0dHJpYnV0ZXMpLFxuICB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGdldENvb3Jkc0RhdGFUeXBlLCBnZXRHbENoYW5uZWxzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBnZXRBY3RpdmF0aW9uU25pcHBldCwgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyIH0gZnJvbSAnLi9tYXRtdWwtcGFjayc7XG5cbmV4cG9ydCBjb25zdCBtYXRNdWw6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICByZXR1cm4gW2luZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaW5mZXJlbmNlSGFuZGxlci5ydW4oY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5wdXRzLCBhdHRyaWJ1dGVzKSwgaW5wdXRzKV07XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1hdE11bEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0+IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhub2RlLmF0dHJpYnV0ZXMpO1xuXG5jb25zdCBjcmVhdGVNYXRtdWxQcm9ncmFtTWV0YWRhdGEgPSAoaGFzQmlhczogYm9vbGVhbiwgY2FjaGVIaW50OiBzdHJpbmcpID0+ICh7XG4gIG5hbWU6ICdNYXRNdWwnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydBJywgJ0InLCAnQmlhcyddIDogWydBJywgJ0InXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhc1xuICAgID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG4gICAgOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFTaGFwZSwgYlNoYXBlLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gIH1cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBhbGxHbENoYW5uZWxzID0gZ2V0R2xDaGFubmVscygpO1xuICBjb25zdCB7IGFjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9uIH0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcyk7XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gZ2V0Qmlhc0Zvck1hdG11bCgpOycgOiAnJztcbiAgY29uc3QgZ2V0Qmlhc0Zvck1hdG11bFNuaXBwZXQgPSBoYXNCaWFzXG4gICAgPyBgJHtnZXRCaWFzRm9yTWF0bXVsKGNvb3Jkc0RhdGFUeXBlLCBhbGxHbENoYW5uZWxzLCBpbnB1dHNbMl0uZGltcywgb3V0cHV0U2hhcGUsIGZhbHNlKX1gXG4gICAgOiAnJztcblxuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBhcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGJyYW5rID0gYlNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhcmVkRGltID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgICR7Z2V0Qmlhc0Zvck1hdG11bFNuaXBwZXR9XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgYVske2FyYW5rfV07XG4gICAgICAgIGludCBiWyR7YnJhbmt9XTtcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0EoaW5kaWNlcywgYSk7XG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xuXG4gICAgICAgIGZsb2F0IHZhbHVlO1xuICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtzaGFyZWREaW19OyArK2spIHtcbiAgICAgICAgICAgIGFbJHthcmFuayAtIDF9XSA9IGs7XG4gICAgICAgICAgICBiWyR7YnJhbmsgLSAyfV0gPSBrO1xuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcbiAgICAgICAgfVxuICAgICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyIHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVNYXRtdWxQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCA+IDIsIGFjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb25DYWNoZUtleSk7XG4gIHJldHVybiB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1ldGFkYXRhLCBpbnB1dHMsIGFjdGl2YXRpb25BdHRyaWJ1dGVzKSB9O1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bCByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXSAhPT0gaW5wdXRzWzFdLmRpbXNbaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guJyk7XG4gIH1cblxuICBpZiAoXG4gICAgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAoaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0NjQnKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaCcpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qmlhc0Zvck1hdG11bChcbiAgY29vcmRzRGF0YVR5cGU6IHN0cmluZyxcbiAgYWxsR2xDaGFubmVsczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIGluU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzUGFja2VkOiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICBjb25zdCBpblJhbmsgPSBpblNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0UmFuayA9IG91dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICB9IGVsc2Uge1xuICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGluU2hhcGUubWFwKChfcywgaSkgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbaSArIHJhbmtEaWZmXX1gKS5qb2luKCcsICcpO1xuICB9XG4gIGNvbnN0IGJyb2FkY2FzdERpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpO1xuICBjb25zdCBjb29yZHNTbmlwcGV0ID0gYnJvYWRjYXN0RGltcy5tYXAoKGQpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgY29uc3QgaW5TaXplID0gU2hhcGVVdGlsLnNpemUoaW5TaGFwZSk7XG4gIGNvbnN0IGlzSW5wdXRTY2FsYXIgPSBpblNpemUgPT09IDE7XG4gIGxldCBvdXRwdXQgPSAndmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUueXkpJztcbiAgaWYgKGlzSW5wdXRTY2FsYXIpIHtcbiAgICBvdXRwdXQgPSAndmVjNChvdXRwdXRWYWx1ZS54KSc7XG4gIH1cbiAgY29uc3QgZ2V0Qmlhc0Zvck1hdG11bFNvdXJjZSA9IGlzUGFja2VkXG4gICAgPyBgXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke2Nvb3Jkc1NuaXBwZXR9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gIHJldHVybiAke291dHB1dH07XG59YFxuICAgIDogYFxuZmxvYXQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcbiAgJHtjb29yZHNEYXRhVHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICR7Y29vcmRzU25pcHBldH1cbiAgcmV0dXJuIGdldEJpYXMoY29vcmRzLngpO1xufWA7XG5cbiAgcmV0dXJuIGdldEJpYXNGb3JNYXRtdWxTb3VyY2U7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSwgZ2V0R2xDaGFubmVscyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgZ2V0QWN0aXZhdGlvblNuaXBwZXQsIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Qmlhc0Zvck1hdG11bCB9IGZyb20gJy4vbWF0bXVsJztcblxuY29uc3QgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbU1ldGFkYXRhID0gKGhhc0JpYXM6IGJvb2xlYW4sIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnTWF0TXVsIChwYWNrZWQpJyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnQScsICdCJywgJ0JpYXMnXSA6IFsnQScsICdCJ10sXG4gIGlucHV0VHlwZXM6IGhhc0JpYXNcbiAgICA/IFtUZXh0dXJlVHlwZS5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkXVxuICAgIDogW1RleHR1cmVUeXBlLnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7JyA6ICcnO1xuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYVNoYXBlLCBiU2hhcGUsIHRydWUpO1xuICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcblxuICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcbiAgfVxuICBjb25zdCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBzaGFyZWREaW1JbmRleCA9IE1hdGguY2VpbChzaGFyZWREaW0gLyAyKTtcbiAgY29uc3QgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICBjb25zdCBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG5cbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dFJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGFsbEdsQ2hhbm5lbHMgPSBnZXRHbENoYW5uZWxzKCk7XG4gIGNvbnN0IHsgYWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb24gfSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzKTtcblxuICBjb25zdCBnZXRCaWFzRm9yTWF0bXVsU25pcHBldCA9IGhhc0JpYXNcbiAgICA/IGAke2dldEJpYXNGb3JNYXRtdWwoY29vcmRzRGF0YVR5cGUsIGFsbEdsQ2hhbm5lbHMsIGlucHV0c1syXS5kaW1zLCBvdXRwdXRTaGFwZSwgdHJ1ZSl9YFxuICAgIDogJyc7XG5cbiAgY29uc3QgZ2V0QmNhc3RlZFNhbXBsZXJGb3JNYXRtdWxTbmlwcGV0ID0gaXNCcm9hZGNhc3RcbiAgICA/IGAke2dldEJjYXN0U2FtcGxlckZvck1hdG11bChjb29yZHNEYXRhVHlwZSwgYWxsR2xDaGFubmVscywgaW5wdXRzLCBvdXRwdXRTaGFwZSl9YFxuICAgIDogJyc7XG5cbiAgY29uc3QgZ2V0U2FtcGxlckFJbkxvb3BTbmlwcGV0ID0gaXNCcm9hZGNhc3QgPyAnZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpJyA6IGBnZXRBKCR7Z2V0QShhbGxHbENoYW5uZWxzLCBhUmFuayl9KWA7XG4gIGNvbnN0IGdldFNhbXBsZXJCSW5Mb29wU25pcHBldCA9IGlzQnJvYWRjYXN0ID8gJ2dldEJBdE91dENvb3Jkc01hdG11bChpKScgOiBgZ2V0Qigke2dldEIoYWxsR2xDaGFubmVscywgYlJhbmspfSlgO1xuICBjb25zdCBnZXRPdXRwdXRDb29yZHNTbmlwcGV0ID0gaXNCcm9hZGNhc3RcbiAgICA/ICcnXG4gICAgOiBgJHtjb29yZHNEYXRhVHlwZX0gcmMgPVxuICAgICAgICAgIGdldE91dHB1dENvb3JkcygpOyBpbnQgbGFzdERpbSA9IHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMV19OyByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfSA9XG4gICAgICAgICAgcmMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAyXX07IHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19ID0gbGFzdERpbTtcbiAgICAgIGA7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICAgICR7Z2V0QmNhc3RlZFNhbXBsZXJGb3JNYXRtdWxTbmlwcGV0fVxuICAgICAgICAgICAgJHtnZXRCaWFzRm9yTWF0bXVsU25pcHBldH1cbiAgICAgICAgICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAke2dldE91dHB1dENvb3Jkc1NuaXBwZXR9XG5cbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMCk7XG4gICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW1JbmRleH07IGkrKykge1xuICAgICAgICAgICAgICAgIHZlYzQgYSA9ICR7Z2V0U2FtcGxlckFJbkxvb3BTbmlwcGV0fTtcbiAgICAgICAgICAgICAgICB2ZWM0IGIgPSAke2dldFNhbXBsZXJCSW5Mb29wU25pcHBldH07XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5ycmJiICogYi5yZ3JnKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5nZ2FhICogYi5iYWJhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCA+IDIsIGFjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb25DYWNoZUtleSk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhY3RpdmF0aW9uQXR0cmlidXRlcyksXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCY2FzdFNhbXBsZXJGb3JNYXRtdWwoXG4gIGNvb3Jkc0RhdGFUeXBlOiBzdHJpbmcsXG4gIGFsbEdsQ2hhbm5lbHM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBvdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBzdHJpbmcge1xuICBsZXQgdW5wYWNrZWRBQ29vcmRzU25pcHBldCA9IFtdO1xuICBsZXQgdW5wYWNrZWRCQ29vcmRzU25pcHBldCA9IFtdO1xuXG4gIGNvbnN0IGluQVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluQlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgY29uc3QgaW5BUmFuayA9IGluQVNoYXBlLmxlbmd0aDtcbiAgY29uc3QgaW5CUmFuayA9IGluQlNoYXBlLmxlbmd0aDtcblxuICBjb25zdCBvdXRSYW5rID0gb3V0U2hhcGUubGVuZ3RoO1xuICBjb25zdCByYW5rQURpZmYgPSBvdXRSYW5rIC0gaW5BUmFuaztcbiAgY29uc3QgcmFua0JEaWZmID0gb3V0UmFuayAtIGluQlJhbms7XG5cbiAgdW5wYWNrZWRBQ29vcmRzU25pcHBldCA9IGluQVNoYXBlLm1hcCgoX3MsIGkpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2kgKyByYW5rQURpZmZdfWApO1xuICB1bnBhY2tlZEFDb29yZHNTbmlwcGV0W2luQVJhbmsgLSAxXSA9ICdpKjInO1xuICB1bnBhY2tlZEFDb29yZHNTbmlwcGV0LmpvaW4oJywgJyk7XG4gIHVucGFja2VkQkNvb3Jkc1NuaXBwZXQgPSBpbkJTaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tpICsgcmFua0JEaWZmXX1gKTtcbiAgdW5wYWNrZWRCQ29vcmRzU25pcHBldFtpbkJSYW5rIC0gMl0gPSAnaSoyJztcbiAgdW5wYWNrZWRCQ29vcmRzU25pcHBldC5qb2luKCcsICcpO1xuXG4gIGNvbnN0IGJyb2FkY2FzdEFEaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluQVNoYXBlLCBvdXRTaGFwZSk7XG4gIGNvbnN0IGJyb2FkY2FzdEJEaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluQlNoYXBlLCBvdXRTaGFwZSk7XG5cbiAgY29uc3QgY29vcmRzQVNuaXBwZXQgPSBicm9hZGNhc3RBRGltcy5tYXAoKGQpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2QgKyByYW5rQURpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gIGNvbnN0IGNvb3Jkc0JTbmlwcGV0ID0gYnJvYWRjYXN0QkRpbXMubWFwKChkKSA9PiBgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tkICsgcmFua0JEaWZmXX0gPSAwO2ApLmpvaW4oJ1xcbicpO1xuICBjb25zdCBzd2FwRGltU25pcHBldCA9IGBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfTtcbiAgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMV19ID0gY29vcmRzLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19O1xuICBjb29yZHMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAyXX0gPSBsYXN0RGltO2A7XG5cbiAgY29uc3QgZ2V0QmNhc3RTYW1wbGVyTWF0bXVsU291cmNlID0gYFxudmVjNCBnZXRBQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcbiAgJHtjb29yZHNEYXRhVHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICR7c3dhcERpbVNuaXBwZXR9XG4gICR7Y29vcmRzQVNuaXBwZXR9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7dW5wYWNrZWRBQ29vcmRzU25pcHBldH0pO1xuICByZXR1cm4gb3V0cHV0VmFsdWU7XG59XG5cbnZlYzQgZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke3N3YXBEaW1TbmlwcGV0fVxuICAke2Nvb3Jkc0JTbmlwcGV0fVxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qigke3VucGFja2VkQkNvb3Jkc1NuaXBwZXR9KTtcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufWA7XG5cbiAgcmV0dXJuIGdldEJjYXN0U2FtcGxlck1hdG11bFNvdXJjZTtcbn1cblxuZnVuY3Rpb24gZ2V0QShhbGxHbENoYW5uZWxzOiBzdHJpbmdbXSwgcmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAyOyBpKyspIHtcbiAgICByZXMgKz0gYHJjLiR7YWxsR2xDaGFubmVsc1tpXX0sIGA7XG4gIH1cbiAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDJdfSwgYCArICdpKjInO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRCKGFsbEdsQ2hhbm5lbHM6IHN0cmluZ1tdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgcmVzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7IGkrKykge1xuICAgIHJlcyArPSBgcmMuJHthbGxHbENoYW5uZWxzW2ldfSwgYDtcbiAgfVxuICByZXMgKz0gJ2kqMiwgJyArIGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDFdfWA7XG4gIHJldHVybiByZXM7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmltcG9ydCB7IGNhbGN1bGF0ZU91dHB1dFNoYXBlLCBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vaW0yY29sLXBhY2snO1xuaW1wb3J0IHsgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL21hdG11bC1wYWNrJztcblxuZXhwb3J0IGNvbnN0IGNvbnYyRFBhY2tlZFBvaW50d2lzZSA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzKTtcbiAgY29uc3QgcmVzaGFwZWRYID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlUGFja2VkKGlucHV0c1swXSwgW3hzaGFwZVsxXSwgeHNoYXBlWzJdICogeHNoYXBlWzNdXSk7XG4gIGNvbnN0IHJlc2hhcGVkSyA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMV0sIFtrc2hhcGVbMF0sIGtzaGFwZVsxXV0pO1xuXG4gIGNvbnN0IG1hdG11bElucHV0cyA9IGlucHV0cy5sZW5ndGggPiAyID8gW3Jlc2hhcGVkSywgcmVzaGFwZWRYLCBpbnB1dHNbMl1dIDogW3Jlc2hhcGVkSywgcmVzaGFwZWRYXTtcbiAgY29uc3QgbWF0bXVsT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgbWF0bXVsSW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICBtYXRtdWxJbnB1dHMsXG4gICk7XG4gIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVQYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udjJEUGFja2VkID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuKTogVGVuc29yID0+IHtcbiAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhzaGFwZSwga3NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuXG4gIC8vIHJ1biBpbTJjb2xcbiAgY29uc3QgaW0yY29sT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgICBbaW5wdXRzWzBdXSxcbiAgKTtcblxuICAvLyByZXNoYXBlIGtlcm5lbFxuICBjb25zdCBrZXJuZWxSZXNoYXBlZCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMV0sIFtrc2hhcGVbMF0sIGtzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXV0pO1xuXG4gIC8vIHJ1biBtYXRtdWxcbiAgY29uc3QgbWF0bXVsSW5wdXRzID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0LCBpbnB1dHNbMl1dIDogW2tlcm5lbFJlc2hhcGVkLCBpbTJjb2xPdXRwdXRdO1xuICBjb25zdCBtYXRtdWxPdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBtYXRtdWxJbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIG1hdG11bElucHV0cyxcbiAgKTtcblxuICAvLyByZXNoYXBlIG91dHB1dFxuICBjb25zdCBvdXRwdXRSZXNoYXBlZCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChtYXRtdWxPdXRwdXQsIG91dHB1dFNoYXBlKTtcbiAgcmV0dXJuIG91dHB1dFJlc2hhcGVkO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL2NvbnYnO1xuXG5jb25zdCBjcmVhdGVJbTJDb2xQcm9ncmFtTWV0YWRhdGEgPSAoY2FjaGVIaW50OiBzdHJpbmcpID0+ICh7XG4gIG5hbWU6ICdJbTJDb2wnLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvID0gKFxuICBfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICB4OiBUZW5zb3IsXG4gIHc6IFRlbnNvcixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeHNoYXBlID0geC5kaW1zO1xuICBjb25zdCB3c2hhcGUgPSB3LmRpbXM7XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgaW0yY29sRGltcyA9IGNhbGN1bGF0ZUltMkNvbERpbXMoeHNoYXBlLCB3c2hhcGUsIG91dHB1dFNoYXBlLCA0KTtcblxuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgIGNvbnN0IGludCBYQyA9ICR7eHNoYXBlWzFdfTtcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHt4c2hhcGVbMl19O1xuICAgICAgICBjb25zdCBpbnQgWFcgPSAke3hzaGFwZVszXX07XG4gICAgICAgIGNvbnN0IGludCBLSCA9ICR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVswXX07XG4gICAgICAgIGNvbnN0IGludCBLVyA9ICR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVsxXX07XG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfTtcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uVyA9ICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19O1xuICAgICAgICBjb25zdCBpbnQgc3RyaWRlSCA9ICR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfTtcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX07XG4gICAgICAgIGNvbnN0IGludCBwYWRIID0gJHthdHRyaWJ1dGVzLnBhZHNbMF19O1xuICAgICAgICBjb25zdCBpbnQgcGFkVyA9ICR7YXR0cmlidXRlcy5wYWRzWzFdfTtcbiAgICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcbiAgICAgICAgY29uc3QgaW50IFhDS0hLVyA9IFhDICogS0hLVztcbiAgICAgICAgY29uc3QgaW50IG91dHB1dENoYW5uZWxzID0gNDtcbiAgICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IGIgID0gaW5kaWNlc1swXTsgLy8gYmF0Y2ggc2l6ZVxuICAgICAgICAgIGludCBvaCA9IGluZGljZXNbMV0gKiBzdHJpZGVIIC0gcGFkSDsgLy9vdXRwdXQgaGVpZ2h0XG4gICAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxuICAgICAgICAgIGludCBwID0gaW5kaWNlc1szXSAqIG91dHB1dENoYW5uZWxzOyAvL3BhdGNoXG4gICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgICAgIGlmKHAgPCBYQ0tIS1cpIHtcbiAgICAgICAgICAgICAgaW50IHBhdGNoQyA9IHAgLyBLSEtXO1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcbiAgICAgICAgICAgICAgaW50IHBhdGNoVyA9IChwIC0gcGF0Y2hDKktIS1cpIC0gcGF0Y2hIICogS1c7XG4gICAgICAgICAgICAgIGludCB4aDIgPSBvaCArIHBhdGNoSCAqIGRpbGF0aW9uSDtcbiAgICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xuICAgICAgICAgICAgICBpbnQgeFske3hzaGFwZS5sZW5ndGh9XTtcbiAgICAgICAgICAgICAgeFswXSA9IGI7XG4gICAgICAgICAgICAgIHhbMV0gPSBwYXRjaEM7XG4gICAgICAgICAgICAgIHhbMl0gPSB4aDI7XG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XG4gICAgICAgICAgICAgIGlmKHhoMiA+PSAwICYmXG4gICAgICAgICAgICAgICAgICB4aDIgPCBYSCAmJlxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcbiAgICAgICAgICAgICAgICAgIHh3MiA8IFhXKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfWCh4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW0yY29sRGltcywgdHlwZTogeC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICB4OiBUZW5zb3IsXG4gIHc6IFRlbnNvcixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVJbTJDb2xQcm9ncmFtTWV0YWRhdGEoYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgZ2V0OiAoKSA9PiBjcmVhdGVJbTJDb2xQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgeCwgdywgb3V0cHV0U2hhcGUsIGF0dHJpYnV0ZXMpLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUltMkNvbERpbXMgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgY2hhbm5lbHMgPSA0LFxuKTogbnVtYmVyW10gPT4gW1xuICBvdXRwdXRTaGFwZVswXSxcbiAgb3V0cHV0U2hhcGVbMl0sXG4gIG91dHB1dFNoYXBlWzNdLFxuICBNYXRoLmNlaWwoKGlucHV0U2hhcGVbMV0gKiBrZXJuZWxTaGFwZVsyXSAqIGtlcm5lbFNoYXBlWzNdKSAvIGNoYW5uZWxzKSxcbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGdldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUltMkNvbERpbXMgfSBmcm9tICcuL2ltMmNvbCc7XG5cbmNvbnN0IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtTWV0YWRhdGEgPSAoaGFzQmlhczogYm9vbGVhbiwgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykgPT4gKHtcbiAgbmFtZTogJ0NvbnZEb3RQcm9kdWN0JyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnSW0yQ29sJywgJ0snLCAnQiddIDogWydJbTJDb2wnLCAnSyddLFxuICBpbnB1dFR5cGVzOiBoYXNCaWFzXG4gICAgPyBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24sIFRleHR1cmVUeXBlLnVucGFja2VkXVxuICAgIDogW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXSxcbiAgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5LFxufSk7XG5cbmNvbnN0IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgYWRqdXN0ZWRLZXJuZWxTaGFwZSA9IFtrc2hhcGVbMF0sIE1hdGguY2VpbCgoeHNoYXBlWzFdICoga3NoYXBlWzJdICoga3NoYXBlWzNdKSAvIDQpXTtcbiAgY29uc3QgaW0yY29sU2hhcGUgPSBjYWxjdWxhdGVJbTJDb2xEaW1zKHhzaGFwZSwga3NoYXBlLCBvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IFtrV2lkdGgsIGtIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgYWRqdXN0ZWRLZXJuZWxTaGFwZSxcbiAgICBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLFxuICApO1xuXG4gIGNvbnN0IGltMmNvbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW0yY29sU2hhcGUpO1xuICBjb25zdCBbaW0yY29sV2lkdGgsIGltMmNvbEhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBpbTJjb2xTaGFwZSxcbiAgICBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLFxuICApO1xuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IGluaXRWYWx1ZSA9IGlucHV0cy5sZW5ndGggPCAzID8gJzAuMCcgOiAnX0IoYiknO1xuICBjb25zdCBzaGFyZWREaW0gPSBNYXRoLmNlaWwoKHhzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXSkgLyA0KTtcbiAgY29uc3QgeyBhY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbiB9ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcyk7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuJHthY3RpdmF0aW9uRnVuY3Rpb259XG5mbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gIGludCBiWzFdO1xuICBiWzBdID0gaW5kaWNlc1sxXTtcbiAgaW50IGltMmNvbFs0XTtcbiAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcbiAgaW0yY29sWzFdID0gaW5kaWNlc1syXTtcbiAgaW0yY29sWzJdID0gaW5kaWNlc1szXTtcbiAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7aW0yY29sU3RyaWRlc1swXX0gKyBpbTJjb2xbMV0gKiAke2ltMmNvbFN0cmlkZXNbMV19ICsgaW0yY29sWzJdICogJHtcbiAgICBpbTJjb2xTdHJpZGVzWzJdXG4gIH07XG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHthZGp1c3RlZEtlcm5lbFNoYXBlWzFdfTtcbiAgZmxvYXQgdmFsdWUgPSAke2luaXRWYWx1ZX07XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW19OyArK2kpIHtcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHtpbTJjb2xXaWR0aH0sICR7aW0yY29sSGVpZ2h0fSk7XG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7a1dpZHRofSwgJHtrSGVpZ2h0fSk7XG4gICAgdmFsdWUgKz0gZG90KCR7Z2xzbC50ZXh0dXJlMkR9KEltMkNvbCwgaW0yY29sQ29vcmRzKSwgJHtnbHNsLnRleHR1cmUyRH0oSywga2VybmVsQ29vcmRzKSk7XG4gICAgKytpbTJjb2xPZmZzZXQ7XG4gICAgKytrZXJuZWxPZmZzZXQ7XG4gIH1cbiAgJHthcHBseUFjdGl2YXRpb259XG4gIHJldHVybiB2YWx1ZTtcbn1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSxcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCA+IDIsIGF0dHJpYnV0ZXMpO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIGdldDogKCkgPT4gY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi8uLi8uLi9iYWNrZW5kJztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgUG9vbENvbnZVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmltcG9ydCB7IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7IGNvbnYyRFBhY2tlZCB9IGZyb20gJy4vY29udi1wYWNrJztcbmltcG9ydCB7IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vZG90LXByb2R1Y3QnO1xuaW1wb3J0IHsgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyIH0gZnJvbSAnLi9pbTJjb2wnO1xuaW1wb3J0IHsgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL21hdG11bCc7XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgYWRqdXN0UGFkczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMik7XG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTcGF0aWFsU2hhcGUubGVuZ3RoO1xuICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xuICBjb25zdCBrZXJuZWxTcGF0aWFsU2hhcGUgPSBrZXJuZWxTaGFwZS5zbGljZSgyKTtcbiAgY29uc3QgZGlsYXRlZEtlcm5lbFNoYXBlID0ga2VybmVsU3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArICh2IC0gMSkgKiAoZGlsYXRpb25zW2ldIC0gMSkpO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcbiAgY29uc3Qgb3V0cHV0U3BhdGlhbFNoYXBlID0gaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkLm1hcCgodiwgaSkgPT5cbiAgICBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSxcbiAgKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVsc10uY29uY2F0KC4uLm91dHB1dFNwYXRpYWxTaGFwZSk7XG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udkF0dHJpYnV0ZXMgZXh0ZW5kcyBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5leHBvcnQgY29uc3QgY29udjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxDb252QXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpOyAvLyBjdXJyZW50bHkgd2lsbCBmYWlsIGlmIG5vdCBjb252MkRcbiAgcmV0dXJuIGNvbnYyZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpO1xufTtcblxuY29uc3QgY29udjJkOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPENvbnZBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICBjb25zdCBwYWNrTW9kZSA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuICBjb25zdCBpc1BvaW50d2lzZSA9IGFkanVzdGVkQXR0cmlidXRlcy5rZXJuZWxTaGFwZVswXSA9PT0gMSAmJiBhZGp1c3RlZEF0dHJpYnV0ZXMua2VybmVsU2hhcGVbMV0gPT09IDE7XG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuZ3JvdXAgPiAxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpLFxuICAgICAgaW5wdXRzLFxuICAgICk7XG4gICAgcmV0dXJuIFtyZXN1bHRdO1xuICB9IGVsc2UgaWYgKGlzUG9pbnR3aXNlICYmIHBhY2tNb2RlKSB7XG4gICAgcmV0dXJuIFtjb252MkRVbnBhY2tlZFBvaW50d2lzZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICB9IGVsc2UgaWYgKHBhY2tNb2RlICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNCAmJiBpbnB1dHNbMF0uZGltc1swXSA9PT0gMSAmJiAhaXNQb2ludHdpc2UpIHtcbiAgICByZXR1cm4gW2NvbnYyRFBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbY29udjJEVW5wYWNrZWQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpXTtcbiAgfVxufTtcblxuY29uc3QgY29udjJEVW5wYWNrZWRQb2ludHdpc2UgPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoeHNoYXBlLCBrc2hhcGUsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyk7XG4gIGNvbnN0IHJlc2hhcGVkWCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgW3hzaGFwZVsxXSwgeHNoYXBlWzJdICogeHNoYXBlWzNdXSk7XG4gIGNvbnN0IHJlc2hhcGVkSyA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1sxXSwgW2tzaGFwZVswXSwga3NoYXBlWzFdXSk7XG5cbiAgY29uc3QgbWF0bXVsSW5wdXRzID0gaW5wdXRzLmxlbmd0aCA+IDIgPyBbcmVzaGFwZWRLLCByZXNoYXBlZFgsIGlucHV0c1syXV0gOiBbcmVzaGFwZWRLLCByZXNoYXBlZFhdO1xuICBjb25zdCBtYXRtdWxPdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcihtYXRtdWxJbnB1dHMsIGF0dHJpYnV0ZXMpLCBtYXRtdWxJbnB1dHMpO1xuICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG59O1xuXG5jb25zdCBjb252MkRVbnBhY2tlZCA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzKTtcbiAgY29uc3QgeEltMkNvbCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgaW5wdXRzWzFdLCBvdXRwdXRTaGFwZSwgYXR0cmlidXRlcyksXG4gICAgW2lucHV0c1swXV0sXG4gICk7XG5cbiAgY29uc3QgZG90UHJvZHVjdElucHV0cyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyBbeEltMkNvbCwgaW5wdXRzWzFdLCBpbnB1dHNbMl1dIDogW3hJbTJDb2wsIGlucHV0c1sxXV07XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgICBkb3RQcm9kdWN0SW5wdXRzLFxuICApO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogVGVuc29yW10pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXRzWzFdLmRpbXNbaV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIFBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIC8vIGFsd2F5cyByZXR1cm4gYSBuZXcgb2JqZWN0IHNvIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgcGFkcywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXkgfSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248Q29udkF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDb252QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGF1dG9QYWQgPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYXV0b19wYWQnLCAnTk9UU0VUJyk7XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnZGlsYXRpb25zJywgWzEsIDFdKTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdldEludCgnZ3JvdXAnLCAxKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScsIFtdKTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbMSwgMV0pO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF1dG9QYWQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgfSk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgfHwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udicpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG4gIGlmIChkYXRhQ2hhbm5lbCAhPT0gZmlsdGVySW5DaGFubmVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XG4gIH1cblxuICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMV0uZGltc1swXSAhPT0gaW5wdXRzWzJdLmRpbXNbMF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpYXMnKTtcbiAgfVxuXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHN0cmlkZXMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgKiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rICogMn1EYCk7XG4gIH1cblxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2VybmVsIHNoYXBlJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyB8fCBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFja2VuZCc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jb252JztcbmltcG9ydCB7IGdldEFjdGl2YXRpb25TbmlwcGV0LCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPSAoXG4gIGluRGltOiBudW1iZXIsXG4gIHN0cmlkZTogbnVtYmVyLFxuICBhZGo6IG51bWJlcixcbiAga2VybmVsOiBudW1iZXIsXG4gIGRpbGF0aW9uOiBudW1iZXIsXG4gIG91dFNpemU6IG51bWJlcixcbikgPT4gKGluRGltIC0gMSkgKiBzdHJpZGUgKyBhZGogKyAoa2VybmVsIC0gMSkgKiBkaWxhdGlvbiArIDEgLSBvdXRTaXplO1xuXG5jb25zdCBkaXN0cmlidXRlUGFkZGluZyA9ICh0b3RhbFBhZDogbnVtYmVyLCBhdXRvUGFkOiBzdHJpbmcsIHBhZHM6IG51bWJlcltdLCBoZWFkOiBudW1iZXIsIHRhaWw6IG51bWJlcikgPT4ge1xuICBjb25zdCBzbWFsbFBhZCA9IE1hdGguZmxvb3IodG90YWxQYWQgLyAyKTtcbiAgaWYgKGF1dG9QYWQgPT09ICdTQU1FX1VQUEVSJykge1xuICAgIHBhZHNbaGVhZF0gPSBzbWFsbFBhZDtcbiAgICBwYWRzW3RhaWxdID0gdG90YWxQYWQgLSBzbWFsbFBhZDtcbiAgfSBlbHNlIGlmIChhdXRvUGFkID09PSAnU0FNRV9MT1dFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gdG90YWxQYWQgLSBzbWFsbFBhZDtcbiAgICBwYWRzW3RhaWxdID0gc21hbGxQYWQ7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyA9IChcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXV0b1BhZDogc3RyaW5nLFxuICBwYWRzOiBudW1iZXJbXSxcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4pID0+IHtcbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XG4gIGNvbnN0IHVwZGF0ZVNoYXBlID0gb3V0cHV0U2hhcGUubGVuZ3RoID09PSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXRpYWxSYW5rOyArK2kpIHtcbiAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlU2hhcGUgPyBpbnB1dFNoYXBlW2kgKyAyXSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcbiAgICBjb25zdCB0b3RhbFBhZCA9IGNvbXB1dGVUb3RhbFBhZChpbnB1dFNoYXBlW2kgKyAyXSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbaV0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XG4gICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgaWYgKHVwZGF0ZVNoYXBlKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKFxuICAgICAgICBzdHJpZGVzW2ldICogKGlucHV0U2hhcGVbaSArIDJdIC0gMSkgK1xuICAgICAgICAgIG91dHB1dFBhZGRpbmdbaV0gK1xuICAgICAgICAgIChrZXJuZWxTaGFwZVtpXSAtIDEpICogZGlsYXRpb25zW2ldICtcbiAgICAgICAgICAxIC1cbiAgICAgICAgICBwYWRzW2ldIC1cbiAgICAgICAgICBwYWRzW2kgKyBzcGF0aWFsUmFua10sXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252VHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIENvbnZBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTsgLy8gY3VycmVudGx5IHdpbGwgZmFpbCBpZiBub3QgY29udlRyYW5zcG9zZTJEXG4gIHJldHVybiBjb252VHJhbnNwb3NlMmQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UyZDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxDb252VHJhbnNwb3NlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5wdXRzKTtcbiAgcmV0dXJuIFtjb252VHJhbnNwb3NlMkRVbnBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xufTtcblxuY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQiddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhc1xuICAgID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG4gICAgOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVVucGFja2VkQ29udlRyYW5zcG9zZVByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IHZhbHVlSW5pdCA9IGhhc0JpYXMgPyAnZ2V0QihvdXRwdXRfY2hhbm5lbCknIDogJzAuMCc7XG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVsxXTtcbiAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cCwgLi4uYXR0cmlidXRlcy5vdXRwdXRTaGFwZV07XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3QgeyBhY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbiB9ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcyk7XG5cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHthdHRyaWJ1dGVzLnN0cmlkZXNbMF19LCAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX0pO1xuICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHthdHRyaWJ1dGVzLnBhZHNbMF19LCAke2F0dHJpYnV0ZXMucGFkc1sxXX0pO1xuICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgdm9pZCBtYWluKCkge1xuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xuXG4gICAgaXZlYzIgbG9jID0gY29vcmRzLnp3ICsgcGFkcztcblxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtvdXRwdXRDaGFubmVsc1Blckdyb3VwfTtcbiAgICBpbnQgd091dENoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbCAtIGdyb3VwX2lkICogJHtvdXRwdXRDaGFubmVsc1Blckdyb3VwfTtcblxuICAgIGZsb2F0IHZhbHVlID0gJHt2YWx1ZUluaXR9O1xuICAgIGZvciAoaW50IGluQ2hhbm5lbE9mZnNldCA9IDA7IGluQ2hhbm5lbE9mZnNldCA8ICR7aW5wdXRDaGFubmVsc1Blckdyb3VwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke2lucHV0Q2hhbm5lbHNQZXJHcm91cH0gKyBpbkNoYW5uZWxPZmZzZXQ7XG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHt3U2hhcGVbMl19OyB3V09mZisrKSB7XG4gICAgICAgIGZvciAoaW50IHdIT2ZmID0gMDsgd0hPZmYgPCAke3dTaGFwZVszXX07IHdIT2ZmKyspIHtcbiAgICAgICAgICBpdmVjMiB3T2ZmID0gaXZlYzIod1dPZmYgKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfSwgd0hPZmYgKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzFdfSk7XG4gICAgICAgICAgaXZlYzIgd0xvYyA9IGxvYyAtIHdPZmY7XG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd0xvY0luICogc3RyaWRlcyA9PSB3TG9jICYmXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt4U2hhcGVbMl19ICYmXG4gICAgICAgICAgICB3TG9jSW4ueSA+PSAwICYmIHdMb2NJbi55IDwgJHt4U2hhcGVbM119XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgd0xvY0luLnksIHdMb2NJbi54KTtcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XG4gIH1cbmA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICAgIGhhc01haW46IHRydWUsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbnZUcmFuc3Bvc2VQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVDb252VHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkQ29udlRyYW5zcG9zZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgbWV0YWRhdGEsIGF0dHJpYnV0ZXMpLFxuICB9O1xufTtcblxuY29uc3QgY29udlRyYW5zcG9zZTJEVW5wYWNrZWQgPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCByZXN1bHQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICBjcmVhdGVVbnBhY2tlZENvbnZUcmFuc3Bvc2VQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IFRlbnNvcltdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5zbGljZSgpO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIC8vIElmIG91dHB1dFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgcGFyYW1ldGVyc1xuICAvLyBTaW1pbGFybHksIGF1dG9tYXRpY2FsbHkgaW5mZXIgcGFkcyBpZiBub3Qgc3BlY2lmaWVkXG4gIGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyhcbiAgICBpbnB1dFNoYXBlLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCxcbiAgICBwYWRzLFxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRTaGFwZSwgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXkgfSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBhdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2RpbGF0aW9ucycsIFsxLCAxXSk7XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5nZXRJbnQoJ2dyb3VwJywgMSk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLmdldEludHMoJ291dHB1dF9wYWRkaW5nJywgWzAsIDBdKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLmdldEludHMoJ291dHB1dF9zaGFwZScsIFtdKTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbMSwgMV0pO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF1dG9QYWQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICB9KTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG5cbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0IHNoYXBlJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyB8fCBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252VHJhbnNwb3NlIGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHBlcm06IG51bWJlcltdO1xufVxuXG5jb25zdCB0cmFuc3Bvc2VQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdUcmFuc3Bvc2UnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248VHJhbnNwb3NlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAge1xuICAgICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSksXG4gICAgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248VHJhbnNwb3NlQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdwZXJtJywgW10pIH0pO1xuXG5jb25zdCBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyA9IChcbiAgX2luZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgcGVybTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuICBwZXJtID0gZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGUsIHBlcm0pO1xuICBjb25zdCB1bnBhY2tlZE91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgcGVybSk7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgLy8gQSBkaW1zPVske2lucHV0c1swXS5kaW1zLnRvU3RyaW5nKCl9XVxuICAvLyBvdXQgRGltcz1bJHt1bnBhY2tlZE91dHB1dFNoYXBlLnRvU3RyaW5nKCl9XVxuICAvLyBiYXNlZCBvbiBwZXJtPVske3Blcm0udG9TdHJpbmcoKX1dXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7Z2V0UGVybUZ1bmN0aW9uQm9keSgncGVybScsIHBlcm0sIHJhbmspfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgYVske3Jhbmt9XTtcbiAgICAgICAgcGVybShhLCBpbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiB1bnBhY2tlZE91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBlcm0gPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm06IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBpZiAocGVybSAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICBwZXJtID0gWy4uLmlucHV0U2hhcGUua2V5cygpXS5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIHBlcm07XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZSwgcGVybSk7XG4gIHJldHVybiBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGlucHV0U2hhcGUsIHBlcm0pO1xufTtcblxuY29uc3QgZ2V0UGVybUZ1bmN0aW9uQm9keSA9IChuYW1lOiBzdHJpbmcsIHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICByZXZlcnNlRnVuYy5wdXNoKGB2b2lkICR7bmFtZX0ob3V0IGludCBhWyR7cmFua31dLCBpbnQgc3JjWyR7cmFua31dKSB7YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChgXFx0YVske3Blcm1baV19XT1zcmNbJHtpfV07YCk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgnXFx0fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuaW1wb3J0IHsgdHJhbnNwb3NlLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMge1xuICBtb2RlOiAnRENSJyB8ICdDUkQnO1xuICBibG9ja3NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGRlcHRoVG9TcGFjZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZTtcbiAgY29uc3QgYmxvY2tzaXplU3FyID0gYmxvY2tzaXplICogYmxvY2tzaXplO1xuICBjb25zdCB0cmFuc3Bvc2VQZXJtID0gYXR0cmlidXRlcy5tb2RlID09PSAnRENSJyA/IFswLCAzLCA0LCAxLCA1LCAyXSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgY29uc3QgZmlyc3RSZXNoYXBlU2hhcGUgPVxuICAgIGF0dHJpYnV0ZXMubW9kZSA9PT0gJ0RDUidcbiAgICAgID8gW1xuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzBdLFxuICAgICAgICAgIGJsb2Nrc2l6ZSxcbiAgICAgICAgICBibG9ja3NpemUsXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMV0gLyBibG9ja3NpemVTcXIsXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbM10sXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzBdLFxuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzFdIC8gYmxvY2tzaXplU3FyLFxuICAgICAgICAgIGJsb2Nrc2l6ZSxcbiAgICAgICAgICBibG9ja3NpemUsXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbM10sXG4gICAgICAgIF07XG5cbiAgLy8gY29uc3QgdHJhbnNwb3NlID0gbmV3IFdlYkdMVHJhbnNwb3NlKCk7XG4gIC8vIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKHVuZGVmaW5lZCk7XG4gIC8vIGF0dHJpYnV0ZXMuc2V0KCdwZXJtJywgJ2ludHMnLCB0cmFuc3Bvc2VQZXJtKTtcbiAgLy8gdHJhbnNwb3NlLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG5cbiAgLy8gRmlyc3QgcmVzaGFwZVxuICBjb25zdCBmaXJzdFJlc2hhcGVkVGVuc29yID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCBmaXJzdFJlc2hhcGVTaGFwZSk7XG5cbiAgLy8gdHJhbnNwb3NlXG4gIGNvbnN0IHRyYW5zcG9zZUF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSB7IHBlcm06IHRyYW5zcG9zZVBlcm0sIGNhY2hlS2V5OiBgJHt0cmFuc3Bvc2VQZXJtfWAgfTtcbiAgY29uc3QgW3RyYW5zcG9zZU91dHB1dF0gPSB0cmFuc3Bvc2UoaW5mZXJlbmNlSGFuZGxlciwgW2ZpcnN0UmVzaGFwZWRUZW5zb3JdLCB0cmFuc3Bvc2VBdHRyaWJ1dGVzKTtcblxuICAvLyBTZWNvbmQgcmVzaGFwZVxuICBjb25zdCBzZWNvbmRSZXNoYXBlU2hhcGUgPSBbXG4gICAgaW5wdXRzWzBdLmRpbXNbMF0sXG4gICAgaW5wdXRzWzBdLmRpbXNbMV0gLyBibG9ja3NpemVTcXIsXG4gICAgaW5wdXRzWzBdLmRpbXNbMl0gKiBibG9ja3NpemUsXG4gICAgaW5wdXRzWzBdLmRpbXNbM10gKiBibG9ja3NpemUsXG4gIF07XG4gIGNvbnN0IHJlc3VsdCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKHRyYW5zcG9zZU91dHB1dCwgc2Vjb25kUmVzaGFwZVNoYXBlKTtcbiAgcmV0dXJuIFtyZXN1bHRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPiA9IChcbiAgbm9kZTogR3JhcGguTm9kZSxcbik6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPT4ge1xuICAvLyBwcm9jZXNzaW5nIG5vZGUgYXR0cmlidXRlc1xuICBjb25zdCBibG9ja3NpemUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdibG9ja3NpemUnKTtcbiAgaWYgKGJsb2Nrc2l6ZSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2Jsb2Nrc2l6ZX0gZm9yIERlcHRoVG9TcGFjZWApO1xuICB9XG4gIGNvbnN0IG1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ0RDUicpO1xuICBpZiAobW9kZSAhPT0gJ0RDUicgJiYgbW9kZSAhPT0gJ0NSRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke21vZGV9IGZvciBEZXB0aFRvU3BhY2VgKTtcbiAgfVxuICByZXR1cm4geyBtb2RlLCBibG9ja3NpemUgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlcHRoVG9TcGFjZSBleHBlY3QgMSBpbnB1dHMsIGJ1dCBnb3QgJHtpbnB1dHMubGVuZ3RofWApO1xuICB9XG5cbiAgLy8gSW5wdXQgaGFzIHRvIGJlIGEgNC1EIHRlbnNvclxuICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyBkZXB0aC10by1zcGFjZS5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJyB8fCBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZXB0aFRvU3BhY2UgaW5wdXQgc2hvdWxkIGJlIGEgNC1EIG51bWVyaWMgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPG51bWJlcj4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXhpczogbnVtYmVyLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF4aXMpO1xuXG4gIGNvbnN0IG91dHB1dERpbXMgPSBTaGFwZVV0aWwuZmxhdHRlblNoYXBlKGlucHV0c1swXS5kaW1zLCBheGlzKTtcbiAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIG91dHB1dERpbXMpXTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPG51bWJlcj4gPSAobm9kZTogR3JhcGguTm9kZSk6IG51bWJlciA9PlxuICBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMSk7IC8vIGRlZmF1bHQgYXhpcyBpcyAxXG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBjb25zdCByID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAociA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgaWYgKGF4aXMgPCAtciB8fCBheGlzID4gcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGlzJyk7XG4gIH1cblxuICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyB0eXBlXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4vYmFja2VuZCc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3InO1xuXG5leHBvcnQgdHlwZSBPcGVyYXRvckltcGxlbWVudGF0aW9uPFQ+ID0gKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGNvbnRleHQ6IFQpID0+IFRlbnNvcltdO1xuZXhwb3J0IHR5cGUgT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUPiA9IChub2RlOiBHcmFwaC5Ob2RlLCBncmFwaDogR3JhcGgpID0+IFQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0b3Ige1xuICByZWFkb25seSBpbXBsOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPHVua25vd24+O1xuICByZWFkb25seSBjb250ZXh0OiBHcmFwaC5Ob2RlIHwgdW5rbm93bjtcbn1cblxuZXhwb3J0IGNvbnN0IE5VTUJFUl9UWVBFUzogcmVhZG9ubHkgVGVuc29yLkRhdGFUeXBlW10gPSBbXG4gICdmbG9hdDMyJyxcbiAgJ2Zsb2F0NjQnLFxuICAnaW50MzInLFxuICAnaW50MTYnLFxuICAnaW50OCcsXG4gICd1aW50MTYnLFxuICAndWludDMyJyxcbiAgJ3VpbnQ4Jyxcbl07XG5leHBvcnQgY29uc3QgSU5UX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9IFsnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgRkxPQVRfVFlQRVM6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdID0gWydmbG9hdDMyJywgJ2Zsb2F0NjQnXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBOVU1CRVJfVFlQRVMsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgR2F0aGVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGdhdGhlcjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHYXRoZXJBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMuYXhpcyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2F0aGVyQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IEdhdGhlckF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDApIH0pO1xuXG5jb25zdCBnYXRoZXJQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdHYXRoZXInLFxuICBpbnB1dE5hbWVzOiBbJ0EnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID0gKFxuICBfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCBpbmRleERhdGFTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGlucHV0U2hhcGUubGVuZ3RoICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIC0gMSk7XG5cbiAgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgaW5kZXhDb3B5T3BzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gb3V0cHV0U2hhcGUgaXMgZGl2aWRlZCBpbnRvIHRocmVlIHBhcnRzOiBBLCBCLCBDXG4gICAgLy8gfDAgICAgICAgIGF4aXN8ICBheGlzICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIHwgICAgICAgICAgZW5kfFxuICAgIC8vIHwgICAgIEEgICAgICAgfCAgICAgICAgICAgICBCICAgICAgICAgICAgICAgICB8ICAgICAgQyAgICAgIHxcbiAgICAvL1xuICAgIC8vIGlucHV0SWR4OiBbQSwgaW5wdXRzWzFdW0JdLCBDXVxuICAgIGlmIChpIDwgYXhpcykge1xuICAgICAgLy8gQVxuICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbnB1dFNoYXBlW2ldO1xuICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA8IGF4aXMgKyBpbmRleERhdGFTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gQlxuICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGluZGV4RGF0YVNoYXBlW2kgLSBheGlzXTtcbiAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGluZGV4RGF0YUlkeFske2kgLSBheGlzfV0gPSBvdXRwdXRJZHhbJHtpfV07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDXG4gICAgICAgIG91dHB1dFNoYXBlW2ldID0gaW5wdXRTaGFwZVtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMV07IC8vIHNraXAgMSBmb3IgYXhpc1xuICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5wdXRJZHhbJHtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoIHx8IDE7XG4gIGNvbnN0IGlyYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGlEcmFuayA9IGluZGV4RGF0YVNoYXBlLmxlbmd0aCB8fCAxO1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtvcmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske2lyYW5rfV07XG4gICAgICAgIGludCBpbmRleERhdGFJZHhbJHtpRHJhbmt9XTtcbiAgICAgICAgaW5kZXhEYXRhSWR4WzBdID0gMDtcbiAgICAgICAgJHtpbmRleENvcHlPcHMuam9pbignXFxuICAgICAgICAnKX1cbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcbiAgICAgICAgaW5wdXRJZHhbJHtheGlzfV0gPSBpZHggPCAwID8gaWR4ICsgJHtpbnB1dFNoYXBlW2F4aXNdfSA6IGlkeDtcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0geyAuLi5nYXRoZXJQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSB9O1xuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG4gIGNvbnN0IHRlbnNvclJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGlmICh0ZW5zb3JSYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxuICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rIHx8IGF4aXMgPiB0ZW5zb3JSYW5rIC0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGlzLicpO1xuICB9XG4gIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IEdlbW1VdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VtbUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICB0cmFuc0E6IGJvb2xlYW47XG4gIHRyYW5zQjogYm9vbGVhbjtcbiAgYWxwaGE6IG51bWJlcjtcbiAgYmV0YTogbnVtYmVyO1xuICBpc09wdGlvbmFsQzogYm9vbGVhbjsgLy8gaW4gb3BzZXQgMTEsIEMgYmVjb21lcyBvcHRpb25hbFxufVxuXG5leHBvcnQgY29uc3QgZ2VtbTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHZW1tQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUdlbW1Qcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5jb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzID0gKG5vZGU6IEdyYXBoLk5vZGUsIGlzT3B0aW9uYWxDOiBib29sZWFuKTogR2VtbUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCB0cmFuc0EgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCd0cmFuc0EnLCAwKSAhPT0gMDtcbiAgY29uc3QgdHJhbnNCID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgndHJhbnNCJywgMCkgIT09IDA7XG4gIGNvbnN0IGFscGhhID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdhbHBoYScsIDEuMCk7XG4gIGNvbnN0IGJldGEgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JldGEnLCAxLjApO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgdHJhbnNBLCB0cmFuc0IsIGFscGhhLCBiZXRhLCBpc09wdGlvbmFsQyB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjc6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2VtbUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBHZW1tQXR0cmlidXRlcyA9PlxuICBwYXJzZUdlbW1BdHRyaWJ1dGVzKG5vZGUsIGZhbHNlKTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2VtbUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBHZW1tQXR0cmlidXRlcyA9PlxuICBwYXJzZUdlbW1BdHRyaWJ1dGVzKG5vZGUsIHRydWUpO1xuXG5jb25zdCBjcmVhdGVHZW1tUHJvZ3JhbUluZm9Mb2FkZXIgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdHZW1tJyxcbiAgICBpbnB1dE5hbWVzOiBpbnB1dHMubGVuZ3RoID09PSAzID8gWydBJywgJ0InLCAnQyddIDogWydBJywgJ0InXSxcbiAgICBpbnB1dFR5cGVzOlxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gM1xuICAgICAgICA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXVxuICAgICAgICA6IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgIGtleTogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgfTtcblxuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVHZW1tUHJvZ3JhbUluZm8obWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcykgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9IChcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IFtNLCBOXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGFTaGFwZSxcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQSxcbiAgICBiU2hhcGUsXG4gICAgYXR0cmlidXRlcy50cmFuc0IsXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGxldCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBsZXQgbGluZSA9ICcnO1xuICBpZiAoYXR0cmlidXRlcy50cmFuc0EpIHtcbiAgICBzaGFyZWREaW0gPSBhU2hhcGVbMF07XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgbGluZSA9ICd2YWx1ZSArPSBfQV9UKGEpICogX0JfVChiKTsnO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgIGxpbmUgPSAndmFsdWUgKz0gX0FfVChhKSAqIF9CKGIpOyc7XG4gIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7JztcbiAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CKGIpOyc7XG4gIH1cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZGVjbGFyZUMgPSBpbnB1dHMubGVuZ3RoID09PSAzID8gYGludCBjWyR7aW5wdXRzWzJdLmRpbXMubGVuZ3RofV07YCA6ICcnO1xuICBjb25zdCBicm9hZGNhc3RDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICdiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTsnIDogJyc7XG4gIGNvbnN0IGNhbGN1bGF0ZUMgPSBpbnB1dHMubGVuZ3RoID09PSAzID8gJ3ZhbHVlICs9IGJldGEgKiBfQyhjKTsnIDogJyc7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgYVske3Jhbmt9XTtcbiAgICAgICAgICBpbnQgYlske3Jhbmt9XTtcbiAgICAgICAgICAke2RlY2xhcmVDfVxuXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBhKTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGIpO1xuICAgICAgICAgICR7YnJvYWRjYXN0Q31cblxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke3NoYXJlZERpbX07ICsraykge1xuICAgICAgICAgICAgICBhWyR7cmFuayAtIDF9XSA9IGs7XG4gICAgICAgICAgICAgIGJbJHtyYW5rIC0gMn1dID0gaztcbiAgICAgICAgICAgICAgJHtsaW5lfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBhbHBoYTtcbiAgICAgICAgICAke2NhbGN1bGF0ZUN9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgdmFyaWFibGVzOiBbXG4gICAgICB7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEgfSxcbiAgICAgIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZmxvYXQnLCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEgfSxcbiAgICBdLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMuaXNPcHRpb25hbEMgJiYgKGlucHV0cy5sZW5ndGggPCAyIHx8IGlucHV0cy5sZW5ndGggPiAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmICghYXR0cmlidXRlcy5pc09wdGlvbmFsQyAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHZW1tIHJlcXVpcmVzIDMgaW5wdXRzJyk7XG4gIH1cblxuICAvLyAnQycgY2FuIGJlIG9mIGRpbWVuc2lvbmFsaXR5IDEgb3IgMiBvbmx5XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUgb2YgQycpO1xuICB9XG5cbiAgaWYgKFxuICAgIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgKGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1syXS50eXBlICE9PSAnZmxvYXQ2NCcpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSB8fCAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzWzJdLnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZCcpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZVNjYWxlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBzY2FsZTogbnVtYmVyO1xuICBiaWFzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGltYWdlU2NhbGVyOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEltYWdlU2NhbGVyQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVJbWFnZVNjYWxlclByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxJbWFnZVNjYWxlckF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc2NhbGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ3NjYWxlJyk7XG4gIGNvbnN0IGJpYXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXRzKCdiaWFzJyk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBzY2FsZSwgYmlhcyB9KTtcbn07XG5cbmNvbnN0IGltYWdlU2NhbGVyUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnSW1hZ2VTY2FsZXInLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUltYWdlU2NhbGVyUHJvZ3JhbUluZm8gPSAoXG4gIF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IEltYWdlU2NhbGVyQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBnZXRCaWFzTWV0aG9kID0gY3JlYXRlR2V0Qmlhc01ldGhvZChhdHRyaWJ1dGVzLmJpYXMubGVuZ3RoKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtnZXRCaWFzTWV0aG9kfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICByZXR1cm4gX1goaW5kaWNlcykgKiBzY2FsZSArIGdldEJpYXMoYmlhcywgaW5kaWNlc1sxXSk7XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICB2YXJpYWJsZXM6IFtcbiAgICAgIHsgbmFtZTogJ2JpYXMnLCB0eXBlOiAnZmxvYXQnLCBhcnJheUxlbmd0aDogYXR0cmlidXRlcy5iaWFzLmxlbmd0aCwgZGF0YTogYXR0cmlidXRlcy5iaWFzIH0sXG4gICAgICB7IG5hbWU6ICdzY2FsZScsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGF0dHJpYnV0ZXMuc2NhbGUgfSxcbiAgICBdLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUltYWdlU2NhbGVyUHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHsgLi4uaW1hZ2VTY2FsZXJQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSB9O1xuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVJbWFnZVNjYWxlclByb2dyYW1JbmZvKGhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dHMsIGF0dHJpYnV0ZXMpIH07XG59O1xuXG5jb25zdCBjcmVhdGVHZXRCaWFzTWV0aG9kID0gKG51bUNoYW5uZWxzOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBnZXRCaWFzKGZsb2F0IGJpYXNbJHtudW1DaGFubmVsc31dLCBpbnQgY2hhbm5lbCkge2BdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNoYW5uZWxzOyArK2kpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgaWYgKGNoYW5uZWwgPT0gJHtpfSkgeyByZXR1cm4gYmlhc1ske2l9XTsgfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtQ2hhbm5lbHMgLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaCgnXFx0JyArIGBlbHNlIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSBpZiAoY2hhbm5lbCA9PSAke2l9KSB7IHJldHVybiBiaWFzWyR7aX1dOyB9YCk7XG4gICAgfVxuICB9XG4gIGNvZGVMaW5lcy5wdXNoKCdcXHQnICsgJ30nKTtcbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2VTY2FsZXIgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtYWxpemF0aW9uOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPG51bWJlcj4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgZXBzaWxvbjogbnVtYmVyLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IG1lYW5BbmRWYXJpYW5jZSA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZU1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvTG9hZGVyKGlucHV0c1swXSksIGlucHV0cyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGVwc2lsb24sIG1lYW5BbmRWYXJpYW5jZS5kaW1zKSxcbiAgICBbaW5wdXRzWzBdLCBtZWFuQW5kVmFyaWFuY2UsIGlucHV0c1sxXSwgaW5wdXRzWzJdXSxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxudW1iZXI+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXIgPT5cbiAgbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdlcHNpbG9uJywgMWUtNSk7XG5cbmNvbnN0IG1lYW5BbmRWYXJpYW5jZVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbl9NZWFuQW5kVmFyaWFuY2UnLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZU1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvID0gKG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHhEaW1zID0gaW5wdXQuZGltcy5zbGljZSgpO1xuICBjb25zdCBjaGFubmVsID0geERpbXNbMV07XG4gIGNvbnN0IGNoYW5uZWxTaXplID0geERpbXNbMl0gKiB4RGltc1szXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbeERpbXNbMF0sIGNoYW5uZWxdO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZlYzQgcHJvY2VzcyhpbnRbMl0gaW5kaWNlcykge1xuICAgICAgICB2ZWM0IHYgPSB2ZWM0KDAuMCk7XG4gICAgICAgIGludCBhWzRdO1xuICAgICAgICBhWzBdID0gaW5kaWNlc1swXTtcbiAgICAgICAgYVsxXSA9IGluZGljZXNbMV07XG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XG4gICAgICAgIGZvcihpbnQgYTI9MDsgYTI8JHt4RGltc1syXX07IGEyKyspIHtcbiAgICAgICAgICBhWzJdID0gYTI7XG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke3hEaW1zWzNdfTsgYTMrKykge1xuICAgICAgICAgICAgYVszXSA9IGEzO1xuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xuICAgICAgICAgICAgdGVtcCArPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbG9hdCBtZWFuID0gdGVtcCAvIGZsb2F0KCR7Y2hhbm5lbFNpemV9KTtcbiAgICAgICAgdGVtcCA9IDAuMDtcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke3hEaW1zWzJdfTsgYTIrKykge1xuICAgICAgICAgIGFbMl0gPSBhMjtcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7eERpbXNbM119OyBhMysrKSB7XG4gICAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgICB0ZW1wICs9ICh4IC0gbWVhbikgKiAoeCAtIG1lYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2LnIgPSBtZWFuO1xuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtjaGFubmVsU2l6ZX0pO1xuXG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZU1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvTG9hZGVyID0gKGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiAoe1xuICAuLi5tZWFuQW5kVmFyaWFuY2VQcm9ncmFtTWV0YWRhdGEsXG4gIGdldDogKCkgPT4gY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8obWVhbkFuZFZhcmlhbmNlUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dCksXG59KTtcblxuY29uc3QgY29tcHV0ZU91dHB1dFByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0JyxcbiAgaW5wdXROYW1lczogWydYJywgJ01lYW5BbmRWYXJpYW5jZScsICdTY2FsZScsICdCJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dDogVGVuc29yLFxuICBlcHNpbG9uOiBudW1iZXIsXG4gIG1lYW5BbmRWYXJpYW5jZVNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBbdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0XSA9IGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KFxuICAgIG1lYW5BbmRWYXJpYW5jZVNoYXBlLFxuICAgIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24sXG4gICk7XG4gIGNvbnN0IFttZWFuQW5kVmFyaWFuY2VXaWR0aCwgbWVhbkFuZFZhcmlhbmNlSGVpZ2h0XSA9IFt0ZXh0dXJlV2lkdGggLyA0LCB0ZXh0dXJlSGVpZ2h0XTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke21lYW5BbmRWYXJpYW5jZVdpZHRofSwgJHttZWFuQW5kVmFyaWFuY2VIZWlnaHR9KTtcbiAgICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xuICAgICAgICBpbnQgbXZbMl07XG4gICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xuICAgICAgICB2ZWM0IG1lYW5fYW5kX3ZhcmlhbmNlID0gZ2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XG5cbiAgICAgICAgaW50IHNiWzFdO1xuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XG4gICAgICAgIGZsb2F0IHNjYWxlID0gX1NjYWxlKHNiKTtcbiAgICAgICAgZmxvYXQgYiA9IF9CKHNiKTtcblxuICAgICAgICByZXR1cm4gc2NhbGUgKiAoX1goaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBlcHNpbG9uKSArIGI7XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgdmFyaWFibGVzOiBbeyBuYW1lOiAnZXBzaWxvbicsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGVwc2lsb24gfV0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQ29tcHV0ZU91dHB1dFByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGVwc2lsb246IG51bWJlcixcbiAgbWVhbkFuZFZhcmlhbmNlU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHsgLi4uY29tcHV0ZU91dHB1dFByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBgJHtlcHNpbG9ufWAgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXQsIGVwc2lsb24sIG1lYW5BbmRWYXJpYW5jZVNoYXBlKSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5zdGFuY2VOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDMgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgWCA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gIGNvbnN0IEIgPSBpbnB1dHNbMl07XG5cbiAgLy8gaW5wdXQgc2hvdWxkIGF0IGxlYXN0IGhhdmUgdGhyZWUgZGltZW5zaW9ucyAtIE4sQyxkaW0xLC4uLixkaW1uXG4gIC8vIG90aGVyIGlucHV0cyBjYW4gaGF2ZSBvbmx5IG9uZSBkaW1lbnNpb25zXG4gIGlmIChYLmRpbXMubGVuZ3RoIDwgMyB8fCBzY2FsZS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBCLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChzY2FsZS5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHwgQi5kaW1zWzBdICE9PSBYLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC4nKTtcbiAgfVxuICBpZiAoXG4gICAgKFgudHlwZSAhPT0gJ2Zsb2F0MzInICYmIFgudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgIChzY2FsZS50eXBlICE9PSAnZmxvYXQzMicgJiYgc2NhbGUudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgIChCLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBCLnR5cGUgIT09ICdmbG9hdDY0JylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExybkF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG4gIGJpYXM6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgbHJuOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPExybkF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IExybkF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgLy8gaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrKSB7XG4gIC8vICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVQYWNrZWRMcm5Qcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAvLyAgIGlucHV0cyldO1xuICAvLyB9IGVsc2Uge1xuICByZXR1cm4gW2luZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyKGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyldO1xuICAvL31cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxybkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248THJuQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IExybkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhbHBoYSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAwMDEpO1xuICBjb25zdCBiZXRhID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdiZXRhJywgMC43NSk7XG4gIGNvbnN0IGJpYXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JpYXMnLCAxLjApO1xuICBjb25zdCBzaXplID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc2l6ZScpO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBhbHBoYSwgYmV0YSwgYmlhcywgc2l6ZSB9KTtcbn07XG5cbmNvbnN0IGxyblByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0xSTicsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZnVuY3Rpb24gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogTHJuQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgQyA9IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBjb25zdCBmcm9tID0gLU1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuc2l6ZSAtIDEpIC8gMik7XG4gIGNvbnN0IHRvID0gTWF0aC5jZWlsKChhdHRyaWJ1dGVzLnNpemUgLSAxKSAvIDIpO1xuICBjb25zdCBhbHBoYSA9IGBmbG9hdCgke2F0dHJpYnV0ZXMuYWxwaGF9KSAvIGZsb2F0KCR7YXR0cmlidXRlcy5zaXplfSlgO1xuICBjb25zdCBiaWFzID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iaWFzfSlgO1xuICBjb25zdCBiZXRhID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iZXRhfSlgO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBjID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgeCA9IF9YKGluZGljZXMpO1xuICAgICAgICBmbG9hdCBzcXVhcmVfc3VtID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAke2Zyb219OyBpIDw9ICR7dG99OyBpKyspIHtcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XG4gICAgICAgICAgaWYgKGMgPj0gMCAmJiBjIDwgJHtDfSkge1xuICAgICAgICAgICAgaW5kaWNlc1sxXSA9IGlkeDtcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcbiAgICAgICAgICAgIHNxdWFyZV9zdW0gKz0gaiAqIGo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IC8gcG93KCR7Ymlhc30gKyAke2FscGhhfSAqIHNxdWFyZV9zdW0sICR7YmV0YX0pO1xuICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLmxyblByb2dyYW1NZXRhZGF0YSxcbiAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgb3V0cHV0OiB7IGRpbXM6IGlucHV0c1swXS5kaW1zLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTHJuUHJvZ3JhbUluZm9Mb2FkZXIoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogTHJuQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyIHtcbiAgcmV0dXJuIHsgLi4ubHJuUHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGdldDogKCkgPT4gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzLCBhdHRyaWJ1dGVzKSB9O1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xSTiByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgTFJOIGZvciBpbnB1dCB3aXRoIFwiTkNIV1wiIGZvcm1hdCcpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgYmUgZmxvYXQgdHlwZScpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgZ2V0R2xzbCwgR2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQYWRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgbW9kZTogc3RyaW5nO1xuICByZWFkb25seSBwYWRzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcbn1cblxuY29uc3QgcGFkUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnUGFkJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5leHBvcnQgY29uc3QgcGFkVjI6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UGFkQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMihpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5wYWRQcm9ncmFtTWV0YWRhdGEsXG4gICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhZFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgYXR0cmlidXRlcyksXG4gICAgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVBhZEF0dHJpYnV0ZXNWMjogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxQYWRBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUGFkQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IG1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG4gIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCd2YWx1ZScsIDAuMCk7XG4gIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbW9kZSwgdmFsdWUsIHBhZHMgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFkVjExOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPHN0cmluZz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgbW9kZTogc3RyaW5nLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0c1YxMShpbnB1dHMpO1xuICBjb25zdCBhdHRydWJ1dGVzID0gZ2VuZXJhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1vZGUpO1xuICByZXR1cm4gcGFkVjIoaW5mZXJlbmNlSGFuZGxlciwgW2lucHV0c1swXV0sIGF0dHJ1YnV0ZXMpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUGFkQXR0cmlidXRlc1YxMTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxzdHJpbmc+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBzdHJpbmcgPT5cbiAgbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnbW9kZScsICdjb25zdGFudCcpO1xuXG5jb25zdCBnZW5lcmF0ZVBhZEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIG1vZGU6IHN0cmluZyxcbik6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoXG4gICAgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1sxXS5kYXRhSWQpIHx8XG4gICAgKGlucHV0cy5sZW5ndGggPj0gMyAmJiAhaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzJdLmRhdGFJZCkpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBwYWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IHBhZHMgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXRzLmxlbmd0aCA+PSAzID8gaW5wdXRzWzJdLmZsb2F0RGF0YVswXSA6IDAuMDtcblxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbW9kZSwgcGFkcywgdmFsdWUgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dDogVGVuc29yLFxuICBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5wYWRTaGFwZShpbnB1dC5kaW1zLnNsaWNlKCksIGF0dHJpYnV0ZXMucGFkcyk7XG4gIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHBhZEZ1bmN0aW9uID0gZ2V0UGFkRnVuY3Rpb24oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXQsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke3BhZEZ1bmN0aW9ufVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgICAgICAgIHJldHVybiBwYWRBKGluZGljZXMpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1BhZCcsXG4gICAgaW5wdXROYW1lczogWydBJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjIgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWQgcmVxdWlyZXMgMSBpbnB1dCcpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNWMTEgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRQYWRGdW5jdGlvbiA9IChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGlucHV0LmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhpbnB1dC5kaW1zKTtcblxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgIGNhc2UgJ2NvbnN0YW50JzpcbiAgICAgIHJldHVybiBnZXRQYWRDb25zdGFudChnbHNsLCBpbnB1dC5kaW1zLCBzdHJpZGVzLCB3aWR0aCwgaGVpZ2h0LCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMudmFsdWUpO1xuICAgIGNhc2UgJ3JlZmxlY3QnOlxuICAgICAgcmV0dXJuIGdldFBhZFJlZmxlY3QoZ2xzbCwgaW5wdXQuZGltcywgc3RyaWRlcywgd2lkdGgsIGhlaWdodCwgYXR0cmlidXRlcy5wYWRzKTtcbiAgICBjYXNlICdlZGdlJzpcbiAgICAgIHJldHVybiBnZXRQYWRFZGdlKGdsc2wsIGlucHV0LmRpbXMsIHN0cmlkZXMsIHdpZHRoLCBoZWlnaHQsIGF0dHJpYnV0ZXMucGFkcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RlJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldFBhZENvbnN0YW50ID0gKFxuICBnbHNsOiBHbHNsLFxuICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgcGFkczogbnVtYmVyW10sXG4gIHZhbHVlOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIGlmIChrID49ICR7c2hhcGVbaV19KSByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3Jhbmt9XSkge1xuICAgICAgICBjb25zdCBmbG9hdCBjb25zdGFudCA9IGZsb2F0KCR7dmFsdWV9KTtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPSAoXG4gIGdsc2w6IEdsc2wsXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICBwYWRzOiBudW1iZXJbXSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgIGsgPSBtWyR7aX1dIC0gJHtwYWRzW2ldfTtcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW50IF8ybl8xID0gJHsyICogKHNoYXBlW2ldIC0gMSl9O1xuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xuICAgICAgICAgIGlmKGsgPj0gJHtzaGFwZVtpXX0pIHsgayA9IF8ybl8xIC0gazsgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9IChcbiAgZ2xzbDogR2xzbCxcbiAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHBhZHM6IG51bWJlcltdLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICBrID0gMDtcbiAgICAgICAgaWYgKGsgPj0gJHtzaGFwZVtpXX0pIGsgPSAke3NoYXBlW2ldIC0gMX07XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgUG9vbENvbnZVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgY2VpbE1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgY291bnRJbmNsdWRlUGFkOiBib29sZWFuO1xuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBwYWRzOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQXZlcmFnZVBvb2wnLFxuICAgIGlucHV0TmFtZXM6IFsnWCddLFxuICAgIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG4gICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICB9O1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oaW5wdXRzLCBtZXRhZGF0YSwgZmFsc2UsIGF0dHJpYnV0ZXMpIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248QXZlcmFnZVBvb2xBdHRyaWJ1dGVzPiA9IChcbiAgbm9kZTogR3JhcGguTm9kZSxcbik6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF1dG9QYWQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdhdXRvX3BhZCcsICdOT1RTRVQnKTtcbiAgY29uc3QgY2VpbE1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdjZWlsX21vZGUnLCAwKTtcbiAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY291bnRfaW5jbHVkZV9wYWQnLCAwKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygna2VybmVsX3NoYXBlJyk7XG4gIGNvbnN0IHN0cmlkZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnc3RyaWRlcycsIFtdKTtcbiAgY29uc3QgcGFkcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJywgW10pO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnXG4gIGlmIChjZWlsTW9kZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF1dG9QYWQsIGNlaWxNb2RlLCBjb3VudEluY2x1ZGVQYWQsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzIH0pO1xufTtcblxuY29uc3QgY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPSBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUoXG4gICAgaW5wdXRzLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgKTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGFkanVzdGVkQXR0cmlidXRlcy5rZXJuZWxTaGFwZSk7XG4gIGNvbnN0IG9wMSA9ICd2YWx1ZSArPSBfWCh4KTsnO1xuICBsZXQgb3AyID0gJyc7XG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkKSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSBmbG9hdCgke2tlcm5lbFNpemV9KTtgO1xuICB9IGVsc2Uge1xuICAgIG9wMiArPSBgdmFsdWUgLz0gZmxvYXQoJHtrZXJuZWxTaXplfSAtIHBhZCk7YDtcbiAgfVxuICBjb25zdCBwb29saW5nQ29kZSA9IGdlbmVyYXRlUG9vbGluZ0NvZGUoaW5wdXRzWzBdLmRpbXMsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsICcwLjAnKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAke3Bvb2xpbmdDb2RlfVxuICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsQXZlcmFnZVBvb2w6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248QXZlcmFnZVBvb2xBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdHbG9iYWxBdmVyYWdlUG9vbCcsXG4gICAgaW5wdXROYW1lczogWydYJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBjYWNoZUhpbnQ6IGAke2F0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkfWAsXG4gIH07XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyhpbnB1dHMsIG1ldGFkYXRhLCB0cnVlLCBhdHRyaWJ1dGVzKSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdjb3VudF9pbmNsdWRlX3BhZCcsIDApID09PSAwID8gZmFsc2UgOiB0cnVlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhdXRvUGFkOiAnJyxcbiAgICBjZWlsTW9kZTogMCxcbiAgICBjb3VudEluY2x1ZGVQYWQsXG4gICAga2VybmVsU2hhcGU6IFtdLFxuICAgIHN0cmlkZXM6IFtdLFxuICAgIHBhZHM6IFtdLFxuICB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF4UG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IG1heFBvb2w6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248TWF4UG9vbEF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnTWF4UG9vbCcsXG4gICAgaW5wdXROYW1lczogWydYJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gIH07XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKGlucHV0cywgbWV0YWRhdGEsIGZhbHNlLCBhdHRyaWJ1dGVzKSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248TWF4UG9vbEF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhdXRvUGFkID0gbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnYXV0b19wYWQnLCAnTk9UU0VUJyk7XG4gIGNvbnN0IGNlaWxNb2RlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY2VpbF9tb2RlJywgMCk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScpO1xuICBjb25zdCBzdHJpZGVzID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbXSk7XG4gIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFtdKTtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc3RvcmFnZV9vcmRlcicsIDApO1xuICBjb25zdCBkaWxhdGlvbnMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnZGlsYXRpb25zJywgW10pO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnIGFuZCAnc3RvcmFnZV9vcmRlcidcbiAgaWYgKHN0b3JhZ2VPcmRlciAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBpZiAoY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYXV0b1BhZCxcbiAgICBjZWlsTW9kZSxcbiAgICBjb3VudEluY2x1ZGVQYWQ6IGZhbHNlLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHN0cmlkZXMsXG4gICAgcGFkcyxcbiAgICBzdG9yYWdlT3JkZXIsXG4gICAgZGlsYXRpb25zLFxuICB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShcbiAgICBpbnB1dHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBpc0dsb2JhbE9wZXJhdG9yLFxuICApO1xuICBjb25zdCBvcDEgPSBgXG4gICAgICB2YWx1ZSA9IG1heChfWCh4KSwgdmFsdWUpO1xuICAgIGA7XG4gIGNvbnN0IG9wMiA9ICcnO1xuICBjb25zdCBwb29saW5nQ29kZSA9IGdlbmVyYXRlUG9vbGluZ0NvZGUoaW5wdXRzWzBdLmRpbXMsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsICctMWU1Jyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7cG9vbGluZ0NvZGV9XG4gICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUgPSAoXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzLFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuKTogW0F2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGUsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZHMpO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICBpbnB1dFNoYXBlLFxuICAgIHN0cmlkZXMsXG4gICAgZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xuICB9XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgb3V0cHV0U2hhcGVdO1xufTtcblxuY29uc3QgZ2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMgPSB7XG4gIGF1dG9QYWQ6ICcnLFxuICBjZWlsTW9kZTogMCxcbiAgY291bnRJbmNsdWRlUGFkOiBmYWxzZSxcbiAga2VybmVsU2hhcGU6IFtdLFxuICBzdHJpZGVzOiBbXSxcbiAgcGFkczogW10sXG4gIHN0b3JhZ2VPcmRlcjogMCxcbiAgZGlsYXRpb25zOiBbXSxcbiAgY2FjaGVLZXk6ICcnLFxufTtcblxuY29uc3QgZ2xvYmFsTWF4UG9vbE1ldGFkYXRhID0ge1xuICBuYW1lOiAnR2xvYmFsTWF4UG9vbCcsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5nbG9iYWxNYXhQb29sTWV0YWRhdGEsXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyhpbnB1dHMsIGdsb2JhbE1heFBvb2xNZXRhZGF0YSwgdHJ1ZSwgZ2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gKFxuICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4gIG9wMTogc3RyaW5nLFxuICBvcDI6IHN0cmluZyxcbiAgc3RhcnQ6IHN0cmluZyxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dERpbXMubGVuZ3RoO1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGNvbnN0IGt3ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgY29uc3QgcHdFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRpbVcgPSBpbnB1dERpbXNbcmFuayAtIDFdO1xuICAgIGxldCBjb2RlVyA9ICcnO1xuICAgIGxldCBjb2RlSCA9ICcnO1xuICAgIGxldCBjb2RlSEVuZCA9ICcnO1xuICAgIGlmIChwd1N0YXJ0ICsgcHdFbmQgIT09IDApIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMV0gPCAwIHx8IHhbJHtyYW5rfSAtIDFdID49ICR7ZGltV30pIHtcbiAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICAke29wMX1cbiAgICAgICAgICB9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGtoID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3Qgc2ggPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgcGhTdGFydCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC8gMiAtIDJdO1xuICAgICAgY29uc3QgcGhFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgZGltSCA9IGlucHV0RGltc1tyYW5rIC0gMl07XG4gICAgICBpZiAocGhTdGFydCArIHBoRW5kICE9PSAwKSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke2tofTsgaisrKSB7XG4gICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDJdID0gaW5kaWNlc1ske3Jhbmt9IC0gMl0gKiAke3NofSAtICR7cGhTdGFydH0gKyBqO1xuICAgICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMl0gPCAwIHx8IHhbJHtyYW5rfSAtIDJdID49ICR7ZGltSH0pIHtcbiAgICAgICAgICAgICAgICBwYWQrPSAke2t3fTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtraH07IGorKykge1xuICAgICAgICAgICAgICB4WyR7cmFua30gLSAyXSA9IGluZGljZXNbJHtyYW5rfSAtIDJdICogJHtzaH0gLSAke3BoU3RhcnR9ICsgajtcbiAgICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb2RlSEVuZCA9IGBcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgfVxuXG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgeFske3Jhbmt9XTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke3N0YXJ0fTtcbiAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAke2NvZGVIfVxuICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAke29wMn1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICAgIGNvbnN0IHN0cmlkZXNSYW5rID0ga2VybmVsU3RyaWRlcy5sZW5ndGg7XG4gICAgY29uc3QgcGFkc1JhbmsgPSBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoO1xuICAgIGNvbnN0IG9mZnNldFRvSW5kaWNlc0Z1bmN0aW9uID0gb2Zmc2V0VG9JbmRpY2VzKHN0cmlkZXNSYW5rKTtcbiAgICBjb25zdCBjb3B5SW5wdXREaW1zID0gY29weUFycmF5KGlucHV0RGltcywgJ2lucHV0RGltcycpO1xuICAgIGNvbnN0IGNvcHlQYWRzID0gY29weUFycmF5KGF0dHJpYnV0ZXMucGFkcywgJ3BhZHMnKTtcbiAgICBjb25zdCBjb3B5S2VybmVsU3RyaWRlcyA9IGNvcHlBcnJheShrZXJuZWxTdHJpZGVzLCAna2VybmVsU3RyaWRlcycpO1xuICAgIGNvbnN0IGNvcHlTdHJpZGVzID0gY29weUFycmF5KGF0dHJpYnV0ZXMuc3RyaWRlcywgJ3N0cmlkZXMnKTtcbiAgICBjb25zdCBoYXNQYWRzID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoc3VtLCBjdXIpID0+IHN1bSArIGN1cik7XG4gICAgbGV0IHBhZENvZGUgPSAnJztcbiAgICBpZiAoaGFzUGFkcykge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZENvZGUgPSBgXG4gICAgICAgICAgfVxuICAgICAgICAgICR7b3AxfVxuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgJHtvZmZzZXRUb0luZGljZXNGdW5jdGlvbn1cbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgIGludCB4WyR7cmFua31dO1xuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XG4gICAgICAgICAgaW50IG9mZnNldFske3N0cmlkZXNSYW5rfV07XG4gICAgICAgICAgaW50IHBhZHNbJHtwYWRzUmFua31dO1xuICAgICAgICAgIGludCBpbnB1dERpbXNbJHtyYW5rfV07XG4gICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtzdHJpZGVzUmFua31dO1xuICAgICAgICAgIGludCBzdHJpZGVzWyR7c3RyaWRlc1Jhbmt9XTtcbiAgICAgICAgICAke2NvcHlQYWRzfVxuICAgICAgICAgICR7Y29weUlucHV0RGltc31cbiAgICAgICAgICAke2NvcHlTdHJpZGVzfVxuICAgICAgICAgICR7Y29weUtlcm5lbFN0cmlkZXN9XG5cbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7c3RhcnR9O1xuICAgICAgICAgIGludCBwYWQgPSAwO1xuICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7a2VybmVsU2l6ZX07IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0VG9JbmRpY2VzKGksIGtlcm5lbFN0cmlkZXMsIG9mZnNldCk7XG4gICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9ICR7cmFua30gLSAke3N0cmlkZXNSYW5rfTsgaiA8ICR7cmFua307IGorKykge1xuICAgICAgICAgICAgICB4W2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7cmFua30gKyAke3N0cmlkZXNSYW5rfV1cbiAgICAgICAgICAgICAgICArIG9mZnNldFtqIC0gJHtyYW5rfSArICR7c3RyaWRlc1Jhbmt9XSAtIHBhZHNbaiAtIDJdO1xuICAgICAgICAgICAgICAke3BhZENvZGV9XG4gICAgICAgICAgfVxuICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBwb29saW5nQ29kZTtcbiAgfVxufTtcblxuY29uc3QgY29weUFycmF5ID0gKGFycmF5OiByZWFkb25seSBudW1iZXJbXSwgYXJyYXlOYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICR7YXJyYXlOYW1lfVske2l9XSA9ICR7YXJyYXlbaV19O1xuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufTtcblxuY29uc3Qgb2Zmc2V0VG9JbmRpY2VzID0gKHJhbms6IG51bWJlcik6IHN0cmluZyA9PiBgXG4gIHZvaWQgb2Zmc2V0VG9JbmRpY2VzKGludCBvZmZzZXQsIGludFske3Jhbmt9XSBzdHJpZGVzLCBvdXQgaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICBpZiAoJHtyYW5rfSA9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtyYW5rfSAtIDE7ICsraSkge1xuICAgICAgaW5kaWNlc1tpXSA9IG9mZnNldCAvIHN0cmlkZXNbaV07XG4gICAgICBvZmZzZXQgLT0gaW5kaWNlc1tpXSAqIHN0cmlkZXNbaV07XG4gICAgfVxuICAgIGluZGljZXNbJHtyYW5rfSAtIDFdID0gb2Zmc2V0O1xuICB9YDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBOVU1CRVJfVFlQRVMsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVkdWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xuICByZWFkb25seSBrZWVwRGltczogYm9vbGVhbjtcbn1cblxuLy8gcmV0dXJuIFtpbml0IG9wcywgcmVkdWNlIG9wcywgZmluYWwgb3BzXVxudHlwZSBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSkgPT4gc3RyaW5nW107XG5cbmNvbnN0IHJlZHVjZSA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICBuYW1lOiBzdHJpbmcsXG4gIHJlZHVjZU9wOiBSZWR1Y2VPcCxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBjb25zdCByZWR1Y2VQcm9ncmFtTWV0YWRhdGEgPSB7XG4gICAgbmFtZSxcbiAgICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHtcbiAgICAgIC4uLnJlZHVjZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGdldDogKCkgPT4gY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCBuYW1lLCByZWR1Y2VPcCwgcmVkdWNlUHJvZ3JhbU1ldGFkYXRhKSxcbiAgICB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVkdWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUmVkdWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4ZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycsIFtdKTtcbiAgY29uc3Qga2VlcERpbXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdrZWVwZGltcycsIDEpID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhlcywga2VlcERpbXMgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyA9IChcbiAgX2hhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgX25hbWU6IHN0cmluZyxcbiAgcmVkdWNlT3A6IFJlZHVjZU9wLFxuICByZWR1Y2VQcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIHx8IDE7XG5cbiAgY29uc3QgaWR4Q29weSA9IFtdOyAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICBjb25zdCBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXR0cmlidXRlcy5heGVzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBvcHMgPSByZWR1Y2VPcChpbnB1dHMsIGF4ZXMpO1xuICBsZXQgcmVkdWNlT3BzID0gb3BzWzFdO1xuXG4gIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAvLyBpZiB0aGlzIGF4aXMgaXMgcmVkdWNlZFxuICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMua2VlcERpbXMpIHtcbiAgICAgICAgb3V0cHV0U2hhcGUucHVzaCgxKTtcbiAgICAgIH0gLy8gZWxzZSB7IHJlbW92ZSB0aGUgYXhpcyBmcm9tIG91dHB1dFNoYXBlOyB9XG5cbiAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZC10aCBheGlzXG4gICAgICByZWR1Y2VPcHMgPSBgXG4gICAgICAgICAgZm9yKGludCBqJHtrfSA9IDA7IGoke2t9IDwgJHtpbnB1dHNbMF0uZGltc1trXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgIGlucHV0SWR4WyR7a31dID0gaiR7a307XG4gICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4Q29weS5wdXNoKGBpbnB1dElkeFske2t9XSA9IG91dHB1dElkeFske291dHB1dFNoYXBlLmxlbmd0aH1dO2ApO1xuXG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKGlucHV0c1swXS5kaW1zW2tdKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBvUmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aCB8fCAxO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske29SYW5rfV0pIHtcbiAgICAgICAgZmxvYXQgdmFsdWU7ICAgICAgICAgICAgICAgICAvLyBmaW5hbCByZXN1bHRcbiAgICAgICAgaW50IGlucHV0SWR4WyR7aVJhbmt9XTsgICAgICAvLyBhZGRyZXNzaW5nIGlucHV0IGRhdGFcbiAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxuICAgICAgICAke29wc1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICR7cmVkdWNlT3BzfVxuICAgICAgICAke29wc1syXX0gICAgICAgLy8gZmluYWwgY29tcHV0YXRpb24gZm9yIHJlZHVjZSBtZWFuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1gO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVkdWNlUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogc3VwcG9ydCBSZWR1Y2UqIG9wZXJhdG9ycyB3aXRoIDIgaW5wdXRzLlxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW06IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKCk6IHN0cmluZ1tdID0+IFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlU3VtJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW46IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW10gPT4ge1xuICAgIGxldCBzaXplID0gMS4wO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzaXplICo9IGlucHV0c1swXS5kaW1zW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbJ3ZhbHVlID0gMC4wOycsICd2YWx1ZSArPSBfQShpbnB1dElkeCk7JywgYHZhbHVlIC89ICR7c2l6ZX0uO2BdOyAvLyBlbnN1cmUgcmVhbCBudW1iZXIgd2l0aCBgLmBcbiAgfTtcbiAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VNZWFuJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXhlczogbnVtYmVyW10pOiBzdHJpbmdbXSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0SWR4WyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYCR7aWR4WmVyby5qb2luKCdcXG4nKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLCAndmFsdWUgPSBtYXgodmFsdWUsIF9BKGlucHV0SWR4KSk7JywgJyddO1xuICB9O1xuICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZU1heCcsIHJlZHVjZU9wKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNaW46IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dElkeFske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2Ake2lkeFplcm8uam9pbignXFxuJyl9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCwgJ3ZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpOycsICcnXTtcbiAgfTtcbiAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VNaW4nLCByZWR1Y2VPcCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlUHJvZDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWyd2YWx1ZSA9IDEuMDsnLCAndmFsdWUgKj0gX0EoaW5wdXRJZHgpOycsICcnXTtcbiAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VQcm9kJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWyd2YWx1ZSA9IDAuMDsnLCAndmFsdWUgKz0gX0EoaW5wdXRJZHgpOycsICd2YWx1ZSA9IGxvZyh2YWx1ZSk7J107XG4gIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlTG9nU3VtJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bVNxdWFyZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWydmbG9hdCB0OyB2YWx1ZSA9IDAuMDsnLCAndCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7JywgJyddO1xuICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZUxvZ1N1bVNxdWFyZScsIHJlZHVjZU9wKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IHJlc2hhcGUgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZXNoYXBlZERpbXMgPSBTaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uaW50ZWdlckRhdGEpO1xuICBpZiAoaGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICByZXR1cm4gW2hhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMF0sIHJlc2hhcGVkRGltcyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCByZXNoYXBlZERpbXMpXTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwc2FtcGxlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG9wc2V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlzUmVzaXplOiBib29sZWFuO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNjYWxlczogbnVtYmVyW107XG4gIHJlYWRvbmx5IGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xuICByZWFkb25seSBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogc3RyaW5nO1xuICByZWFkb25seSB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuO1xuICByZWFkb25seSBuZWVkUm9pSW5wdXQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG5lYXJlc3RNb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGN1YmljQ29lZmZpY2llbnRBOiBudW1iZXI7XG4gIHJlYWRvbmx5IGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICByZWFkb25seSB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb246IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJvaUlucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjYWxlc0lucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNpemVzSW5wdXRJZHg6IG51bWJlcjtcbn1cblxuY29uc3QgdXBzYW1wbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdVcHNhbXBsZScsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHVwc2FtcGxlOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi51cHNhbXBsZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGdldDogKCkgPT4gY3JlYXRlVXBzYW1wbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNzogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogVXBzYW1wbGVBdHRyaWJ1dGVzID0+IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKG5vZGUsIDcpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogVXBzYW1wbGVBdHRyaWJ1dGVzID0+IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKG5vZGUsIDkpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSwgb3BzZXQ6IG51bWJlcik6IFVwc2FtcGxlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGlzUmVzaXplID0gb3BzZXQgPj0gMTA7XG5cbiAgLy8gcHJvY2Vzc2luZyBub2RlIGF0dHJpYnV0ZXNcbiAgY29uc3QgbW9kZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnbmVhcmVzdCcpO1xuICBpZiAobW9kZSAhPT0gJ25lYXJlc3QnICYmIG1vZGUgIT09ICdsaW5lYXInICYmIChvcHNldCA8IDExIHx8IG1vZGUgIT09ICdjdWJpYycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICB9XG5cbiAgbGV0IHNjYWxlczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKG9wc2V0IDwgOSkge1xuICAgIHNjYWxlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdHMoJ3NjYWxlcycpO1xuICAgIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIH1cblxuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2V4dHJhcG9sYXRpb25fdmFsdWUnLCAwLjApO1xuXG4gIGNvbnN0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICBvcHNldCA+IDEwID8gbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnY29vcmRpbmF0ZV90cmFuc2Zvcm1hdGlvbl9tb2RlJywgJ2hhbGZfcGl4ZWwnKSA6ICdhc3ltbWV0cmljJztcbiAgaWYgKFxuICAgIFtcbiAgICAgICdhc3ltbWV0cmljJyxcbiAgICAgICdweXRvcmNoX2hhbGZfcGl4ZWwnLFxuICAgICAgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJyxcbiAgICAgICdhbGlnbl9jb3JuZXJzJyxcbiAgICAgICd0Zl9jcm9wX2FuZF9yZXNpemUnLFxuICAgICAgJ2hhbGZfcGl4ZWwnLFxuICAgIF0uaW5kZXhPZihjb29yZGluYXRlVHJhbnNmb3JtTW9kZSkgPT09IC0xXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY29vcmRpbmF0ZV90cmFuc2Zvcm1fbW9kZSAnJHtjb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICBjb25zdCBuZWVkUm9pSW5wdXQgPSBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc7XG4gIGNvbnN0IHVzZUV4dHJhcG9sYXRpb24gPSBuZWVkUm9pSW5wdXQ7XG5cbiAgY29uc3QgbmVhcmVzdE1vZGUgPVxuICAgIG1vZGUgPT09ICduZWFyZXN0JyAmJiBvcHNldCA+PSAxMSA/IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ25lYXJlc3RfbW9kZScsICdyb3VuZF9wcmVmZXJfZmxvb3InKSA6ICcnO1xuICBpZiAoWydyb3VuZF9wcmVmZXJfZmxvb3InLCAncm91bmRfcHJlZmVyX2NlaWwnLCAnZmxvb3InLCAnY2VpbCcsICcnXS5pbmRleE9mKG5lYXJlc3RNb2RlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5lYXJlc3RfbW9kZSAnJHtuZWFyZXN0TW9kZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuXG4gIGNvbnN0IGN1YmljQ29lZmZpY2llbnRBID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdjdWJpY19jb2VmZl9hJywgLTAuNzUpO1xuICBjb25zdCBleGNsdWRlT3V0c2lkZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2V4Y2x1ZGVfb3V0c2lkZScsIDApICE9PSAwO1xuICBpZiAoZXhjbHVkZU91dHNpZGUgJiYgbW9kZSAhPT0gJ2N1YmljJykge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZV9vdXRzaWRlIGNhbiBiZSBzZXQgdG8gMSBvbmx5IHdoZW4gbW9kZSBpcyBDVUJJQy4nKTtcbiAgfVxuXG4gIGNvbnN0IHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbiA9XG4gICAgb3BzZXQgPCAxMSA/IHRydWUgOiBtb2RlID09PSAnbmVhcmVzdCcgJiYgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICdhc3ltbWV0cmljJyAmJiBuZWFyZXN0TW9kZSA9PT0gJ2Zsb29yJztcblxuICBsZXQgcm9pSW5wdXRJZHggPSAwO1xuICBsZXQgc2NhbGVzSW5wdXRJZHggPSAwO1xuICBsZXQgc2l6ZXNJbnB1dElkeCA9IDA7XG5cbiAgaWYgKG9wc2V0ID4gMTApIHtcbiAgICAvLyBoYW5kbGUgd2hlbiByb2lJbnB1dCBpcyBub3QgZ2l2ZW5cbiAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoID4gMikge1xuICAgICAgcm9pSW5wdXRJZHggPSAxO1xuICAgICAgc2NhbGVzSW5wdXRJZHggPSAyO1xuICAgICAgc2l6ZXNJbnB1dElkeCA9IDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlc0lucHV0SWR4ID0gMTtcbiAgICAgIHNpemVzSW5wdXRJZHggPSAyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHNldCA9PT0gOSkge1xuICAgIHNjYWxlc0lucHV0SWR4ID0gMTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIG9wc2V0LFxuICAgIGlzUmVzaXplLFxuICAgIG1vZGUsXG4gICAgc2NhbGVzLFxuICAgIGV4dHJhcG9sYXRpb25WYWx1ZSxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICB1c2VFeHRyYXBvbGF0aW9uLFxuICAgIG5lZWRSb2lJbnB1dCxcbiAgICBuZWFyZXN0TW9kZSxcbiAgICBjdWJpY0NvZWZmaWNpZW50QSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb24sXG4gICAgcm9pSW5wdXRJZHgsXG4gICAgc2NhbGVzSW5wdXRJZHgsXG4gICAgc2l6ZXNJbnB1dElkeCxcbiAgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVVcHNhbXBsZVByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBbaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgVGV4dHVyZVR5cGUudW5wYWNrZWQsXG4gICk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5tYXAoKGRpbSwgaSkgPT4gTWF0aC5mbG9vcihkaW0gKiBhdHRyaWJ1dGVzLnNjYWxlc1tpXSkpO1xuICBjb25zdCBbb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBvdXRwdXRTaGFwZSxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3QgZGltID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IG91dHB1dFBpdGNoZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pO1xuICBjb25zdCBpbnB1dFBpdGNoZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pO1xuICBsZXQgcHJlY2FsY3VsYXRlZFBpdGNoZXMgPSBgXG4gICAgICBpbnQgb3V0cHV0X3BpdGNoZXNbJHtkaW19XTtcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7ZGltfV07XG4gICAgICBgO1xuICBmb3IgKGxldCBkID0gZGltIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICBvdXRwdXRQaXRjaGVzW2RdID0gZCA9PT0gZGltIC0gMSA/IDEgOiBvdXRwdXRQaXRjaGVzW2QgKyAxXSAqIG91dHB1dFNoYXBlW2QgKyAxXTtcbiAgICBpbnB1dFBpdGNoZXNbZF0gPSBkID09PSBkaW0gLSAxID8gMSA6IGlucHV0UGl0Y2hlc1tkICsgMV0gKiBpbnB1dHNbMF0uZGltc1tkICsgMV07XG5cbiAgICBwcmVjYWxjdWxhdGVkUGl0Y2hlcyArPSBgXG4gICAgICAgIG91dHB1dF9waXRjaGVzWyR7ZH1dID0gJHtvdXRwdXRQaXRjaGVzW2RdfTtcbiAgICAgICAgaW5wdXRfcGl0Y2hlc1ske2R9XSA9ICR7aW5wdXRQaXRjaGVzW2RdfTtcbiAgICAgICAgYDtcbiAgfVxuICBjb25zdCBnZXRJbnB1dEZsb2F0RnVuY3Rpb24gPSBgXG4gICAgICBmbG9hdCBnZXRJbnB1dEZsb2F0KGludCBpbmRleCkge1xuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGluZGV4LCAke2lucHV0V2lkdGh9LCAke2lucHV0SGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KFgsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9XG4gICAgYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCdcbiAgICAgID8gLy8gbmVhcmVzdFxuICAgICAgICBgXG4gICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2RpbX1dKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBkLCBtO1xuICAgICAgZm9yIChpbnQgZGltID0gMDsgZGltIDwgJHtkaW19OyArK2RpbSkge1xuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGQgKiBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xuICAgICAgICBvdXRwdXRfaW5kZXggPSBtO1xuXG4gICAgICAgIGlmIChzY2FsZXNbZGltXSAhPSAxICYmIGQgPiAwKSB7XG4gICAgICAgICAgaW50IGQyID0gZCAvIHNjYWxlc1tkaW1dO1xuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcbiAgICAgICAgICBkID0gZDI7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgIH1gXG4gICAgICA6IGRpbSA9PT0gNFxuICAgICAgICA/IC8vIGJpbGluZWFyIDREXG4gICAgICAgICAgYFxuICAgICR7Z2V0SW5wdXRGbG9hdEZ1bmN0aW9ufVxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbNF0pIHtcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke291dHB1dFdpZHRofSwgJHtvdXRwdXRIZWlnaHR9KTtcblxuICAgICAgJHtwcmVjYWxjdWxhdGVkUGl0Y2hlc31cblxuICAgICAgaW50IG07XG4gICAgICBpbnQgaW5kZXhfb2ZfZGltMCwgaW5kZXhfb2ZfZGltMSwgaW5kZXhfb2ZfZGltMiwgaW5kZXhfb2ZfZGltMztcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBpbmRleF9vZl9kaW0xID0gbSAvIG91dHB1dF9waXRjaGVzWzFdO1xuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XG4gICAgICBpbmRleF9vZl9kaW0yID0gbSAvIG91dHB1dF9waXRjaGVzWzJdO1xuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0yICogb3V0cHV0X3BpdGNoZXNbMl07XG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcblxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTIsIGluZGV4X29mX2lucHV0X2RpbTMsIHhfb2Zmc2V0LCB5X29mZnNldDtcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xuICAgICAgeV9vZmZzZXQgPSBpbmRleF9vZl9kaW0yIC0gaW5kZXhfb2ZfaW5wdXRfZGltMiAqIHNjYWxlc1syXTtcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTMgPSBpbmRleF9vZl9kaW0zIC8gc2NhbGVzWzNdO1xuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcblxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXG4gICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0yICogaW5wdXRfcGl0Y2hlc1syXSArXG4gICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0zO1xuXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgIGJvb2wgZW5kX29mX2RpbTIgPSBmYWxzZTtcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0yID09ICgke2lucHV0c1swXS5kaW1zWzJdfSAtIDEpKSB7XG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMlxuICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTMgPT0gKGlucHV0X3BpdGNoZXNbMl0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcbiAgICAgICAgeDEwID0geDAwO1xuICAgICAgICB4MTEgPSB4MDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1syXSk7XG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbM10pO1xuICAgIH1gXG4gICAgICAgIDogLy8gYmlsaW5lYXIgMkRcbiAgICAgICAgICBgXG4gICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1syXSkge1xuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7b3V0cHV0V2lkdGh9LCAke291dHB1dEhlaWdodH0pO1xuXG4gICAgICAke3ByZWNhbGN1bGF0ZWRQaXRjaGVzfVxuXG4gICAgICBpbnQgbTtcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xO1xuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtO1xuXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMCwgaW5kZXhfb2ZfaW5wdXRfZGltMSwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMCA9IGluZGV4X29mX2RpbTAgLyBzY2FsZXNbMF07XG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMSA9IGluZGV4X29mX2RpbTEgLyBzY2FsZXNbMV07XG4gICAgICB4X29mZnNldCA9IGluZGV4X29mX2RpbTEgLSBpbmRleF9vZl9pbnB1dF9kaW0xICogc2NhbGVzWzFdO1xuXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2lucHV0X2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICsgaW5kZXhfb2ZfaW5wdXRfZGltMTtcblxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xuXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMCA9PSAoJHtpbnB1dHNbMF0uZGltc1swXX0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcbiAgICAgICAgeDAxID0geDAwO1xuICAgICAgICBlbmRfb2ZfZGltMCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0xID09IChpbnB1dF9waXRjaGVzWzBdIC0gMSkpIHtcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAxXG4gICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgeDExID0geDAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTAgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSArIDEpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzBdKTtcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzFdKTtcbiAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi51cHNhbXBsZVByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgdmFyaWFibGVzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzY2FsZXMnLFxuICAgICAgICB0eXBlOiAnaW50JyxcbiAgICAgICAgYXJyYXlMZW5ndGg6IGF0dHJpYnV0ZXMuc2NhbGVzLmxlbmd0aCxcbiAgICAgICAgZGF0YTogYXR0cmlidXRlcy5zY2FsZXMubWFwKCh4KSA9PiBNYXRoLmNlaWwoeCkpLFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZTogVXBzYW1wbGVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChcbiAgICAhaW5wdXRzIHx8XG4gICAgKGF0dHJpYnV0ZS5vcHNldCA8IDkgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMSkgfHxcbiAgICAoYXR0cmlidXRlLm9wc2V0ID49IDkgJiYgYXR0cmlidXRlLm9wc2V0IDwgMTEgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMikgfHxcbiAgICAoYXR0cmlidXRlLm9wc2V0ID49IDExICYmIGlucHV0cy5sZW5ndGggPCAyKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZS5zY2FsZXMubGVuZ3RoID4gMCAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGF0dHJpYnV0ZS5zY2FsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzY2FsZXNWYWxpZGF0aW9uID0gKHNjYWxlczogbnVtYmVyW10sIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgaWYgKCFpc1Jlc2l6ZSkge1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICBpZiAoc2NhbGUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IHNjYWxlIG9mIHNjYWxlcykge1xuICAgICAgaWYgKHNjYWxlIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnbGluZWFyJyB8fCBtb2RlID09PSAnY3ViaWMnKSB7XG4gICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDIgJiYgKHNjYWxlcy5sZW5ndGggIT09IDQgfHwgc2NhbGVzWzBdICE9PSAxIHx8IHNjYWxlc1sxXSAhPT0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ0xpbmVhcicgbW9kZSBhbmQgJ0N1YmljJyBtb2RlIG9ubHkgc3VwcG9ydCAyLUQgaW5wdXRzICgnQmlsaW5lYXInLCAnQmljdWJpYycpIFxcXG4gICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSBcXFxuICAgICAgICBpbiB0aGUgJHtpc1Jlc2l6ZSA/ICdSZXNpemUnIDogJ1Vwc2FtcGxlJ30gb3BlYXJ0b3IuYCk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgdW5wYWNrRnJvbUNoYW5uZWwgfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMsIHNjYWxlc1ZhbGlkYXRpb24sIFVwc2FtcGxlQXR0cmlidXRlcywgdmFsaWRhdGVJbnB1dHMgfSBmcm9tICcuL3Vwc2FtcGxlJztcblxuY29uc3QgcmVzaXplUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnUmVzaXplJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHJlc2l6ZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAge1xuICAgICAgLi4ucmVzaXplUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRSZXNpemVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4gcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMobm9kZSwgMTApO1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4gcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMobm9kZSwgMTEpO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRSZXNpemVQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3QgW3NjYWxlcywgb3V0cHV0U2hhcGVdID0gcHJlcGFyZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IGlzU2FtZSA9IHNjYWxlcy5ldmVyeSgoczogbnVtYmVyKSA9PiBzID09PSAxKSAmJiBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlICE9PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgaWYgKGlzU2FtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNpemVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkIH0sXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgc2hhZGVyU291cmNlOiBgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke2dsc2wudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHY7XG4gICAgICAgICAgICAgICAgfWAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGRpbSA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgaWYgKGRpbSA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDIsIGJ1dCBnb3QgJHtkaW19YCk7XG4gIH1cblxuICBjb25zdCBvdXRwdXRIZWlnaHQgPSBvdXRwdXRTaGFwZVtkaW0gLSAyXTtcbiAgY29uc3Qgb3V0cHV0V2lkdGggPSBvdXRwdXRTaGFwZVtkaW0gLSAxXTtcblxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGlmIChkaW0gIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBtYXRjaCBpbnB1dCAke2lucHV0U2hhcGUubGVuZ3RofSwgYnV0IGdvdCAke2RpbX1gKTtcbiAgfVxuICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0U2hhcGVbZGltIC0gMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dFNoYXBlW2RpbSAtIDFdO1xuXG4gIGNvbnN0IHNjYWxlc0hlaWdodCA9IHNjYWxlc1tkaW0gLSAyXTtcbiAgY29uc3Qgc2NhbGVzV2lkdGggPSBzY2FsZXNbZGltIC0gMV07XG5cbiAgbGV0IGdldFNvdXJjZUZyYWNJbmRleCA9ICcnO1xuXG4gIGlmIChhdHRyaWJ1dGVzLm1vZGUgIT09ICdsaW5lYXInKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBtb2Rlc1xuICAgIHRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgbW9kZTogJyR7YXR0cmlidXRlcy5tb2RlfSdgKTtcbiAgfVxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpIHtcbiAgICBjYXNlICdhc3ltbWV0cmljJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hhbGZfcGl4ZWwnOlxuICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdweXRvcmNoX2hhbGZfcGl4ZWwnOlxuICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0V2lkdGh9LjAgPiAxLjAgPyAoZmNvb3Jkcy54ICsgMC41KSAvIHNjYWxlV0hXSC54IC0gMC41IDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dFdpZHRofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dEhlaWdodH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7b3V0cHV0V2lkdGh9LjAgLSAxLjAsICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wLCAke291dHB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7aW5wdXRXaWR0aH0uMCAtIDEuMCwgJHtpbnB1dEhlaWdodH0uMCAtIDEuMCwgJHtpbnB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aW5wdXRIZWlnaHR9LjAgLSAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUT0RPOnN1cHBvcnRpbmcgb3RoZXIgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGVzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHthdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKTtcbiAgfVxuXG4gIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoZGltKTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICAgIGNvbnN0IHZlYzIgaW5wdXRXSCA9IHZlYzIoJHtpbnB1dEhlaWdodH0uMCwgJHtpbnB1dFdpZHRofS4wKTtcbiAgICAgICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNChmbG9hdCgke3NjYWxlc0hlaWdodH0pLCBmbG9hdCgke3NjYWxlc1dpZHRofSksIGZsb2F0KCR7c2NhbGVzSGVpZ2h0fSksIGZsb2F0KCR7XG4gICAgICAgICAgICAgIHNjYWxlc1dpZHRoXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAke3VucGFja0NoYW5uZWx9XG4gICAgICAgICAgICAke2dldFNvdXJjZUZyYWNJbmRleH1cbiAgICAgICAgICAgIGZsb2F0IGdldEFWYWx1ZShpbnQgeDEwLCBpbnQgciwgaW50IGMsIGludCBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QSh4MTAsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XG4gICAgICAgICAgICAgICAgaW50IGRlcHRoID0gcmNbMV07XG5cbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgaXZlYzQgY29vcmRzID0gaXZlYzQocmMud3osIHJjLncgKyAxLCByYy56ICsgMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxuICAgICAgICAgICAgICAgIHZlYzQgc291cmNlRnJhYyA9IGdldFNvdXJjZUZyYWNJbmRleChjb29yZHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXG4gICAgICAgICAgICAgICAgaXZlYzQgeDAwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHkpKSk7XG4gICAgICAgICAgICAgICAgaXZlYzQgeDAxID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHcsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHcpKSk7XG4gICAgICAgICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XG4gICAgICAgICAgICAgICAgaXZlYzQgeDExID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuencsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuencpKSk7XG5cbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtvdXRwdXRIZWlnaHQgLSAxfTtcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtvdXRwdXRXaWR0aCAtIDF9O1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLnkpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcFJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLncpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyBib3R0b20tbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSkgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC53KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgdmVjNCBmcmFjID0gdmVjNChzb3VyY2VGcmFjKSAtIGZsb29yKHNvdXJjZUZyYWMpO1xuICAgICAgICAgICAgICAgIHZlYzQgY2xhbXBGcmFjID0gY2xhbXAoZnJhYywgdmVjNCgwLjApLCB2ZWM0KDEuMCkpO1xuXG4gICAgICAgICAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGNsYW1wRnJhYy55d3l3KTtcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcblxuICAgICAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzaXplUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHByZXBhcmVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzKTogW3JlYWRvbmx5IG51bWJlcltdLCByZWFkb25seSBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB4ID0gaW5wdXRzWzBdO1xuICBjb25zdCB4RGltcyA9IHguZGltcztcblxuICBsZXQgc2NhbGVzID0gYXR0cmlidXRlcy5zY2FsZXM7XG4gIGxldCBvdXRwdXRTaXplczogbnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3Qgc2NhbGVzVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMuc2NhbGVzSW5wdXRJZHhdO1xuICAgIGlmIChzY2FsZXNUZW5zb3IgJiYgc2NhbGVzVGVuc29yLnNpemUgIT09IDApIHtcbiAgICAgIGlmIChpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzID0gcGFyc2VTY2FsZXNEYXRhKHNjYWxlc1RlbnNvciwgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2l6ZXNUZW5zb3IgPSBpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XTtcbiAgICAgIGlmICghc2l6ZXNUZW5zb3IgfHwgc2l6ZXNUZW5zb3Iuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC4nKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0U2l6ZXMgPSBBcnJheS5mcm9tKHNpemVzVGVuc29yLmludGVnZXJEYXRhKTtcbiAgICAgIHNjYWxlcyA9IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplKG91dHB1dFNpemVzLCB4RGltcywgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlucHV0c1thdHRyaWJ1dGVzLnNpemVzSW5wdXRJZHhdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHlEaW1zID0gb3V0cHV0U2l6ZXMgfHwgeERpbXMubWFwKChkaW0sIGkpID0+IE1hdGguZmxvb3IoZGltICogc2NhbGVzW2ldKSk7XG5cbiAgcmV0dXJuIFtzY2FsZXMsIHlEaW1zXTtcbn07XG5cbmNvbnN0IHBhcnNlU2NhbGVzRGF0YSA9IChzY2FsZTogVGVuc29yLCBtb2RlOiBzdHJpbmcsIGlzUmVzaXplOiBib29sZWFuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBzY2FsZXMgPSBBcnJheS5mcm9tKHNjYWxlLmZsb2F0RGF0YSk7XG4gIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIHJldHVybiBzY2FsZXM7XG59O1xuXG5jb25zdCBwYXJzZVNjYWxlc0RhdGFGcm9tT3V0cHV0U2l6ZSA9IChcbiAgeURpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICB4RGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG1vZGU6IHN0cmluZyxcbiAgaXNSZXNpemU6IGJvb2xlYW4sXG4pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGxlbmd0aCA9IHhEaW1zLmxlbmd0aDtcbiAgY29uc3Qgc2NhbGVzID0gbmV3IEFycmF5PG51bWJlcj4obGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMCwgZW5kID0gbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoeERpbXNbaV0gPT09IDApIHtcbiAgICAgIGlmICh5RGltc1tpXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzW2ldID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzW2ldID0geURpbXNbaV0gLyB4RGltc1tpXTtcbiAgICB9XG4gIH1cbiAgc2NhbGVzVmFsaWRhdGlvbihzY2FsZXMsIG1vZGUsIGlzUmVzaXplKTtcbiAgcmV0dXJuIHNjYWxlcztcbn07XG5cbi8vIHJvaSBkYXRhIGlzIG5vdCB1c2VkIHlldC4gYnV0IGxlYXZlIGhlcmUgZm9yIGZ1dHVyZSB1c2FnZS5cbi8vIGNvbnN0IGdldFJvaSA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMpIDogbnVtYmVyW10gPT4ge1xuLy8gICAgIGxldCByb2k6IG51bWJlcltdID0gW107XG4vLyAgICAgaWYgKGF0dHJpYnV0ZXMubmVlZFJvaUlucHV0KSB7XG4vLyAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnJvaUlucHV0SWR4IDw9IDApIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByb2kgaW5wdXQgaW5kZXguJyk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgY29uc3Qgcm9pVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMucm9pSW5wdXRJZHhdO1xuLy8gICAgICAgICByb2kgPSByb2lUZW5zb3Iuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHJvaVRlbnNvci5mbG9hdERhdGEpIDogW107XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgcm9pID0gbmV3IEFycmF5KGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIpLmZpbGwoMCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiByb2k7XG4vLyB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3Qgc2hhcGUgPSAoX2luZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgcmV0dXJuIFtuZXcgVGVuc29yKFtpbnB1dHNbMF0uZGltcy5sZW5ndGhdLCAnaW50MzInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbmV3IEludDMyQXJyYXkoaW5wdXRzWzBdLmRpbXMpKV07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgTlVNQkVSX1RZUEVTLCBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTbGljZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG59XG5cbmNvbnN0IHNsaWNlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU2xpY2UnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzbGljZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTbGljZUF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAge1xuICAgICAgLi4uc2xpY2VQcm9ncmFtTWV0YWRhdGEsXG4gICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBhdHRyaWJ1dGVzKSxcbiAgICB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2xpY2VBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNsaWNlQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHN0YXJ0cyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdzdGFydHMnKTtcbiAgY29uc3QgZW5kcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdlbmRzJyk7XG4gIGNvbnN0IGF4ZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycsIFtdKTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHN0YXJ0cywgZW5kcywgYXhlcyB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8gPSAoXG4gIF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPT09IDAgPyBpbnB1dC5kaW1zLnNsaWNlKDApLm1hcCgoX3ZhbCwgaSkgPT4gaSkgOiBhdHRyaWJ1dGVzLmF4ZXM7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBeGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXhlcywgaW5wdXQuZGltcy5sZW5ndGgpO1xuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cy5tYXAoKHN0YXJ0LCBpKSA9PiB7XG4gICAgaWYgKHN0YXJ0ID4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0gLSAxKSB7XG4gICAgICByZXR1cm4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhzdGFydCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICB9KTtcbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcy5tYXAoKGVuZCwgaSkgPT4ge1xuICAgIGlmIChlbmQgPiBpbnB1dC5kaW1zW25vcm1hbGl6ZWRBeGVzW2ldXSAtIDEpIHtcbiAgICAgIHJldHVybiBpbnB1dC5kaW1zW25vcm1hbGl6ZWRBeGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGVuZCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICB9KTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0LmRpbXMuc2xpY2UoKTtcblxuICBjb25zdCBzbGljZU9wczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3JtYWxpemVkQXhlcy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFNoYXBlW25vcm1hbGl6ZWRBeGVzW2ldXSA9IGVuZHNbaV0gLSBzdGFydHNbaV07XG4gICAgaWYgKHN0YXJ0c1tpXSA+IDApIHtcbiAgICAgIHNsaWNlT3BzLnB1c2goYG91dHB1dElkeFske25vcm1hbGl6ZWRBeGVzW2ldfV0gKz0gJHtzdGFydHNbaV19O2ApO1xuICAgIH0gLy8gZWxzZSB7IHNsaWNlT3BzLnB1c2goYG91dHB1dElkeFske25vcm1hbGl6ZWRBeGVzW2ldfV0gKz0gMDtgKTsgfVxuICB9XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgICR7c2xpY2VPcHMuam9pbignXFxuICAgICAgJyl9XG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4uc2xpY2VQcm9ncmFtTWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NsaWNlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlVjEwID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMTAoaW5wdXRzKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5zbGljZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGdldDogKCkgPT4gY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgW2lucHV0c1swXV0sXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuKTogU2xpY2VBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKFxuICAgICFpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMV0uZGF0YUlkKSB8fFxuICAgICFpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMl0uZGF0YUlkKSB8fFxuICAgIChpbnB1dHMubGVuZ3RoID49IDQgJiYgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1szXS5kYXRhSWQpKSB8fFxuICAgIChpbnB1dHMubGVuZ3RoID49IDUgJiYgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1s0XS5kYXRhSWQpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHMubGVuZ3RoID49IDUgJiYgaW5wdXRzWzRdLmludGVnZXJEYXRhLnNvbWUoKGk6IG51bWJlcikgPT4gaSAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub24tMSBzdGVwcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBTbGljZScpO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRzID0gQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpO1xuICBjb25zdCBlbmRzID0gQXJyYXkuZnJvbShpbnB1dHNbMl0uaW50ZWdlckRhdGEpO1xuICBjb25zdCBheGVzID0gaW5wdXRzLmxlbmd0aCA+PSA0ID8gQXJyYXkuZnJvbShpbnB1dHNbM10uaW50ZWdlckRhdGEpIDogW107XG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7YXhlc307JHtzdGFydHN9OyR7ZW5kc31gO1xuICByZXR1cm4geyBzdGFydHMsIGVuZHMsIGF4ZXMsIGNhY2hlS2V5IH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c1YxMCA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IG51bWJlci4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgfHwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1syXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID49IDQgJiYgKGlucHV0c1szXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1szXS5kaW1zLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmIChpbnB1dHNbNF0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbNF0uZGltcy5sZW5ndGggIT09IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyB0cmFuc3Bvc2UsIFRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29mdG1heEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHNvZnRtYXhDb21wdXRlTWF4UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU29mdG1heENvbXB1dGVNYXgnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IHNvZnRtYXhDb21wdXRlU2NhbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdTb2Z0bWF4Q29tcHV0ZVNjYWxlJyxcbiAgaW5wdXROYW1lczogWydBJywgJ01heCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IHNvZnRtYXhQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdTb2Z0TWF4JyxcbiAgaW5wdXROYW1lczogWydBJywgJ01heCcsICdOb3JtJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzb2Z0bWF4OiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBTb2Z0bWF4QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBsb2dpY2FsUm93Q291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuICBjb25zdCBmZWF0dXJlQ291bnQgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXhpcyk7XG5cbiAgY29uc3Qgb3V0cHV0ID0gY29tcHV0ZVNvZnRtYXgoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCBsb2dpY2FsUm93Q291bnQsIGZlYXR1cmVDb3VudCk7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTb2Z0bWF4QXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxTb2Z0bWF4QXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMSkgfSk7XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9IChcbiAgbm9kZTogR3JhcGguTm9kZSxcbik6IFNvZnRtYXhBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAtMSkgfSk7XG5cbi8vIFRoZSBcInNlbWFudGljXCIgbWVhbmluZyBvZiBheGlzIGhhcyBjaGFuZ2VkIGluIG9wc2V0LTEzLlxuLy8gUGxlYXNlIGNvbXBhcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI1NvZnRtYXhcbi8vIHdpdGggaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9DaGFuZ2Vsb2cubWQjU29mdG1heC0xMSBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb25zXG4vLyBUbyBhY2NvdW50IGZvciB0aGUgb3BzZXQtMTMgYmVoYXZpb3IsIG91ciBwbGFuIHdpbGwgYmUgdG8gdHJhbnNwb3NlIHRoZSBcImF4aXNcIiBkaW0gdG8gdGhlIGlubmVybW9zdCBkaW1cbi8vIGFuZCBwZXJmb3JtIHNvZnRtYXggYW5kIHRoZW4gcmV2ZXJzZSB0aGUgdHJhbnNwb3NlLiBXZSBjYW4gc2tpcCB0aGUgdHJhbnNwb3NpbmcgYXNwZWN0IGlmIHRoZSBheGlzIGlzIGFscmVhZHlcbi8vIHRoZSBpbm5lcm1vc3QgZGltXG5leHBvcnQgY29uc3Qgc29mdG1heFYxMzogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTb2Z0bWF4QXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgcmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IGlzVHJhbnNwb3NlUmVxdWlyZWQgPSBheGlzICE9PSByYW5rIC0gMSA/IHRydWUgOiBmYWxzZTtcbiAgY29uc3QgdHJhbnNwb3NlZElucHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGxldCBwZXJtOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgdHJhbnNwb3NlZElucHV0czogVGVuc29yW10gPSBbXTtcbiAgbGV0IHRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcztcblxuICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgIHBlcm0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByYW5rIH0pLm1hcCgoXywgaSkgPT4gaSk7XG5cbiAgICAvLyBzd2FwIHRoZSBpbm5lcm1vc3QgZGltIHdpdGggdGhlIGRpbSBjb3JyZXNwb25kaW5nIHRvIGF4aXNcbiAgICBwZXJtW2F4aXNdID0gcmFuayAtIDE7XG4gICAgcGVybVtyYW5rIC0gMV0gPSBheGlzO1xuXG4gICAgcGVybS5tYXAoKHApID0+IHRyYW5zcG9zZWRJbnB1dFNoYXBlLnB1c2goaW5wdXRTaGFwZVtwXSkpO1xuXG4gICAgdHJhbnNwb3NlQXR0cmlidXRlID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcGVybSB9KTtcbiAgICB0cmFuc3Bvc2VkSW5wdXRzID0gdHJhbnNwb3NlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgdHJhbnNwb3NlQXR0cmlidXRlKTtcbiAgfVxuXG4gIGNvbnN0IGxvZ2ljYWxSb3dDb3VudCA9IGlzVHJhbnNwb3NlUmVxdWlyZWRcbiAgICA/IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24odHJhbnNwb3NlZElucHV0U2hhcGUsIHJhbmsgLSAxKVxuICAgIDogU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihpbnB1dFNoYXBlLCByYW5rIC0gMSk7XG4gIGNvbnN0IGZlYXR1cmVDb3VudCA9IGlzVHJhbnNwb3NlUmVxdWlyZWRcbiAgICA/IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih0cmFuc3Bvc2VkSW5wdXRTaGFwZSwgcmFuayAtIDEpXG4gICAgOiBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgcmFuayAtIDEpO1xuXG4gIGNvbnN0IG91dHB1dCA9IGNvbXB1dGVTb2Z0bWF4KFxuICAgIGluZmVyZW5jZUhhbmRsZXIsXG4gICAgaXNUcmFuc3Bvc2VSZXF1aXJlZCA/IHRyYW5zcG9zZWRJbnB1dHMgOiBpbnB1dHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBsb2dpY2FsUm93Q291bnQsXG4gICAgZmVhdHVyZUNvdW50LFxuICApO1xuXG4gIGlmIChpc1RyYW5zcG9zZVJlcXVpcmVkKSB7XG4gICAgY29uc3QgcmV2ZXJzZWRPdXRwdXQgPSB0cmFuc3Bvc2UoaW5mZXJlbmNlSGFuZGxlciwgb3V0cHV0LCB0cmFuc3Bvc2VBdHRyaWJ1dGUhKTtcbiAgICByZXR1cm4gcmV2ZXJzZWRPdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuY29uc3QgY29tcHV0ZVNvZnRtYXggPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMsXG4gIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLFxuICBmZWF0dXJlQ291bnQ6IG51bWJlcixcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgY29tcHV0ZU1heFByb2dyYW1JbmZvID0gY3JlYXRlQ29tcHV0ZU1heFByb2dyYW1JbmZvKFxuICAgIGluZmVyZW5jZUhhbmRsZXIsXG4gICAgaW5wdXRzWzBdLFxuICAgIGxvZ2ljYWxSb3dDb3VudCxcbiAgICBmZWF0dXJlQ291bnQsXG4gICAgW2xvZ2ljYWxSb3dDb3VudF0sXG4gICk7XG4gIGNvbnN0IG1heCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc29mdG1heENvbXB1dGVNYXhQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgZ2V0OiAoKSA9PiBjb21wdXRlTWF4UHJvZ3JhbUluZm8gfSxcbiAgICBpbnB1dHMsXG4gICk7XG5cbiAgY29uc3QgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8gPSBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvKFxuICAgIGluZmVyZW5jZUhhbmRsZXIsXG4gICAgaW5wdXRzWzBdLFxuICAgIGxvZ2ljYWxSb3dDb3VudCxcbiAgICBmZWF0dXJlQ291bnQsXG4gICAgY29tcHV0ZU1heFByb2dyYW1JbmZvLm91dHB1dC5kaW1zLFxuICAgIFtsb2dpY2FsUm93Q291bnRdLFxuICApO1xuICBjb25zdCBzY2FsZSA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc29mdG1heENvbXB1dGVTY2FsZVByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBnZXQ6ICgpID0+IGNvbXB1dGVTY2FsZVByb2dyYW1JbmZvIH0sXG4gICAgW2lucHV0c1swXSwgbWF4XSxcbiAgKTtcblxuICBjb25zdCBzb2Z0TWF4UHJvZ3JhbUluZm8gPSBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8oXG4gICAgaW5mZXJlbmNlSGFuZGxlcixcbiAgICBpbnB1dHNbMF0sXG4gICAgbG9naWNhbFJvd0NvdW50LFxuICAgIGZlYXR1cmVDb3VudCxcbiAgICBjb21wdXRlTWF4UHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICAgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc29mdG1heFByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBnZXQ6ICgpID0+IHNvZnRNYXhQcm9ncmFtSW5mbyB9LFxuICAgIFtpbnB1dHNbMF0sIG1heCwgc2NhbGVdLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgbG9naWNhbFJvd0NvdW50OiBudW1iZXIsXG4gIGZlYXR1cmVDb3VudDogbnVtYmVyLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFt0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgaW5wdXQuZGltcyxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICBpZiAobG9naWNhbFJvd0NvdW50IDwgMSB8fCBmZWF0dXJlQ291bnQgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlWzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gIH1cblxuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHt0ZXh0dXJlV2lkdGh9LFxuICAgICAgICAke3RleHR1cmVIZWlnaHR9ICkpKTtcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtmZWF0dXJlQ291bnR9OyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXG4gICAgICAgICAgICAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pKSk7XG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLnNvZnRtYXhDb21wdXRlTWF4UHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIG5vcm1hbGl6YXRpb24gZmFjdG9yIGZvciBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLFxuICBmZWF0dXJlQ291bnQ6IG51bWJlcixcbiAgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3c6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFt0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgaW5wdXQuZGltcyxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICBpZiAobG9naWNhbFJvd0NvdW50IDwgMSB8fCBmZWF0dXJlQ291bnQgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlWzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gIH1cblxuICBpZiAobWF4RWxlbWVudFBlckxvZ2ljYWxSb3cubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgfVxuXG4gIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvd1swXSAhPT0gbG9naWNhbFJvd0NvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gIH1cblxuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XG4gICAgICAgIGZvcihpbnQgaT0wOyBpPCR7ZmVhdHVyZUNvdW50fTsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgbm9ybV9mYWN0b3IgKz0gZXhwKGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxuICAgICAgICAgICAgJHt0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KSkpIC0gbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtX2ZhY3RvcjtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLnNvZnRtYXhDb21wdXRlU2NhbGVQcm9ncmFtTWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgbG9naWNhbFJvd0NvdW50OiBudW1iZXIsXG4gIGZlYXR1cmVDb3VudDogbnVtYmVyLFxuICBtYXhFbGVtZW50UGVyTG9naWNhbFJvdzogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93OiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBpbnB1dC5kaW1zLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICApO1xuICBjb25zdCByYW5rID0gaW5wdXQuZGltcy5sZW5ndGg7XG5cbiAgaWYgKGxvZ2ljYWxSb3dDb3VudCA8IDEgfHwgZmVhdHVyZUNvdW50IDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgfVxuXG4gIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5sZW5ndGggIT09IDEgfHwgbm9ybWFsaXphdGlvblBlckxvZ2ljYWxSb3cubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgfVxuXG4gIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvd1swXSAhPT0gbG9naWNhbFJvd0NvdW50IHx8IG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93WzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnQnKTtcbiAgfVxuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcblxuICAgICAgLy8gZ2V0IG9mZnNldCBvZiBjdXJyZW50IGxvZ2ljYWwgdGVuc29yIGluZGV4IGZyb20gdGhlIDItRCB0ZXh0dXJlIGNvb3JkaW5hdGVzIChUZXhDb29yZHMpXG4gICAgICBpbnQgb2Zmc2V0ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pO1xuXG4gICAgICAvL2RldGVybWluZSB0aGUgbG9naWNhbCByb3cgZm9yIHRoaXMgaW5kZXhcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcbiAgICAgIGxvZ2ljYWxfcm93X2luZGV4WzBdID0gb2Zmc2V0IC8gJHtmZWF0dXJlQ291bnR9O1xuXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IF9Ob3JtKGxvZ2ljYWxfcm93X2luZGV4KTtcblxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxuICAgICAgLy8gaWYgbm9ybV9mYWNvciBpcyAwLCBhbGwgZWxlbWVudHMgYXJlIHplcm9cbiAgICAgIC8vIGlmIHNvLCByZXR1cm4gMFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxuICAgICAgICByZXR1cm4gMC4wO1xuXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XG4gICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4uc29mdG1heFByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUnKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwsIFNwbGl0VXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXQ6IG51bWJlcltdO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG59XG5cbmNvbnN0IHNwbGl0UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU3BsaXQnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTcGxpdEF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBjb3VudCA9IGdldFByb2dyYW1Db3VudChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF4aXMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBvdXRwdXQ6IFRlbnNvcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgIG91dHB1dC5wdXNoKFxuICAgICAgaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5zcGxpdFByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICBjYWNoZUhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aX1gLFxuICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMsIGF4aXMsIGkpLFxuICAgICAgICB9LFxuICAgICAgICBpbnB1dHMsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNwbGl0QXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMCk7XG4gIGNvbnN0IHNwbGl0ID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3NwbGl0JywgW10pO1xuICBjb25zdCBudW1PdXRwdXRzID0gbm9kZS5vdXRwdXRzLmxlbmd0aDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXMsIHNwbGl0LCBudW1PdXRwdXRzIH0pO1xufTtcblxuY29uc3QgZ2V0UHJvZ3JhbUNvdW50ID0gKFxuICBfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbik6IG51bWJlciA9PiB7XG4gIGNvbnN0IFssIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4aXMsIGF0dHJpYnV0ZXMuc3BsaXQsIGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIHJldHVybiBvZmZzZXRzLmxlbmd0aDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8gPSAoXG4gIF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbiAgYXhpczogbnVtYmVyLFxuICBpbmRleDogbnVtYmVyLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBbc2hhcGVzLCBvZmZzZXRzXSA9IFNwbGl0VXRpbC5zcGxpdFNoYXBlKGlucHV0LmRpbXMsIGF4aXMsIGF0dHJpYnV0ZXMuc3BsaXQsIGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIGNvbnN0IG9mZnNldCA9IG9mZnNldHNbaW5kZXhdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IHNoYXBlc1tpbmRleF07XG4gIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW5kaWNlc1ske2F4aXN9XSArPSAke29mZnNldH07XG4gICAgICAgIHJldHVybiBfQShpbmRpY2VzKTtcbiAgICAgIH1cbiAgICBgO1xuICByZXR1cm4ge1xuICAgIC4uLnNwbGl0UHJvZ3JhbU1ldGFkYXRhLFxuICAgIGNhY2hlSGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX06JHtpbmRleH1gLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoXG4gICAgaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQ4JyAmJlxuICAgIGlucHV0c1swXS50eXBlICE9PSAndWludDgnICYmXG4gICAgaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQxNicgJiZcbiAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQxNicgJiZcbiAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgIGlucHV0c1swXS50eXBlICE9PSAndWludDMyJyAmJlxuICAgIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnICYmXG4gICAgaW5wdXRzWzBdLnR5cGUgIT09ICdib29sJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IHNxdWVlemU6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248bnVtYmVyW10+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF4ZXM6IG51bWJlcltdLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5zcXVlZXplU2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4ZXMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIG91dHB1dFNoYXBlKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHNxdWVlemVWMTMgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0c1YxMyhpbnB1dHMpO1xuICByZXR1cm4gc3F1ZWV6ZShpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdXSwgQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNxdWVlemVBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPG51bWJlcltdPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogbnVtYmVyW10gPT5cbiAgbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnKTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy4nKTtcbiAgfVxufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNWMTMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcXVlZXplIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBzdW0gPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IHN1bVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnU3VtJyxcbiAgICBpbnB1dE5hbWVzOiBpbnB1dHMubWFwKChfdiwgaSkgPT4gYFgke2l9YCksXG4gICAgaW5wdXRUeXBlczogbmV3IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoVGV4dHVyZVR5cGUudW5wYWNrZWQpLFxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc3VtUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVN1bVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgc3VtUHJvZ3JhbU1ldGFkYXRhKSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuY29uc3QgY3JlYXRlU3VtUHJvZ3JhbUluZm8gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgc3VtUHJvZ3JhbU1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCBzdW1MaW5lID0gaW5wdXRzLm1hcCgoX3YsIGkpID0+IGAke2dsc2wudGV4dHVyZTJEfShYJHtpfSxUZXhDb29yZHMpYCkuam9pbignICsgJyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke3N1bUxpbmV9O1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgO1xuICByZXR1cm4ge1xuICAgIC4uLnN1bVByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3VtIHJlcXVpcmVzIGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGVuZ3RoICE9PSBpbnB1dHNbaV0uZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpbnB1dHNbMF0uZGltc1tqXSAhPT0gaW5wdXRzW2ldLmRpbXNbal0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzW2ldLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLicpO1xuICAgIH1cbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTlVNQkVSX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IHRpbGUgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IHRpbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ1RpbGUnLFxuICAgIGlucHV0TmFtZXM6IFsnQSddLFxuICAgIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG4gIH07XG5cbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgeyAuLi50aWxlUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIHRpbGVQcm9ncmFtTWV0YWRhdGEpIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5jb25zdCBjcmVhdGVUaWxlUHJvZ3JhbUluZm8gPSAoXG4gIF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIHRpbGVQcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGlucHV0U2hhcGUubGVuZ3RoKTtcblxuICBjb25zdCB0aWxlT3BzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaV0gKiBpbnB1dHNbMV0ubnVtYmVyRGF0YVtpXTtcbiAgICB0aWxlT3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHtpfV0pLCAke2lucHV0U2hhcGVbaV19LikpO2ApO1xuICB9XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske3Jhbmt9XTtcbiAgICAgICAgJHt0aWxlT3BzLmpvaW4oJ1xcbicpfVxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xuICAgICAgfVxuICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4udGlsZVByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgcmVxdWlyZXMgMiBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVwZWF0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmV4cG9ydCBjb25zdCB1bnNxdWVlemU6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248bnVtYmVyW10+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF4ZXM6IG51bWJlcltdLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC51bnNxdWVlemVTaGFwZShpbnB1dHNbMF0uZGltcywgYXhlcyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgb3V0cHV0U2hhcGUpO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgdW5zcXVlZXplVjEzID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMTMoaW5wdXRzKTtcbiAgcmV0dXJuIHVuc3F1ZWV6ZShpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdXSwgQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248bnVtYmVyW10+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXJbXSA9PlxuICBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycpO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3F1ZWV6ZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjEzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zcXVlZXplIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IE9wU2V0IH0gZnJvbSAnLi4vLi4vb3BzZXQnO1xuXG5pbXBvcnQgeyBiYXRjaE5vcm1hbGl6YXRpb24sIHBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0ICogYXMgYmluYXJ5T3BzIGZyb20gJy4vb3BzL2JpbmFyeS1vcCc7XG5pbXBvcnQgeyBjYXN0LCBwYXJzZUNhc3RBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY2FzdCc7XG5pbXBvcnQgeyBjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbmNhdCc7XG5pbXBvcnQgeyBjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY29udic7XG5pbXBvcnQgeyBjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY29udi10cmFuc3Bvc2UnO1xuaW1wb3J0IHsgZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9kZXB0aC10by1zcGFjZSc7XG5pbXBvcnQgeyBmbGF0dGVuLCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZmxhdHRlbic7XG5pbXBvcnQgeyBnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlcic7XG5pbXBvcnQgeyBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjExLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjcgfSBmcm9tICcuL29wcy9nZW1tJztcbmltcG9ydCB7IGltYWdlU2NhbGVyLCBwYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2ltYWdlLXNjYWxlcic7XG5pbXBvcnQgeyBpbnN0YW5jZU5vcm1hbGl6YXRpb24sIHBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0IHsgbHJuLCBwYXJzZUxybkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9scm4nO1xuaW1wb3J0IHsgbWF0TXVsLCBwYXJzZU1hdE11bEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHsgcGFkVjExLCBwYWRWMiwgcGFyc2VQYWRBdHRyaWJ1dGVzVjExLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMiB9IGZyb20gJy4vb3BzL3BhZCc7XG5pbXBvcnQge1xuICBhdmVyYWdlUG9vbCxcbiAgZ2xvYmFsQXZlcmFnZVBvb2wsXG4gIGdsb2JhbE1heFBvb2wsXG4gIG1heFBvb2wsXG4gIHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxuICBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcyxcbiAgcGFyc2VNYXhQb29sQXR0cmlidXRlcyxcbn0gZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQge1xuICBwYXJzZVJlZHVjZUF0dHJpYnV0ZXMsXG4gIHJlZHVjZUxvZ1N1bSxcbiAgcmVkdWNlTG9nU3VtU3F1YXJlLFxuICByZWR1Y2VNYXgsXG4gIHJlZHVjZU1lYW4sXG4gIHJlZHVjZU1pbixcbiAgcmVkdWNlUHJvZCxcbiAgcmVkdWNlU3VtLFxufSBmcm9tICcuL29wcy9yZWR1Y2UnO1xuaW1wb3J0IHsgcmVzaGFwZSB9IGZyb20gJy4vb3BzL3Jlc2hhcGUnO1xuaW1wb3J0IHsgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwLCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTEsIHJlc2l6ZSB9IGZyb20gJy4vb3BzL3Jlc2l6ZS1wYWNrZWQnO1xuaW1wb3J0IHsgc2hhcGUgfSBmcm9tICcuL29wcy9zaGFwZSc7XG5pbXBvcnQgeyBwYXJzZVNsaWNlQXR0cmlidXRlcywgc2xpY2UsIHNsaWNlVjEwIH0gZnJvbSAnLi9vcHMvc2xpY2UnO1xuaW1wb3J0IHsgcGFyc2VTb2Z0bWF4QXR0cmlidXRlcywgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMywgc29mdG1heCwgc29mdG1heFYxMyB9IGZyb20gJy4vb3BzL3NvZnRtYXgnO1xuaW1wb3J0IHsgcGFyc2VTcGxpdEF0dHJpYnV0ZXMsIHNwbGl0IH0gZnJvbSAnLi9vcHMvc3BsaXQnO1xuaW1wb3J0IHsgcGFyc2VTcXVlZXplQXR0cmlidXRlcywgc3F1ZWV6ZSwgc3F1ZWV6ZVYxMyB9IGZyb20gJy4vb3BzL3NxdWVlemUnO1xuaW1wb3J0IHsgc3VtIH0gZnJvbSAnLi9vcHMvc3VtJztcbmltcG9ydCB7IHRpbGUgfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlIH0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7IHBhcnNlVW5zcXVlZXplQXR0cmlidXRlcywgdW5zcXVlZXplLCB1bnNxdWVlemVWMTMgfSBmcm9tICcuL29wcy91bnNxdWVlemUnO1xuaW1wb3J0IHsgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNywgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOSwgdXBzYW1wbGUgfSBmcm9tICcuL29wcy91cHNhbXBsZSc7XG5cbmV4cG9ydCBjb25zdCBXRUJHTF9PUF9SRVNPTFZFX1JVTEVTOiByZWFkb25seSBPcFNldC5SZXNvbHZlUnVsZVtdID0gW1xuICBbJ0FicycsICcnLCAnNisnLCB1bmFyeU9wcy5hYnNdLFxuICBbJ0Fjb3MnLCAnJywgJzcrJywgdW5hcnlPcHMuYWNvc10sXG4gIFsnQWRkJywgJycsICc3KycsIGJpbmFyeU9wcy5hZGRdLFxuICBbJ0FuZCcsICcnLCAnNysnLCBiaW5hcnlPcHMuYW5kXSxcbiAgWydBc2luJywgJycsICc3KycsIHVuYXJ5T3BzLmFzaW5dLFxuICBbJ0F0YW4nLCAnJywgJzcrJywgdW5hcnlPcHMuYXRhbl0sXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIEF2ZXJhZ2VQb29sLTEwXG4gIFsnQXZlcmFnZVBvb2wnLCAnJywgJzcrJywgYXZlcmFnZVBvb2wsIHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxcbiAgWydCYXRjaE5vcm1hbGl6YXRpb24nLCAnJywgJzcrJywgYmF0Y2hOb3JtYWxpemF0aW9uLCBwYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXNdLFxuICBbJ0Nhc3QnLCAnJywgJzYrJywgY2FzdCwgcGFyc2VDYXN0QXR0cmlidXRlc10sXG4gIFsnQ2VpbCcsICcnLCAnNisnLCB1bmFyeU9wcy5jZWlsXSxcbiAgWydDbGlwJywgJycsICc2LTEwJywgdW5hcnlPcHMuY2xpcCwgdW5hcnlPcHMucGFyc2VDbGlwQXR0cmlidXRlc10sXG4gIFsnQ2xpcCcsICcnLCAnMTErJywgdW5hcnlPcHMuY2xpcFYxMV0sXG4gIFsnQ29uY2F0JywgJycsICc0KycsIGNvbmNhdCwgcGFyc2VDb25jYXRBdHRyaWJ1dGVzXSxcbiAgWydDb252JywgJycsICcxKycsIGNvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdLFxuICBbJ0NvbnZUcmFuc3Bvc2UnLCAnJywgJzErJywgY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc10sXG4gIFsnQ29zJywgJycsICc3KycsIHVuYXJ5T3BzLmNvc10sXG4gIFsnRGl2JywgJycsICc3KycsIGJpbmFyeU9wcy5kaXZdLFxuICBbJ0Ryb3BvdXQnLCAnJywgJzcrJywgdW5hcnlPcHMuaWRlbnRpdHldLFxuICBbJ0RlcHRoVG9TcGFjZScsICcnLCAnMSsnLCBkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sXG4gIFsnRXF1YWwnLCAnJywgJzcrJywgYmluYXJ5T3BzLmVxdWFsXSxcbiAgWydFbHUnLCAnJywgJzYrJywgdW5hcnlPcHMuZWx1LCB1bmFyeU9wcy5wYXJzZUVsdUF0dHJpYnV0ZXNdLFxuICBbJ0V4cCcsICcnLCAnNisnLCB1bmFyeU9wcy5leHBdLFxuICBbJ0ZsYXR0ZW4nLCAnJywgJzErJywgZmxhdHRlbiwgcGFyc2VGbGF0dGVuQXR0cmlidXRlc10sXG4gIFsnRmxvb3InLCAnJywgJzYrJywgdW5hcnlPcHMuZmxvb3JdLFxuICBbJ0Z1c2VkQ29udicsICdjb20ubWljcm9zb2Z0JywgJzErJywgY29udiwgcGFyc2VDb252QXR0cmlidXRlc10sXG4gIFsnR2F0aGVyJywgJycsICcxKycsIGdhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzXSxcbiAgWydHZW1tJywgJycsICc3LTEwJywgZ2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxcbiAgWydHZW1tJywgJycsICcxMSsnLCBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjExXSxcbiAgWydHbG9iYWxBdmVyYWdlUG9vbCcsICcnLCAnMSsnLCBnbG9iYWxBdmVyYWdlUG9vbCwgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdLFxuICBbJ0dsb2JhbE1heFBvb2wnLCAnJywgJzErJywgZ2xvYmFsTWF4UG9vbF0sXG4gIFsnR3JlYXRlcicsICcnLCAnNysnLCBiaW5hcnlPcHMuZ3JlYXRlcl0sXG4gIFsnSWRlbnRpdHknLCAnJywgJzErJywgdW5hcnlPcHMuaWRlbnRpdHldLFxuICBbJ0ltYWdlU2NhbGVyJywgJycsICcxKycsIGltYWdlU2NhbGVyLCBwYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlc10sXG4gIFsnSW5zdGFuY2VOb3JtYWxpemF0aW9uJywgJycsICc2KycsIGluc3RhbmNlTm9ybWFsaXphdGlvbiwgcGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzXSxcbiAgWydMZWFreVJlbHUnLCAnJywgJzYrJywgdW5hcnlPcHMubGVha3lSZWx1LCB1bmFyeU9wcy5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFxuICBbJ0xlc3MnLCAnJywgJzcrJywgYmluYXJ5T3BzLmxlc3NdLFxuICBbJ0xSTicsICcnLCAnMSsnLCBscm4sIHBhcnNlTHJuQXR0cmlidXRlc10sXG4gIFsnTG9nJywgJycsICc2KycsIHVuYXJ5T3BzLmxvZ10sXG4gIFsnTWF0TXVsJywgJycsICcxKycsIG1hdE11bCwgcGFyc2VNYXRNdWxBdHRyaWJ1dGVzXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXG4gIFsnTWF4UG9vbCcsICcnLCAnMSsnLCBtYXhQb29sLCBwYXJzZU1heFBvb2xBdHRyaWJ1dGVzXSxcbiAgWydNdWwnLCAnJywgJzcrJywgYmluYXJ5T3BzLm11bF0sXG4gIFsnTmVnJywgJycsICc2KycsIHVuYXJ5T3BzLm5lZ10sXG4gIFsnTm90JywgJycsICcxKycsIHVuYXJ5T3BzLm5vdF0sXG4gIFsnT3InLCAnJywgJzcrJywgYmluYXJ5T3BzLm9yXSxcbiAgWydQYWQnLCAnJywgJzItMTAnLCBwYWRWMiwgcGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFxuICBbJ1BhZCcsICcnLCAnMTErJywgcGFkVjExLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMTFdLFxuICBbJ1BvdycsICcnLCAnNysnLCBiaW5hcnlPcHMucG93XSxcbiAgWydQUmVsdScsICcnLCAnNysnLCBiaW5hcnlPcHMucFJlbHVdLFxuICBbJ1JlZHVjZUxvZ1N1bScsICcnLCAnMSsnLCByZWR1Y2VMb2dTdW0sIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlTWF4JywgJycsICcxKycsIHJlZHVjZU1heCwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VNZWFuJywgJycsICcxKycsIHJlZHVjZU1lYW4sIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlTWluJywgJycsICcxKycsIHJlZHVjZU1pbiwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VQcm9kJywgJycsICcxKycsIHJlZHVjZVByb2QsIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlU3VtJywgJycsICcxLTEyJywgcmVkdWNlU3VtLCBwYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFxuICBbJ1JlZHVjZVN1bVNxdWFyZScsICcnLCAnMSsnLCByZWR1Y2VMb2dTdW1TcXVhcmUsIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVsdScsICcnLCAnNisnLCB1bmFyeU9wcy5yZWx1XSxcbiAgWydSZXNoYXBlJywgJycsICc1KycsIHJlc2hhcGVdLFxuICBbJ1Jlc2l6ZScsICcnLCAnMTAnLCByZXNpemUsIHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMF0sXG4gIFsnUmVzaXplJywgJycsICcxMSsnLCByZXNpemUsIHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMV0sXG4gIFsnU2hhcGUnLCAnJywgJzErJywgc2hhcGVdLFxuICBbJ1NpZ21vaWQnLCAnJywgJzYrJywgdW5hcnlPcHMuc2lnbW9pZF0sXG4gIFsnU2luJywgJycsICc3KycsIHVuYXJ5T3BzLnNpbl0sXG4gIFsnU2xpY2UnLCAnJywgJzEwKycsIHNsaWNlVjEwXSwgLy8gVE9ETzogc3VwcG9ydCAnc3RlcHMnIGZvciBTbGljZS0xMFxuICBbJ1NsaWNlJywgJycsICcxLTknLCBzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdLFxuICAvLyBUaGUgXCJzZW1hbnRpY1wiIG1lYW5pbmcgb2YgYXhpcyBoYXMgY2hhbmdlZCBpbiBvcHNldC0xMy5cbiAgWydTb2Z0bWF4JywgJycsICcxLTEyJywgc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sXG4gIFsnU29mdG1heCcsICcnLCAnMTMrJywgc29mdG1heFYxMywgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxM10sXG4gIC8vICdTcGxpdCcgb3BlcmF0b3IgaGFzIGFuIG9wdGlvbmFsIGF0dHJpYnV0ZSAnc3BsaXQnXG4gIC8vIHRoaXMgYXR0cmlidXRlIGRldGVybWluZXMgaG93IHRoZSBzcGVjaWZpZWQgYXhpcyBvZiBpbnB1dCBkYXRhIGlzIHNwbGl0LlxuICAvLyBXaGVuIHRoZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgd2UgbmVlZCB0aGUgY291bnQgb2YgbnVtYmVyIG9mIG91dHB1dHNcbiAgLy8gc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSAnc3BsaXQnIGF0dHJpYnV0ZSBmcm9tIHRoZSBydW50aW1lIGlucHV0IHRvIHRoZSBPcGVyYXRvclxuICBbJ1NwbGl0JywgJycsICcyLTEyJywgc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxcbiAgWydTcXJ0JywgJycsICc2KycsIHVuYXJ5T3BzLnNxcnRdLFxuICBbJ1NxdWVlemUnLCAnJywgJzEtMTInLCBzcXVlZXplLCBwYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxcbiAgWydTcXVlZXplJywgJycsICcxMysnLCBzcXVlZXplVjEzXSxcbiAgWydTdWInLCAnJywgJzcrJywgYmluYXJ5T3BzLnN1Yl0sXG4gIFsnU3VtJywgJycsICc2KycsIHN1bV0sXG4gIFsnVGFuJywgJycsICc3KycsIHVuYXJ5T3BzLnRhbl0sXG4gIFsnVGFuaCcsICcnLCAnNisnLCB1bmFyeU9wcy50YW5oXSxcbiAgWydUaWxlJywgJycsICc2KycsIHRpbGVdLFxuICBbJ1RyYW5zcG9zZScsICcnLCAnMSsnLCB0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc10sXG4gIFsnVXBzYW1wbGUnLCAnJywgJzctOCcsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxcbiAgWydVcHNhbXBsZScsICcnLCAnOScsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5XSxcbiAgWydVbnNxdWVlemUnLCAnJywgJzEtMTInLCB1bnNxdWVlemUsIHBhcnNlVW5zcXVlZXplQXR0cmlidXRlc10sXG4gIFsnVW5zcXVlZXplJywgJycsICcxMysnLCB1bnNxdWVlemVWMTNdLFxuICBbJ1hvcicsICcnLCAnNysnLCBiaW5hcnlPcHMueG9yXSxcbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNvbnN0IElOTElORV9GVU5DX0RFRl9SRUdFWCA9IC9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207XG5jb25zdCBGVU5DX0NBTExfUkVHRVggPSAnKFxcXFx3Kyk/XFxcXHMrKFtfMC05YS16QS1aXSspXFxcXHMrPVxcXFxzK19fRlVOQ19fXFxcXCgoLiopXFxcXClcXFxccyo7Jztcbi8qKlxuICogR0xTTCBwcmVwcm9jZXNzb3IgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBAaW5saW5lIGRpcmVjdGl2ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VJbmxpbmVzKHNjcmlwdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaW5saW5lRGVmczogeyBbbmFtZTogc3RyaW5nXTogeyBwYXJhbXM6IEFycmF5PHsgdHlwZTogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfSB8IG51bGw+OyBib2R5OiBzdHJpbmcgfSB9ID0ge307XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IElOTElORV9GVU5DX0RFRl9SRUdFWC5leGVjKHNjcmlwdCkpICE9PSBudWxsKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbM11cbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHMudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgIGlmICh0b2tlbnMgJiYgdG9rZW5zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IHRva2Vuc1swXSwgbmFtZTogdG9rZW5zWzFdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodikgPT4gdiAhPT0gbnVsbCk7XG4gICAgaW5saW5lRGVmc1ttYXRjaFsyXV0gPSB7IHBhcmFtcywgYm9keTogbWF0Y2hbNF0gfTtcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gaW5saW5lRGVmcykge1xuICAgIGNvbnN0IHJlZ2V4U3RyaW5nID0gRlVOQ19DQUxMX1JFR0VYLnJlcGxhY2UoJ19fRlVOQ19fJywgbmFtZSk7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nLCAnZ20nKTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhzY3JpcHQpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSBtYXRjaFsyXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoWzNdLnNwbGl0KCcsJyk7XG4gICAgICBjb25zdCBkZWNsTGluZSA9IHR5cGUgPyBgJHt0eXBlfSAke3ZhcmlhYmxlfTtgIDogJyc7XG4gICAgICBsZXQgbmV3Qm9keTogc3RyaW5nID0gaW5saW5lRGVmc1tuYW1lXS5ib2R5O1xuICAgICAgbGV0IHBhcmFtUmVkZWNMaW5lID0gJyc7XG4gICAgICBpbmxpbmVEZWZzW25hbWVdLnBhcmFtcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgcGFyYW1SZWRlY0xpbmUgKz0gYCR7di50eXBlfSAke3YubmFtZX0gPSAke3BhcmFtc1tpXX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXdCb2R5ID0gYCR7cGFyYW1SZWRlY0xpbmV9XFxuICR7bmV3Qm9keX1gO1xuICAgICAgbmV3Qm9keSA9IG5ld0JvZHkucmVwbGFjZSgncmV0dXJuJywgYCR7dmFyaWFibGV9ID0gYCk7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGBcbiAgICAgICR7ZGVjbExpbmV9XG4gICAgICB7XG4gICAgICAgICR7bmV3Qm9keX1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShtYXRjaFswXSwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShJTkxJTkVfRlVOQ19ERUZfUkVHRVgsICcnKTtcbiAgcmV0dXJuIHNjcmlwdDtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi8uLi91dGlsJztcblxuLyoqIExheW91dCBwcmVmZXJlbmNlcyAqL1xuZXhwb3J0IGludGVyZmFjZSBXaWR0aEhlaWdodFByZWZzIHtcbiAgYnJlYWtBeGlzPzogbnVtYmVyO1xuICBpc1BhY2tlZD86IGJvb2xlYW47XG4gIHJldmVyc2VXSD86IGJvb2xlYW47XG59XG4vKipcbiAqIFRleHR1cmVMYXlvdXRTdHJhdGVneSBpcyBhbiBhYnN0cmFjdGlvbiBmb3IgZGlmZmVyZW50IHBsYW5zXG4gKiBmb3IgbWFwcGluZyBuLWRpbWVuc2lvbmFsIGFycmF5cyB0byAyRCB0ZXh0dXJlcyAoYW5kIGJhY2spXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl07XG59XG5cbi8qKlxuICogVGhpcyBzdHJhdGVneSB0cnkgdG8gZmluZCB0aGUgbWluaW1hbCBtYXgoVyxIKSB0aGF0IGZ1bGZpbGxzIChXICogSCA9PSB0b3RhbFNpemUpXG4gKi9cbmV4cG9ydCBjbGFzcyBBbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3kgaW1wbGVtZW50cyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF4VGV4dHVyZVNpemU6IG51bWJlcikge31cbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIC8vIHNjYWxhciB0ZW5zb3JcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWzEsIDFdO1xuICAgIH1cbiAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemU7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmJyZWFrQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGltcyBmaXRcbiAgICAgIGNvbnN0IHdzaXplID0gcHJlZnMuYnJlYWtBeGlzID49IHNoYXBlLmxlbmd0aCA/IDEgOiBzaGFwZS5zbGljZShwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgaHNpemUgPSBwcmVmcy5icmVha0F4aXMgPD0gMCA/IDEgOiBzaGFwZS5zbGljZSgwLCBwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgaWYgKHdzaXplID4gbWF4VGV4dHVyZVNpemUgfHwgaHNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAvLyBpZ25vcmUgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gY29udGludWUgd2l0aCBkZWZhdWx0IGxheW91dFxuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAnVGV4dHVyZUxheW91dCcsXG4gICAgICAgICAgYEdpdmVuIHdpZHRoL2hlaWdodCBwcmVmZXJlbmNlcyB3ZXJlIHVuYXR0YWluYWJsZTogc2hhcGU6JHtzaGFwZX0sIGJyZWFrQXhpczoke3ByZWZzLmJyZWFrQXhpc31gLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt3c2l6ZSwgaHNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b3RhbFNpemUgPSBzaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcblxuICAgIGxldCB3aWR0aCA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KHRvdGFsU2l6ZSkpO1xuXG4gICAgZm9yICg7IHdpZHRoIDwgbWF4VGV4dHVyZVNpemUgJiYgd2lkdGggPCB0b3RhbFNpemU7IHdpZHRoKyspIHtcbiAgICAgIGlmICh0b3RhbFNpemUgJSB3aWR0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lkdGggPj0gbWF4VGV4dHVyZVNpemUgfHwgdG90YWxTaXplICUgd2lkdGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3NoYXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gW3dpZHRoLCB0b3RhbFNpemUgLyB3aWR0aF07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByZWZlckxvZ2ljYWxTdHJhdGVneSBpbXBsZW1lbnRzIFRleHR1cmVMYXlvdXRTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtYXhUZXh0dXJlU2l6ZTogbnVtYmVyKSB7fVxuICBjb21wdXRlVGV4dHVyZVdIKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3Qgd2ggPSB0aGlzLmNvbXB1dGVUZXh0dXJlKHNoYXBlLCBwcmVmcyk7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmlzUGFja2VkKSB7XG4gICAgICB3aFswXSAvPSAyO1xuICAgICAgd2hbMV0gLz0gMjtcbiAgICB9XG4gICAgaWYgKHByZWZzICYmIHByZWZzLnJldmVyc2VXSCkge1xuICAgICAgcmV0dXJuIFt3aFsxXSwgd2hbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gd2g7XG4gIH1cblxuICBjb21wdXRlVGV4dHVyZShzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IGlzUGFja2VkID0gcHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQ7XG4gICAgLy8gc2NhbGFyIHRlbnNvclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpc1BhY2tlZCA/IFsyLCAyXSA6IFsxLCAxXTtcbiAgICB9XG4gICAgbGV0IG1heFRleHR1cmVTaXplID0gdGhpcy5tYXhUZXh0dXJlU2l6ZTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMuYnJlYWtBeGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBkaW1zIGZpdFxuICAgICAgY29uc3Qgd3NpemUgPSBwcmVmcy5icmVha0F4aXMgPj0gc2hhcGUubGVuZ3RoID8gMSA6IHNoYXBlLnNsaWNlKHByZWZzLmJyZWFrQXhpcykucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBoc2l6ZSA9IHByZWZzLmJyZWFrQXhpcyA8PSAwID8gMSA6IHNoYXBlLnNsaWNlKDAsIHByZWZzLmJyZWFrQXhpcykucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBpZiAod3NpemUgPiBtYXhUZXh0dXJlU2l6ZSB8fCBoc2l6ZSA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgICAgIC8vIGlnbm9yZSBwcmVmZXJlbmNlc1xuICAgICAgICAvLyBjb250aW51ZSB3aXRoIGRlZmF1bHQgbGF5b3V0XG4gICAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICdUZXh0dXJlTGF5b3V0JyxcbiAgICAgICAgICBgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3NoYXBlfSwgYnJlYWtBeGlzOiR7cHJlZnMuYnJlYWtBeGlzfWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3dzaXplLCBoc2l6ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsb2dTaGFwZSA9IHNoYXBlLnNsaWNlKDApO1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgbWF4VGV4dHVyZVNpemUgPSBtYXhUZXh0dXJlU2l6ZSAqIDI7XG5cbiAgICAgIC8vIFRoaXMgbG9naWMgZW5zdXJlcyB3ZSBhY2N1cmF0ZWx5IGNvdW50IHRoZSBudW1iZXIgb2YgcGFja2VkIHRleGVscyBuZWVkZWRcbiAgICAgIC8vIHRvIGFjY29tbW9kYXRlIHRoZSB0ZW5zb3IuIFdlIGNhbiBvbmx5IHBhY2sgdmFsdWVzIGluIHRoZSBzYW1lIHRleGVsIGlmXG4gICAgICAvLyB0aGV5IGFyZSBmcm9tIGFkamFjZW50IHBhaXJzIG9mIHJvd3MvY29scyB3aXRoaW4gdGhlIHNhbWUgYmF0Y2guIFNvIGlmIGFcbiAgICAgIC8vIHRlbnNvciBoYXMgMyByb3dzLCB3ZSBwcmV0ZW5kIGl0IGhhcyA0IHJvd3MgaW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhlXG4gICAgICAvLyBmYWN0IHRoYXQgdGhlIHRleGVscyBjb250YWluaW5nIHRoZSB0aGlyZCByb3cgYXJlIGhhbGYgZW1wdHkuXG4gICAgICBsb2dTaGFwZSA9IGxvZ1NoYXBlLm1hcCgoX2QsIGkpID0+XG4gICAgICAgIGkgPj0gbG9nU2hhcGUubGVuZ3RoIC0gMiA/IChsb2dTaGFwZVtpXSAlIDIgPT09IDAgPyBsb2dTaGFwZVtpXSA6IGxvZ1NoYXBlW2ldICsgMSkgOiBsb2dTaGFwZVtpXSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFBhY2tlZCB0ZXh0dXJlIGhlaWdodCBpcyBhdCBsZWFzdCAyICh0aGUgY2hhbm5lbCBoZWlnaHQgb2YgYSBzaW5nbGVcbiAgICAgIC8vIHRleGVsKS5cbiAgICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbG9nU2hhcGUgPSBbMiwgbG9nU2hhcGVbMF1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGxvZ2ljYWwgc2hhcGUgaXMgMiwgd2UgZG9uJ3Qgc3F1ZWV6ZSwgc2luY2Ugd2Ugd2FudCB0byBtYXRjaCBwaHlzaWNhbC5cbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb25zdCBzcXVlZXplUmVzdWx0ID0gc3F1ZWV6ZVNoYXBlKGxvZ1NoYXBlKTtcbiAgICAgIGxvZ1NoYXBlID0gc3F1ZWV6ZVJlc3VsdC5uZXdTaGFwZTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gc2l6ZUZyb21TaGFwZShsb2dTaGFwZSk7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCA8PSAxICYmIHNpemUgPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbMSwgc2l6ZV07XG4gICAgfSBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDIgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMV0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBsb2dTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSwgbG9nU2hhcGVbMl1dO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl1dO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBsb2dTaGFwZS5sZW5ndGggPT09IDQgJiZcbiAgICAgIGxvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJlxuICAgICAgbG9nU2hhcGVbM10gPD0gbWF4VGV4dHVyZVNpemVcbiAgICApIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdLCBsb2dTaGFwZVszXV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJlxuICAgICAgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiZcbiAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXh0dXJlU2l6ZVxuICAgICkge1xuICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIC8vIEZvciBwYWNrZWQgdGV4dHVyZXMgc2l6ZSBlcXVhbHMgdGhlIG51bWJlciBvZiBjaGFubmVscyByZXF1aXJlZCB0b1xuICAgICAgICAvLyBhY2NvbW1vZGF0ZSB0aGUgdGV4dHVyZSBkYXRhLiBIb3dldmVyIGluIG9yZGVyIHRvIHNxdWFyaWZ5IHN1Y2ggdGhhdFxuICAgICAgICAvLyBpbm5lciBkaW1lbnNpb25zIHN0YXkgZXZlbiwgd2UgcmV3cml0ZSBzaXplIHRvIGVxdWFsIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gdGV4ZWxzLiBUaGVuIGluIHRoZSByZXR1cm4gc3RhdGVtZW50IHdlIHJlaHlkcmF0ZSB0aGUgc3F1YXJpZmllZFxuICAgICAgICAvLyBkaW1lbnNpb25zIHRvIGNoYW5uZWwgdW5pdHMuXG4gICAgICAgIHJldHVybiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUgLyA0KS5tYXAoKGQpID0+IGQgKiAyKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVlZXplU2hhcGUoc2hhcGU6IG51bWJlcltdLCBheGlzPzogbnVtYmVyW10pOiB7IG5ld1NoYXBlOiBudW1iZXJbXTsga2VwdERpbXM6IG51bWJlcltdIH0ge1xuICBjb25zdCBuZXdTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qga2VwdERpbXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlzRW1wdHlBcnJheSA9IGF4aXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGF4aXMpICYmIGF4aXMubGVuZ3RoID09PSAwO1xuICBjb25zdCBheGVzID0gYXhpcyA9PSBudWxsIHx8IGlzRW1wdHlBcnJheSA/IG51bGwgOiBwYXJzZUF4aXNQYXJhbShheGlzLCBzaGFwZSkuc29ydCgpO1xuICBsZXQgaiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXhlcyAhPSBudWxsKSB7XG4gICAgICBpZiAoYXhlc1tqXSA9PT0gaSAmJiBzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNxdWVlemUgYXhpcyAke2l9IHNpbmNlIGl0cyBkaW0gJyR7c2hhcGVbaV19JyBpcyBub3QgMWApO1xuICAgICAgfVxuICAgICAgaWYgKChheGVzW2pdID09IG51bGwgfHwgYXhlc1tqXSA+IGkpICYmIHNoYXBlW2ldID09PSAxKSB7XG4gICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgaWYgKGF4ZXNbal0gPD0gaSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBuZXdTaGFwZSwga2VwdERpbXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGF4aXM6IG51bWJlciB8IG51bWJlcltdLCBzaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgLy8gTm9ybWFsaXplIGlucHV0XG4gIGF4aXMgPSBheGlzID09IG51bGwgPyBzaGFwZS5tYXAoKF9zLCBpKSA9PiBpKSA6IChbXSBhcyBudW1iZXJbXSkuY29uY2F0KGF4aXMpO1xuXG4gIC8vIENoZWNrIGZvciB2YWxpZCByYW5nZVxuICBhc3NlcnQoXG4gICAgYXhpcy5ldmVyeSgoYXgpID0+IGF4ID49IC1yYW5rICYmIGF4IDwgcmFuayksXG4gICAgKCkgPT4gYEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtyYW5rfSwgJHtyYW5rfSkgYnV0IGAgKyBgZ290IGF4aXMgJHtheGlzfWAsXG4gICk7XG5cbiAgLy8gQ2hlY2sgZm9yIG9ubHkgaW50ZWdlcnNcbiAgYXNzZXJ0KGF4aXMuZXZlcnkoaXNJbnQpLCAoKSA9PiAnQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0ICcgKyBgZ290IGF4aXMgJHtheGlzfWApO1xuXG4gIC8vIEhhbmRsZSBuZWdhdGl2ZSBheGlzLlxuICByZXR1cm4gYXhpcy5tYXAoKGEpID0+IChhIDwgMCA/IHJhbmsgKyBhIDogYSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50KGE6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gYSAlIDEgPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gc2l6ZUZyb21TaGFwZShzaGFwZTogbnVtYmVyW10pOiBudW1iZXIge1xuICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gU2NhbGFyLlxuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBzaXplID0gc2hhcGVbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICBzaXplICo9IHNoYXBlW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvd3NDb2xzKHNoYXBlOiBudW1iZXJbXSk6IFtudW1iZXIsIG51bWJlcl0ge1xuICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS4nKTtcbiAgfVxuXG4gIHJldHVybiBbc2hhcGUubGVuZ3RoID4gMSA/IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdIDogMSwgc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV1dO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSk7XG4gIHJldHVybiBbd2lkdGgsIE1hdGguY2VpbChzaXplIC8gd2lkdGgpXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXRjaERpbShzaGFwZTogbnVtYmVyW10sIGRpbXNUb1NraXAgPSAyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHNpemVGcm9tU2hhcGUoc2hhcGUuc2xpY2UoMCwgc2hhcGUubGVuZ3RoIC0gZGltc1RvU2tpcCkpO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBcnJheVV0aWwsIEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQgeyBHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmUgfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgc3F1ZWV6ZVNoYXBlIH0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQgeyBUZXh0dXJlTGF5b3V0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUsXG4gIGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzLFxuICBnZXRDb29yZHNEYXRhVHlwZSxcbiAgZ2V0R2xDaGFubmVscyxcbiAgZ2V0U3F1ZWV6ZWRQYXJhbXMsXG4gIHNxdWVlemVJbnB1dFNoYXBlLFxufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBHTFNMIExpYnJhcnkgcmVzcG9uc2libGUgZm9yIGRhdGEgdHlwZXMgYW5kIHJvdXRpbmVzIGZvciBtYW5pcHVsYXRpbmdcbiAqIGNvb3JkaW5hdGVzIGFuZCBtYXBwaW5nIHRvL2Zyb20gdGVuc29yIGluZGljZXNcbiAqL1xuZXhwb3J0IGNsYXNzIENvb3Jkc0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgcmV0dXJuVHlwZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9mZnNldFRvQ29vcmRzKCksXG4gICAgICAuLi50aGlzLmNvb3Jkc1RvT2Zmc2V0KCksXG4gICAgICAuLi50aGlzLnRvVmVjKCksXG4gICAgICAuLi50aGlzLnZhbHVlRnJvbSgpLFxuICAgICAgLy8gVE9ETyByZXR1cm4gdGhlc2Ugb25seSB3aGVuIHBhY2tpbmcgaXMgZW5hYmxlZC5cbiAgICAgIC4uLnRoaXMuZ2V0Q29tbW9uVXRpbEZ1bmNzKCksXG4gICAgICAuLi50aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSxcbiAgICAgIC4uLnRoaXMuZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KCksXG4gICAgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYW4gbWFwIGZyb21cbiAgICogMkQgbm9ybWFsemllZCBjb29yZGluYXRlcyAocyx0KSB0byBhIGZsYXQgb2Zmc2V0XG4gICAqL1xuICBwcm90ZWN0ZWQgb2Zmc2V0VG9Db29yZHMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSAnb2Zmc2V0VG9Db29yZHMnO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRUb0Nvb3JkczogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgJHtmdW5jTmFtZX0oaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgfVxuICAgICAgYCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIG1hcCBmcm9tXG4gICAqIDJEIG5vcm1hbHppZWQgY29vcmRpbmF0ZXMgKHMsdCkgdG8gYSBmbGF0IG9mZnNldFxuICAgKi9cbiAgcHJvdGVjdGVkIGNvb3Jkc1RvT2Zmc2V0KCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2Nvb3Jkc1RvT2Zmc2V0JztcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRzVG9PZmZzZXQ6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBpbnQgJHtmdW5jTmFtZX0odmVjMiBjb29yZHMsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XG4gICAgICAgIGZsb2F0IHQgPSBjb29yZHMudCAqIGZsb2F0KGhlaWdodCk7XG4gICAgICAgIGludCBvZmZzZXQgPSBpbnQodCkgKiB3aWR0aCArIGludChzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGApLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGlmIChvdXRwdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgcGFja2VkIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgY29uc3QgZnVuY05hbWUgPSAnZ2V0T3V0cHV0Q29vcmRzJztcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZDJEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoXG4gICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkTkRDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIC8vIFRPRE8gd2UgbmVlZCB0aGlzIHRvIHByb3Blcmx5IHJldHVybiBhIHBhY2tlZCB2ZWM0IGZyb20ga2VybmVscy5cbiAgICAvLyBSZXBsYWNlIGFsbCAne2dsc2wub3V0cHV0fSA9IHJlc3VsdCcgd2l0aCAnc2V0T3V0cHV0KHJlc3VsdCknIGluIGFsbCBrZXJuZWxzLlxuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJHQkFTb3VyY2UgPSBgXG4gICAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZhbDtcbiAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJHQkFGdW5jTmFtZSA9ICdmbG9hdFRleHR1cmVTZXRSR0JBJztcbiAgICByZXN1bHRbZmxvYXRUZXh0dXJlU2V0UkdCQUZ1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShmbG9hdFRleHR1cmVTZXRSR0JBU291cmNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb2RlIGZvciB1bnBhY2tlZCBvdXRwdXQgc2FtcGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgY29uc3QgZnVuY05hbWUgPSAnZ2V0T3V0cHV0Q29vcmRzJztcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkMURDb29yZHMob3V0U2hhcGUgYXMgW251bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhcbiAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKFxuICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgICBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhcbiAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgICBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhcbiAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKFxuICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgICBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3V0cHV0IGRpbWVuc2lvbmFsaXR5OiAke291dFNoYXBlLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAvLyBUT0RPIHdlIG5lZWQgdGhpcyB0byBwcm9wZXJseSByZXR1cm4gYSBwYWNrZWQgdmVjNCBmcm9tIGtlcm5lbHMuXG4gICAgLy8gUmVwbGFjZSBhbGwgJ3tnbHNsLm91dHB1dH0gPSByZXN1bHQnIHdpdGggJ3NldE91dHB1dChyZXN1bHQpJyBpbiBhbGwga2VybmVscy5cbiAgICBjb25zdCBmbG9hdFRleHR1cmVTZXRSU291cmNlID0gYFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIGA7XG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkZ1bmNOYW1lID0gJ2Zsb2F0VGV4dHVyZVNldFInO1xuICAgIHJlc3VsdFtmbG9hdFRleHR1cmVTZXRSRnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGZsb2F0VGV4dHVyZVNldFJTb3VyY2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGFyIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTogR2xzbExpYlJvdXRpbmUge1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogMUQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQxRENvb3Jkcyhfc2hhcGU6IFtudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IHRleFNoYXBlO1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBpZiAocGFja2VkVGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIHNvdXJjZSA9IGBcbiAgICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiBpbnQoVGV4Q29vcmRzLnkgKiAke3BhY2tlZFRleFNoYXBlWzFdfS4wKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhY2tlZFRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy54ICogJHtwYWNrZWRUZXhTaGFwZVswXX0uMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7cGFja2VkVGV4U2hhcGVbMF19LCAke3BhY2tlZFRleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnkgKiAke3BhY2tlZFRleFNoYXBlWzBdfSArIHJlc1RleFJDLngpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAyRCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZDJEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgaWYgKEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKFRleENvb3Jkcy54eSAqIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICAvLyB0ZXhlbHMgbmVlZGVkIHRvIGFjY29tbW9kYXRlIGEgbG9naWNhbCByb3dcbiAgICBjb25zdCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIC8qKlxuICAgICAqIGdldE91dHB1dENvb3Jkc1xuICAgICAqXG4gICAgICogcmVzVGV4UkM6IFRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIHRoZSB0ZXhlbHMuIElmIHlvdSBtb3ZlIG92ZXIgb25lXG4gICAgICogdGV4ZWwgdG8gdGhlIHJpZ2h0IGluIHRoZSBwYWNrZWQgdGV4dHVyZSwgeW91IGFyZSBtb3Zpbmcgb3ZlciBvbmUgY29sdW1uXG4gICAgICogKG5vdCB0d28pLlxuICAgICAqXG4gICAgICogaW5kZXg6IFRoZSB0ZXhlbCBpbmRleFxuICAgICAqL1xuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcblxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3BhY2tlZFRleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG5cbiAgICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3RleGVsc0luTG9naWNhbFJvd30pO1xuXG4gICAgICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAzRCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZDNEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gW3RleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXV07XG4gICAgY29uc3QgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlWzJdIC8gMik7XG4gICAgY29uc3QgdGV4ZWxzSW5CYXRjaCA9IHRleGVsc0luTG9naWNhbFJvdyAqIE1hdGguY2VpbChzaGFwZVsxXSAvIDIpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICAgaW50IGIgPSBpbmRleCAvICR7dGV4ZWxzSW5CYXRjaH07XG4gICAgICAgICAgaW5kZXggLT0gYiAqICR7dGV4ZWxzSW5CYXRjaH07XG5cbiAgICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3RleGVsc0luTG9naWNhbFJvd30pO1xuXG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBORCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZE5EQ29vcmRzKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcblxuICAgIGNvbnN0IHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVtzaGFwZS5sZW5ndGggLSAxXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBNYXRoLmNlaWwoc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaE4gPSB0ZXhlbHNJbkJhdGNoO1xuICAgIGxldCBiYXRjaGVzID0gJyc7XG4gICAgbGV0IGNvb3JkcyA9ICdiLCByLCBjJztcblxuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgc2hhcGUubGVuZ3RoIC0gMTsgYisrKSB7XG4gICAgICB0ZXhlbHNJbkJhdGNoTiAqPSBzaGFwZVtzaGFwZS5sZW5ndGggLSBiIC0gMV07XG4gICAgICBiYXRjaGVzID1cbiAgICAgICAgYFxuICAgICAgaW50IGIke2J9ID0gaW5kZXggLyAke3RleGVsc0luQmF0Y2hOfTtcbiAgICAgIGluZGV4IC09IGIke2J9ICogJHt0ZXhlbHNJbkJhdGNoTn07XG4gICAgYCArIGJhdGNoZXM7XG4gICAgICBjb29yZHMgPSBgYiR7Yn0sIGAgKyBjb29yZHM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgIGl2ZWMke3NoYXBlLmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7cGFja2VkVGV4U2hhcGVbMF19LCAke3BhY2tlZFRleFNoYXBlWzFdfSkpO1xuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICR7YmF0Y2hlc31cblxuICAgICAgICBpbnQgYiA9IGluZGV4IC8gJHt0ZXhlbHNJbkJhdGNofTtcbiAgICAgICAgaW5kZXggLT0gYiAqICR7dGV4ZWxzSW5CYXRjaH07XG5cbiAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSkgKiAyO1xuICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3RleGVsc0luTG9naWNhbFJvd30pO1xuXG4gICAgICAgIHJldHVybiBpdmVjJHtzaGFwZS5sZW5ndGh9KCR7Y29vcmRzfSk7XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkMURDb29yZHMoX3NoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMkQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkMkRDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgIGludCByID0gaW5kZXggLyAke3NoYXBlWzFdfTtcbiAgICAgICAgICBpbnQgYyA9IGluZGV4IC0gciAqICR7c2hhcGVbMV19O1xuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgM0Qgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkM0RDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJ107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9IHN0cmlkZXNcbiAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICBjb25zdCBsaW5lMiA9XG4gICAgICAgICAgaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxXG4gICAgICAgICAgICA/IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaSArIDFdfSA9IGluZGV4IC0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YFxuICAgICAgICAgICAgOiBgaW5kZXggLT0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YDtcbiAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgIH0pXG4gICAgICAuam9pbignJyk7XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA0RCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhcbiAgICBzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgICBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gXG4gICAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkNURDb29yZHMoXG4gICAgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgICBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gXG4gICAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDZEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKFxuICAgIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnLCAnZDQnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgICBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gXG4gICAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgICAgcmV0dXJuIGl2ZWM2KHIsIGMsIGQsIGQyLCBkMywgZDQpO1xuICAgICAgIH1cbiAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIGNvbW1vbiBVViBjb29yZHMgY29tcHV0YXRpb24gdXRpbGl0eSBmdW5jdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0Q29tbW9uVXRpbEZ1bmNzKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSA9IHt9O1xuICAgIGxldCBmdW5jTmFtZSA9ICd1dkZyb21GbGF0JztcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICB2ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xuICAgICAgaW50IHRleFIgPSBpbmRleCAtIHRleEMgKiB0ZXhOdW1SO1xuICAgICAgLy8gVE9ETzogc3dhcCB0ZXhSLCB0ZXhDIG9yZGVyIGluIGZvbGxvd2luZyBmdW5jdGlvbiBzbyByb3cgaXMgY29ycmVzcG9uZGluZyB0byB1IGFuZCBjb2x1bW4gaXMgY29ycmVzcG9uZGluZyB0b1xuICAgICAgLy8gICAgICAgdi5cbiAgICAgIHJldHVybiAodmVjMih0ZXhSLCB0ZXhDKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bVIsIHRleE51bUMpO1xuICAgIH1cbiAgICBgKTtcbiAgICBmdW5jTmFtZSA9ICdwYWNrZWRVVmZyb20xRCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgICB9XG4gICAgICBgKTtcbiAgICBmdW5jTmFtZSA9ICdwYWNrZWRVVmZyb20yRCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tM0QnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXG4gICAgICAgICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxuICAgICAgICAgIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gICAgICAgIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAnc2FtcGxlVGV4dHVyZSc7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XG4gICAgICAgIH1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgaW5wdXRzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChzYW1wbGVyTmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IGZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lKTtcbiAgICAgIGlmIChpbnB1dExheW91dC5pc1BhY2tlZCkge1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRDb29yZEZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWUpO1xuICAgICAgaWYgKGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoIDw9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgICAgICByZXN1bHRbb3V0Q29vcmRGdW5jTmFtZV0gPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgICAgICAgIG91dENvb3JkRnVuY05hbWUsXG4gICAgICAgICAgICBpbnB1dExheW91dCxcbiAgICAgICAgICAgIG91dHB1dExheW91dCxcbiAgICAgICAgICAgIHNhbXBsZXJOYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W291dENvb3JkRnVuY05hbWVdID0gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgICAgICAgIG91dENvb3JkRnVuY05hbWUsXG4gICAgICAgICAgICBpbnB1dExheW91dCxcbiAgICAgICAgICAgIG91dHB1dExheW91dCxcbiAgICAgICAgICAgIHNhbXBsZXJOYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgZnVuY05hbWU6IHN0cmluZyxcbiAgICBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCxcbiAgICBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgbmFtZTogc3RyaW5nLFxuICApOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhOYW1lID0gbmFtZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSh0ZXhOYW1lKTtcblxuICAgIGNvbnN0IGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBnZXRHbENoYW5uZWxzKCk7XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKChkKSA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5TaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICBsZXQgb3V0cHV0ID0gJ3JldHVybiBvdXRwdXRWYWx1ZTsnO1xuICAgIGNvbnN0IGluU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGluU2hhcGUpO1xuICAgIGNvbnN0IGlzSW5wdXRTY2FsYXIgPSBpblNpemUgPT09IDE7XG4gICAgY29uc3Qgb3V0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dFNoYXBlKTtcbiAgICBjb25zdCBpc091dHB1dFNjYWxhciA9IG91dFNpemUgPT09IDE7XG5cbiAgICBpZiAoaW5SYW5rID09PSAxICYmICFpc0lucHV0U2NhbGFyICYmICFpc091dHB1dFNjYWxhcikge1xuICAgICAgb3V0cHV0ID0gYFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xuICAgICAgYDtcbiAgICB9IGVsc2UgaWYgKGlzSW5wdXRTY2FsYXIgJiYgIWlzT3V0cHV0U2NhbGFyKSB7XG4gICAgICBpZiAob3V0UmFuayA9PT0gMSkge1xuICAgICAgICBvdXRwdXQgPSBgXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcbiAgICAgICAgYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IGBcbiAgICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCByb3dzID0gaW5SYW5rIC0gMjtcbiAgICAgIGNvbnN0IGNvbHMgPSBpblJhbmsgLSAxO1xuXG4gICAgICBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKHJvd3MpID4gLTEgJiYgYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgb3V0cHV0ID0gJ3JldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpOyc7XG4gICAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihyb3dzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55LCAnICsgJ291dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpOyc7XG4gICAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihjb2xzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3dhcExhc3REaW1zU25pcHBldCA9IGBcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDFdfTtcbiAgICAgICAgY29vcmRzLiR7ZmllbGRzW291dFJhbmsgLSAxXX0gPSBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDJdfTtcbiAgICAgICAgY29vcmRzLiR7ZmllbGRzW291dFJhbmsgLSAyXX0gPSBsYXN0RGltO1xuICAgICAgYDtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICB2ZWM0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAke3N3YXBMYXN0RGltc1NuaXBwZXR9XG4gICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9ICR7dGV4RnVuY1NuaXBwZXR9KCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gICAgICAgICR7b3V0cHV0fVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgdW5wYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzIG9mIHNhbXBsZXJzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgZnVuY05hbWU6IHN0cmluZyxcbiAgICBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCxcbiAgICBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgbmFtZTogc3RyaW5nLFxuICApOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgb3V0VGV4U2hhcGUgPSBbb3V0cHV0TGF5b3V0LndpZHRoLCBvdXRwdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBpblRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGluUmFuayA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZShuYW1lKTtcblxuICAgIGlmIChpblJhbmsgPT09IG91dFJhbmsgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKGluVGV4U2hhcGUsIG91dFRleFNoYXBlKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgVGV4Q29vcmRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBnZXRHbENoYW5uZWxzKCk7XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKChkKSA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgICByZXR1cm4gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBwYWNrZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgc3dpdGNoIChpbnB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lLCBuYW1lKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QoZnVuY05hbWUsIG5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIHVucGFja2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IG1vcmUgZGltZW5zaW9uYWxpdGllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke3NoYXBlLmxlbmd0aH0tRGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgc2NhbGFyIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgdmVjNCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMV0sIHRleFNoYXBlWzBdXTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxuICAgICAgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19LCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMUQnXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1DfS4wLCAke3RleE51bVJ9LjApO1xuICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgICAgfWA7XG5cbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUocGFja2VkU2FtcGxlcik7XG4gICAgfVxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCgke3BhY2tlZFRleFNoYXBlWzFdfSwgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7dmFsdWVzUGVyUm93fSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTJEJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGtlcHREaW1zID0gWzEsIDJdO1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYicsICdyb3cnLCAnY29sJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgICAgY29uc3Qgc2FtcGxlclJvdXRpbmUgPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KTtcbiAgICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgJHtzYW1wbGVyUm91dGluZS5yb3V0aW5lQm9keX1cbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgIH0gYDtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgc2FtcGxlclJvdXRpbmUuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgY29uc3QgdGV4TnVtUiA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSBwYWNrZWRUZXhTaGFwZVsxXTtcblxuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgdmVjNCAke2Z1bmNOYW1lfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxuICAgICAgICAke3RleE51bUN9LCAke3RleE51bVJ9LCAke3RleGVsc0luQmF0Y2h9LCAke3ZhbHVlc1BlclJvd30sIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7fWA7XG4gICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRCddKTtcbiAgfVxuICAvKlxuICAgKiBQYWNrZWQgTkQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyTkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcbiAgICBjb25zdCB0ZXhOdW1SID0gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgY29uc3QgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMV0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMl0gLyAyKTtcbiAgICBsZXQgcGFyYW1zID0gJ2ludCBiLCBpbnQgcm93LCBpbnQgY29sJztcbiAgICBsZXQgaW5kZXggPSBgYiAqICR7dGV4ZWxzSW5CYXRjaH0gKyAocm93IC8gMikgKiAke3ZhbHVlc1BlclJvd30gKyAoY29sIC8gMilgO1xuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgcmFuayAtIDE7IGIrKykge1xuICAgICAgcGFyYW1zID0gYGludCBiJHtifSwgYCArIHBhcmFtcztcbiAgICAgIHRleGVsc0luQmF0Y2ggKj0gc2hhcGVbcmFuayAtIGIgLSAxXTtcbiAgICAgIGluZGV4ID0gYGIke2J9ICogJHt0ZXhlbHNJbkJhdGNofSArIGAgKyBpbmRleDtcbiAgICB9XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KCR7cGFyYW1zfSkge1xuICAgICAgaW50IGluZGV4ID0gJHtpbmRleH07XG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gJHt0ZXhOdW1DfTtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogJHt0ZXhOdW1DfTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtQ30sICR7dGV4TnVtUn0pO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCBzY2FsYXIgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBbdGV4TnVtUiwgdGV4TnVtQ10gPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgaWYgKHRleE51bVIgPT09IDEgJiYgdGV4TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgaW50IG9mZnNldF8ke25hbWV9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleE51bVJ9LCAke3RleE51bUN9KTtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBvZmZzZXRfJHtuYW1lfSk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbXG4gICAgICAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsXG4gICAgICAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsXG4gICAgICAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyMUQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCB0TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHROdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuXG4gICAgaWYgKHROdW1DID09PSAxICYmIHROdW1SID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIGhhbGZDUik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGlmICh0TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke3ROdW1SfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuICAgIGlmICh0TnVtUiA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7dE51bUN9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0TnVtUn0sICR7dE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCAyRCBzbmlwcGV0LlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyMkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG5cbiAgICAvLyBUT0RPOiBtb2RpZnkgcm93L2NvbCBvcmRlciBmb3Igb3RoZXIgZGltZW5zaW9ucy5cbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC5oZWlnaHQsIGlucHV0TGF5b3V0LndpZHRoXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCB0ZXhOdW1SID0gdGV4U2hhcGVbMV07XG4gICAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHJvdywgY29sKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtUn0uMCwgJHt0ZXhOdW1DfS4wKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbmV3U2hhcGUsIGtlcHREaW1zIH0gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ2NvbCcsICdyb3cnXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke3RleE51bVJ9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHt0ZXhOdW1DfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtzaGFwZVsxXX0gKyByb3c7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgW1xuICAgICAgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0JyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyM0QoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdO1xuXG4gICAgY29uc3QgeyBuZXdTaGFwZSwga2VwdERpbXMgfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYmF0Y2gnLCAnY29sJywgJ3JvdyddO1xuICAgICAgLy8gRGVlcCBjb3B5IG9mIGlucHV0IHRleHR1cmUgbGF5b3V0LlxuICAgICAgY29uc3QgbmV3SW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0TGF5b3V0KSk7XG4gICAgICBuZXdJbnB1dExheW91dC51bnBhY2tlZFNoYXBlID0gbmV3SW5wdXRTaGFwZTtcbiAgICAgIGNvbnN0IHJvdXRpbmUgPSB0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpO1xuICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGUgbG9naWMgaGVyZSB0byBtYWtlIGl0IHNpbXBsZXJcbiAgICAgIGNvbnN0IHJldkRpbXMgPSBrZXB0RGltcy5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHtyb3V0aW5lLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCByZXZEaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCByb3V0aW5lLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICAgICAgaW50IGluZGV4ID0gZGVwdGggKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIHJvdztcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbXG4gICAgICAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsXG4gICAgICAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsXG4gICAgICAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDREIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZS1lbmFibGUgdGhpcyBzaG9ydGN1dCBvbmNlIHRoZSBpbmRleCBjYWxjdWxhdGlvbiBidWcgaXMgZml4ZWQuXG4gICAgLy9cbiAgICAvLyBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgLy8gaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgIC8vICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBuZXdTaGFwZSk7XG4gICAgLy8gICBjb25zdCBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJ107XG4gICAgLy8gICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgLy8gICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAvLyAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgIC8vICAgY29uc3Qgc291cmNlID0gYFxuICAgIC8vICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KS5yb3V0aW5lQm9keX1cbiAgICAvLyAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAvLyAgICAgICAgIHJldHVybiAke2Z1bmNOYW1lfSgke2dldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpfSk7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICBgO1xuICAgIC8vICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAvLyAgICAgICBzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pO1xuICAgIC8vIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSBpbnB1dExheW91dC53aWR0aDtcbiAgICBjb25zdCB0ZXhOdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtzdHJpZGUwfSArIGNvbCAqICR7c3RyaWRlMX0gK1xuICAgICAgICAgICAgICBkZXB0aDIgKiAke3N0cmlkZTJ9ICsgZGVwdGg7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF07XG4gICAgY29uc3Qgc3RyaWRlMiA9IHNoYXBlWzNdICogc3RyaWRlMztcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgICBjb25zdCB7IG5ld1NoYXBlLCBrZXB0RGltcyB9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgZGVwdGgzICogJHtzdHJpZGUzfSArIGRlcHRoMjtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjZEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTQgPSBzaGFwZVs1XTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF0gKiBzdHJpZGU0O1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgY29uc3QgeyBuZXdTaGFwZSwga2VwdERpbXMgfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJywgJ2RlcHRoMycsICdkZXB0aDQnXTtcbiAgICAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KS5yb3V0aW5lQm9keX1cbiAgICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7c3RyaWRlMH0gKyBjb2wgKiAke3N0cmlkZTF9ICsgZGVwdGggKiAke3N0cmlkZTJ9ICtcbiAgICAgICAgICAgIGRlcHRoMiAqICR7c3RyaWRlM30gKyBkZXB0aDMgKiAke3N0cmlkZTR9ICsgZGVwdGg0O1xuICAgICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgW1xuICAgICAgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0JyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIG1hcCBmcm9tIHRoZSBnaXZlbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIChzLHQpXG4gICAqIHRvIGxvZ2ljYWwgaW5kaWNlcyBmb3IgdGhlIG91dHB1dFxuICAgKiBUaGVyZSB3aWxsIG9ubHkgYmUgb25lIHNpbmdsZSB2YXJpYXRpb24gb2YgdGhpc1xuICAgKiBBbHNvIHNlZSBjb29yZHNUb09mZnNldCBhbmQgb2Zmc2V0VG9JbmRpY2VzIGZvciBpbnB1dC1zcGVjaWZpYyB2ZXJzaW9uc1xuICAgKi9cbiAgcHJvdGVjdGVkIHRvVmVjKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXQuc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHN0cmlkZXMgPSBvdXRwdXQuc3RyaWRlcztcbiAgICBjb25zdCB4U2NhbGUgPSBvdXRwdXQud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gb3V0cHV0LmhlaWdodDtcblxuICAgIGNvbnN0IHN0cmlkZXNCbG9jayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgICBjWyR7aX1dID0gb2Zmc2V0IC8gJHtzdHJpZGVzW2ldfTtgKTtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgb2Zmc2V0IC09IGNbJHtpfV0gKiAke3N0cmlkZXNbaV19O2ApO1xuICAgIH1cbiAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIGNbJHtyYW5rIC0gMX1dID0gb2Zmc2V0O2ApO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICB2b2lkIHRvVmVjKHZlYzIgdGV4Q29vcmRzLCBvdXQgaW50IGNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHt4U2NhbGV9LCAke3lTY2FsZX0pO1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICAgIHZvaWQgdG9WZWMoaW50IG9mZnNldCwgb3V0IGludCBjWyR7cmFua31dKSB7XG4gICAgICAgICR7c3RyaWRlc0Jsb2NrLmpvaW4oJycpfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHsgdG9WZWM6IG5ldyBHbHNsTGliUm91dGluZShib2R5LCBbJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSB2YWx1ZSBnZXR0ZXIgZnVuY3Rpb25zIGdlbmVyYXRlZCBmb3IgZWFjaCBpbnB1dFxuICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGhhcmR3aXJlZCB0byB0aGUgbmFtZSBhbmQgZGltZW5zaW9ucyBvZiB0aGUgaW5wdXRcbiAgICogQW4gJ19UJyB2YXJpYXRpb24gaXMgYWxzbyBwcm9kdWNlZCB3aGljaCBhY2Nlc3NlcyB2YWx1ZXMgYXMgaWYgdGhlXG4gICAqIGlucHV0IHdhcyB0cmFuc3Bvc2VkXG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsdWVGcm9tKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldO1xuICAgICAgY29uc3Qgc2hhcGUgPSBsYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGggPiAwID8gbGF5b3V0LnVucGFja2VkU2hhcGUgOiBsYXlvdXQuc2hhcGU7XG4gICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGZ1bmNOYW1lID0gYF8ke25hbWV9YDtcbiAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUobmFtZSwgcmFuaywgbGF5b3V0LndpZHRoLCBsYXlvdXQuaGVpZ2h0LCBmYWxzZSksIFtcbiAgICAgICAgYHNoYXBlVXRpbHMuaW5kaWNlc1RvT2Zmc2V0JHtmdW5jTmFtZX1gLFxuICAgICAgICAnY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHMnLFxuICAgICAgICAnZnJhZ2NvbG9yLmdldENvbG9yQXNGbG9hdCcsXG4gICAgICBdKTtcbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUgKyAnX1QnO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShuYW1lLCByYW5rLCBsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHQsIHRydWUpLCBbXG4gICAgICAgIGBzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7ZnVuY05hbWV9YCxcbiAgICAgICAgJ2Nvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzJyxcbiAgICAgICAgJ2ZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXQnLFxuICAgICAgXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgb25lIHZhbHVlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIG5hbWUgYW5kIHJhbmsgZ2l2ZW5cbiAgICogSWYgYSB0cmFuc3Bvc2UgaXMgc2V0IHByb3BlciBvZmZzZXRUb0Nvb3JkcyBtYXBwaW5nIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmFuayByYW5rIG9mIHRoZSBpbnB1dFxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIHdoZXRoZXIgb3Igbm90IHNob3VsZCBnZW5lcmF0ZSBhIHRyYW5zcG9zZSB2YXJpYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBnZXRWYWx1ZUZyb21TaW5nbGUoXG4gICAgdmFyTmFtZTogc3RyaW5nLFxuICAgIHJhbms6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIHRyYW5zcG9zZTogYm9vbGVhbixcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgbmFtZSA9IGBfJHt2YXJOYW1lfWA7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgbmFtZSA9IG5hbWUgKyAnX1QnO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiBgXG4gICAgICAgIGZsb2F0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHtuYW1lfShtKTtcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oJHt2YXJOYW1lfSwgY29vcmRzKSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBwYWNrZWQgdmFsdWUgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbmFtZSBhbmQgcmFuayBnaXZlblxuICAgKiBJZiBhIHRyYW5zcG9zZSBpcyBzZXQgcHJvcGVyIG9mZnNldFRvQ29vcmRzIG1hcHBpbmcgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSByYW5rIHJhbmsgb2YgdGhlIGlucHV0XG4gICAqIEBwYXJhbSB0cmFuc3Bvc2Ugd2hldGhlciBvciBub3Qgc2hvdWxkIGdlbmVyYXRlIGEgdHJhbnNwb3NlIHZhcmlhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFZhbHVlRnJvbShcbiAgICB2YXJOYW1lOiBzdHJpbmcsXG4gICAgcmFuazogbnVtYmVyLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgdHJhbnNwb3NlOiBib29sZWFuLFxuICApOiBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gYF8ke3Zhck5hbWV9X1BhY2tgO1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJ19UJztcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gYFxuICAgICAgICB2ZWM0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0XyR7dmFyTmFtZX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke3Zhck5hbWV9LCBjb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lIH0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGNvbnZlcnRpbmdcbiAqIGZsb2F0MzIgdG8vZnJvbSBVbnNpZ25lZCBieXRlIG9yIGZsb2F0IDE2XG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGluZ0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5lbmNvZGVGbG9hdDMyKCksIC4uLnRoaXMuZGVjb2RlRmxvYXQzMigpIH07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKTogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm90ZWN0ZWQgZW5jb2RlRmxvYXQzMigpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoZiwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICB9XG4gICAgICAgIGApLFxuICAgIH07XG4gIH1cbiAgcHJvdGVjdGVkIGRlY29kZUZsb2F0MzIoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XG4gICAgICAgIHJldHVybiByZ2JhLnI7XG4gICAgICB9XG4gICAgICAgIGApLFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHJvdXRpbmUgdG8gZW5jb2RlIGVuY29kZSBhIDMyYml0IGZsb2F0IHRvIGEgdmVjNCAob2YgdW5zaWduZWQgYnl0ZXMpXG4gICAqIEBjcmVkaXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNTk5NjIvaG93LWRvLWktY29udmVydC1hLXZlYzQtcmdiYS12YWx1ZS10by1hLWZsb2F0XG4gICAqL1xuICBwcm90ZWN0ZWQgZW5jb2RlVWludDgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZW5kaWFubmVzcyA9IEVuY29kaW5nR2xzbExpYi5pc0xpdHRsZUVuZGlhbigpID8gJ3JnYmEucmdiYT1yZ2JhLmFiZ3I7JyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XG4gICAgICAgIGhpZ2hwIGZsb2F0IEYgPSBhYnMoZik7XG4gICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSBzdGVwKDAuMCwtZik7XG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XG4gICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gKGV4cDIoLSBFeHBvbmVudCkgKiBGKTtcbiAgICAgICAgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpICsgMTI3LjApICsgZmxvb3IobG9nMihNYW50aXNzYSkpO1xuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XG4gICAgICAgIHJnYmFbMF0gPSAxMjguMCAqIFNpZ24gICsgZmxvb3IoRXhwb25lbnQqZXhwMigtMS4wKSk7XG4gICAgICAgIHJnYmFbMV0gPSAxMjguMCAqIG1vZChFeHBvbmVudCwyLjApICsgbW9kKGZsb29yKE1hbnRpc3NhKjEyOC4wKSwxMjguMCk7XG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcbiAgICAgICAgcmdiYVszXSA9IGZsb29yKGV4cDIoMjMuMCkqbW9kKE1hbnRpc3NhLGV4cDIoLTE1LjApKSk7XG4gICAgICAgICR7ZW5kaWFubmVzc31cbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG4gICAgICAgIGApLFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHJvdXRpbmUgdG8gZW5jb2RlIGEgdmVjNCBvZiB1bnNpZ25lZCBieXRlcyB0byBmbG9hdDMyXG4gICAqIEBjcmVkaXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNTk5NjIvaG93LWRvLWktY29udmVydC1hLXZlYzQtcmdiYS12YWx1ZS10by1hLWZsb2F0XG4gICAqL1xuICBwcm90ZWN0ZWQgZGVjb2RlVWludDgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZW5kaWFubmVzcyA9IEVuY29kaW5nR2xzbExpYi5pc0xpdHRsZUVuZGlhbigpID8gJ3JnYmEucmdiYT1yZ2JhLmFiZ3I7JyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICBkZWNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICAgIGhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxuICAgICAgICAgICR7ZW5kaWFubmVzc31cbiAgICAgICAgICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjguMCxyZ2JhWzBdKSoyLjA7XG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XG4gICAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsxXSwxMjguMCkqNjU1MzYuMCArIHJnYmFbMl0qMjU2LjAgK3JnYmFbM10gKyBmbG9hdCgweDgwMDAwMCk7XG4gICAgICAgICAgaGlnaHAgZmxvYXQgUmVzdWx0ID0gIFNpZ24gKiBleHAyKEV4cG9uZW50KSAqIChNYW50aXNzYSAqIGV4cDIoLTIzLjAgKSk7XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcbiAgICAgIH1cbiAgICAgICAgYCksXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbWFjaGluZSBpcyBsaXR0bGUgZW5kaWFuIG9yIG5vdFxuICAgKiBAY3JlZGl0OiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Ub29UYWxsTmF0ZS80NzUwOTUzXG4gICAqL1xuICBzdGF0aWMgaXNMaXR0bGVFbmRpYW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICBjb25zdCBhID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBhWzBdID0gMHhkZWFkYmVlZjtcbiAgICBpZiAoY1swXSA9PT0gMHhlZikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjWzBdID09PSAweGRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbmRpYW5uZXNzJyk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lIH0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuL2dsc2wtc291cmNlJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGFyb3VuZCByZWFkaW5nIGEgdGV4bGV0IGFuZCB3cml0aW5nIHRvIGl0XG4gKiBSZWFkaW5nIGFuZCB3cml0aW5nIGNvdWxkIGJlIG1vcmUgdGhhbiBqdXN0IGRlYWxpbmcgd2l0aCBvbmUgY2hhbm5lbFxuICogSXQgbWF5IHJlcXVpcmUgZW5jb2RpbmcvZGVjb2RpbmcgdG8vZnJvbSA0IGNoYW5uZWxzIGludG8gb25lXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnQ29sb3JHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc2V0RnJhZ0NvbG9yKCksIC4uLnRoaXMuZ2V0Q29sb3JBc0Zsb2F0KCkgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHByb3RlY3RlZCBzZXRGcmFnQ29sb3IoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhZ0NvbG9yOiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIGBcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICBbJ2VuY29kaW5nLmVuY29kZSddLFxuICAgICAgKSxcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRDb2xvckFzRmxvYXQoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbG9yQXNGbG9hdDogbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICBgXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlKGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICBbJ2VuY29kaW5nLmRlY29kZSddLFxuICAgICAgKSxcbiAgICB9O1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZSB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciBkYXRhIHR5cGVzIGFuZCByb3V0aW5lcyBmb3IgbWFuaXB1bGF0aW5nXG4gKiBjb29yZGluYXRlcyBhbmQgbWFwcGluZyB0by9mcm9tIHRlbnNvciBpbmRpY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWxzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBHbHNsQ29udGV4dCkge1xuICAgIHN1cGVyKGNvbnRleHQpO1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5iY2FzdEluZGV4KCksXG4gICAgICAuLi50aGlzLmJjYXN0TWF0bXVsSW5kZXgoKSxcbiAgICAgIC4uLnRoaXMub2Zmc2V0VG9JbmRpY2VzKCksXG4gICAgICAuLi50aGlzLmluZGljZXNUb09mZnNldCgpLFxuICAgICAgLi4udGhpcy5pbmNyZW1lbnRJbmRpY2VzKCksXG4gICAgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGJjYXN0SW5kZXgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7XG4gICAgICBpZiAoc2hhcGUubGVuZ3RoIDw9IG91dHB1dFJhbmspIHtcbiAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGltT2Zmc2V0ID0gb3V0cHV0UmFuayAtIHJhbms7XG4gICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gYGJjYXN0SW5kaWNlc18ke25hbWV9YDtcbiAgICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgICAgYmxvY2sgKz0gYFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHtkaW1PZmZzZXQgKyBpfV0pLCAke3NoYXBlW2ldfS4wKSApO1xuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFua31dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgJHtibG9ja31cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGJjYXN0TWF0bXVsSW5kZXgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgaWYgKCEoc2hhcGUubGVuZ3RoIDwgMiB8fCBzaGFwZS5sZW5ndGggPiBvdXRwdXRSYW5rKSkge1xuICAgICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBvdXRwdXRSYW5rIC0gcmFuaztcbiAgICAgICAgY29uc3QgZnVuY05hbWUgPSBgYmNhc3RNYXRtdWxJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgKytpKSB7XG4gICAgICAgICAgYmxvY2sgKz0gYFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHtkaW1PZmZzZXQgKyBpfV0pLCAke3NoYXBlW2ldfS4wKSApO1xuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7cmFuayAtIDF9XSA9IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFuayAtIDF9XTtcbiAgICAgICAgICByZWFsSW5kaWNlc1ske3JhbmsgLSAyfV0gPSBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmsgLSAyfV07XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBpbmRpY2VzVG9PZmZzZXQoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zdHJpZGVzO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBpbmRpY2VzVG9PZmZzZXRfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYGluZGljZXNUb09mZnNldF8ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgU2hhcGVVdGlsc0dsc2xMaWIuaW5kZXhUb09mZnNldFNpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcy5zbGljZSgpLnJldmVyc2UoKSksXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGluZGV4VG9PZmZzZXRTaW5nbGUobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdKTogc3RyaW5nIHtcbiAgICBsZXQgYmxvY2sgPSAnJztcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7aX1dICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIGludCAke25hbWV9KGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYDtcbiAgfVxuICBwcm90ZWN0ZWQgb2Zmc2V0VG9JbmRpY2VzKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc2hhcGU7XG4gICAgICBjb25zdCBzdHJpZGVzID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc3RyaWRlcztcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgZnVuY05hbWUgPSBgb2Zmc2V0VG9JbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShTaGFwZVV0aWxzR2xzbExpYi5vZmZzZXRUb0luZGljZXNTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYG9mZnNldFRvSW5kaWNlc18ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgU2hhcGVVdGlsc0dsc2xMaWIub2Zmc2V0VG9JbmRpY2VzU2luZ2xlKGZ1bmNOYW1lLCByYW5rLCBzdHJpZGVzLnNsaWNlKCkucmV2ZXJzZSgpKSxcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgb2Zmc2V0VG9JbmRpY2VzU2luZ2xlKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3RyaWRlc0Jsb2NrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICBpbmRpY2VzWyR7aX1dID0gb2Zmc2V0IC8gJHtzdHJpZGVzW2ldfTtgKTtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgb2Zmc2V0IC09IGluZGljZXNbJHtpfV0gKiAke3N0cmlkZXNbaV19O2ApO1xuICAgIH1cbiAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICBpbmRpY2VzWyR7cmFuayAtIDF9XSA9IG9mZnNldDtgKTtcbiAgICByZXR1cm4gYFxuICAgICAgdm9pZCAke25hbWV9KGludCBvZmZzZXQsIG91dCBpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICAgIGA7XG4gIH1cbiAgcHJvdGVjdGVkIGluY3JlbWVudEluZGljZXMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBmdW5jTmFtZSA9IGBpbmNyZW1lbnRJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgbGV0IHNoYXBlSW5pdCA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgc2hhcGVJbml0ICs9IGBcbiAgICAgICAgc2hhcGVbJHtpfV0gPSAke3NoYXBlW2ldfTtgO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IHNoYXBlWyR7cmFua31dO1xuICAgICAgICAgICR7c2hhcGVJbml0fTtcbiAgICAgICAgICBmb3IoaW50IGkgPSAke3Jhbmt9IC0xIDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmKGkgPiBheGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcbiAgICAgICAgICAgIGlmKGluZGljZXNbaV0gPCBzaGFwZVtpXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGljZXNbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZSB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciB2ZWMgcm91dGluZXNcbiAqIFZlYyBpcyBhbiB2YXJpYmxlIGxlbmd0aCBpbnQgYXJyYXkuIFRoZSBsZW5ndGggaXMgZml4ZWQgYXQgdGhlIHRpbWUgb2ZcbiAqIGdlbmVyYXRpbmcgdGhlIGxpYnJhcnkgZnVuY3Rpb25zIGZyb20gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlY0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICByZXR1cm4geyAuLi50aGlzLmJpbmFyeVZlY0Z1bmN0aW9ucygpLCAuLi50aGlzLmNvcHlWZWMoKSwgLi4udGhpcy5zZXRWZWNJdGVtKCksIC4uLnRoaXMuZ2V0VmVjSXRlbSgpIH07XG4gIH1cbiAgcHJvdGVjdGVkIGJpbmFyeVZlY0Z1bmN0aW9ucygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBuYW1lT3A6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0geyBhZGQ6ICcrPScsIHN1YjogJy09JywgbXVsOiAnKj0nLCBkaXY6ICcvPScgfTtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmFtZU9wKSB7XG4gICAgICBjb25zdCBmbmFtZSA9IGAke25hbWV9VmVjYDtcbiAgICAgIGxldCBhc3NpZ25tZW50QmxvY2sgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIGFzc2lnbm1lbnRCbG9jayArPSBgXG4gICAgICAgICAgZGVzdFske2l9XSAke25hbWVPcFtuYW1lXX0gc3JjWyR7aX1dO1xuICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7Zm5hbWV9KGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAgICR7YXNzaWdubWVudEJsb2NrfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXN1bHRbZm5hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGNvcHlWZWMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBhc3NpZ25tZW50QmxvY2sgKz0gYFxuICAgICAgICBkZXN0WyR7aX1dID0gc3JjWyR7aX1dO1xuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAke2Fzc2lnbm1lbnRCbG9ja31cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHsgY29weVZlYzogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0VmVjSXRlbSgpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBsZXQgYmxvY2sgPSBgXG4gICAgICAgIGlmKGluZGV4IDwgMClcbiAgICAgICAgICAgIGluZGV4ID0ke3Jhbmt9ICsgaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgbVswXSA9IHZhbHVlO1xuICAgICAgICBgO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke2l9KVxuICAgICAgICAgICAgbVske2l9XSA9IHZhbHVlO1xuICAgICAgICAgICAgYDtcbiAgICB9XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtWyR7cmFuayAtIDF9XSA9IHZhbHVlO1xuICAgICAgICBgO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICB2b2lkIHNldFZlY0l0ZW0ob3V0IGludCBtWyR7cmFua31dLCBpbnQgaW5kZXgsIGludCB2YWx1ZSkge1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgfVxuICAgICAgICBgO1xuICAgIHJldHVybiB7IHNldFZlY0l0ZW06IG5ldyBHbHNsTGliUm91dGluZShib2R5KSB9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRWZWNJdGVtKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBibG9jayA9IGBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSAke3Jhbmt9ICsgaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICBgO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke2l9KVxuICAgICAgICAgICAgcmV0dXJuIG1bJHtpfV07XG4gICAgICBgO1xuICAgIH1cbiAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtWyR7cmFuayAtIDF9XTtcbiAgICAgICAgYDtcbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgaW50IGdldFZlY0l0ZW0oaW50IG1bJHtyYW5rfV0sIGludCBpbmRleCkge1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHsgZ2V0VmVjSXRlbTogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpIH07XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQ29vcmRzR2xzbExpYiB9IGZyb20gJy4vZ2xzbC1jb29yZGluYXRlLWxpYic7XG5pbXBvcnQgeyBHbHNsQ29udGV4dCwgR2xzbExpYiB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBFbmNvZGluZ0dsc2xMaWIgfSBmcm9tICcuL2dsc2wtZW5jb2RpbmctbGliJztcbmltcG9ydCB7IEZyYWdDb2xvckdsc2xMaWIgfSBmcm9tICcuL2dsc2wtZnJhZ2NvbG9yLWxpYic7XG5pbXBvcnQgeyBTaGFwZVV0aWxzR2xzbExpYiB9IGZyb20gJy4vZ2xzbC1zaGFwZS11dGlscy1saWInO1xuaW1wb3J0IHsgVmVjR2xzbExpYiB9IGZyb20gJy4vZ2xzbC12ZWMtbGliJztcblxuZXhwb3J0IGNvbnN0IGdsc2xSZWdpc3RyeTogeyBbbmFtZTogc3RyaW5nXTogbmV3IChjb250ZXh0OiBHbHNsQ29udGV4dCkgPT4gR2xzbExpYiB9ID0ge1xuICBlbmNvZGluZzogRW5jb2RpbmdHbHNsTGliLFxuICBmcmFnY29sb3I6IEZyYWdDb2xvckdsc2xMaWIsXG4gIHZlYzogVmVjR2xzbExpYixcbiAgc2hhcGVVdGlsczogU2hhcGVVdGlsc0dsc2xMaWIsXG4gIGNvb3JkaW5hdGVzOiBDb29yZHNHbHNsTGliLFxuICAvLyAgJ2FycmF5cyc6IEFycmF5R2xzbFNMaWJcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZU5vZGUsIFRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcyB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQgeyByZXBsYWNlSW5saW5lcyB9IGZyb20gJy4vZ2xzbC1mdW5jdGlvbi1pbmxpbmVyJztcbmltcG9ydCB7IGdsc2xSZWdpc3RyeSB9IGZyb20gJy4vZ2xzbC1yZWdpc3RlcmVkLWxpYnMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluLCBnZXRGcmFnU2hhZGVyUHJlYW1ibGUgfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlTGF5b3V0LCBWYXJpYWJsZUluZm8gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbi8qKlxuICogUHJlcHJvY2Vzc29yIGZvciB0aGUgYWRkaXRpb25zIHRvIHRoZSBHTFNMIGxhbmd1YWdlXG4gKiBJdCBkZWFscyB3aXRoOlxuICogIEBpbmNsdWRlIGRpcmVjdGl2ZXNcbiAqICBAaW5saW5lXG4gKiAgTG9vcCB1bnJvbGxpbmcgKG5vdCBpbXBsZW1lbnRlZClcbiAqICBNYWNybyByZXNvbHV0aW9uIChub3QgaW1wbGVtZW50ZWQpXG4gKi9cbmV4cG9ydCBjbGFzcyBHbHNsUHJlcHJvY2Vzc29yIHtcbiAgcmVhZG9ubHkgY29udGV4dDogR2xzbENvbnRleHQ7XG4gIHJlYWRvbmx5IGxpYnM6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWIgfSA9IHt9O1xuICByZWFkb25seSBnbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDogeyBbcm91dGluZU5hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lTm9kZSB9ID0ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsXG4gICAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLFxuICAgIGlucHV0VGV4dHVyZUxheW91dHM6IFRleHR1cmVMYXlvdXRbXSxcbiAgICBvdXRwdXRUZXh0dXJlTGF5b3V0OiBUZXh0dXJlTGF5b3V0LFxuICApIHtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgR2xzbENvbnRleHQoZ2xDb250ZXh0LCBwcm9ncmFtSW5mbywgaW5wdXRUZXh0dXJlTGF5b3V0cywgb3V0cHV0VGV4dHVyZUxheW91dCk7XG5cbiAgICAvLyBjb25zdHJ1Y3QgR2xzbExpYnNcbiAgICBPYmplY3Qua2V5cyhnbHNsUmVnaXN0cnkpLmZvckVhY2goKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbGliID0gbmV3IGdsc2xSZWdpc3RyeVtuYW1lXSh0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5saWJzW25hbWVdID0gbGliO1xuICAgIH0pO1xuXG4gICAgLy8gY29uc3RydWN0IEdsc2xSb3V0aW5lRGVwZW5kZW5jeUdyYXBoXG4gICAgY29uc3QgbWFwID0gdGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDtcbiAgICBmb3IgKGNvbnN0IGxpYk5hbWUgaW4gdGhpcy5saWJzKSB7XG4gICAgICBjb25zdCBsaWIgPSB0aGlzLmxpYnNbbGliTmFtZV07XG4gICAgICBjb25zdCByb3V0aW5lc0luTGliID0gbGliLmdldEZ1bmN0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCByb3V0aW5lIGluIHJvdXRpbmVzSW5MaWIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbGliTmFtZSArICcuJyArIHJvdXRpbmU7XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZTogR2xzbExpYlJvdXRpbmVOb2RlO1xuICAgICAgICBpZiAobWFwW2tleV0pIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG1hcFtrZXldO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnJvdXRpbmVCb2R5ID0gcm91dGluZXNJbkxpYltyb3V0aW5lXS5yb3V0aW5lQm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG5ldyBHbHNsTGliUm91dGluZU5vZGUoa2V5LCByb3V0aW5lc0luTGliW3JvdXRpbmVdLnJvdXRpbmVCb2R5KTtcbiAgICAgICAgICBtYXBba2V5XSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJvdXRpbmVzSW5MaWJbcm91dGluZV0uZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbWFwW2RlcGVuZGVuY2llc1tpXV0pIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBHbHNsTGliUm91dGluZU5vZGUoZGVwZW5kZW5jaWVzW2ldKTtcbiAgICAgICAgICAgICAgbWFwW2RlcGVuZGVuY2llc1tpXV0gPSBub2RlO1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hZGREZXBlbmRlbmN5KG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUuYWRkRGVwZW5kZW5jeShtYXBbZGVwZW5kZW5jaWVzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJlcHJvY2VzcygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO1xuICAgIGxldCBzb3VyY2UgPSBwcm9ncmFtSW5mby5zaGFkZXJTb3VyY2U7XG5cbiAgICAvLyBhcHBlbmQgbWFpbigpIGZ1bmN0aW9uXG4gICAgaWYgKCF0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbikge1xuICAgICAgc291cmNlID0gYCR7c291cmNlfVxuICAgICAgJHtnZXREZWZhdWx0RnJhZ1NoYWRlck1haW4odGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uLCB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgpfWA7XG4gICAgfVxuICAgIC8vIHJlcGxhY2UgaW5saW5lc1xuICAgIHNvdXJjZSA9IHJlcGxhY2VJbmxpbmVzKHNvdXJjZSk7XG5cbiAgICAvLyBjb25jYXQgZmluYWwgc291cmNlIHN0cmluZ1xuICAgIHJldHVybiBgJHtnZXRGcmFnU2hhZGVyUHJlYW1ibGUodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKX1cbiAgICAke3RoaXMuZ2V0VW5pZm9ybXMocHJvZ3JhbUluZm8uaW5wdXROYW1lcywgcHJvZ3JhbUluZm8udmFyaWFibGVzKX1cbiAgICAke3RoaXMuZ2V0SW1wb3J0cyhzb3VyY2UpfVxuICAgICR7c291cmNlfWA7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0SW1wb3J0cyhzY3JpcHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgcm91dGluZXNJbmNsdWRlZCA9IHRoaXMuc2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHNjcmlwdCk7XG5cbiAgICBpZiAocm91dGluZXNJbmNsdWRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgcm91dGluZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRpbmVzSW5jbHVkZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChyb3V0aW5lc0luY2x1ZGVkW2ldLnJvdXRpbmVCb2R5KSB7XG4gICAgICAgIHJvdXRpbmVzICs9IHJvdXRpbmVzSW5jbHVkZWRbaV0ucm91dGluZUJvZHkgKyAnXFxuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBib2R5IGZvciB0aGUgR2xzbCBMaWJyYXJ5IHJvdXRpbmU6ICR7cm91dGluZXNJbmNsdWRlZFtpXS5uYW1lfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3V0aW5lcztcbiAgfVxuICBwcml2YXRlIHNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChzY3JpcHQ6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lTm9kZVtdIHtcbiAgICBjb25zdCBub2RlczogR2xzbExpYlJvdXRpbmVOb2RlW10gPSBbXTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKGNsYXNzQW5kUm91dGluZSkgPT4ge1xuICAgICAgY29uc3Qgcm91dGluZSA9IGNsYXNzQW5kUm91dGluZS5zcGxpdCgnLicpWzFdO1xuICAgICAgaWYgKHNjcmlwdC5pbmRleE9mKHJvdXRpbmUpICE9PSAtMSkge1xuICAgICAgICBub2Rlcy5wdXNoKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGhbY2xhc3NBbmRSb3V0aW5lXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzLnJldHVybk9yZGVyZWROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VW5pZm9ybXMoc2FtcGxlcnM/OiBzdHJpbmdbXSwgdmFyaWFibGVzPzogVmFyaWFibGVJbmZvW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHVuaWZvcm1MaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoc2FtcGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBvZiBzYW1wbGVycykge1xuICAgICAgICB1bmlmb3JtTGluZXMucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgJHtzYW1wbGVyfTtgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgICAgdW5pZm9ybUxpbmVzLnB1c2goXG4gICAgICAgICAgYHVuaWZvcm0gJHt2YXJpYWJsZS50eXBlfSAke3ZhcmlhYmxlLm5hbWV9JHt2YXJpYWJsZS5hcnJheUxlbmd0aCA/IGBbJHt2YXJpYWJsZS5hcnJheUxlbmd0aH1dYCA6ICcnfTtgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pZm9ybUxpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IExvZ2dlciwgUHJvZmlsZXIgfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuaW1wb3J0IHsgR2xzbFByZXByb2Nlc3NvciB9IGZyb20gJy4vZ2xzbC1wcmVwcm9jZXNzb3InO1xuaW1wb3J0IHsgZ2V0VmVydGV4U2hhZGVyU291cmNlIH0gZnJvbSAnLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kgfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7IEFydGlmYWN0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVZhcmlhYmxlLCBUZXh0dXJlRGF0YSwgVGV4dHVyZUxheW91dCwgVmFyaWFibGVJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBXZWJHTENvbnRleHQgfSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47IC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxuICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xuICBhdHRyaWJ1dGVzQm91bmQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sXG4gICAgcHVibGljIGdsQ29udGV4dDogV2ViR0xDb250ZXh0LFxuICAgIHB1YmxpYyB0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSxcbiAgKSB7XG4gICAgdGhpcy5yZXBvID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XG4gIH1cbiAgZ2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duKTogQXJ0aWZhY3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihidWlsZEFydGlmYWN0OiBBcnRpZmFjdCwgaW5wdXRzOiBUZXh0dXJlRGF0YVtdLCBvdXRwdXQ6IFRleHR1cmVEYXRhKTogdm9pZCB7XG4gICAgdGhpcy5wcm9maWxlci5ldmVudChcbiAgICAgICdvcCcsXG4gICAgICBgUHJvZ3JhbU1hbmFnZXIucnVuICR7YnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lID8/ICd1bmtub3duIGtlcm5lbCd9YCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmJpbmRPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlc0JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRBdHRyaWJ1dGVzKGJ1aWxkQXJ0aWZhY3QuYXR0cmliTG9jYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5iaW5kVW5pZm9ybXMoYnVpbGRBcnRpZmFjdC51bmlmb3JtTG9jYXRpb25zLCBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyA/PyBbXSwgaW5wdXRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgTG9nZ2VyLmVycm9yKCdQcm9ncmFtTWFuYWdlcicsIGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8uc2hhZGVyU291cmNlKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdHbENvbnRleHQuZHJhdygpJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2xDb250ZXh0LmRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdGhpcy5nbENvbnRleHQsXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZlcnRleFNoYWRlcikge1xuICAgICAgdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgdGhpcy5yZXBvLmZvckVhY2goKGEpID0+IHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0oYS5wcm9ncmFtKSk7XG4gIH1cbiAgYnVpbGQocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sIG91dHB1dFRleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBBcnRpZmFjdCB7XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnUHJvZ3JhbU1hbmFnZXIuYnVpbGQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVwcm9jZXNzb3IgPSBuZXcgR2xzbFByZXByb2Nlc3Nvcih0aGlzLmdsQ29udGV4dCwgcHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZUxheW91dHMsIG91dHB1dFRleHR1cmVMYXlvdXQpO1xuICAgICAgY29uc3QgZnJhZ1NjcmlwdCA9IHByZXByb2Nlc3Nvci5wcmVwcm9jZXNzKCk7XG4gICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5jb21waWxlKGZyYWdTY3JpcHQpO1xuICAgICAgY29uc3QgYXJ0aWZhY3QgPSB7XG4gICAgICAgIHByb2dyYW1JbmZvLFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoXG4gICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICBwcmVwcm9jZXNzb3IuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLFxuICAgICAgICAgIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyxcbiAgICAgICAgKSxcbiAgICAgICAgYXR0cmliTG9jYXRpb25zOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtKSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXJ0aWZhY3Q7XG4gICAgfSk7XG4gIH1cbiAgcHJvdGVjdGVkIGNvbXBpbGUoZnJhZ1NoYWRlclNjcmlwdDogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICBpZiAoIXRoaXMudmVydGV4U2hhZGVyKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnUHJvcmdyYW1NYW5hZ2VyJywgJ0NvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZScpO1xuICAgICAgY29uc3QgdmVydGV4U2hhZGVyU2NyaXB0ID0gZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgfVxuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAnUHJvcmdyYW1NYW5hZ2VyJyxcbiAgICAgICAgYEZyYWdTaGFkZXI6XG4ke2ZyYWdTaGFkZXJTY3JpcHR9XG5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ1NoYWRlciA9IHRoaXMuZ2xDb250ZXh0LmNvbXBpbGVTaGFkZXIoZnJhZ1NoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nbENvbnRleHQuY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlciwgZnJhZ1NoYWRlcik7XG4gICAgdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKGZyYWdTaGFkZXIpO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGJpbmRPdXRwdXQodGQ6IFRleHR1cmVEYXRhKTogdm9pZCB7XG4gICAgY29uc3Qgd2lkdGggPSB0ZC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0ZC5oZWlnaHQ7XG4gICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAnUHJvcmdyYW1NYW5hZ2VyJyxcbiAgICAgIGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHt3aWR0aH0vJHtoZWlnaHR9LCBzaGFwZT0ke3RkLnNoYXBlfSwgdHlwZT0ke3RkLnRlbnNvci50eXBlfWAsXG4gICAgKTtcbiAgICB0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0ZC50ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBiaW5kQXR0cmlidXRlcyhhdHRyaWJMb2NhdGlvbnM6IEFydGlmYWN0LkF0dHJpYkxvY2F0aW9ucyk6IHZvaWQge1xuICAgIGNvbnN0IHBvc2l0aW9uSGFuZGxlID0gYXR0cmliTG9jYXRpb25zLnBvc2l0aW9uO1xuICAgIGNvbnN0IHRleHR1cmVDb29yZEhhbmRsZSA9IGF0dHJpYkxvY2F0aW9ucy50ZXh0dXJlQ29vcmQ7XG4gICAgdGhpcy5nbENvbnRleHQuc2V0VmVydGV4QXR0cmlidXRlcyhwb3NpdGlvbkhhbmRsZSwgdGV4dHVyZUNvb3JkSGFuZGxlKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IHRydWU7XG4gIH1cbiAgYmluZFVuaWZvcm1zKFxuICAgIHVuaWZvcm1Mb2NhdGlvbnM6IEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgdmFyaWFibGVzOiBQcm9ncmFtVmFyaWFibGVbXSxcbiAgICB0ZXh0dXJlczogVGV4dHVyZURhdGFbXSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICBsZXQgdGV4dHVyZVBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdHlwZSwgbG9jYXRpb24sIGFycmF5TGVuZ3RoIH0gb2YgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YXJpYWJsZXMuZmluZCgodikgPT4gdi5uYW1lID09PSBuYW1lKT8uZGF0YTtcbiAgICAgIGlmICh0eXBlICE9PSAnc2FtcGxlcjJEJyAmJiAhdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YXJpYWJsZSAnJHtuYW1lfScgZG9lcyBub3QgaGF2ZSBkYXRhIGRlZmluZWQgaW4gcHJvZ3JhbSBpbmZvYCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmVzW3RleHR1cmVQb3NpdGlvbl0sIGxvY2F0aW9uLCB0ZXh0dXJlUG9zaXRpb24pO1xuICAgICAgICAgIHRleHR1cmVQb3NpdGlvbisrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXJbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXJbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIG5vdCBpbXBsZW1lbnRlZDogJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIHVuaWZvcm1IYW5kbGU6IFdlYkdMVW5pZm9ybUxvY2F0aW9uLCBwb3NpdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuYmluZFRleHR1cmVUb1VuaWZvcm0odGQudGV4dHVyZSwgcG9zaXRpb24sIHVuaWZvcm1IYW5kbGUpO1xuICB9XG4gIGdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtOiBXZWJHTFByb2dyYW0pOiBBcnRpZmFjdC5BdHRyaWJMb2NhdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zaXRpb24nKSxcbiAgICAgIHRleHR1cmVDb29yZDogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAndGV4dHVyZUNvb3JkJyksXG4gICAgfTtcbiAgfVxuICBnZXRVbmlmb3JtTG9jYXRpb25zKFxuICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAgICBzYW1wbGVycz86IHN0cmluZ1tdLFxuICAgIHZhcmlhYmxlcz86IFZhcmlhYmxlSW5mb1tdLFxuICApOiBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zIHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zOiBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zID0gW107XG4gICAgaWYgKHNhbXBsZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHNhbXBsZXIgb2Ygc2FtcGxlcnMpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBzYW1wbGVyLFxuICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBzYW1wbGVyKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdmFyaWFibGVzKSB7XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMucHVzaCh7IC4uLnZhcmlhYmxlLCBsb2NhdGlvbjogdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdmFyaWFibGUubmFtZSkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTG9jYXRpb25zO1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtOiBXZWJHTFByb2dyYW0sIG5hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gJHtuYW1lfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiByZWZlcmVuY2U7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb246IG51bWJlciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVMb2NhdGlvbjtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBMb2dnZXIsIFByb2ZpbGVyIH0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG5pbXBvcnQgeyBFbmNvZGVyLCBFbmNvZGVyVXNhZ2UgfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7IFRleHR1cmVMYXlvdXRTdHJhdGVneSB9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHsgVGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZU1hbmFnZXJDb25maWcge1xuICByZXVzZVRleHR1cmVzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUZXh0dXJlTWFuYWdlciBpcyB0aGUgbWFpbmx5IHJlc3BvbnNpYmxlIGZvciBjYWNoaW5nIFRleHR1cmVzXG4gKiBUZXh0dXJlcyBhcmUgY2FjaGVkIGluIDIgbGV2ZWxzOlxuICogICAxLiB0aGUgdGV4dXJlcyB3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgZGF0YUlkIChmcm9tIFRlbnNvcilcbiAqICAgIENhY2hpbmcgdGhlc2UgaXMgY3J1Y2lhbCB0byBwZXJmb3JtYW5jZS4gVGhlc2UgYXJlIEluLXVzZSBUZXh0dXJlc1xuICogICAyLiB0ZXh0dXJlcyB3aGljaCBhcmUgbm90IGluIHVzZSBieSBhbnkgY3VycmVudCBQcm9ncmFtSW5mby9UZW5zb3JcbiAqICAgICBUaGVzZSBhcmUgY2FsbGVkIEZyZWUgVGV4dHVyZXNcbiAqIFRleHR1cmVNYW5hZ2VyIGlzIGFsc28gdXNlZCB0byBoZWxwIGNyZWF0aW5nIHRleHR1cmVzLiBGb3IgdGhpcyBpdFxuICogdXNlcyBXZWJHTENvbnRleHQgYW5kIFRleHR1cmVMYXlvdXRTdHJhdGVneVxuICovXG5leHBvcnQgY2xhc3MgVGV4dHVyZU1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGluVXNlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSBpZGxlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSB0ZXh0dXJlTG9va3VwOiBNYXA8V2ViR0xUZXh0dXJlLCBzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IHBlbmRpbmdSZWFkOiBNYXA8VGVuc29yLklkLCBBcnJheTwoYXJyOiBUZW5zb3IuTnVtYmVyVHlwZSkgPT4gdm9pZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCxcbiAgICBwdWJsaWMgbGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSxcbiAgICBwdWJsaWMgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPixcbiAgICBwcml2YXRlIGNvbmZpZzogVGV4dHVyZU1hbmFnZXJDb25maWcsXG4gICkge1xuICAgIGlmIChjb25maWcucmV1c2VUZXh0dXJlcykge1xuICAgICAgdGhpcy5pblVzZVRleHR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZGxlVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KFxuICAgIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsXG4gICAgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LFxuICAgIGRhdGE/OiBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICB1c2FnZT86IEVuY29kZXJVc2FnZSxcbiAgKSB7XG4gICAgY29uc3QgdGV4dHVyZURhdGFUeXBlID0gdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKTtcblxuICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmdsQ29udGV4dC5nZXRFbmNvZGVyKHRleHR1cmVEYXRhVHlwZSwgbGF5b3V0LmNoYW5uZWxzIHx8IDEsIHVzYWdlKTtcbiAgICBpZiAobGF5b3V0LmlzUGFja2VkICYmIHVzYWdlID09PSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBsYXlvdXQud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gbGF5b3V0LmhlaWdodDtcblxuICAgIGxldCBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5Vc2VUZXh0dXJlczogV2ViR0xUZXh0dXJlW10gfCB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IGAke3dpZHRofXgke2hlaWdodH1fJHtlbmNvZGVyLmZvcm1hdH1fJHtlbmNvZGVyLmludGVybmFsRm9ybWF0fV8ke2VuY29kZXIudGV4dHVyZVR5cGV9YDtcbiAgICAgIGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIWluVXNlVGV4dHVyZXMpIHtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGtleSwgaW5Vc2VUZXh0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgaWYgKGlkbGVUZXh0dXJlcyAmJiBpZGxlVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gaWRsZVRleHR1cmVzLnBvcCgpITtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICBpZiAodXNhZ2UgPT09IEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KSB7XG4gICAgICAgICAgdGhpcy5nbENvbnRleHQudXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVyLCB0aGlzLnRvVGV4dHVyZURhdGEoZGF0YVR5cGUsIGRhdGEpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYENyZWF0aW5nIG5ldyB0ZXh0dXJlIG9mIHNpemUgJHtsYXlvdXQud2lkdGh9eCR7bGF5b3V0LmhlaWdodH1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbENvbnRleHQuYWxsb2NhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGVuY29kZXIsIHRoaXMudG9UZXh0dXJlRGF0YShkYXRhVHlwZSwgZGF0YSkpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGluVXNlVGV4dHVyZXMhLnB1c2godGV4dHVyZSk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAuc2V0KHRleHR1cmUsIGtleSEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICByZWFkVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGNoYW5uZWxzPzogbnVtYmVyKTogVGVuc29yLk51bWJlclR5cGUge1xuICAgIGlmICghY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICB0ZC50ZXh0dXJlLFxuICAgICAgICB0ZC53aWR0aCxcbiAgICAgICAgdGQuaGVpZ2h0LFxuICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKSxcbiAgICAgICAgY2hhbm5lbHMhLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLnRvVGVuc29yRGF0YShkYXRhVHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVhZFRleHR1cmVBc3luYyh0ZDogVGV4dHVyZURhdGEsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGNoYW5uZWxzPzogbnVtYmVyKTogUHJvbWlzZTxUZW5zb3IuTnVtYmVyVHlwZT4ge1xuICAgIGNvbnN0IGRhdGFJZCA9IHRkLnRlbnNvci5kYXRhSWQ7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5wZW5kaW5nUmVhZC5oYXMoZGF0YUlkKSkge1xuICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLnBlbmRpbmdSZWFkLmdldChkYXRhSWQpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFRlbnNvci5OdW1iZXJUeXBlPigocmVzb2x2ZSkgPT4gc3Vic2NyaWJlcnM/LnB1c2gocmVzb2x2ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jJywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nUmVhZC5zZXQoZGF0YUlkLCBbXSk7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgLy8gYWRkIGEgZmVuY2Ugd2FpdGluZyBmb3IgdGhlIGRhdGEgdG8gYmUgcmVhZHlcbiAgICAgIGF3YWl0IHRoaXMuZ2xDb250ZXh0LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICB0ZC50ZXh0dXJlLFxuICAgICAgICB0ZC53aWR0aCxcbiAgICAgICAgdGQuaGVpZ2h0LFxuICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKSxcbiAgICAgICAgY2hhbm5lbHMhLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRlbnNvckRhdGEgPSB0aGlzLnRvVGVuc29yRGF0YShkYXRhVHlwZSwgZGF0YSk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgICB0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgc3Vic2NyaWJlcnM/LmZvckVhY2goKHJlc29sdmUpID0+IHJlc29sdmUodGVuc29yRGF0YSkpO1xuICAgICAgcmV0dXJuIHRlbnNvckRhdGE7XG4gICAgfSk7XG4gIH1cbiAgcmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQodGQ6IFRleHR1cmVEYXRhKTogRmxvYXQzMkFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gdGQuc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodGQudGV4dHVyZSwgdGQud2lkdGgsIHRkLmhlaWdodCwgZGF0YVNpemUgKiA0LCAnYnl0ZScsIDQpO1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YVNpemUpO1xuICAgIH0pO1xuICB9XG4gIHJlbGVhc2VUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgZGVsZXRlVGV4dHVyZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IHRoaXMudGV4dHVyZUxvb2t1cC5nZXQodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChkZWxldGVUZXh0dXJlKSB7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpblVzZVRleHR1cmVzKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBpblVzZVRleHR1cmVzLmluZGV4T2YodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaW5Vc2VUZXh0dXJlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgbGV0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFpZGxlVGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgaWRsZVRleHR1cmVzID0gW107XG4gICAgICAgICAgICAgIHRoaXMuaWRsZVRleHR1cmVzLnNldChrZXksIGlkbGVUZXh0dXJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZGxlVGV4dHVyZXMucHVzaCh0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWtleSB8fCBkZWxldGVUZXh0dXJlKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnVGV4dHVyZU1hbmFnZXInLCBgRGVsZXRpbmcgdGV4dHVyZSBvZiBzaXplICR7dGV4dHVyZURhdGEud2lkdGh9eCR7dGV4dHVyZURhdGEuaGVpZ2h0fWApO1xuICAgICAgdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcbiAgICB9XG4gIH1cbiAgdG9UZW5zb3JEYXRhKGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSA/IGRhdGEgOiBJbnQxNkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50MzJBcnJheSA/IGRhdGEgOiBJbnQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgPyBkYXRhIDogSW50OEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ID8gZGF0YSA6IFVpbnQxNkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ID8gZGF0YSA6IFVpbnQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZGF0YSA6IFVpbnQ4QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IGRhdGEgOiBGbG9hdDMyQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSA/IGRhdGEgOiBGbG9hdDY0QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZGF0YVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbiAgdG9UZXh0dXJlRGF0YShfZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgZGF0YTogVGVuc29yLk51bWJlclR5cGUgfCB1bmRlZmluZWQpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUgfCB1bmRlZmluZWQge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBkYXRhIDogbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAvKlxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gKGRhdGEuY29uc3RydWN0b3IgPT09IFVpbnQzMkFycmF5KSA/IGRhdGEgYXMgVWludDMyQXJyYXkgOiBuZXcgVWludDMyQXJyYXkoZGF0YSk7XG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gKGRhdGEuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpID8gZGF0YSBhcyBVaW50OEFycmF5IDogbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gKGRhdGEuY29uc3RydWN0b3IgPT09IEZsb2F0MzJBcnJheSkgPyBkYXRhIGFzIEZsb2F0MzJBcnJheSA6IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgICovXG4gIH1cbiAgdG9FbmNvZGVyVHlwZShfZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSk6IEVuY29kZXIuRGF0YVR5cGUge1xuICAgIHJldHVybiAnZmxvYXQnO1xuICAgIC8vIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAvLyAgIGNhc2UgJ2ludDE2JzpcbiAgICAvLyAgIGNhc2UgJ2ludDMyJzpcbiAgICAvLyAgIGNhc2UgJ3VpbnQxNic6XG4gICAgLy8gICBjYXNlICd1aW50MzInOlxuICAgIC8vICAgICByZXR1cm4gJ2ludCc7XG4gICAgLy8gICBjYXNlICd1aW50OCc6XG4gICAgLy8gICBjYXNlICdib29sJzpcbiAgICAvLyAgICAgcmV0dXJuICdieXRlJztcbiAgICAvLyAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgIC8vICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgLy8gICAgIHJldHVybiAnZmxvYXQnO1xuICAgIC8vICAgZGVmYXVsdDpcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHtkYXRhVHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIC8vIH1cbiAgfVxuICBjbGVhckFjdGl2ZVRleHR1cmVzKCk6IHZvaWQge1xuICAgIHRoaXMuZ2xDb250ZXh0LmNsZWFyQWN0aXZlVGV4dHVyZXMoKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IE9wU2V0LCByZXNvbHZlT3BlcmF0b3IgfSBmcm9tICcuLi8uLi9vcHNldCc7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgV2ViR0xCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJnbCc7XG5cbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgV0VCR0xfT1BfUkVTT0xWRV9SVUxFUyB9IGZyb20gJy4vb3AtcmVzb2x2ZS1ydWxlcyc7XG5pbXBvcnQgeyBQcm9ncmFtTWFuYWdlciB9IGZyb20gJy4vcHJvZ3JhbS1tYW5hZ2VyJztcbmltcG9ydCB7IFByZWZlckxvZ2ljYWxTdHJhdGVneSwgVGV4dHVyZUxheW91dFN0cmF0ZWd5IH0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQgeyBUZXh0dXJlTWFuYWdlciB9IGZyb20gJy4vdGV4dHVyZS1tYW5hZ2VyJztcbmltcG9ydCB7IFRleHR1cmVEYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFNlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgU2Vzc2lvbkhhbmRsZXIge1xuICBwcm9ncmFtTWFuYWdlcjogUHJvZ3JhbU1hbmFnZXI7XG4gIHRleHR1cmVNYW5hZ2VyOiBUZXh0dXJlTWFuYWdlcjtcbiAgbGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneTtcbiAgcGFja2VkVGV4dHVyZURhdGFDYWNoZTogTWFwPFRlbnNvci5JZCwgVGV4dHVyZURhdGE+O1xuICB1bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU6IE1hcDxUZW5zb3IuSWQsIFRleHR1cmVEYXRhPjtcbiAgcGFjazJ1bnBhY2tNYXA6IE1hcDxUZW5zb3IuSWQsIFRlbnNvci5JZD47XG4gIHVucGFjazJwYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICBpbml0aWFsaXplcnM6IFNldDxUZW5zb3IuSWQ+O1xuICBwYWNrPzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgYmFja2VuZDogV2ViR0xCYWNrZW5kLFxuICAgIHB1YmxpYyByZWFkb25seSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQsXG4gICkge1xuICAgIHRoaXMubGF5b3V0U3RyYXRlZ3kgPSBuZXcgUHJlZmVyTG9naWNhbFN0cmF0ZWd5KGJhY2tlbmQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlciwgYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3kpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3ksIHRoaXMuY29udGV4dC5wcm9maWxlciwge1xuICAgICAgcmV1c2VUZXh0dXJlczogYmFja2VuZC50ZXh0dXJlQ2FjaGVNb2RlID09PSAnZnVsbCcsXG4gICAgfSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGFjayA9IGJhY2tlbmQucGFjaztcbiAgICB0aGlzLnBhY2sydW5wYWNrTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrMnBhY2tNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBjcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCkge1xuICAgIHJldHVybiBuZXcgV2ViR0xJbmZlcmVuY2VIYW5kbGVyKHRoaXMpO1xuICB9XG4gIG9uR3JhcGhJbml0aWFsaXplZChncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBncmFwaFxuICAgICAgLmdldFZhbHVlcygpXG4gICAgICAuZmlsdGVyKCh2KSA9PiB2LmZyb20gPT09IC0xICYmIHYudGVuc29yKVxuICAgICAgLm1hcCgodikgPT4gdi50ZW5zb3IhLmRhdGFJZCk7XG4gICAgdGhpcy5pbml0aWFsaXplcnMgPSBuZXcgU2V0KGluaXRpYWxpemVycyk7XG4gIH1cbiAgaXNJbml0aWFsaXplcih0ZW5zb3JJZDogVGVuc29yLklkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXJzID8gdGhpcy5pbml0aWFsaXplcnMuaGFzKHRlbnNvcklkKSA6IGZhbHNlO1xuICB9XG4gIGFkZEluaXRpYWxpemVyKHRlbnNvcklkOiBUZW5zb3IuSWQpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRpYWxpemVycy5hZGQodGVuc29ySWQpO1xuICB9XG4gIGdldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIGlzUGFja2VkOiBib29sZWFuKTogVGV4dHVyZURhdGEgfCB1bmRlZmluZWQge1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKTtcbiAgICB9XG4gIH1cbiAgc2V0VGV4dHVyZURhdGEodGVuc29ySWQ6IFRlbnNvci5JZCwgdGV4dHVyZURhdGE6IFRleHR1cmVEYXRhLCBpc1BhY2tlZCA9IGZhbHNlKTogdm9pZCB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ1dlYkdMU2Vzc2lvbkhhbmRsZXInLCAnU3RvcmluZyBUZXh0dXJlIGRhdGEgaW4gY2FjaGUnKTtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQodGVuc29ySWQsIHRleHR1cmVEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KHRlbnNvcklkLCB0ZXh0dXJlRGF0YSk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlci5kaXNwb3NlKCk7XG4gICAgdGhpcy50ZXh0dXJlTWFuYWdlci5jbGVhckFjdGl2ZVRleHR1cmVzKCk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHRkKSA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHRkKSA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yIHtcbiAgICBjb25zdCBvcCA9IHJlc29sdmVPcGVyYXRvcihub2RlLCBvcHNldHMsIFdFQkdMX09QX1JFU09MVkVfUlVMRVMpO1xuICAgIHJldHVybiB7IGltcGw6IG9wLm9wSW1wbCwgY29udGV4dDogb3Aub3BJbml0ID8gb3Aub3BJbml0KG5vZGUsIGdyYXBoKSA6IG5vZGUgfTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgKiBhcyBEYXRhRW5jb2RlcnMgZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQgeyBEYXRhRW5jb2RlciwgRW5jb2RlciwgRW5jb2RlclVzYWdlIH0gZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQgeyByZXBlYXRlZFRyeSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZlbmNlQ29udGV4dCB7XG4gIHF1ZXJ5OiBXZWJHTFN5bmMgfCBudWxsO1xuICBpc0ZlbmNlUGFzc2VkKCk6IGJvb2xlYW47XG59XG5cbnR5cGUgUG9sbEl0ZW0gPSB7XG4gIGlzRG9uZUZuOiAoKSA9PiBib29sZWFuO1xuICByZXNvbHZlRm46ICgpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyU2VhcmNoTGFzdFRydWUoYXJyOiBBcnJheTwoKSA9PiBib29sZWFuPik6IG51bWJlciB7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpc0RvbmUgPSBhcnJbaV0oKTtcbiAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBhbmQgd3JhcHBlciBhcm91bmQgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGFuZCBpdHMgb3BlcmF0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgV2ViR0xDb250ZXh0IHtcbiAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgdmVyc2lvbjogMSB8IDI7XG5cbiAgcHJpdmF0ZSB2ZXJ0ZXhidWZmZXI6IFdlYkdMQnVmZmVyO1xuICBwcml2YXRlIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuXG4gIC8vIFdlYkdMIGZsYWdzIGFuZCB2aXRhbCBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjogYm9vbGVhbjtcbiAgaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ6IGJvb2xlYW47XG4gIGlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZDogYm9vbGVhbjtcbiAgaXNCbGVuZFN1cHBvcnRlZDogYm9vbGVhbjtcbiAgbWF4VGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4VGV4dHVyZUltYWdlVW5pdHM6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDdWJlTWFwVGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uOiBzdHJpbmc7XG4gIC8vIHByaXZhdGUgd2ViZ2xWZW5kb3I6IHN0cmluZztcbiAgLy8gcHJpdmF0ZSB3ZWJnbFZlcnNpb246IHN0cmluZztcblxuICAvLyBXZWJHTDIgZmxhZ3MgYW5kIHZpdGFsIHBhcmFtZXRlcnNcbiAgLy8gcHJpdmF0ZSBtYXgzRFRleHR1cmVTaXplOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4QXJyYXlUZXh0dXJlTGF5ZXJzOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4Q29sb3JBdHRhY2htZW50czogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heERyYXdCdWZmZXJzOiBudW1iZXI7XG5cbiAgLy8gV2ViR0wgZXh0ZW5zaW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVGbG9hdEV4dGVuc2lvbjogT0VTX3RleHR1cmVfZmxvYXQgfCBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb246IE9FU190ZXh0dXJlX2hhbGZfZmxvYXQgfCBudWxsO1xuXG4gIC8vIFdlYkdMMiBleHRlbnNpb25zXG4gIGNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb246IHVua25vd24gfCBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIGRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjogeyBUSU1FX0VMQVBTRURfRVhUOiBHTGVudW07IEdQVV9ESVNKT0lOVF9FWFQ6IEdMZW51bSB9IHwgbnVsbDtcblxuICBwcml2YXRlIGRpc3Bvc2VkOiBib29sZWFuO1xuICBwcml2YXRlIGZyYW1lQnVmZmVyQm91bmQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB2ZXJzaW9uOiAxIHwgMikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgdGhpcy52ZXJ0ZXhidWZmZXIgPSB0aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSB0aGlzLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5xdWVyeVZpdGFsUGFyYW1ldGVycygpO1xuICB9XG5cbiAgYWxsb2NhdGVUZXh0dXJlKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBlbmNvZGVyOiBEYXRhRW5jb2RlciwgZGF0YT86IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIGNyZWF0ZSB0aGUgdGV4dHVyZVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgLy8gYmluZCB0aGUgdGV4dHVyZSBzbyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgZWZmZWN0IHRoaXMgdGV4dHVyZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGRhdGEgPyBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCkgOiBudWxsO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCwgLy8gTGV2ZWwgb2YgZGV0YWlsLlxuICAgICAgZW5jb2Rlci5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgMCwgLy8gQWx3YXlzIDAgaW4gT3BlbkdMIEVTLlxuICAgICAgZW5jb2Rlci5mb3JtYXQsXG4gICAgICBlbmNvZGVyLnRleHR1cmVUeXBlLFxuICAgICAgYnVmZmVyLFxuICAgICk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgcmV0dXJuIHRleHR1cmUgYXMgV2ViR0xUZXh0dXJlO1xuICB9XG4gIHVwZGF0ZVRleHR1cmUoXG4gICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgZW5jb2RlcjogRGF0YUVuY29kZXIsXG4gICAgZGF0YTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUoZGF0YSwgd2lkdGggKiBoZWlnaHQpO1xuICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCwgLy8gbGV2ZWxcbiAgICAgIDAsIC8vIHhvZmZzZXRcbiAgICAgIDAsIC8vIHlvZmZzZXRcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZW5jb2Rlci5mb3JtYXQsXG4gICAgICBlbmNvZGVyLnRleHR1cmVUeXBlLFxuICAgICAgYnVmZmVyLFxuICAgICk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgYXR0YWNoRnJhbWVidWZmZXIodGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAvLyBNYWtlIGl0IHRoZSB0YXJnZXQgZm9yIGZyYW1lYnVmZmVyIG9wZXJhdGlvbnMgLSBpbmNsdWRpbmcgcmVuZGVyaW5nLlxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTsgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHJlYWRUZXh0dXJlKFxuICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIGRhdGFTaXplOiBudW1iZXIsXG4gICAgZGF0YVR5cGU6IEVuY29kZXIuRGF0YVR5cGUsXG4gICAgY2hhbm5lbHM6IG51bWJlcixcbiAgKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZnJhbWVCdWZmZXJCb3VuZCkge1xuICAgICAgdGhpcy5hdHRhY2hGcmFtZWJ1ZmZlcih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihkYXRhVHlwZSwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuYWxsb2NhdGUod2lkdGggKiBoZWlnaHQpO1xuICAgIC8vIGJpbmQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7IC8vIDAsIHdlIGFyZW4ndCB1c2luZyBNSVBNQVBzXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgZnJhbWVidWZmZXIgaXMgcmVhZHlcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGVuY29kZXIudGV4dHVyZVR5cGUsIGJ1ZmZlcik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgLy8gdW5iaW5kIEZCXG4gICAgcmV0dXJuIGVuY29kZXIuZGVjb2RlKGJ1ZmZlciwgZGF0YVNpemUpO1xuICB9XG5cbiAgaXNGcmFtZWJ1ZmZlclJlYWR5KCk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudCBsb2dpYyB0byBjaGVjayBpZiB0aGUgZnJhbWVidWZmZXIgaXMgcmVhZHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRBY3RpdmVUZXh0dXJlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IG4gPSBnbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5BQ1RJVkVfVEVYVFVSRSk7XG4gICAgcmV0dXJuIGBURVhUVVJFJHtuIC0gZ2wuVEVYVFVSRTB9YDtcbiAgfVxuICBnZXRUZXh0dXJlQmluZGluZygpOiBXZWJHTFRleHR1cmUge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLlRFWFRVUkVfQklORElOR18yRCk7XG4gIH1cbiAgZ2V0RnJhbWVidWZmZXJCaW5kaW5nKCk6IFdlYkdMRnJhbWVidWZmZXIge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLkZSQU1FQlVGRkVSX0JJTkRJTkcpO1xuICB9XG4gIHNldFZlcnRleEF0dHJpYnV0ZXMocG9zaXRpb25IYW5kbGU6IG51bWJlciwgdGV4dHVyZUNvb3JkSGFuZGxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkhhbmRsZSwgMywgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25IYW5kbGUpO1xuICAgIGlmICh0ZXh0dXJlQ29vcmRIYW5kbGUgIT09IC0xKSB7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleHR1cmVDb29yZEhhbmRsZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMTIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4dHVyZUNvb3JkSGFuZGxlKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLCBmcmFnU2hhZGVyOiBXZWJHTFNoYWRlcik6IFdlYkdMUHJvZ3JhbSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCkhO1xuXG4gICAgLy8gdGhlIHByb2dyYW0gY29uc2lzdHMgb2Ygb3VyIHNoYWRlcnNcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgY29tcGlsZVNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZywgc2hhZGVyVHlwZTogbnVtYmVyKTogV2ViR0xTaGFkZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY3JlYXRlU2hhZGVyKCkgcmV0dXJuZWQgbnVsbCB3aXRoIHR5cGUgJHtzaGFkZXJUeXBlfWApO1xuICAgIH1cblxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb21waWxlIHNoYWRlcjogJHtnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcil9XG5TaGFkZXIgc291cmNlOlxuJHtzaGFkZXJTb3VyY2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cbiAgZGVsZXRlU2hhZGVyKHNoYWRlcjogV2ViR0xTaGFkZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICB9XG4gIGJpbmRUZXh0dXJlVG9Vbmlmb3JtKHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcG9zaXRpb246IG51bWJlciwgdW5pZm9ybUhhbmRsZTogV2ViR0xVbmlmb3JtTG9jYXRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHBvc2l0aW9uKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC51bmlmb3JtMWkodW5pZm9ybUhhbmRsZSwgcG9zaXRpb24pO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGRyYXcoKTogdm9pZCB7XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGNoZWNrRXJyb3IoKTogdm9pZCB7XG4gICAgaWYgKGVudi5kZWJ1Zykge1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgY29uc3QgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xuICAgICAgbGV0IGxhYmVsID0gJyc7XG4gICAgICBzd2l0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhc2UgZ2wuTk9fRVJST1I6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRU5VTTpcbiAgICAgICAgICBsYWJlbCA9ICdJTlZBTElEX0VOVU0nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfVkFMVUU6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9PUEVSQVRJT046XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBnbC5PVVRfT0ZfTUVNT1JZOlxuICAgICAgICAgIGxhYmVsID0gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLkNPTlRFWFRfTE9TVF9XRUJHTDpcbiAgICAgICAgICBsYWJlbCA9ICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxhYmVsID0gYFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZXJyb3IudG9TdHJpbmcoMTYpfWA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwpO1xuICAgIH1cbiAgfVxuICBkZWxldGVUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgfVxuICBkZWxldGVQcm9ncmFtKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgfVxuICBnZXRFbmNvZGVyKGRhdGFUeXBlOiBFbmNvZGVyLkRhdGFUeXBlLCBjaGFubmVsczogbnVtYmVyLCB1c2FnZTogRW5jb2RlclVzYWdlID0gRW5jb2RlclVzYWdlLkRlZmF1bHQpOiBEYXRhRW5jb2RlciB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhRW5jb2RlcnMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgaWYgKHVzYWdlID09PSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSB8fCB0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SR0JBRmxvYXREYXRhRW5jb2RlcihcbiAgICAgICAgICAgIHRoaXMuZ2wsXG4gICAgICAgICAgICBjaGFubmVscyxcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiEuSEFMRl9GTE9BVF9PRVMsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgIGNhc2UgJ2J5dGUnOlxuICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5VaW50OERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJBY3RpdmVUZXh0dXJlcygpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCB0aGlzLm1heFRleHR1cmVJbWFnZVVuaXRzOyArK3VuaXQpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmZpbmlzaCgpO1xuICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTogRmxvYXQzMkFycmF5IHtcbiAgICAvLyBTZXRzIG9mIHgseSx6KD0wKSxzLHQgY29vcmRpbmF0ZXMuXG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgLTEuMCxcbiAgICAgIDEuMCxcbiAgICAgIDAuMCxcbiAgICAgIDAuMCxcbiAgICAgIDEuMCwgLy8gdXBwZXIgbGVmdFxuICAgICAgLTEuMCxcbiAgICAgIC0xLjAsXG4gICAgICAwLjAsXG4gICAgICAwLjAsXG4gICAgICAwLjAsIC8vIGxvd2VyIGxlZnRcbiAgICAgIDEuMCxcbiAgICAgIDEuMCxcbiAgICAgIDAuMCxcbiAgICAgIDEuMCxcbiAgICAgIDEuMCwgLy8gdXBwZXIgcmlnaHRcbiAgICAgIDEuMCxcbiAgICAgIC0xLjAsXG4gICAgICAwLjAsXG4gICAgICAxLjAsXG4gICAgICAwLjAsIC8vIGxvd2VyIHJpZ2h0XG4gICAgXSk7XG4gIH1cbiAgcHJpdmF0ZSBjcmVhdGVWZXJ0ZXhidWZmZXIoKTogV2ViR0xCdWZmZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCdWZmZXIoKSByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHByaXZhdGUgY3JlYXRlRnJhbWVidWZmZXIoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG4gICAgY29uc3QgZmIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgaWYgKCFmYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVGcmFtZWJ1ZmZlciByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBmYjtcbiAgfVxuXG4gIHByaXZhdGUgcXVlcnlWaXRhbFBhcmFtZXRlcnMoKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyID0gdGhpcy5jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk7XG4gICAgdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrUmVuZGVyRmxvYXQzMigpO1xuICAgIHRoaXMuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCk7XG5cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxICYmICF0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gJiYgIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuaXNCbGVuZFN1cHBvcnRlZCA9ICF0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCB8fCB0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCk7XG5cbiAgICAvLyB0aGlzLm1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgdGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0cyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgLy8gdGhpcy5tYXhDdWJlTWFwVGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSk7XG4gICAgLy8gdGhpcy5zaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTik7XG4gICAgLy8gdGhpcy53ZWJnbFZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihnbC5WRU5ET1IpO1xuICAgIC8vIHRoaXMud2ViZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgLy8gdGhpcy5tYXgzRFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUFYXzNEX1RFWFRVUkVfU0laRSk7XG4gICAgICAvLyB0aGlzLm1heEFycmF5VGV4dHVyZUxheWVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyk7XG4gICAgICAvLyB0aGlzLm1heENvbG9yQXR0YWNobWVudHMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfQ09MT1JfQVRUQUNITUVOVFMpO1xuICAgICAgLy8gdGhpcy5tYXhEcmF3QnVmZmVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGdldEV4dGVuc2lvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPSB0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk6IGJvb2xlYW4ge1xuICAgIC8vIHRlc3Qgd2hldGhlciBGbG9hdDMyIHRleHR1cmUgaXMgc3VwcG9ydGVkOlxuICAgIC8vIFNURVAuMSBjcmVhdGUgYSBmbG9hdCB0ZXh0dXJlXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gdGhpcy52ZXJzaW9uID09PSAyID8gKGdsIGFzIHVua25vd24gYXMgeyBSR0JBMzJGOiBudW1iZXIgfSkuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIC8vIFNURVAuMiBiaW5kIGEgZnJhbWUgYnVmZmVyXG4gICAgY29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIC8vIFNURVAuMyBhdHRhY2ggdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgLy8gU1RFUC40IHRlc3Qgd2hldGhlciBmcmFtZWJ1ZmZlciBpcyBjb21wbGV0ZVxuICAgIGNvbnN0IGlzQ29tcGxldGUgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICByZXR1cm4gaXNDb21wbGV0ZTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tSZW5kZXJGbG9hdDMyKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGlmICghdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXI7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRmxvYXQzMkRvd25sb2FkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGlmICghdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBHTF9CTEVORCBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIHByaXZhdGUgY2hlY2tGbG9hdDMyQmxlbmQoKTogYm9vbGVhbiB7XG4gICAgLy8gaXQgbG9va3MgbGlrZSBjdXJyZW50bHkgKDIwMTktMDUtMDgpIHRoZXJlIGlzIG5vIGVhc3kgd2F5IHRvIGRldGVjdCB3aGV0aGVyIEJMRU5EIGlzIHN1cHBvcnRlZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueGpzL2lzc3Vlcy8xNDVcblxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGxldCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGxldCBmcmFtZUJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGxldCBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGxldCBwcm9ncmFtOiBXZWJHTFByb2dyYW0gfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLnZlcnNpb24gPT09IDIgPyAoZ2wgYXMgdW5rbm93biBhcyB7IFJHQkEzMkY6IG51bWJlciB9KS5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICBpZiAoIXZlcnRleFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCAndm9pZCBtYWluKCl7fScpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKCFmcmFnbWVudFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXZlYzQoMC41KTt9Jyk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcbiAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIGlmIChwcm9ncmFtKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICBpZiAodmVydGV4U2hhZGVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdtZW50U2hhZGVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVCdWZmZXIpIHtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmVnaW5UaW1lcigpOiBXZWJHTFF1ZXJ5IHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcblxuICAgICAgY29uc3QgcXVlcnkgPSBnbDIuY3JlYXRlUXVlcnkoKSBhcyBXZWJHTFF1ZXJ5O1xuICAgICAgZ2wyLmJlZ2luUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgZW5kVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMiAmJiB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgY29uc3QgZXh0ID0gdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247XG4gICAgICBnbDIuZW5kUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGlzVGltZXJSZXN1bHRBdmFpbGFibGUocXVlcnk6IFdlYkdMUXVlcnkpOiBib29sZWFuIHtcbiAgICBsZXQgYXZhaWxhYmxlID0gZmFsc2UsXG4gICAgICBkaXNqb2ludCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIgJiYgdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IGdsMiA9IHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO1xuXG4gICAgICBhdmFpbGFibGUgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtcbiAgICAgIGRpc2pvaW50ID0gZ2wyLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkZCB3ZWJnbCAxIGhhbmRsaW5nLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhZGlzam9pbnQ7XG4gIH1cblxuICBnZXRUaW1lclJlc3VsdChxdWVyeTogV2ViR0xRdWVyeSk6IG51bWJlciB7XG4gICAgbGV0IHRpbWVFbGFwc2VkID0gMDtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICB0aW1lRWxhcHNlZCA9IGdsMi5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgZ2wyLlFVRVJZX1JFU1VMVCk7XG4gICAgICBnbDIuZGVsZXRlUXVlcnkocXVlcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gbWlsaXNlY29uZHNcbiAgICByZXR1cm4gdGltZUVsYXBzZWQgLyAxMDAwMDAwO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvclF1ZXJ5QW5kR2V0VGltZShxdWVyeTogV2ViR0xRdWVyeSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgYXdhaXQgcmVwZWF0ZWRUcnkoKCkgPT4gdGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHF1ZXJ5KSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGltZXJSZXN1bHQocXVlcnkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmZW5jZUNvbnRleHQgPSB0aGlzLmNyZWF0ZUZlbmNlKHRoaXMuZ2wpO1xuICAgIHJldHVybiB0aGlzLnBvbGxGZW5jZShmZW5jZUNvbnRleHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVGZW5jZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogRmVuY2VDb250ZXh0IHtcbiAgICBsZXQgaXNGZW5jZVBhc3NlZDogKCkgPT4gYm9vbGVhbjtcbiAgICBjb25zdCBnbDIgPSBnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIGNvbnN0IHF1ZXJ5ID0gZ2wyLmZlbmNlU3luYyhnbDIuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsIDApO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgaWYgKHF1ZXJ5ID09PSBudWxsKSB7XG4gICAgICBpc0ZlbmNlUGFzc2VkID0gKCkgPT4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNGZW5jZVBhc3NlZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZ2wyLmNsaWVudFdhaXRTeW5jKHF1ZXJ5LCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gZ2wyLkFMUkVBRFlfU0lHTkFMRUQgfHwgc3RhdHVzID09PSBnbDIuQ09ORElUSU9OX1NBVElTRklFRDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5LCBpc0ZlbmNlUGFzc2VkIH07XG4gIH1cblxuICBhc3luYyBwb2xsRmVuY2UoZmVuY2VDb250ZXh0OiBGZW5jZUNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgIHZvaWQgdGhpcy5hZGRJdGVtVG9Qb2xsKFxuICAgICAgICAoKSA9PiBmZW5jZUNvbnRleHQuaXNGZW5jZVBhc3NlZCgpLFxuICAgICAgICAoKSA9PiByZXNvbHZlKCksXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpdGVtc1RvUG9sbDogUG9sbEl0ZW1bXSA9IFtdO1xuXG4gIHBvbGxJdGVtcygpOiB2b2lkIHtcbiAgICAvLyBGaW5kIHRoZSBsYXN0IHF1ZXJ5IHRoYXQgaGFzIGZpbmlzaGVkLlxuICAgIGNvbnN0IGluZGV4ID0gbGluZWFyU2VhcmNoTGFzdFRydWUodGhpcy5pdGVtc1RvUG9sbC5tYXAoKHgpID0+IHguaXNEb25lRm4pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbmRleDsgKytpKSB7XG4gICAgICBjb25zdCB7IHJlc29sdmVGbiB9ID0gdGhpcy5pdGVtc1RvUG9sbFtpXTtcbiAgICAgIHJlc29sdmVGbigpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zVG9Qb2xsID0gdGhpcy5pdGVtc1RvUG9sbC5zbGljZShpbmRleCArIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhZGRJdGVtVG9Qb2xsKGlzRG9uZUZuOiAoKSA9PiBib29sZWFuLCByZXNvbHZlRm46ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLml0ZW1zVG9Qb2xsLnB1c2goeyBpc0RvbmVGbiwgcmVzb2x2ZUZuIH0pO1xuICAgIGlmICh0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhIHJ1bm5pbmcgbG9vcCB0aGF0IHBvbGxzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBsb29wIHRoYXQgcG9sbHMuXG4gICAgYXdhaXQgcmVwZWF0ZWRUcnkoKCkgPT4ge1xuICAgICAgdGhpcy5wb2xsSXRlbXMoKTtcbiAgICAgIC8vIEVuZCB0aGUgbG9vcCBpZiBubyBtb3JlIGl0ZW1zIHRvIHBvbGwuXG4gICAgICByZXR1cm4gdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGggPT09IDA7XG4gICAgfSk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmNvbnN0IGNhY2hlOiB7IFtjb250ZXh0SWQ6IHN0cmluZ106IFdlYkdMQ29udGV4dCB9ID0ge307XG5cbi8qKlxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZXMgcHJvcGVyIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBiYXNlZCBvblxuICogdGhlIGN1cnJlbnQgYnJvd3NlcnMgY2FwYWJpbGl0aWVzXG4gKiBUaGUgb3JkZXIgaXMgZnJvbSBoaWdoZXIvbW9zdCByZWNlbnQgdmVyc2lvbnMgdG8gbW9zdCBiYXNpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGNvbnRleHRJZD86ICd3ZWJnbCcgfCAnd2ViZ2wyJyk6IFdlYkdMQ29udGV4dCB7XG4gIGxldCBjb250ZXh0OiBXZWJHTENvbnRleHQgfCB1bmRlZmluZWQ7XG4gIGlmICgoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbDInKSAmJiAnd2ViZ2wyJyBpbiBjYWNoZSkge1xuICAgIGNvbnRleHQgPSBjYWNoZS53ZWJnbDI7XG4gIH0gZWxzZSBpZiAoKCFjb250ZXh0SWQgfHwgY29udGV4dElkID09PSAnd2ViZ2wnKSAmJiAnd2ViZ2wnIGluIGNhY2hlKSB7XG4gICAgY29udGV4dCA9IGNhY2hlLndlYmdsO1xuICB9XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHRyeSB0byBjcmVhdGUgd2ViZ2wgY29udGV4dCBmcm9tIGFuIG9mZnNjcmVlbiBjYW52YXNcbiAgICAgIGNvbnN0IG9mZnNjcmVlbkNhbnZhcyA9IGNyZWF0ZU9mZnNjcmVlbkNhbnZhcygpO1xuICAgICAgY29udGV4dCA9IGNyZWF0ZU5ld1dlYkdMQ29udGV4dChvZmZzY3JlZW5DYW52YXMsIGNvbnRleHRJZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgZmFpbGVkLCBmYWxsYmFjayB0byB0cnkgdG8gdXNlIGEgbm9ybWFsIGNhbnZhcyBlbGVtZW50XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnRleHQgPSBjcmVhdGVOZXdXZWJHTENvbnRleHQoY2FudmFzLCBjb250ZXh0SWQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHRJZCA9IGNvbnRleHRJZCB8fCBjb250ZXh0LnZlcnNpb24gPT09IDEgPyAnd2ViZ2wnIDogJ3dlYmdsMic7XG4gIGNvbnN0IGdsID0gY29udGV4dC5nbDtcblxuICBjYWNoZVtjb250ZXh0SWRdID0gY29udGV4dDtcblxuICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgZGVsZXRlIGNhY2hlW2NvbnRleHRJZF07XG4gICAgcmV0dXJuIGNyZWF0ZVdlYkdMQ29udGV4dChjb250ZXh0SWQpO1xuICB9XG5cbiAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgZ2wuZGlzYWJsZShnbC5ESVRIRVIpO1xuICBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSk7XG4gIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdXZWJHTENvbnRleHQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgY29udGV4dElkPzogJ3dlYmdsJyB8ICd3ZWJnbDInKTogV2ViR0xDb250ZXh0IHtcbiAgY29uc3QgY29udGV4dEF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYWxwaGE6IGZhbHNlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgfTtcbiAgbGV0IGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBudWxsO1xuICBjb25zdCBjYSA9IGNvbnRleHRBdHRyaWJ1dGVzO1xuICBpZiAoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbDInKSB7XG4gICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgY2EpO1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKCdHbENvbnRleHRGYWN0b3J5JywgYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbCcpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNhKSB8fCAoY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNhKSBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQpO1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICdHbENvbnRleHRGYWN0b3J5JyxcbiAgICAgICAgICBgZmFpbGVkIHRvIGNyZWF0ZSBXZWJHTENvbnRleHQgdXNpbmcgY29udGV4dElkICd3ZWJnbCcgb3IgJ2V4cGVyaW1lbnRhbC13ZWJnbCcuIEVycm9yOiAke2Vycn1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV2ViR0wgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5kZWNsYXJlIGxldCBPZmZzY3JlZW5DYW52YXM6IHsgbmV3ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IEhUTUxDYW52YXNFbGVtZW50IH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmFpbGVkIHRvIGNyZWF0ZSBjYW52YXM6IGRvY3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPZmZzY3JlZW5DYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYWlsZWQgdG8gY3JlYXRlIG9mZnNjcmVlbiBjYW52YXM6IE9mZnNjcmVlbkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IEJhY2tlbmQsIFNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9pbnN0cnVtZW50JztcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICcuLi9zZXNzaW9uJztcblxuaW1wb3J0IHsgV2ViR0xTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4vd2ViZ2wvc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5pbXBvcnQgeyBjcmVhdGVXZWJHTENvbnRleHQgfSBmcm9tICcuL3dlYmdsL3dlYmdsLWNvbnRleHQtZmFjdG9yeSc7XG5cbi8qKlxuICogV2ViR0xCYWNrZW5kIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYWxsIFdlYkdMIG9wZWFydGlvbnNcbiAqIFdoZW4gaXQgc3RhcnRzIGl0IGNyZWF0ZWQgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogYW5kIG90aGVyIG1haW4gZnJhbWV3b3JrIGNvbXBvbmVudHMgc3VjaCBhcyBQcm9ncmFtIGFuZCBUZXh0dXJlIE1hbmFnZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTEJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQ7XG5cbiAgZ2V0IGNvbnRleHRJZCgpOiAnd2ViZ2wnIHwgJ3dlYmdsMicgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuY29udGV4dElkO1xuICB9XG4gIHNldCBjb250ZXh0SWQodmFsdWU6ICd3ZWJnbCcgfCAnd2ViZ2wyJyB8IHVuZGVmaW5lZCkge1xuICAgIGVudi53ZWJnbC5jb250ZXh0SWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBtYXRtdWxNYXhCYXRjaFNpemUoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZTtcbiAgfVxuICBzZXQgbWF0bXVsTWF4QmF0Y2hTaXplKHZhbHVlOiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplID0gdmFsdWU7XG4gIH1cblxuICBnZXQgdGV4dHVyZUNhY2hlTW9kZSgpOiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlO1xuICB9XG4gIHNldCB0ZXh0dXJlQ2FjaGVNb2RlKHZhbHVlOiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJyB8IHVuZGVmaW5lZCkge1xuICAgIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcGFjaygpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLnBhY2s7XG4gIH1cbiAgc2V0IHBhY2sodmFsdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wucGFjayA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGFzeW5jKCk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuYXN5bmM7XG4gIH1cbiAgc2V0IGFzeW5jKHZhbHVlOiBib29sZWFuIHwgdW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmFzeW5jID0gdmFsdWU7XG4gIH1cblxuICBpbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdsQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dCh0aGlzLmNvbnRleHRJZCk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZSA9IDE2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlTW9kZSA9ICdmdWxsJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWNrICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5wYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXN5bmMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci5zZXRXaXRoRW52KGVudik7XG5cbiAgICAgIGlmICghZW52LndlYmdsLmNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudi53ZWJnbCwgJ2NvbnRleHQnLCB7IHZhbHVlOiB0aGlzLmdsQ29udGV4dC5nbCB9KTtcbiAgICAgIH1cblxuICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICdXZWJHTEJhY2tlbmQnLFxuICAgICAgICBgQ3JlYXRlZCBXZWJHTENvbnRleHQ6ICR7dHlwZW9mIHRoaXMuZ2xDb250ZXh0fSB3aXRoIG1hdG11bE1heEJhdGNoU2l6ZTogJHtcbiAgICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZVxuICAgICAgICB9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnV2ViR0xCYWNrZW5kJywgYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHtlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpOiBTZXNzaW9uSGFuZGxlciB7XG4gICAgcmV0dXJuIG5ldyBXZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsIGNvbnRleHQpO1xuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFdlYkdMQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZHMvYmFja2VuZC13ZWJnbCc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPcFNldCB9IGZyb20gJy4vb3BzZXQnO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlSGFuZGxlciB7XG4gIC8qKlxuICAgKiBkaXNwb3NlIHRoZSBpbmZlcmVuY2UgaGFuZGxlci4gaXQgd2lsbCBiZSBjYWxsZWQgYXMgdGhlIGxhc3Qgc3RlcCBpbiBTZXNzaW9uLnJ1bigpXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICAvKipcbiAgICogdHJhbnNmb3JtIHRoZSBncmFwaCBhdCBpbml0aWFsaXphdGlvbiB0aW1lXG4gICAqIEBwYXJhbSBncmFwaFRyYW5zZm9ybWVyIHRoZSBncmFwaCB0cmFuc2Zvcm1lciB0byBtYW5pcHVsYXRlIHRoZSBtb2RlbCBncmFwaFxuICAgKi9cbiAgdHJhbnNmb3JtR3JhcGg/KGdyYXBoVHJhbnNmb3JtZXI6IEdyYXBoLlRyYW5zZm9ybWVyKTogdm9pZDtcblxuICAvKipcbiAgICogY3JlYXRlIGFuIGluc3RhbmNlIG9mIEluZmVyZW5jZUhhbmRsZXIgdG8gdXNlIGluIGEgU2Vzc2lvbi5ydW4oKSBjYWxsXG4gICAqL1xuICBjcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCk6IEluZmVyZW5jZUhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIHNlc3Npb24gaGFuZGxlci4gaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHNlc3Npb24gaXMgYmVpbmcgZGlzcG9zZWQgZXhwbGljaXRseVxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb3BlcmF0b3IgZnJvbSB0aGUgbmFtZSBhbmQgb3BzZXQgdmVyc2lvbjsgYmFja2VuZCBzcGVjaWZpY1xuICAgKiBAcGFyYW0gbm9kZSB0aGUgbm9kZSB0byByZXNvbHZlXG4gICAqIEBwYXJhbSBvcHNldHMgYSBsaXN0IG9mIG9wc2V0cyB0aGF0IGV4cG9ydGVkIGZyb20gdGhlIG1vZGVsXG4gICAqIEBwYXJhbSBncmFwaCB0aGUgY29tcGxldGVseSBpbml0aWFsaXplZCBncmFwaFxuICAgKi9cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBsZXQncyB0aGUgc2Vzc2lvbkhhbmRsZXIga25vdyB0aGF0IHRoZSBncmFwaCBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZVxuICAgKiBAcGFyYW0gZ3JhcGggdGhlIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQgZ3JhcGhcbiAgICovXG4gIG9uR3JhcGhJbml0aWFsaXplZD8oZ3JhcGg6IEdyYXBoKTogdm9pZDtcblxuICAvKipcbiAgICogYSByZWZlcmVuY2UgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYmFja2VuZFxuICAgKi9cbiAgcmVhZG9ubHkgYmFja2VuZDogQmFja2VuZDtcblxuICAvKipcbiAgICogYSByZWZlcmVuY2UgdG8gdGhlIHNlc3Npb24gY29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dDogU2Vzc2lvbi5Db250ZXh0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmQge1xuICAvKipcbiAgICogaW5pdGlhbGl6ZSB0aGUgYmFja2VuZC4gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLCB3aGVuIHRoZSBmaXJzdCB0aW1lIHRoZVxuICAgKiBiYWNrZW5kIGl0IHRvIGJlIHVzZWRcbiAgICovXG4gIGluaXRpYWxpemUoKTogYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBTZXNzaW9uSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uIG9iamVjdCdzIGxpZmVjeWNsZVxuICAgKi9cbiAgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoY29udGV4dDogU2Vzc2lvbi5Db250ZXh0KTogU2Vzc2lvbkhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGJhY2tlbmQuIGN1cnJlbnRseSB0aGlzIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG4vLyBjYWNoZXMgYWxsIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2VzXG5jb25zdCBiYWNrZW5kc0NhY2hlOiBNYXA8c3RyaW5nLCBCYWNrZW5kPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IGJhY2tlbmQ6IHsgW25hbWU6IHN0cmluZ106IEJhY2tlbmQgfSA9IHtcbiAgd2ViZ2w6IG5ldyBXZWJHTEJhY2tlbmQoKSxcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlZmVyZW5jZSB0byB0aGUgYmFja2VuZC4gSWYgYSBoaW50IGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGJhY2tlbmQgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJhY2tlbmQoaGludD86IHN0cmluZyB8IHJlYWRvbmx5IHN0cmluZ1tdKTogUHJvbWlzZTxCYWNrZW5kPiB7XG4gIGlmICghaGludCkge1xuICAgIHJldHVybiByZXNvbHZlQmFja2VuZChbJ3dlYmdsJ10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhpbnRzID0gdHlwZW9mIGhpbnQgPT09ICdzdHJpbmcnID8gW2hpbnRdIDogaGludDtcblxuICAgIGZvciAoY29uc3QgYmFja2VuZEhpbnQgb2YgaGludHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gYmFja2VuZHNDYWNoZS5nZXQoYmFja2VuZEhpbnQpO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFja2VuZCA9IGF3YWl0IHRyeUxvYWRCYWNrZW5kKGJhY2tlbmRIaW50KTtcbiAgICAgIGlmIChiYWNrZW5kKSB7XG4gICAgICAgIHJldHVybiBiYWNrZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignbm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlJyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyeUxvYWRCYWNrZW5kKGJhY2tlbmRIaW50OiBzdHJpbmcpOiBQcm9taXNlPEJhY2tlbmQgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3QgYmFja2VuZE9iaiA9IGJhY2tlbmQ7XG5cbiAgaWYgKHR5cGVvZiBiYWNrZW5kT2JqW2JhY2tlbmRIaW50XSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNCYWNrZW5kKGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdKSkge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBiYWNrZW5kT2JqW2JhY2tlbmRIaW50XTtcbiAgICBsZXQgaW5pdCA9IGJhY2tlbmQuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGluaXQpIHtcbiAgICAgIGluaXQgPSBhd2FpdCBpbml0O1xuICAgIH1cbiAgICBpZiAoaW5pdCkge1xuICAgICAgYmFja2VuZHNDYWNoZS5zZXQoYmFja2VuZEhpbnQsIGJhY2tlbmQpO1xuICAgICAgcmV0dXJuIGJhY2tlbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCYWNrZW5kKG9iajogdW5rbm93bikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBvID0gb2JqIGFzIGFueTtcblxuICAvLyBjaGVjayBpZiBhbiBvYmplY3QgaXMgYSBCYWNrZW5kIGluc3RhbmNlXG4gIGlmIChcbiAgICAnaW5pdGlhbGl6ZScgaW4gbyAmJlxuICAgIHR5cGVvZiBvLmluaXRpYWxpemUgPT09ICdmdW5jdGlvbicgJiYgLy8gaW5pdGlhbGl6ZSgpXG4gICAgJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJyBpbiBvICYmXG4gICAgdHlwZW9mIG8uY3JlYXRlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicgJiYgLy8gY3JlYXRlU2Vzc2lvbkhhbmRsZXIoKVxuICAgICdkaXNwb3NlJyBpbiBvICYmXG4gICAgdHlwZW9mIG8uZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAvLyBkaXNwb3NlKClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tlbmRUeXBlID0gQmFja2VuZDtcbmV4cG9ydCB0eXBlIFNlc3Npb25IYW5kbGVyVHlwZSA9IFJldHVyblR5cGU8QmFja2VuZFR5cGVbJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJ10+O1xuZXhwb3J0IHR5cGUgSW5mZXJlbmNlSGFuZGxlclR5cGUgPSBSZXR1cm5UeXBlPFNlc3Npb25IYW5kbGVyVHlwZVsnY3JlYXRlSW5mZXJlbmNlSGFuZGxlciddPjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IExvZ2dlciwgUHJvZmlsZXIgfSBmcm9tICcuL2luc3RydW1lbnQnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5cbmNsYXNzIEtlcm5lbE9wIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG9wOiBPcGVyYXRvcixcbiAgICBwdWJsaWMgbm9kZTogR3JhcGguTm9kZSxcbiAgKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uUGxhbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZ3JhcGg6IEdyYXBoLFxuICAgIG9wczogT3BlcmF0b3JbXSxcbiAgICBwcml2YXRlIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sXG4gICkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZShvcHMpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHM6IE9wZXJhdG9yW10pIHtcbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ0V4ZWN1dGlvblBsYW4uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG4gICAgICBpZiAoZ3JhcGhOb2Rlcy5sZW5ndGggIT09IG9wcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3BzID0gb3BzLm1hcCgob3AsIGkpID0+IG5ldyBLZXJuZWxPcChvcCwgZ3JhcGhOb2Rlc1tpXSkpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAvLyBsb29rIGZvciBzdGFydGVyIG5vZGUocylcbiAgICAgIHRoaXMuX3N0YXJ0ZXIgPSBbXTtcbiAgICAgIHRoaXMuX29wcy5mb3JFYWNoKChvcCwgaSkgPT4ge1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG9wLm5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMuX3ZhbHVlc1tpbnB1dF0gJiYgLy8gbm90IGFuIGluaXRpYWxpemVkIGlucHV0XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoaW5wdXQpID09PSAtMSAvLyBub3QgbW9kZWwgaW5wdXRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKChpKSA9PiBpLnRlbnNvcik7XG4gIH1cblxuICBhc3luYyBleGVjdXRlKHNlc3Npb25IYW5kbGVyOiBTZXNzaW9uSGFuZGxlciwgbW9kZWxJbnB1dHM6IFRlbnNvcltdKTogUHJvbWlzZTxUZW5zb3JbXT4ge1xuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ0V4ZWN1dGlvblBsYW4uZXhlY3V0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHJlc2V0IG1lZGllbSByZXN1bHRcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgLy8gY3JlYXRlIGluZmVyZW5jZSBoYW5kbGVyXG4gICAgICBjb25zdCBpbmZlcmVuY2VIYW5kbGVyID0gc2Vzc2lvbkhhbmRsZXIuY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpO1xuXG4gICAgICAvLyBwb3B1bGF0ZSBpbnB1dHMgdmFsdWVcbiAgICAgIGNvbnN0IGdyYXBoSW5wdXRzID0gdGhpcy5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGlmIChtb2RlbElucHV0cy5sZW5ndGggIT09IGdyYXBoSW5wdXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYG51bWJlciBvZiBpbnB1dCB0ZW5zb3JzIGRvbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgaW5wdXRzIHRvIHRoZSBtb2RlbDogYWN0dWFsOiAke1xuICAgICAgICAgICAgbW9kZWxJbnB1dHMubGVuZ3RoXG4gICAgICAgICAgfSBleHBlY3RlZDogJHtncmFwaElucHV0cy5sZW5ndGh9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWxJbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBncmFwaElucHV0c1tpXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IGlucHV0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXBhcmUgcnVubmluZyBzZXF1ZW5jZVxuICAgICAgY29uc3Qgc2VxdWVuY2U6IG51bWJlcltdID0gdGhpcy5fc3RhcnRlci5zbGljZSgwKTtcblxuICAgICAgLy8gZXhlY3V0aW9uIGl0ZXJhdGlvbnNcbiAgICAgIGNvbnN0IGdyYXBoVmFsdWVzID0gdGhpcy5ncmFwaC5nZXRWYWx1ZXMoKTtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG5cbiAgICAgIGxldCByZWFyID0gMDtcbiAgICAgIHdoaWxlIChyZWFyIDwgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRoaXNPcEluZGV4ID0gc2VxdWVuY2VbcmVhcisrXTtcbiAgICAgICAgY29uc3QgdGhpc09wID0gdGhpcy5fb3BzW3RoaXNPcEluZGV4XTtcblxuICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICBjb25zdCBpbnB1dExpc3QgPSB0aGlzT3Aubm9kZS5pbnB1dHMubWFwKChpKSA9PiB0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICBpZiAoaW5wdXRMaXN0LmluZGV4T2YodW5kZWZpbmVkKSAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke3RoaXNPcC5ub2RlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuXG4gICAgICAgIGNvbnN0IGlucHV0VGVuc29ycyA9IGlucHV0TGlzdCBhcyBUZW5zb3JbXTtcbiAgICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgJ0V4ZWNQbGFuJyxcbiAgICAgICAgICBgUnVubmluZyBvcDoke3RoaXNPcC5ub2RlLm5hbWV9ICgke2lucHV0VGVuc29yc1xuICAgICAgICAgICAgLm1hcCgodCwgaSkgPT4gYCcke3RoaXNPcC5ub2RlLmlucHV0c1tpXX0nOiAke3QudHlwZX1bJHt0LmRpbXMuam9pbignLCcpfV1gKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9KWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0TGlzdCA9IGF3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoJ25vZGUnLCB0aGlzT3Aubm9kZS5uYW1lLCBhc3luYyAoKSA9PlxuICAgICAgICAgIHRoaXNPcC5vcC5pbXBsKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0VGVuc29ycywgdGhpc09wLm9wLmNvbnRleHQpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNoZWNrIG91dHB1dFxuICAgICAgICBpZiAob3V0cHV0TGlzdC5sZW5ndGggIT09IHRoaXNPcC5ub2RlLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGwgdmFsdWVcbiAgICAgICAgb3V0cHV0TGlzdC5mb3JFYWNoKChvdXRwdXQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBqID0gdGhpc09wLm5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzW2pdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBbJHtqfV0gYWxyZWFkeSBoYXMgdmFsdWU6IG9wOiR7dGhpc09wLm5vZGUubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdmFsdWVzW2pdID0gb3V0cHV0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXNvbHZlIGRvd25zdHJlYW0gbm9kZXNcbiAgICAgICAgY29uc3QgZG93bnN0cmVhbU5vZGVzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIG91dHB1dExpc3QuZm9yRWFjaCgoX291dHB1dCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGogPSB0aGlzT3Aubm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXggb2YgZ3JhcGhWYWx1ZXNbal0udG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb3duc3RyZWFtTm9kZSA9IGdyYXBoTm9kZXNbY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXhdO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBjdXJyZW50RG93bnN0cmVhbU5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fdmFsdWVzW2tdKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgIGRvd25zdHJlYW1Ob2Rlcy5hZGQoY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlcXVlbmNlLnB1c2goLi4uZG93bnN0cmVhbU5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0OiBUZW5zb3JbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IHRoaXMuZ3JhcGguZ2V0T3V0cHV0SW5kaWNlcygpW2ldO1xuICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSB0aGlzLl92YWx1ZXNbb3V0cHV0SW5kZXhdO1xuICAgICAgICBpZiAob3V0cHV0VGVuc29yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIG91dHB1dCBbJHtvdXRwdXRJbmRleH1dIGRvZXMgbm90IGhhdmUgdmFsdWVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0SW5kZXggPT09IDApIHtcbiAgICAgICAgICBhd2FpdCBvdXRwdXRUZW5zb3IuZ2V0RGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgICBvdXRwdXRUZW5zb3IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3IpO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ0V4ZWNQbGFuJywgJ2Rpc3Bvc2luZyBvZiBpbmZlcmVuY2VIYW5kbGVyJyk7XG4gICAgICBpbmZlcmVuY2VIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG4gIH1cblxuICBfdmFsdWVzOiBBcnJheTxUZW5zb3IgfCB1bmRlZmluZWQ+O1xuICBfb3BzOiBLZXJuZWxPcFtdO1xuICBfc3RhcnRlcjogbnVtYmVyW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQgeyBvbm54cnVudGltZSB9IGZyb20gJy4vb3J0LXNjaGVtYS9mbGF0YnVmZmVycy9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCB7IG9ubnggfSBmcm9tICcuL29ydC1zY2hlbWEvcHJvdG9idWYvb25ueCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQgeyBkZWNvZGVVdGY4U3RyaW5nLCBMb25nVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQXR0cmlidXRlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgZmxvYXQ6IG51bWJlcjtcbiAgICBpbnQ6IG51bWJlcjtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICB0ZW5zb3I6IFRlbnNvcjtcbiAgICBmbG9hdHM6IG51bWJlcltdO1xuICAgIGludHM6IG51bWJlcltdO1xuICAgIHN0cmluZ3M6IHN0cmluZ1tdO1xuICAgIHRlbnNvcnM6IFRlbnNvcltdO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcbn1cblxudHlwZSBWYWx1ZVR5cGVzID0gQXR0cmlidXRlLkRhdGFUeXBlTWFwW0F0dHJpYnV0ZS5EYXRhVHlwZV07XG5cbnR5cGUgVmFsdWUgPSBbVmFsdWVUeXBlcywgQXR0cmlidXRlLkRhdGFUeXBlXTtcblxuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZXM6IG9ubnguSUF0dHJpYnV0ZVByb3RvW10gfCBvcnRGYnMuQXR0cmlidXRlW10gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoYXR0cmlidXRlcyAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMuc2V0KGF0dHIubmFtZSwgW0F0dHJpYnV0ZS5nZXRWYWx1ZShhdHRyKSwgQXR0cmlidXRlLmdldFR5cGUoYXR0cildKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyIGluc3RhbmNlb2Ygb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMuc2V0KGF0dHIubmFtZSgpISwgW0F0dHJpYnV0ZS5nZXRWYWx1ZShhdHRyKSwgQXR0cmlidXRlLmdldFR5cGUoYXR0cildKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZSA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwbGljYXRlZCBhdHRyaWJ1dGUgbmFtZXMnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXQoa2V5OiBzdHJpbmcsIHR5cGU6IEF0dHJpYnV0ZS5EYXRhVHlwZSwgdmFsdWU6IFZhbHVlVHlwZXMpOiB2b2lkIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChrZXksIFt2YWx1ZSwgdHlwZV0pO1xuICB9XG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZ2V0RmxvYXQoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnZmxvYXQnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdmbG9hdCcsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRJbnQoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnaW50J10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnaW50JywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFN0cmluZyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydzdHJpbmcnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdzdHJpbmcnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0VGVuc29yKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ3RlbnNvciddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3RlbnNvcicsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRGbG9hdHMoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnZmxvYXRzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnZmxvYXRzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldEludHMoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnaW50cyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2ludHMnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0U3RyaW5ncyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydzdHJpbmdzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnc3RyaW5ncycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRUZW5zb3JzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ3RlbnNvcnMnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICd0ZW5zb3JzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0PFYgZXh0ZW5kcyBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbQXR0cmlidXRlLkRhdGFUeXBlXT4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdHlwZTogQXR0cmlidXRlLkRhdGFUeXBlLFxuICAgIGRlZmF1bHRWYWx1ZT86IFYsXG4gICk6IFYge1xuICAgIGNvbnN0IHZhbHVlQW5kVHlwZSA9IHRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlQW5kVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUFuZFR5cGVbMV0gIT09IHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0eXBlfSBidXQgZ290ICR7dmFsdWVBbmRUeXBlWzFdfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVBbmRUeXBlWzBdIGFzIFY7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUeXBlKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvIHwgb3J0RmJzLkF0dHJpYnV0ZSk6IEF0dHJpYnV0ZS5EYXRhVHlwZSB7XG4gICAgY29uc3QgdHlwZSA9IGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvID8gYXR0ci50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuICd0ZW5zb3InO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0cyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gJ2ludHMnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmdzJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiAndGVuc29ycyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0OiAke29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0eXBlXX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZShhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90byB8IG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvID8gYXR0ci50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIIHx8IGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEhTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBoIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZU5vQ2hlY2soYXR0cik7XG5cbiAgICAvLyBjYXN0IExPTkcgdG8gbnVtYmVyXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UICYmIExvbmdVdGlsLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBMb25nVXRpbC5sb25nVG9OdW1iZXIodmFsdWUgYXMgTG9uZyB8IGZsYXRidWZmZXJzLkxvbmcpO1xuICAgIH1cblxuICAgIC8vIGNhc3QgTE9OR1tdIHRvIG51bWJlcltdXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UUykge1xuICAgICAgY29uc3QgYXJyID0gdmFsdWUgYXMgQXJyYXk8bnVtYmVyIHwgTG9uZyB8IGZsYXRidWZmZXJzLkxvbmc+O1xuICAgICAgY29uc3QgbnVtYmVyVmFsdWU6IG51bWJlcltdID0gbmV3IEFycmF5PG51bWJlcj4oYXJyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1heWJlTG9uZyA9IGFycltpXTtcbiAgICAgICAgbnVtYmVyVmFsdWVbaV0gPSBMb25nVXRpbC5sb25nVG9OdW1iZXIobWF5YmVMb25nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWJlclZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90byB0byBvbm54anMuVGVuc29yXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SKSB7XG4gICAgICByZXR1cm4gYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgPyBUZW5zb3IuZnJvbVByb3RvKHZhbHVlIGFzIG9ubnguSVRlbnNvclByb3RvKVxuICAgICAgICA6IFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlIGFzIG9ydEZicy5UZW5zb3IpO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90b1tdIHRvIG9ubnhqcy5UZW5zb3JbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpIHtcbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICBjb25zdCB0ZW5zb3JQcm90b3MgPSB2YWx1ZSBhcyBvbm54LklUZW5zb3JQcm90b1tdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCgodmFsdWUpID0+IFRlbnNvci5mcm9tUHJvdG8odmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc3QgdGVuc29yUHJvdG9zID0gdmFsdWUgYXMgb3J0RmJzLlRlbnNvcltdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCgodmFsdWUpID0+IFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FzdCBVaW50OEFycmF5IHRvIHN0cmluZ1xuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORykge1xuICAgICAgLy8gc3RyaW5nIGluIG9ubnggYXR0cmlidXRlIGlzIG9mIHVpbnQ4YXJyYXkgdHlwZSwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHN0cmluZyBiZWxvdy4gV2hpbGUgaW4gb3J0IGZvcm1hdCxcbiAgICAgIC8vIHN0cmluZyBhdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmcsIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVlZGVkLlxuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGNvbnN0IHV0ZjhTdHJpbmcgPSB2YWx1ZSBhcyBVaW50OEFycmF5O1xuICAgICAgICByZXR1cm4gZGVjb2RlVXRmOFN0cmluZyh1dGY4U3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYXN0IFVpbnQ4QXJyYXlbXSB0byBzdHJpbmdbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1MpIHtcbiAgICAgIC8vIHN0cmluZ3MgaW4gb25ueCBhdHRyaWJ1dGUgaXMgcmV0dXJuZWQgYXMgdWludDhhcnJheVtdLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gc3RyaW5nW10gYmVsb3cuIFdoaWxlIGluIG9ydFxuICAgICAgLy8gZm9ybWF0IHN0cmluZ3MgYXR0cmlidXRlcyBhcmUgcmV0dXJuZWQgYXMgc3RyaW5nW10sIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVlZGVkLlxuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGNvbnN0IHV0ZjhTdHJpbmdzID0gdmFsdWUgYXMgVWludDhBcnJheVtdO1xuICAgICAgICByZXR1cm4gdXRmOFN0cmluZ3MubWFwKGRlY29kZVV0ZjhTdHJpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSBhcyBWYWx1ZVR5cGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvIHwgb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgPyB0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGF0dHIpXG4gICAgICA6IHRoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQoYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG8pIHtcbiAgICBzd2l0Y2ggKGF0dHIudHlwZSEpIHtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOlxuICAgICAgICByZXR1cm4gYXR0ci5mO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gYXR0ci5pO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gYXR0ci5zO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOlxuICAgICAgICByZXR1cm4gYXR0ci50O1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEg6XG4gICAgICAgIHJldHVybiBhdHRyLmc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmZsb2F0cztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmludHM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOlxuICAgICAgICByZXR1cm4gYXR0ci5zdHJpbmdzO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpcbiAgICAgICAgcmV0dXJuIGF0dHIudGVuc29ycztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpcbiAgICAgICAgcmV0dXJuIGF0dHIuZ3JhcGhzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbYXR0ci50eXBlIV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChhdHRyOiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChhdHRyLnR5cGUoKSkge1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZigpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5JTlQ6XG4gICAgICAgIHJldHVybiBhdHRyLmkoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gYXR0ci5zKCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuIGF0dHIudCgpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5HUkFQSDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZygpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5GTE9BVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmZsb2F0c0FycmF5KCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLklOVFM6IHtcbiAgICAgICAgY29uc3QgaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuaW50c0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICBpbnRzLnB1c2goYXR0ci5pbnRzKGkpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludHM7XG4gICAgICB9XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6IHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuc3RyaW5nc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goYXR0ci5zdHJpbmdzKGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzoge1xuICAgICAgICBjb25zdCB0ZW5zb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ci50ZW5zb3JzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgIHRlbnNvcnMucHVzaChhdHRyLnRlbnNvcnMoaSkhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29ycztcbiAgICAgIH1cbiAgICAgIC8vIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuR1JBUEhTOlxuICAgICAgLy8gVE9ETzogU3ViZ3JhcGggbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAvLyBjb25zdCBncmFwaHMgPSBbXTtcbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ci5ncmFwaHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAvLyAgIGdyYXBocy5wdXNoKGF0dHIuZ3JhcGhzKGkpISk7XG4gICAgICAvLyB9XG4gICAgICAvLyByZXR1cm4gZ3JhcGhzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtvcnRGYnMuQXR0cmlidXRlVHlwZVthdHRyLnR5cGUoKV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hdHRyaWJ1dGVzOiBNYXA8c3RyaW5nLCBWYWx1ZT47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZSB9IGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCB7IG9ubnhydW50aW1lIH0gZnJvbSAnLi9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHsgb25ueCB9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yJztcbmltcG9ydCB7IExvbmdVdGlsLCBNQVhfQ0xJUCwgTUlOX0NMSVAsIFByb3RvVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgR3JhcGgge1xuICBleHBvcnQgaW50ZXJmYWNlIFNoYXBlIHtcbiAgICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlVHlwZSB7XG4gICAgcmVhZG9ubHkgdGVuc29yVHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICAgIHJlYWRvbmx5IHNoYXBlOiBTaGFwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlIHtcbiAgICAvLyB0aGUgdGVuc29yIGRhdGEuIGVtcHR5IGZvciBub24taW5pdGlhbGl6ZWQgaW5wdXRzXG4gICAgcmVhZG9ubHkgdGVuc29yPzogVGVuc29yO1xuXG4gICAgLy8gaW5kZXggdG8gdGhlIE5vZGUgd2hlcmUgdGhlIHZhbHVlIGNvbWVzIGZyb20uIC0xIGZvciBpbml0aWFsaXplci5cbiAgICByZWFkb25seSBmcm9tOiBudW1iZXI7XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBOb2RlcyB3aGVyZSB0aGUgdmFsdWVzIGdvIHRvLlxuICAgIHJlYWRvbmx5IHRvOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHZhbHVlIHR5cGUgc3BlY2lmaWNhdGlvbi4gZW1wdHkgZm9yIG5vbi1pbnB1dCB2YWx1ZXMuXG4gICAgcmVhZG9ubHkgdHlwZT86IFZhbHVlVHlwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAgIC8vIG5hbWUgb2YgdGhlIG5vZGVcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvLyB0aGUgb3BlcmF0b3IgdHlwZVxuICAgIHJlYWRvbmx5IG9wVHlwZTogc3RyaW5nO1xuXG4gICAgLy8gaW5kaWNlcyB0byB0aGUgVmFsdWVzIHdoZXJlIHRoZSBpbnB1dHMgY29tZSBmcm9tLlxuICAgIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBWYWx1ZXMgd2hlcmUgdGhlIG91dHB1cyBnbyB0by5cbiAgICByZWFkb25seSBvdXRwdXRzOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHRoYXQgdXNlZCBieSB0aGUgb3BlcmF0b3JcbiAgICByZWFkb25seSBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIH1cblxuICAvKipcbiAgICogYSBUcmFuc2Zvcm1lciBpcyBhbiBpbnN0YW5jZSB0aGF0IGFsbG93cyBhbGwgcG9zc2libGUgdHJhbnNmb3JtYXRpb24gb3BlcmF0aW9ucyB0aGF0IGFwcGxpZWQgdG8gYSBncmFwaFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lciB7XG4gICAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpOiB2b2lkO1xuICAgIHJlbW92ZUFsbERyb3BvdXROb2RlcygpOiB2b2lkO1xuICAgIGZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCk6IHZvaWQ7XG4gICAgLy8gVE9ETzogYWRkIGdlbmVyaWMgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoXG4gIH1cblxuICAvLyBhbiBpbml0aWFsaXplciBjYW4gdXNlIHRyYW5zZm9ybWVyIHRvIHRyYW5zZm9ybSB0aGUgZ3JhcGhcbiAgZXhwb3J0IGludGVyZmFjZSBJbml0aWFsaXplciB7XG4gICAgdHJhbnNmb3JtR3JhcGgodHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBHcmFwaCB7XG4gIGdldElucHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXTtcbiAgZ2V0T3V0cHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0T3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW107XG4gIGdldFZhbHVlcygpOiByZWFkb25seSBHcmFwaC5WYWx1ZVtdO1xuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW107XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbmV4cG9ydCBjb25zdCBHcmFwaCA9IHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdCBhIGdyYXBoIGZyb20gYSBncmFwaCBwcm90b2J1ZiB0eXBlXG4gICAqL1xuICBmcm9tOiAoZ3JhcGhQcm90bzogb25ueC5JR3JhcGhQcm90byB8IG9ydEZicy5HcmFwaCwgaW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikgPT5cbiAgICBuZXcgR3JhcGhJbXBsKGdyYXBoUHJvdG8sIGluaXRpYWxpemVyKSxcbn07XG5cbmNsYXNzIFZhbHVlIGltcGxlbWVudHMgR3JhcGguVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZUluZm8/OiBvbm54LklWYWx1ZUluZm9Qcm90bykge1xuICAgIHRoaXMuX2Zyb20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG8gPSBbXTtcbiAgICB0aGlzLnRlbnNvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodmFsdWVJbmZvKSB7XG4gICAgICB0aGlzLnR5cGUgPSBQcm90b1V0aWwudGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlSW5mby50eXBlIS50ZW5zb3JUeXBlISk7XG4gICAgfVxuICB9XG5cbiAgX2Zyb20/OiBudW1iZXI7IC8vIC0xIHJlcHJlc2VudCBmcm9tIGluaXRpYWxpemVyXG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLl9mcm9tITtcbiAgfVxuICBfdG86IG51bWJlcltdO1xuICBnZXQgdG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvO1xuICB9XG4gIHR5cGU/OiBHcmFwaC5WYWx1ZVR5cGU7XG4gIHRlbnNvcj86IFRlbnNvcjtcbn1cblxuY2xhc3MgTm9kZSBpbXBsZW1lbnRzIEdyYXBoLk5vZGUge1xuICBjb25zdHJ1Y3Rvcihfbm9kZVByb3RvOiBvbm54LklOb2RlUHJvdG8gfCBvcnRGYnMuTm9kZSwgbmFtZT86IHN0cmluZykge1xuICAgIGlmIChfbm9kZVByb3RvIGluc3RhbmNlb2Ygb25ueC5Ob2RlUHJvdG8pIHtcbiAgICAgIHRoaXMubmFtZSA9IF9ub2RlUHJvdG8ubmFtZTtcbiAgICAgIHRoaXMub3BUeXBlID0gX25vZGVQcm90by5vcFR5cGU7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKF9ub2RlUHJvdG8uYXR0cmlidXRlKTtcbiAgICB9IGVsc2UgaWYgKF9ub2RlUHJvdG8gaW5zdGFuY2VvZiBvcnRGYnMuTm9kZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZSA/PyBfbm9kZVByb3RvLm5hbWUoKSE7XG4gICAgICB0aGlzLm9wVHlwZSA9IF9ub2RlUHJvdG8ub3BUeXBlKCkhO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0ZShQcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQoX25vZGVQcm90bykpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgdGhpcy5leGVjdXRlTm9kZSA9IHRydWU7XG4gIH1cblxuICBuYW1lOiBzdHJpbmc7XG4gIG9wVHlwZTogc3RyaW5nO1xuICBpbnB1dHM6IG51bWJlcltdO1xuICBvdXRwdXRzOiBudW1iZXJbXTtcbiAgYXR0cmlidXRlczogQXR0cmlidXRlO1xuICBleGVjdXRlTm9kZTogYm9vbGVhbjtcbn1cblxuY2xhc3MgR3JhcGhJbXBsIGltcGxlbWVudHMgR3JhcGgsIEdyYXBoLlRyYW5zZm9ybWVyIHtcbiAgcHJpdmF0ZSBfYWxsRGF0YTogVmFsdWVbXTtcblxuICBwcml2YXRlIF9hbGxJbnB1dEluZGljZXM6IG51bWJlcltdO1xuICBwcml2YXRlIF9hbGxJbnB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBwcml2YXRlIF9hbGxPdXRwdXRJbmRpY2VzOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBfYWxsT3V0cHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgX25vZGVzOiBOb2RlW107XG5cbiAgY29uc3RydWN0b3IoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG8gfCBvcnRGYnMuR3JhcGgsIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikge1xuICAgIGlmICghZ3JhcGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dyYXBoIGlzIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIGdyYXBoIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIHRoaXMuYnVpbGRHcmFwaChncmFwaCk7XG5cbiAgICAvLyBleGVjdXRlIGFueSB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBmb3IgdGhlIGdyYXBoIChpZiBhcHBsaWNhYmxlKVxuICAgIHRoaXMudHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcik7XG5cbiAgICAvLyBjaGVjayBmb3IgY3ljbGVzIGFuZCBvdGhlciBpbmNvbnNpc3RlbmNpZXMgLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgdGhpcy5jaGVja0lzQWN5Y2xpYygpO1xuICB9XG5cbiAgZ2V0SW5wdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsSW5wdXRJbmRpY2VzO1xuICB9XG5cbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXM7XG4gIH1cblxuICBnZXRPdXRwdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcztcbiAgfVxuXG4gIGdldE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXRWYWx1ZXMoKTogcmVhZG9ubHkgR3JhcGguVmFsdWVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbERhdGE7XG4gIH1cblxuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW10ge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaChncmFwaDogb25ueC5JR3JhcGhQcm90byB8IG9ydEZicy5HcmFwaCkge1xuICAgIC8vIGJ1aWxkIHRoZSBncmFwaCAtIHdpbGwgdGhyb3cgZXhjZXB0aW9ucyBpZiBzb21ldGhpbmcgZmF0YWwgaXMgZGV0ZWN0ZWRcbiAgICBpZiAoZ3JhcGggaW5zdGFuY2VvZiBvbm54LkdyYXBoUHJvdG8pIHtcbiAgICAgIHRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGdyYXBoKTtcbiAgICB9IGVsc2UgaWYgKGdyYXBoIGluc3RhbmNlb2Ygb3J0RmJzLkdyYXBoKSB7XG4gICAgICB0aGlzLmJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KGdyYXBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR3JhcGggdHlwZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdChncmFwaDogb25ueC5JR3JhcGhQcm90bykge1xuICAgIGNvbnN0IGRhdGFJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxEYXRhID0gW107XG5cbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxJbnB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX25vZGVzID0gW107XG5cbiAgICBjb25zdCBub2Rlc0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgLy8gc2NhbiBhbGwgaW5wdXRzXG4gICAgaWYgKCFncmFwaC5pbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFZhbHVlTmFtZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgZ3JhcGguaW5wdXQpIHtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaS5uYW1lISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7aS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZShpKSkgLSAxO1xuICAgICAgZGF0YUluZGljZXMuc2V0KGkubmFtZSEsIGN1cnJlbnRJbmRleCk7XG4gICAgICBpbnB1dFZhbHVlTmFtZXMucHVzaChpLm5hbWUhKTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBpbml0aWFsaXplcnNcbiAgICBpZiAoIWdyYXBoLmluaXRpYWxpemVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBvZiBncmFwaC5pbml0aWFsaXplcikge1xuICAgICAgbGV0IGluZGV4ID0gZGF0YUluZGljZXMuZ2V0KGkubmFtZSEpO1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgdmFsdWUudHlwZSA9IHtcbiAgICAgICAgICBzaGFwZTogeyBkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhpLmRpbXMhKSB9LFxuICAgICAgICAgIHRlbnNvclR5cGU6IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhpLmRhdGFUeXBlISksXG4gICAgICAgIH07XG4gICAgICAgIGluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBpbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbGxEYXRhW2luZGV4XS5fZnJvbSA9IC0xO1xuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0udGVuc29yID0gVGVuc29yLmZyb21Qcm90byhpKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGluZGljZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChpbnB1dFZhbHVlTmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG91dHB1dHNcbiAgICBpZiAoIWdyYXBoLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXQnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpIG9mIGdyYXBoLm91dHB1dCkge1xuICAgICAgaWYgKGRhdGFJbmRpY2VzLmhhcyhpLm5hbWUhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7aS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZShpKSkgLSAxO1xuICAgICAgZGF0YUluZGljZXMuc2V0KGkubmFtZSEsIGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLnB1c2goY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2goaS5uYW1lISk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgbm9kZXNcbiAgICBpZiAoIWdyYXBoLm5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogbm9kZScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGVQcm90byBvZiBncmFwaC5ub2RlKSB7XG4gICAgICBpZiAoIW5vZGVQcm90by5uYW1lKSB7XG4gICAgICAgIC8vIGFzc2lnbiBhIG5hbWUgdG8gdGhlIG5vZGUgaWYgaXQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgICBmb3IgKGxldCBwaWNrID0gMDsgOyBwaWNrKyspIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYHVubmFtZWRfJHtub2RlUHJvdG8ub3BUeXBlfV8ke3BpY2t9YDtcbiAgICAgICAgICBpZiAoIW5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGVQcm90by5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNJbmRpY2VzLmhhcyhub2RlUHJvdG8ubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChub2RlUHJvdG8ubmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZVtpXTtcbiAgICAgIGlmICghbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXQsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5vdXRwdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHtkYXRhSW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gaTtcblxuICAgICAgICAvLyBmb3IgdGhlICdDb25zdGFudCcgb3BlcmF0b3IsIGp1c3QgY3JlYXRlIGEgbmV3IGVkZ2UgaW4gdGhlIGdyYXBoIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdvdXRwdXQnIG9mIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgaWdub3JlIHRoZSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICAgIGlmIChub2RlUHJvdG8ub3BUeXBlID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8uYXR0cmlidXRlIHx8IG5vZGVQcm90by5hdHRyaWJ1dGUubGVuZ3RoICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlWzBdLnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8ub3V0cHV0IHx8IG5vZGVQcm90by5vdXRwdXQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8obm9kZVByb3RvLmF0dHJpYnV0ZVswXS50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVbaV07XG5cbiAgICAgIGlmICghbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGhhbmRsZSBleGNlcHRpb24gd2hlbiBvcHNldCA+IDkgYW5kIHJvaSAvIHNjYWxlcyBub3QgZ2l2ZW5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnB1dCA9PT0gJycgJiZcbiAgICAgICAgICAgIChub2RlUHJvdG8uaW5wdXQubGVuZ3RoID09PSAzIHx8IG5vZGVQcm90by5pbnB1dC5sZW5ndGggPT09IDQpICYmXG4gICAgICAgICAgICBub2RlUHJvdG8ub3BUeXBlID09PSAnUmVzaXplJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2lucHV0fScgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbnB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fdG8ucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaEZyb21PcnRGb3JtYXQoZ3JhcGg6IG9ydEZicy5HcmFwaCkge1xuICAgIGNvbnN0IGRhdGFJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxEYXRhID0gW107XG5cbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxJbnB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX25vZGVzID0gW107XG5cbiAgICBjb25zdCBub2Rlc0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgLy8gc2NhbiBhbGwgaW5wdXRzXG4gICAgY29uc3QgaW5wdXRWYWx1ZU5hbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5pbnB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBpbnB1dE5hbWUgPSBncmFwaC5pbnB1dHMoaSk7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGlucHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7aW5wdXROYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gRmluZCB0aGUgaW5wdXQgdHlwZUluZm8gZnJvbSBub2RlYXJnc1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaC5ub2RlQXJnc0xlbmd0aCgpOyBqKyspIHtcbiAgICAgICAgaWYgKGdyYXBoLm5vZGVBcmdzKGopPy5uYW1lKCkgPT09IGlucHV0TmFtZSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ3JhcGgubm9kZUFyZ3Moaik/LnR5cGUoKT8udmFsdWVUeXBlKCk7XG4gICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPT0gb3J0RmJzLlR5cGVJbmZvVmFsdWUudGVuc29yX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSB0eXBlIGZvciB0aGUgbm9kZUFyZy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWVJbmZvID0gZ3JhcGgubm9kZUFyZ3MoaikhLnR5cGUoKSEudmFsdWUobmV3IG9ydEZicy5UZW5zb3JUeXBlQW5kU2hhcGUoKSkhO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odmFsdWVJbmZvLmVsZW1UeXBlKCkpO1xuICAgICAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWVJbmZvLnNoYXBlKCkhO1xuICAgICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNoYXBlLmRpbUxlbmd0aCgpITsgaysrKSB7XG4gICAgICAgICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHNoYXBlLmRpbShrKSEudmFsdWUoKSEuZGltVmFsdWUoKSEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUudHlwZSA9IHsgc2hhcGU6IHsgZGltcyB9LCB0ZW5zb3JUeXBlOiB0eXBlIH07XG4gICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgICAgZGF0YUluZGljZXMuc2V0KGlucHV0TmFtZSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICBpbnB1dFZhbHVlTmFtZXMucHVzaChpbnB1dE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGluaXRpYWxpemVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGguaW5pdGlhbGl6ZXJzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZXIgPSBncmFwaC5pbml0aWFsaXplcnMoaSkhO1xuICAgICAgbGV0IGluZGV4ID0gZGF0YUluZGljZXMuZ2V0KGluaXRpYWxpemVyLm5hbWUoKSEpO1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgY29uc3QgZGltcyA9IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChpbml0aWFsaXplcik7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oaW5pdGlhbGl6ZXIuZGF0YVR5cGUoKSk7XG4gICAgICAgIHZhbHVlLnR5cGUgPSB7IHNoYXBlOiB7IGRpbXMgfSwgdGVuc29yVHlwZTogdHlwZSB9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaW5pdGlhbGl6ZXIubmFtZSgpISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKGluaXRpYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGluZGljZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChpbnB1dFZhbHVlTmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG91dHB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm91dHB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBvdXRwdXROYW1lID0gZ3JhcGgub3V0cHV0cyhpKTtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMob3V0cHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke291dHB1dE5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXROYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG91dHB1dE5hbWUpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2Rlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBub2RlJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGgubm9kZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKTtcbiAgICAgIGxldCBuYW1lID0gbm9kZVByb3RvIS5uYW1lKCk7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIGEgbmFtZSB0byB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgIGZvciAobGV0IHBpY2sgPSAwOyA7IHBpY2srKykge1xuICAgICAgICAgIG5hbWUgPSBgdW5uYW1lZF8ke25vZGVQcm90byEub3BUeXBlKCl9XyR7cGlja31gO1xuICAgICAgICAgIGlmICghbm9kZXNJbmRpY2VzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gYW4gdW5pcXVlIG5hbWUgaXMgZm91bmQuIGJyZWFrLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc0luZGljZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvISwgbmFtZSkpIC0gMTtcbiAgICAgIG5vZGVzSW5kaWNlcy5zZXQobmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZXMoaSk7XG4gICAgICBpZiAobm9kZVByb3RvID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBub2RlIGV4aXN0cyBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZVByb3RvPy5vdXRwdXRzTGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZVByb3RvPy5vdXRwdXRzTGVuZ3RoKCk7IGorKykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBub2RlUHJvdG8/Lm91dHB1dHMoaik7XG4gICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQob3V0cHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGF0YUluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZSgpKSAtIDE7XG4gICAgICAgICAgZGF0YUluZGljZXMuc2V0KG91dHB1dCwgZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm91dHB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke2RhdGFJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gPSBpO1xuXG4gICAgICAgIC8vIGZvciB0aGUgJ0NvbnN0YW50JyBvcGVyYXRvciwganVzdCBjcmVhdGUgYSBuZXcgZWRnZSBpbiB0aGUgZ3JhcGggY29ycmVzcG9uZGluZyB0byB0aGUgJ291dHB1dCcgb2YgdGhlXG4gICAgICAgIC8vIG9wZXJhdG9yIGFuZCBpZ25vcmUgdGhlIG5vZGUgZnJvbSB0aGUgZ3JhcGhcbiAgICAgICAgaWYgKG5vZGVQcm90by5vcFR5cGUoKSA9PT0gJ0NvbnN0YW50Jykge1xuICAgICAgICAgIGlmIChub2RlUHJvdG8uYXR0cmlidXRlc0xlbmd0aCgpICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlcygwKSEudCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlUHJvdG8ub3V0cHV0c0xlbmd0aCgpICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKG5vZGVQcm90by5hdHRyaWJ1dGVzKDApIS50KCkhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVzKGkpITtcblxuICAgICAgaWYgKG5vZGVQcm90by5pbnB1dHNMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVQcm90by5pbnB1dHNMZW5ndGgoKSE7IGorKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IG5vZGVQcm90by5pbnB1dHMoaikhO1xuICAgICAgICBjb25zdCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtpbnB1dH0nIGZvciBub2RlOiAke25vZGVQcm90byEubmFtZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5wdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX3RvLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lzQWN5Y2xpYygpIHtcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBncmFwaCBhbmQgY2hlY2sgZm9yIGN5Y2xlcyBvciBvdGhlciBmYXRhbCBpbmNvbnNpc3RlbmNpZXNcbiAgICBjb25zdCBzdGFydGVyczogU2V0PG51bWJlcj4gPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbaV07XG4gICAgICBkYXRhLl90by5mb3JFYWNoKChqKSA9PiB7XG4gICAgICAgIHN0YXJ0ZXJzLmFkZChqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0aXZlIERGUyB0byBjaGVjayBmb3IgY3ljbGVzXG4gICAgY29uc3Qgbm9kZXNTdGFjayA9IEFycmF5LmZyb20oc3RhcnRlcnMpO1xuICAgIGNvbnN0IG5vZGVzU3RhdGUgPSBuZXcgQXJyYXk8c3RyaW5nPih0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoJ3doaXRlJyk7XG5cbiAgICB3aGlsZSAobm9kZXNTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBub2Rlc1N0YWNrLnBvcCgpITtcbiAgICAgIC8vIHRoaXMgbm9kZSBoYXMgbm93IGJlZW4gcHJvY2Vzc2VkIGNvbXBsZXRlbHkuIE1hcmsgdGhpcyBub2RlICdibGFjaycgdG8gZGVub3RlIHRoaXMuXG4gICAgICBpZiAobm9kZXNTdGF0ZVtub2RlSW5kZXhdID09PSAnZ3JheScpIHtcbiAgICAgICAgbm9kZXNTdGF0ZVtub2RlSW5kZXhdID0gJ2JsYWNrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgbm9kZSBpcyB1bmRlciBwcm9jZXNzaW5nIHN0YWdlLiBtYXJrIHRoaXMgbm9kZSAnZ3JheScgdG8gZGVub3RlIHRoaXMuXG4gICAgICAgIG5vZGVzU3RhY2sucHVzaChub2RlSW5kZXgpO1xuICAgICAgICBub2Rlc1N0YXRlW25vZGVJbmRleF0gPSAnZ3JheSc7XG5cbiAgICAgICAgdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5vdXRwdXRzLmZvckVhY2goKG91dGdvaW5nRWRnZUluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbb3V0Z29pbmdFZGdlSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS50ZW5zb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgb3V0cHV0cyBzaG91bGQgbm90IGJlIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLl9mcm9tICE9PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyb20gcHJvcGVydHkgb2YgdGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IG1hdGNoIGluZGV4IG9mIE5vZGUgYmVpbmcgcHJvY2Vzc2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLl90by5mb3JFYWNoKChkb3duc3RyZWFtTm9kZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBiYWNrIGVkZ2UgZm91bmQgLSBjeWNsaWNcbiAgICAgICAgICAgIGlmIChub2Rlc1N0YXRlW2Rvd25zdHJlYW1Ob2RlSW5kZXhdID09PSAnZ3JheScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBncmFwaCBpcyBjeWNsaWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyZWUgZWRnZSBmb3VuZCAtIGNvbnRpbnVlIHByb2Nlc3NpbmcgYnkgYWRkaW5nIGl0IHRvIHN0YWNrXG4gICAgICAgICAgICBlbHNlIGlmIChub2Rlc1N0YXRlW2Rvd25zdHJlYW1Ob2RlSW5kZXhdID09PSAnd2hpdGUnKSB7XG4gICAgICAgICAgICAgIG5vZGVzU3RhY2sucHVzaChkb3duc3RyZWFtTm9kZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1HcmFwaChncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpOiB2b2lkIHtcbiAgICAvLyBhcHBseSBjb21tb24gdHJhbnNmb3JtXG4gICAgdGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKTtcbiAgICB0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCk7XG4gICAgLy8gYXBwbHkgaW5pdGlhbGl6ZXIgc3BlY2lmaWMgdHJhbnNmb3JtXG4gICAgaWYgKGdyYXBoSW5pdGlhbGl6ZXIpIHtcbiAgICAgIGdyYXBoSW5pdGlhbGl6ZXIudHJhbnNmb3JtR3JhcGgodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gZmluYWxpemUgZ3JhcGhcbiAgICB0aGlzLmZpbmFsaXplR3JhcGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5hbGl6ZSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhbGwgdGhlIHRyYW5zZm9ybWF0aW9uIGNvbXBsZXRlZC5cbiAgICogdGhpcyBmdW5jdGlvbiByZW1vdmVzIGFsbCB1bm5lY2Vzc2FyeSBub2RlcyBhbmQgdmFsdWVzIGZyb20gdGhlIGdyYXBoXG4gICAqL1xuICBmaW5hbGl6ZUdyYXBoKCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIGRlbGV0ZSBhbGwgbm9kZXMgdGhhdCBhcmUgbm90IGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gVGhlIGdyYXBoIGlzIHJlcHJlc2VudGVkIHVzaW5nIHRoZXNlIHR3byBhcnJheXNcbiAgICAvLyB0aGlzLl9ub2RlcyAtIEFycmF5IGhvbGRpbmcgdGhlIGtlcm5lbHMgdG8gZXhlY3V0ZSAtIGVhY2ggZW50cnkgaXMgYSBrZXJuZWwgcG9pbnRpbmcgdG8gdGhpcy5fYWxsRGF0YVxuICAgIC8vIHRoaXMuX2FsbERhdGEgLSBob2xkIDIgZmllbGRzIC0gdG8gW10gJiBmcm9tIC0gdGhlc2UgZmVpbGVkcyBob2xkIHRoZSBncmFwaCBtYXAgZm9yIGlucHV0cyBhbmQgb3V0cHV0cyBwZXIgbm9kZVxuICAgIC8vIG5ld0luZGljZXMgLSByZW1hcHBpbmcgdGhlIGdyYXBoIGFmdGVyIHJlYWRpbmcgdGhlIGZsYWcgJ2V4ZWN1dGVOb2RlJ1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPih0aGlzLl9ub2Rlcy5sZW5ndGgsIDApO1xuICAgIGxldCBub2RlUG9zc2l0aW9uID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGdpdmluZyBuZXcgaW5kZXhlcyB0byB0aGUgbm9kZXMgYmFzZWQgb24gZXhlY3V0aW9uIGZsYWdcbiAgICAgIG5ld0luZGljZXNbaV0gPSBub2RlUG9zc2l0aW9uO1xuICAgICAgaWYgKHRoaXMuX25vZGVzW2ldLmV4ZWN1dGVOb2RlKSB7XG4gICAgICAgIGlmIChub2RlUG9zc2l0aW9uICE9PSBpKSB7XG4gICAgICAgICAgdGhpcy5fbm9kZXNbbm9kZVBvc3NpdGlvbl0gPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlUG9zc2l0aW9uKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxldGUgYWxsIG91dHB1dCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fbm9kZXNbaV0ub3V0cHV0cy5mb3JFYWNoKChpbmQpID0+IHtcbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2luZF0uX2Zyb20gPSAtMjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZpbmcgdGhlIHVudXNlZCBub2Rlc1xuICAgIHRoaXMuX25vZGVzLnNwbGljZShub2RlUG9zc2l0aW9uLCB0aGlzLl9ub2Rlcy5sZW5ndGggLSBub2RlUG9zc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0aW5nIHRoaXMuX2FsbERhdGEgYWNjb3JkaW5nIHRvIHRoZSBuZXcgdGhpcy5fbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gdGhpcy5fYWxsRGF0YVtpXTtcbiAgICAgIGlmIChjdXJyZW50RGF0YS5fZnJvbSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnREYXRhLl9mcm9tICE9PSAtMSAmJiBjdXJyZW50RGF0YS5fZnJvbSAhPT0gLTIpIHtcbiAgICAgICAgY3VycmVudERhdGEuX2Zyb20gPSBuZXdJbmRpY2VzW2N1cnJlbnREYXRhLl9mcm9tXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyZW50RGF0YS5fdG8ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGN1cnJlbnREYXRhLl90b1tqXSA+PSAwKSB7XG4gICAgICAgICAgY3VycmVudERhdGEuX3RvW2pdID0gbmV3SW5kaWNlc1tjdXJyZW50RGF0YS5fdG9bal1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHVwZGF0ZSBhIHJlbW92ZWQgbm9kZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gMDtcbiAgICAvLyBkZWxldGUgYWxsIHZhbHVlcyB0aGF0IGFyZSBub3QgYmVpbmcgcmVmZXJlbmNlZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWxsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBuZWl0aGVyIGxpbmtlZCB0byBuZXh0IG5vZGUsIG5vciBhbiBvdXRwdXQgdmFsdWUsIHJlbW92ZSBpdC5cbiAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2ldLmZyb20gPT09IC0yICYmIHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KSA9PT0gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIHRoaXMuX2FsbERhdGEuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgbGV0IGluZCA9IC0xO1xuICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIG5laXRoZXIgYW4gaW5wdXQgdmFsdWUgbm9yIGFuIGluaXRpYWxpemVyLCBmaW5kIHRoZSBub2RlIGl0J3NcbiAgICAgICAgLy8gY29taW5nIGZyb20gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBub2RlIG91dHB1dFxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fYWxsRGF0YVtpXS5mcm9tICE9PSAtMSkge1xuICAgICAgICAgIGluZCA9IHRoaXMuX25vZGVzW3RoaXMuX2FsbERhdGFbaV0uZnJvbV0ub3V0cHV0cy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2ldLmZyb21dLm91dHB1dHNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgYW4gaW5wdXQgdmFsdWUsIHVwZGF0ZSBpdHMgcmVmZXJlbmNlIGluIGlucHV0SW5kaWNlc1xuICAgICAgICAgIGluZCA9IHRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxJbnB1dEluZGljZXNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbm9kZSB0aGF0IHRoZSBjdXJyZW50IHZhbHVlIGlzIGxpbmtpbmcgdG8gYW5kIHVwZGF0ZSBpdHMgaW5wdXQgcmVmZXJlbmNlXG4gICAgICAgIHRoaXMuX2FsbERhdGFbaV0udG8uZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIGluZCA9IHRoaXMuX25vZGVzW25vZGVdLmlucHV0cy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1tub2RlXS5pbnB1dHNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbaV0udG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBhIGdyYXBoIG91dHB1dCwgdXBkYXRlIGl0cyByZWZlcmVuY2UgaW4gb3V0cHV0SW5kaWNlc1xuICAgICAgICAgIGluZCA9IHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tpbmRdID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHRoZSBzcGVjaWZpZWQgbm9kZS4gQXNzdW1lIHRoZSBub2RlIGhhcyBvbmUgaW5jb21pbmcgaW5wdXQgYW5kIHRoZSBmaXJzdCBvdXRwdXQgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzLlxuICAgKiBBbiBpbnB1dCB2YWxpZGF0aW9uIG11c3QgYmUgZG9uZSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gbm9kZUluZGV4IFRoZSBpbmRleCBvZiBub2RlIHRvIGJlIGRlbGV0ZWRcbiAgICovXG4gIHByaXZhdGUgZGVsZXRlTm9kZShub2RlSW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlLm91dHB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbbm9kZS5vdXRwdXRzW2ldXS50by5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGRlbGV0aW9uIHdpdGggbW9yZSB0aGFuIG9uZSBvdXRwdXQgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzIGlzIG5vdCBzdXBwb3J0ZWQuICcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBub2RlIHdpbCBub3QgYmUgZXhlY3V0ZWRcbiAgICBub2RlLmV4ZWN1dGVOb2RlID0gZmFsc2U7XG4gICAgY29uc3QgaW5wdXRWYWx1ZUluZGV4ID0gbm9kZS5pbnB1dHNbMF07XG4gICAgY29uc3Qgb3V0cHV0VmFsdWVJbmRleCA9IG5vZGUub3V0cHV0c1swXTtcbiAgICBjb25zdCBub2Rlc0NvbnN1bWluZ091dHB1dCA9IHRoaXMuX2FsbERhdGFbb3V0cHV0VmFsdWVJbmRleF0udG87XG5cbiAgICAvLyByZW1vdmUgdGhpcyBub2RlIGZyb20gdGhlIHRvIHByb3BlcnR5IG9mIHRoZSBpbnB1dCBWYWx1ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlbEluZGV4ID0gdGhpcy5fYWxsRGF0YVtub2RlLmlucHV0c1tpXV0udG8uaW5kZXhPZihub2RlSW5kZXgpO1xuICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgIGlmIChkZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtub2RlLmlucHV0c1tpXV0udG8uc3BsaWNlKGRlbEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBub2RlIGluZGljZXMgY29uc3VtaW5nIHRoaXMgb3V0cHV0IFZhbHVlXG4gICAgdGhpcy5fYWxsRGF0YVtvdXRwdXRWYWx1ZUluZGV4XS5fdG8gPSBbXTtcblxuICAgIC8vIGlmIHRoZSBvdXRwdXQgb2YgdGhpcyBub2RlIGlzIGEgZ3JhcGggb3V0cHV0LCBhZGp1c3QgdGhlIGluZGV4IGFwcHJvcHJpYXRlbHlcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihvdXRwdXRWYWx1ZUluZGV4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW2luZGV4XSA9IGlucHV0VmFsdWVJbmRleDtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgaW5wdXRzIGZvciBub2RlcyBjb25zdW1pbmcgdGhpcyBub2RlJ3Mgb3V0cHV0IHdpdGggdGhlIGlucHV0IHRvIHRoaXMgbm9kZVxuICAgIGlmIChub2Rlc0NvbnN1bWluZ091dHB1dCAmJiBub2Rlc0NvbnN1bWluZ091dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVJbmRleCBvZiBub2Rlc0NvbnN1bWluZ091dHB1dCkge1xuICAgICAgICBjb25zdCByZXBsYWNlSW5kZXggPSB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdLmlucHV0cy5pbmRleE9mKG91dHB1dFZhbHVlSW5kZXgpO1xuICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICBpZiAocmVwbGFjZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdLmlucHV0c1tyZXBsYWNlSW5kZXhdID0gaW5wdXRWYWx1ZUluZGV4O1xuICAgICAgICB0aGlzLl9hbGxEYXRhW2lucHV0VmFsdWVJbmRleF0udG8ucHVzaChub2RlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFsbERyb3BvdXROb2RlcygpIHtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIC8vIHdlZWQgb3V0ICdEcm9wb3V0JyBub2RlcyBzbyB0aGF0IG5vIHRpbWUgaXMgd2FzdGVkIGluIGV4ZWN1dGlvblxuICAgICAgaWYgKG5vZGUub3BUeXBlID09PSAnRHJvcG91dCcpIHtcbiAgICAgICAgLy8gdGhlIG5vZGUgc2hvdWxkIGhhdmUgZXhhY3RseSAxIGlucHV0IGFuZCAxIG9yIDIgb3V0cHV0c1xuICAgICAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wb3V0IG5vZGVzIHNob3VsZCBvbmx5IGNvbnRhaW4gb25lIGlucHV0LiAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCAhPT0gMSAmJiBub2RlLm91dHB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IGFueSBvdGhlciBub2RlXG4gICAgICAgIGlmIChub2RlLm91dHB1dHMubGVuZ3RoID09PSAyICYmIHRoaXMuX2FsbERhdGFbbm9kZS5vdXRwdXRzWzFdXS5fdG8ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZXRlTm9kZShub2RlSW5kZXgpO1xuICAgICAgfVxuICAgICAgbm9kZUluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpIHtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIC8vIHdlZWQgb3V0ICdJZGVudGl0eScgbm9kZXMgc28gdGhhdCBubyB0aW1lIGlzIHdhc3RlZCBpbiBleGVjdXRpb25cbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0lkZW50aXR5Jykge1xuICAgICAgICB0aGlzLmRlbGV0ZU5vZGUobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIGlzQWN0aXZhdGlvbihuOiBOb2RlKTogYm9vbGVhbiB7XG4gICAgc3dpdGNoIChuLm9wVHlwZSkge1xuICAgICAgLy8gVE9ETzogYWRkIG90aGVyIGFjdGl2YXRpb24gbWV0aG9kc1xuICAgICAgY2FzZSAnUmVsdSc6XG4gICAgICBjYXNlICdTaWdtb2lkJzpcbiAgICAgIGNhc2UgJ0NsaXAnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdXNlQ29udkFjdGl2YXRpb25Ob2RlcygpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0NvbnYnKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1swXV0uX3RvO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPT09IDEgJiYgdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbbmV4dFswXV0pKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9ub2Rlc1tuZXh0WzBdXTtcbiAgICAgICAgICBpZiAoY2hpbGQub3BUeXBlID09PSAnQ2xpcCcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pbnB1dHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnYWN0aXZhdGlvbl9wYXJhbXMnLCAnZmxvYXRzJywgW1xuICAgICAgICAgICAgICAgICAgY2hpbGQuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWluJyksXG4gICAgICAgICAgICAgICAgICBjaGlsZC5hdHRyaWJ1dGVzLmdldEZsb2F0KCdtYXgnKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5zZXQoJ2FjdGl2YXRpb25fcGFyYW1zJywgJ2Zsb2F0cycsIFtNSU5fQ0xJUCwgTUFYX0NMSVBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgY2hpbGQuaW5wdXRzLmxlbmd0aCA+PSAzICYmXG4gICAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzFdXS50ZW5zb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICB0aGlzLl9hbGxEYXRhW2NoaWxkLmlucHV0c1syXV0udGVuc29yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLCBbXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsRGF0YVtjaGlsZC5pbnB1dHNbMV1dLnRlbnNvciEuZmxvYXREYXRhWzBdLFxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzJdXS50ZW5zb3IhLmZsb2F0RGF0YVswXSxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBTa2lwIGZ1c2lvbiB3aXRoIGNsaXAgbm9kZSBzaW5jZSBjbGlwIG1pbiBhbmQgY2xpcCBtYXggYXJlIG5vdCBjb21pbmcgZnJvbSBpbml0aWFsaXplclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnYWN0aXZhdGlvbicsICdzdHJpbmcnLCBjaGlsZC5vcFR5cGUpO1xuICAgICAgICAgIHRoaXMuZGVsZXRlTm9kZShuZXh0WzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBmbGF0YnVmZmVycyB9IGZyb20gJ2ZsYXRidWZmZXJzJztcblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IE9wU2V0IH0gZnJvbSAnLi9vcHNldCc7XG5pbXBvcnQgeyBvbm54cnVudGltZSB9IGZyb20gJy4vb3J0LXNjaGVtYS9mbGF0YnVmZmVycy9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCB7IG9ubnggfSBmcm9tICcuL29ydC1zY2hlbWEvcHJvdG9idWYvb25ueCc7XG5pbXBvcnQgeyBMb25nVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgY2xhc3MgTW9kZWwge1xuICAvLyBlbXB0eSBtb2RlbFxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgbG9hZChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplciwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IG9ubnhFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG4gICAgaWYgKCFpc09ydEZvcm1hdCkge1xuICAgICAgLy8gaXNPcnRGb3JtYXQgPT09IGZhbHNlIHx8IGlzT3J0Rm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KGJ1ZiwgZ3JhcGhJbml0aWFsaXplcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzT3J0Rm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIG9ubnhFcnJvciA9IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9hZEZyb21PcnRGb3JtYXQoYnVmLCBncmFwaEluaXRpYWxpemVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNPcnRGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gVHJpZWQgYm90aCBmb3JtYXRzIGFuZCBmYWlsZWQgKHdoZW4gaXNPcnRGb3JtYXQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgbW9kZWwgYXMgT05OWCBmb3JtYXQ6ICR7b25ueEVycm9yfVxcbmFzIE9SVCBmb3JtYXQ6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT25ueEZvcm1hdChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcik6IHZvaWQge1xuICAgIGNvbnN0IG1vZGVsUHJvdG8gPSBvbm54Lk1vZGVsUHJvdG8uZGVjb2RlKGJ1Zik7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG1vZGVsUHJvdG8uaXJWZXJzaW9uKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHNldHMgPSBtb2RlbFByb3RvLm9wc2V0SW1wb3J0Lm1hcCgoaSkgPT4gKHtcbiAgICAgIGRvbWFpbjogaS5kb21haW4gYXMgc3RyaW5nLFxuICAgICAgdmVyc2lvbjogTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKGkudmVyc2lvbiEpLFxuICAgIH0pKTtcblxuICAgIHRoaXMuX2dyYXBoID0gR3JhcGguZnJvbShtb2RlbFByb3RvLmdyYXBoISwgZ3JhcGhJbml0aWFsaXplcik7XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT3J0Rm9ybWF0KGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgY29uc3QgZmIgPSBuZXcgZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcihidWYpO1xuICAgIGNvbnN0IG9ydE1vZGVsID0gb3J0RmJzLkluZmVyZW5jZVNlc3Npb24uZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihmYikubW9kZWwoKSE7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG9ydE1vZGVsLmlyVmVyc2lvbigpKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG4gICAgdGhpcy5fb3BzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcnRNb2RlbC5vcHNldEltcG9ydExlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IG9wc2V0SWQgPSBvcnRNb2RlbC5vcHNldEltcG9ydChpKSE7XG4gICAgICB0aGlzLl9vcHNldHMucHVzaCh7IGRvbWFpbjogb3BzZXRJZD8uZG9tYWluKCkgYXMgc3RyaW5nLCB2ZXJzaW9uOiBMb25nVXRpbC5sb25nVG9OdW1iZXIob3BzZXRJZC52ZXJzaW9uKCkhKSB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9ncmFwaCA9IEdyYXBoLmZyb20ob3J0TW9kZWwuZ3JhcGgoKSEsIGdyYXBoSW5pdGlhbGl6ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ3JhcGg6IEdyYXBoO1xuICBnZXQgZ3JhcGgoKTogR3JhcGgge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaDtcbiAgfVxuXG4gIHByaXZhdGUgX29wc2V0czogT3BTZXRbXTtcbiAgZ2V0IG9wc2V0cygpOiByZWFkb25seSBPcFNldFtdIHtcbiAgICByZXR1cm4gdGhpcy5fb3BzZXRzO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IHJlc29sdmVCYWNrZW5kLCBTZXNzaW9uSGFuZGxlclR5cGUgfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHsgRXhlY3V0aW9uUGxhbiB9IGZyb20gJy4vZXhlY3V0aW9uLXBsYW4nO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IFByb2ZpbGVyIH0gZnJvbSAnLi9pbnN0cnVtZW50JztcbmltcG9ydCB7IE1vZGVsIH0gZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG4gICAgcHJvZmlsZXI/OiBQcm9maWxlci5Db25maWc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIENvbnRleHQge1xuICAgIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj47XG4gICAgZ3JhcGhJbnB1dFR5cGVzPzogVGVuc29yLkRhdGFUeXBlW107XG4gICAgZ3JhcGhJbnB1dERpbXM/OiBBcnJheTxyZWFkb25seSBudW1iZXJbXT47XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWc6IFNlc3Npb24uQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2VuZEhpbnQgPSBjb25maWcuYmFja2VuZEhpbnQ7XG4gICAgdGhpcy5wcm9maWxlciA9IFByb2ZpbGVyLmNyZWF0ZShjb25maWcucHJvZmlsZXIpO1xuICAgIHRoaXMuY29udGV4dCA9IHsgcHJvZmlsZXI6IHRoaXMucHJvZmlsZXIsIGdyYXBoSW5wdXRUeXBlczogW10sIGdyYXBoSW5wdXREaW1zOiBbXSB9O1xuICB9XG5cbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7XG4gIH1cbiAgZ2V0IG91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCkge1xuICAgIHRoaXMucHJvZmlsZXIuc3RhcnQoKTtcbiAgfVxuXG4gIGVuZFByb2ZpbGluZygpIHtcbiAgICB0aGlzLnByb2ZpbGVyLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbCh1cmk6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGxvYWRNb2RlbChidWZmZXI6IEFycmF5QnVmZmVyLCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBsb2FkTW9kZWwoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcbiAgYXN5bmMgbG9hZE1vZGVsKGFyZzogc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBVaW50OEFycmF5LCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ubG9hZE1vZGVsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVzb2x2ZSBiYWNrZW5kIGFuZCBzZXNzaW9uIGhhbmRsZXJcbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZCh0aGlzLmJhY2tlbmRIaW50KTtcbiAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIgPSBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyKHRoaXMuY29udGV4dCk7XG5cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgaXNPcnRGb3JtYXQgPSBhcmcuZW5kc1dpdGgoJy5vcnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgICAgIC8vIG5vZGVcbiAgICAgICAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG4gICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVhZEZpbGUoYXJnKTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemUoYnVmLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXJnKTtcbiAgICAgICAgICBjb25zdCBidWYgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShidWYpLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhhcmcpKSB7XG4gICAgICAgIC8vIGxvYWQgbW9kZWwgZnJvbSBBcnJheUJ1ZmZlclxuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhcmcsIGJ5dGVPZmZzZXQgfHwgMCwgbGVuZ3RoIHx8IGFyZy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIG1vZGVsIGZyb20gVWludDhhcnJheVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShtb2RlbFByb3RvQmxvYjogVWludDhBcnJheSwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIC8vIGxvYWQgZ3JhcGhcbiAgICAgIGNvbnN0IGdyYXBoSW5pdGlhbGl6ZXIgPSB0aGlzLnNlc3Npb25IYW5kbGVyLnRyYW5zZm9ybUdyYXBoXG4gICAgICAgID8gKHRoaXMuc2Vzc2lvbkhhbmRsZXIgYXMgR3JhcGguSW5pdGlhbGl6ZXIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fbW9kZWwubG9hZChtb2RlbFByb3RvQmxvYiwgZ3JhcGhJbml0aWFsaXplciwgaXNPcnRGb3JtYXQpO1xuXG4gICAgICAvLyBncmFwaCBpcyBjb21wbGV0ZWx5IGluaXRpYWx6aWVkIGF0IHRoaXMgc3RhZ2UgLCBsZXQgdGhlIGludGVyZXN0ZWQgaGFuZGxlcnMga25vd1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWxpemUgZWFjaCBvcGVyYXRvciBpbiB0aGUgZ3JhcGhcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCk7XG5cbiAgICAgIC8vIGluc3RhbnRpYXRlIGFuIEV4ZWN1dGlvblBsYW4gb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhlIFNlc3Npb24gb2JqZWN0XG4gICAgICB0aGlzLl9leGVjdXRpb25QbGFuID0gbmV3IEV4ZWN1dGlvblBsYW4odGhpcy5fbW9kZWwuZ3JhcGgsIHRoaXMuX29wcywgdGhpcy5wcm9maWxlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBydW4oaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+IHwgVGVuc29yW10pOiBQcm9taXNlPE1hcDxzdHJpbmcsIFRlbnNvcj4+IHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ucnVuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRUZW5zb3JzID0gdGhpcy5ub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBvdXRwdXRUZW5zb3JzID0gYXdhaXQgdGhpcy5fZXhlY3V0aW9uUGxhbi5leGVjdXRlKHRoaXMuc2Vzc2lvbkhhbmRsZXIsIGlucHV0VGVuc29ycyk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU91dHB1dChvdXRwdXRUZW5zb3JzKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHMoaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+IHwgVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgbW9kZWxJbnB1dE5hbWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO1xuXG4gICAgLy8gbm9ybWFsaXplIGlucHV0c1xuICAgIC8vIGlucHV0czogVGVuc29yW11cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gbW9kZWxJbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7bW9kZWxJbnB1dE5hbWVzLmxlbmd0aH0gYnV0IGdvdCAke2lucHV0cy5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgbWFwIHRvIGFycmF5XG4gICAgLy8gaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5wdXRzLnNpemUgIT09IG1vZGVsSW5wdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgbWFwIHNpemU6IGV4cGVjdGVkICR7bW9kZWxJbnB1dE5hbWVzLmxlbmd0aH0gYnV0IGdvdCAke2lucHV0cy5zaXplfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzb3J0ZWRJbnB1dHMgPSBuZXcgQXJyYXk8VGVuc29yPihpbnB1dHMuc2l6ZSk7XG4gICAgICBsZXQgc29ydGVkSW5wdXRzSW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbElucHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGVuc29yID0gaW5wdXRzLmdldChtb2RlbElucHV0TmFtZXNbaV0pO1xuICAgICAgICBpZiAoIXRlbnNvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCB0ZW5zb3IgZm9yOiAnJHtuYW1lfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0ZWRJbnB1dHNbc29ydGVkSW5wdXRzSW5kZXgrK10gPSB0ZW5zb3I7XG4gICAgICB9XG5cbiAgICAgIGlucHV0cyA9IHNvcnRlZElucHV0cztcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1zIHJlcXVpcmVtZW50c1xuICAgIC8vIEZpcnN0IHNlc3Npb24gcnVuIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBub3QgY2FjaGVkIGZvciB0aGUgc2Vzc2lvblxuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzIHx8XG4gICAgICB0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgIXRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyB8fFxuICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgY29uc3QgbW9kZWxJbnB1dEluZGljZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0VmFsdWVzKCk7XG5cbiAgICAgIGNvbnN0IGdyYXBoSW5wdXREaW1zID0gbmV3IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPihtb2RlbElucHV0SW5kaWNlcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsSW5wdXRJbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoSW5wdXQgPSBtb2RlbFZhbHVlc1ttb2RlbElucHV0SW5kaWNlc1tpXV07XG4gICAgICAgIGdyYXBoSW5wdXREaW1zW2ldID0gZ3JhcGhJbnB1dC50eXBlIS5zaGFwZS5kaW1zO1xuXG4gICAgICAgIC8vIGNhY2hlZCBmb3Igc2Vjb25kIGFuZCBzdWJzZXF1ZW50IHJ1bnMuXG4gICAgICAgIC8vIFNvbWUgcGFydHMgb2YgdGhlIGZyYW1ld29yayB3b3JrcyBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSBncmFwaCBhbmQgdHlwZXMgYW5kIHNoYXBlcyBhcmUgc3RhdGljXG4gICAgICAgIHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMhLnB1c2goZ3JhcGhJbnB1dC50eXBlIS50ZW5zb3JUeXBlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zIS5wdXNoKGlucHV0c1tpXS5kaW1zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyhncmFwaElucHV0RGltcywgaW5wdXRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgYW5kIHN1YnNlcXVlbnQgc2Vzc2lvbiBydW5zIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBjYWNoZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcywgaW5wdXRzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgdHlwZXMgcmVxdWlyZW1lbnRcbiAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzISwgaW5wdXRzKTtcblxuICAgIHJldHVybiBpbnB1dHM7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyhncmFwaElucHV0VHlwZXM6IFRlbnNvci5EYXRhVHlwZVtdLCBnaXZlbklucHV0czogVGVuc29yW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdpdmVuSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBncmFwaElucHV0VHlwZXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZ2l2ZW5JbnB1dHNbaV0udHlwZTtcbiAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGFjdHVhbFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtpfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCB0eXBlICcke2V4cGVjdGVkVHlwZX0nIGJ1dCBnb3QgJHthY3R1YWxUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbnB1dFRlbnNvckRpbXMoXG4gICAgZ3JhcGhJbnB1dERpbXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPixcbiAgICBnaXZlbklucHV0czogVGVuc29yW10sXG4gICAgbm9uZURpbVN1cHBvcnRlZDogYm9vbGVhbixcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnaXZlbklucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwZWN0ZWREaW1zID0gZ3JhcGhJbnB1dERpbXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxEaW1zID0gZ2l2ZW5JbnB1dHNbaV0uZGltcztcbiAgICAgIGlmICghdGhpcy5jb21wYXJlVGVuc29yRGltcyhleHBlY3RlZERpbXMsIGFjdHVhbERpbXMsIG5vbmVEaW1TdXBwb3J0ZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgaW5wdXQgdGVuc29yWyR7aX1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgc2hhcGUgJ1ske2V4cGVjdGVkRGltcy5qb2luKCcsJyl9XScgYnV0IGdvdCBbJHthY3R1YWxEaW1zLmpvaW4oXG4gICAgICAgICAgICAnLCcsXG4gICAgICAgICAgKX1dYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbXBhcmVUZW5zb3JEaW1zKFxuICAgIGV4cGVjdGVkRGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYWN0dWFsRGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgbm9uZURpbVN1cHBvcnRlZDogYm9vbGVhbixcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKGV4cGVjdGVkRGltcy5sZW5ndGggIT09IGFjdHVhbERpbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZERpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChleHBlY3RlZERpbXNbaV0gIT09IGFjdHVhbERpbXNbaV0gJiYgKCFub25lRGltU3VwcG9ydGVkIHx8IGV4cGVjdGVkRGltc1tpXSAhPT0gMCkpIHtcbiAgICAgICAgLy8gZGF0YSBzaGFwZSBtaXMtbWF0Y2ggQU5EIG5vdCBhICdOb25lJyBkaW1lbnNpb24uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlT3V0cHV0KG91dHB1dFRlbnNvcnM6IFRlbnNvcltdKTogTWFwPHN0cmluZywgVGVuc29yPiB7XG4gICAgY29uc3QgbW9kZWxPdXRwdXROYW1lcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gICAgaWYgKG91dHB1dFRlbnNvcnMubGVuZ3RoICE9PSBtb2RlbE91dHB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IE1hcDxzdHJpbmcsIFRlbnNvcj4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsT3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG91dHB1dC5zZXQobW9kZWxPdXRwdXROYW1lc1tpXSwgb3V0cHV0VGVuc29yc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZU9wcyhncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgdGhpcy5fb3BzID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vcHNbaV0gPSB0aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUobm9kZXNbaV0sIHRoaXMuX21vZGVsLm9wc2V0cywgZ3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX21vZGVsOiBNb2RlbDtcbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3BzOiBPcGVyYXRvcltdO1xuICBwcml2YXRlIF9leGVjdXRpb25QbGFuOiBFeGVjdXRpb25QbGFuO1xuXG4gIHByaXZhdGUgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzZXNzaW9uSGFuZGxlcjogU2Vzc2lvbkhhbmRsZXJUeXBlO1xuICBwcml2YXRlIGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dDtcbiAgcHJpdmF0ZSBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uLCBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciwgU2Vzc2lvbkhhbmRsZXIsIFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb24nO1xuaW1wb3J0IHsgVGVuc29yIGFzIE9ubnhqc1RlbnNvciB9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGNsYXNzIE9ubnhqc1Nlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlc3Npb246IFNlc3Npb24pIHtcbiAgICB0aGlzLmlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb24uaW5wdXROYW1lcztcbiAgICB0aGlzLm91dHB1dE5hbWVzID0gdGhpcy5zZXNzaW9uLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHt9XG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFzeW5jIHJ1bihcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIF9mZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBfb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBjb25zdCBpbnB1dE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBPbm54anNUZW5zb3I+KCk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGZlZWRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZmVlZHMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZlZWQgPSBmZWVkc1tuYW1lXTtcbiAgICAgICAgaW5wdXRNYXAuc2V0KFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbmV3IE9ubnhqc1RlbnNvcihcbiAgICAgICAgICAgIGZlZWQuZGltcyxcbiAgICAgICAgICAgIGZlZWQudHlwZSBhcyBPbm54anNUZW5zb3IuRGF0YVR5cGUsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBmZWVkLmRhdGEgYXMgT25ueGpzVGVuc29yLk51bWJlclR5cGUsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0TWFwID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihpbnB1dE1hcCk7XG4gICAgY29uc3Qgb3V0cHV0OiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgb3V0cHV0TWFwLmZvckVhY2goKHRlbnNvciwgbmFtZSkgPT4ge1xuICAgICAgb3V0cHV0W25hbWVdID0gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIHRlbnNvci5kaW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24uZW5kUHJvZmlsaW5nKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cbmltcG9ydCB7IEJhY2tlbmQsIEluZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4vb25ueGpzL3Nlc3Npb24nO1xuaW1wb3J0IHsgT25ueGpzU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlJztcblxuY2xhc3MgT25ueGpzQmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIC8vIE5PVEU6IFNlc3Npb24uQ29uZmlnKGZyb20gb25ueC5qcykgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKGZyb21cbiAgICAvLyBvbm54cnVudGltZS1jb21tb24pLlxuICAgIC8vICAgICAgIEluIGZ1dHVyZSB3ZSBzaG91bGQgcmVtb3ZlIFNlc3Npb24uQ29uZmlnIGFuZCB1c2UgSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucy5cbiAgICAvLyAgICAgICBDdXJyZW50bHkgd2UgYWxsb3cgdGhpcyB0byBoYXBwZW4gdG8gbWFrZSB0ZXN0IHJ1bm5lciB3b3JrLlxuICAgIGNvbnN0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbihvcHRpb25zIGFzIHVua25vd24gYXMgU2Vzc2lvbi5Db25maWcpO1xuXG4gICAgLy8gdHlwZXNjcmlwdCBjYW5ub3QgbWVyZ2UgbWV0aG9kIG92ZXJyaWRlIGNvcnJlY3RseSAoc28gZmFyIGluIDQuMi4zKS4gbmVlZCBpZi1lbHNlIHRvIGNhbGwgdGhlIG1ldGhvZC5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF3YWl0IHNlc3Npb24ubG9hZE1vZGVsKHBhdGhPckJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHNlc3Npb24ubG9hZE1vZGVsKHBhdGhPckJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPbm54anNTZXNzaW9uSGFuZGxlcihzZXNzaW9uKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb25ueGpzQmFja2VuZCA9IG5ldyBPbm54anNCYWNrZW5kKCk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAhISh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJ3ZWJ3b3JrZXJcIiAvPlxuXG4vL1xuLy8gKiB0eXBlIGhhY2sgZm9yIFwiSFRNTEltYWdlRWxlbWVudFwiXG4vL1xuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJIVE1MSW1hZ2VFbGVtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHdoaWNoIGlzIGNvbmZsaWN0IHdpdGggbGliLndlYndvcmtlci5kLnRzLlxuLy8gd2hlbiB3ZSB1c2Ugd2Vid29ya2VyLCB0aGUgbGliLndlYndvcmtlci5kLnRzIHdpbGwgYmUgdXNlZCwgd2hpY2ggZG9lcyBub3QgaGF2ZSBIVE1MSW1hZ2VFbGVtZW50IGRlZmluZWQuXG4vL1xuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBIVE1MSW1hZ2VFbGVtZW50IGlzIG5vdCBkZWZpbmVkOlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gLi4vY29tbW9uL2Rpc3QvY2pzL3RlbnNvci1mYWN0b3J5LmQudHM6MTg3OjI5IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gMTg3ICAgICBmcm9tSW1hZ2UoaW1hZ2VFbGVtZW50OiBIVE1MSW1hZ2VFbGVtZW50LCBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMpOlxuLy8gUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XG4vL1xuLy8gbm9kZV9tb2R1bGVzL0B3ZWJncHUvdHlwZXMvZGlzdC9pbmRleC5kLnRzOjgzOjcgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyA4MyAgICAgfCBIVE1MSW1hZ2VFbGVtZW50XG4vLyAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBgSFRNTEltYWdlRWxlbWVudGAgaXMgb25seSB1c2VkIGluIHR5cGUgZGVjbGFyYXRpb24gYW5kIG5vdCBpbiByZWFsIGNvZGUuIFNvIHdlIGRlZmluZSBpdCBhcyBgdW5rbm93bmAgaGVyZSB0b1xuLy8gYnlwYXNzIHRoZSB0eXBlIGNoZWNrLlxuXG4vL1xuLy8gKiB0eXBlIGhhY2sgZm9yIFwiZG9jdW1lbnRcIlxuLy9cbi8vIGluIHR5cGVzY3JpcHQsIHRoZSB0eXBlIG9mIFwiZG9jdW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgc28gaXQncyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IGRvY3VtZW50IGlzIG5vdCBkZWZpbmVkOlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6NzozMyAtIGVycm9yIFRTMjU4NDogQ2Fubm90IGZpbmQgbmFtZSAnZG9jdW1lbnQnLiBEbyB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB0YXJnZXRcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjYxIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxuLy8gbGlicmFyeT8gVHJ5IGNoYW5naW5nIHRoZSAnbGliJyBjb21waWxlciBvcHRpb24gdG8gaW5jbHVkZSAnZG9tJy5cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3Ojg4IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MU2NyaXB0RWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+flxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBgZG9jdW1lbnRgIGlzIHVzZWQgdG8gZ2V0IHRoZSBjdXJyZW50IHNjcmlwdCBVUkwsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLiBUaGlzIGZpbGUgaXMgc2VydmVkIGFzIGFcbi8vIFwiZHVhbFwiIGZpbGUgZm9yIGVudHJpZXMgb2YgYm90aCB3ZWJ3b3JrZXIgYW5kIHRoZSBlc20gbW9kdWxlLlxuLy9cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgdHlwZSBIVE1MSW1hZ2VFbGVtZW50ID0gdW5rbm93bjtcbiAgdHlwZSBIVE1MU2NyaXB0RWxlbWVudCA9IHsgc3JjPzogc3RyaW5nIH07XG4gIGNvbnN0IGRvY3VtZW50OiB1bmRlZmluZWQgfCB7IGN1cnJlbnRTY3JpcHQ/OiBIVE1MU2NyaXB0RWxlbWVudCB9O1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKlxuICogVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhIFwiZHVhbFwiIGZpbGUgZm9yIGJvdGggZW50cmllcyBvZiB0aGUgZm9sbG93aW5nOlxuICogLSBUaGUgcHJveHkgd29ya2VyIGl0c2VsZi5cbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIsIGl0IGxpc3RlbnMgdG8gdGhlIG1lc3NhZ2VzIGZyb20gdGhlIG1haW4gdGhyZWFkIGFuZCBwZXJmb3JtcyB0aGUgY29ycmVzcG9uZGluZyBvcGVyYXRpb25zLlxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCBkaXJlY3RseSB1c2luZyBgbmV3IFdvcmtlcigpYCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogLSBUaGUgRVNNIG1vZHVsZSB0aGF0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciAoYXMgYSB3b3JrZXIgbGF1bmNoZXIpLlxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciBsYXVuY2hlciwgaXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIGFuZCByZXR1cm5zIGl0LlxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCB1c2luZyBgaW1wb3J0KClgIGluIHRoZSBtYWluIHRocmVhZCwgd2l0aCB0aGUgcXVlcnkgcGFyYW1ldGVyIGBpbXBvcnQ9MWAuXG4gKlxuICogVGhpcyBmaWxlIHdpbGwgYmUgYWx3YXlzIGNvbXBpbGluZyBpbnRvIEVTTSBmb3JtYXQuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTWVzc2FnZSwgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEgfSBmcm9tICcuLi9wcm94eS1tZXNzYWdlcy5qcyc7XG5pbXBvcnQge1xuICBjcmVhdGVTZXNzaW9uLFxuICBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLFxuICBlbmRQcm9maWxpbmcsXG4gIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzLFxuICBpbml0RXAsXG4gIGluaXRSdW50aW1lLFxuICByZWxlYXNlU2Vzc2lvbixcbiAgcnVuLFxufSBmcm9tICcuLi93YXNtLWNvcmUtaW1wbC5qcyc7XG5pbXBvcnQgeyBpbml0aWFsaXplV2ViQXNzZW1ibHkgfSBmcm9tICcuLi93YXNtLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgc2NyaXB0U3JjIH0gZnJvbSAnLi4vd2FzbS11dGlscy1pbXBvcnQuanMnO1xuXG5jb25zdCBXT1JLRVJfTkFNRSA9ICdvcnQtd2FzbS1wcm94eS13b3JrZXInO1xuY29uc3QgaXNQcm94eVdvcmtlciA9IGdsb2JhbFRoaXMuc2VsZj8ubmFtZSA9PT0gV09SS0VSX05BTUU7XG5cbmlmIChpc1Byb3h5V29ya2VyKSB7XG4gIC8vIFdvcmtlciB0aHJlYWRcbiAgc2VsZi5vbm1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGluOiBtZXNzYWdlIH0gPSBldi5kYXRhO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgICAgICBpbml0aWFsaXplV2ViQXNzZW1ibHkobWVzc2FnZSEud2FzbSkudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgaW5pdFJ1bnRpbWUobWVzc2FnZSEpLnRoZW4oXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0LWVwJzoge1xuICAgICAgICAgIGNvbnN0IHsgZXBOYW1lLCBlbnYgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGluaXRFcChlbnYsIGVwTmFtZSkudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29weS1mcm9tJzoge1xuICAgICAgICAgIGNvbnN0IHsgYnVmZmVyIH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBjb25zdCBidWZmZXJEYXRhID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBidWZmZXJEYXRhIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcbiAgICAgICAgICBjb25zdCB7IG1vZGVsLCBvcHRpb25zIH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBjcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKS50aGVuKFxuICAgICAgICAgICAgKHNlc3Npb25NZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIG91dDogc2Vzc2lvbk1ldGFkYXRhIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgICAgcmVsZWFzZVNlc3Npb24obWVzc2FnZSEpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnVuJzoge1xuICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgcnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG5ldyBBcnJheShvdXRwdXRJbmRpY2VzLmxlbmd0aCkuZmlsbChudWxsKSwgb3B0aW9ucykudGhlbihcbiAgICAgICAgICAgIChvdXRwdXRzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChvdXRwdXRzLnNvbWUoKG8pID0+IG9bM10gIT09ICdjcHUnKSkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyOiAnUHJveHkgZG9lcyBub3Qgc3VwcG9ydCBub24tY3B1IHRlbnNvciBsb2NhdGlvbi4nIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgeyB0eXBlLCBvdXQ6IG91dHB1dHMgfSBhcyBPcnRXYXNtTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKFsuLi5pbnB1dHMsIC4uLm91dHB1dHNdIGFzIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VuZC1wcm9maWxpbmcnOlxuICAgICAgICAgIGVuZFByb2ZpbGluZyhtZXNzYWdlISk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3h5V29ya2VyXG4gID8gbnVsbFxuICA6ICh1cmxPdmVycmlkZT86IHN0cmluZykgPT5cbiAgICAgIG5ldyBXb3JrZXIodXJsT3ZlcnJpZGUgPz8gc2NyaXB0U3JjISwgeyB0eXBlOiBCVUlMRF9ERUZTLklTX0VTTSA/ICdtb2R1bGUnIDogJ2NsYXNzaWMnLCBuYW1lOiBXT1JLRVJfTkFNRSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuXG4vKipcbiAqIFRoZSBjbGFzc2ljIHNjcmlwdCBzb3VyY2UgVVJMLiBUaGlzIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIG5vbiBFU01vZHVsZSBlbnZpcm9ubWVudHMuXG4gKlxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPVxuICAvLyBpZiBOb2RlanMsIHJldHVybiB1bmRlZmluZWRcbiAgaXNOb2RlXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IC8vIGlmIEl0J3MgRVNNLCB1c2UgaW1wb3J0Lm1ldGEudXJsXG4gICAgICAoQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMID8/XG4gICAgICAvLyB1c2UgYGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjYCBpZiBhdmFpbGFibGVcbiAgICAgICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmNcbiAgICAgICAgOiAvLyB1c2UgYHNlbGYubG9jYXRpb24uaHJlZmAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgPyBzZWxmLmxvY2F0aW9uPy5ocmVmXG4gICAgICAgICAgOiB1bmRlZmluZWQpKTtcblxuLyoqXG4gKiBUaGUgb3JpZ2luIG9mIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5jb25zdCBvcmlnaW4gPSBpc05vZGUgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uLm9yaWdpbjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZmlsZW5hbWUgd2l0aCBwcmVmaXggaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXG4gKi9cbmNvbnN0IGlzU2FtZU9yaWdpbiA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5vcmlnaW4gPT09IG9yaWdpbjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXRzIHRvIGFuIGFic29sdXRlIFVSTCB3aXRoIHRoZSBnaXZlbiBwcmVmaXggb3ZlcnJpZGUuIElmIGZhaWxlZCwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgbm9ybWFsaXplVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhbGxiYWNrIFVSTCBpZiBhbiBhYnNvbHV0ZSBVUkwgY2Fubm90IGJlIGNyZWF0ZWQgYnkgdGhlIG5vcm1hbGl6ZVVybCBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZmFsbGJhY2tVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IGAke3ByZWZpeE92ZXJyaWRlID8/ICcuLyd9JHtmaWxlbmFtZX1gO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlbG9hZCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxuICpcbiAqIElmIHRoZSBvcmlnaW4gb2YgdGhlIHdvcmtlciBVUkwgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb3JpZ2luLCB0aGUgd29ya2VyIGNhbm5vdCBiZSBsb2FkZWQgZGlyZWN0bHkuXG4gKiBTZWUgZGlzY3Vzc2lvbnMgaW4gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93b3JrZXItbG9hZGVyL2lzc3Vlcy8xNTRcbiAqXG4gKiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgZmV0Y2ggdGhlIHdvcmtlciBVUkwgYW5kIGNyZWF0ZSBhIG5ldyBCbG9iIFVSTCB3aXRoIHRoZSBzYW1lIG9yaWdpbiBhcyBhIHdvcmthcm91bmQuXG4gKlxuICogQHBhcmFtIGFic29sdXRlVXJsIC0gVGhlIGFic29sdXRlIFVSTCB0byBwcmVsb2FkLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgQmxvYiBVUkxcbiAqL1xuY29uc3QgcHJlbG9hZCA9IGFzeW5jIChhYnNvbHV0ZVVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhYnNvbHV0ZVVybCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59O1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZHluYW1pY2FsbHkgaW1wb3J0IGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogVGhlIGJ1aWxkIHNjcmlwdCBoYXMgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhpcyBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCB0aGUgVVJMIGlzIG5vdCBidW5kbGVkIGludG8gdGhlIGZpbmFsIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBpbXBvcnQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqL1xuY29uc3QgZHluYW1pY0ltcG9ydERlZmF1bHQgPSBhc3luYyA8VD4odXJsOiBzdHJpbmcpOiBQcm9taXNlPFQ+ID0+XG4gIChhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyB1cmwpKS5kZWZhdWx0O1xuXG4vKipcbiAqIFRoZSBwcm94eSB3b3JrZXIgZmFjdG9yeSBpbXBvcnRlZCBmcm9tIHRoZSBwcm94eSB3b3JrZXIgbW9kdWxlLlxuICpcbiAqIFRoaXMgaXMgb25seSBhdmFpbGFibGUgd2hlbiB0aGUgV2ViQXNzZW1ibHkgcHJveHkgaXMgbm90IGRpc2FibGVkLlxuICovXG5jb25zdCBjcmVhdGVQcm94eVdvcmtlcjogKCh1cmxPdmVycmlkZT86IHN0cmluZykgPT4gV29ya2VyKSB8IHVuZGVmaW5lZCA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gIEJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZID8gdW5kZWZpbmVkIDogcmVxdWlyZSgnLi9wcm94eS13b3JrZXIvbWFpbicpLmRlZmF1bHQ7XG5cbi8qKlxuICogSW1wb3J0IHRoZSBwcm94eSB3b3JrZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAqIDEuIElmIGEgcHJlbG9hZCBpcyBuZWVkZWQsIGl0IHdpbGwgcHJlbG9hZCB0aGUgbW9kdWxlIGFuZCByZXR1cm4gdGhlIG9iamVjdCBVUkwuXG4gKiAyLiBVc2UgdGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgcHJveHkgd29ya2VyLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXG4gKiAgICAgICAgICAgIC0gVGhlIHByb3h5IHdvcmtlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGltcG9ydFByb3h5V29ya2VyID0gYXN5bmMgKCk6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgV29ya2VyXT4gPT4ge1xuICBpZiAoIXNjcmlwdFNyYykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC4nKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBzY3JpcHQgc291cmNlIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gdXNlIHRoZSBlbWJlZGRlZCBwcm94eSBtb2R1bGUgZGlyZWN0bHkuXG4gIGlmIChpc1NhbWVPcmlnaW4oc2NyaXB0U3JjKSkge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCBjcmVhdGVQcm94eVdvcmtlciEoKV07XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG5lZWQgdG8gcHJlbG9hZFxuICBjb25zdCB1cmwgPSBhd2FpdCBwcmVsb2FkKHNjcmlwdFNyYyk7XG4gIHJldHVybiBbdXJsLCBjcmVhdGVQcm94eVdvcmtlciEodXJsKV07XG59O1xuXG4vKipcbiAqIFRoZSBlbWJlZGRlZCBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKlxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBFU00gYW5kIHdoZW4gZW1iZWRkaW5nIGlzIG5vdCBkaXNhYmxlZC5cbiAqL1xuY29uc3QgZW1iZWRkZWRXYXNtTW9kdWxlOiBFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPiB8IHVuZGVmaW5lZCA9XG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRElTQUJMRV9EWU5BTUlDX0lNUE9SVFxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgIHJlcXVpcmUoXG4gICAgICAgICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxuICAgICAgICAgID8gJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcbiAgICAgICAgICA6ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJyxcbiAgICAgICkuZGVmYXVsdFxuICAgIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEltcG9ydCB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gKiAxLiBJZiBCVUlMRF9ERUZTLkRJU0FCTEVfRFlOQU1JQ19JTVBPUlQgaXMgdHJ1ZSwgdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUuXG4gKiAyLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxuICogMy4gT3RoZXJ3aXNlLCBpdCB3aWxsIHBlcmZvcm0gYSBkeW5hbWljIGltcG9ydCBvZiB0aGUgbW9kdWxlLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXG4gKiAgICAgICAgICAgIC0gVGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUsIHdoaWNoIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGltcG9ydFdhc21Nb2R1bGUgPSBhc3luYyAoXG4gIHVybE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHByZWZpeE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGlzTXVsdGlUaHJlYWRlZDogYm9vbGVhbixcbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XG4gIGlmIChCVUlMRF9ERUZTLkRJU0FCTEVfRFlOQU1JQ19JTVBPUlQpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgZW1iZWRkZWRXYXNtTW9kdWxlIV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FzbU1vZHVsZUZpbGVuYW1lID0gIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXG4gICAgICA/ICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzJ1xuICAgICAgOiAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnO1xuICAgIGNvbnN0IHdhc21Nb2R1bGVVcmwgPSB1cmxPdmVycmlkZSA/PyBub3JtYWxpemVVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSk7XG4gICAgLy8gbmVlZCB0byBwcmVsb2FkIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICAvLyAxLiBub3QgaW4gTm9kZS5qcy5cbiAgICAvLyAgICAtIE5vZGUuanMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gcG9saWN5IGZvciBjcmVhdGluZyB3b3JrZXJzLlxuICAgIC8vIDIuIG11bHRpLXRocmVhZGVkIGlzIGVuYWJsZWQuXG4gICAgLy8gICAgLSBJZiBtdWx0aS10aHJlYWRlZCBpcyBkaXNhYmxlZCwgbm8gd29ya2VyIHdpbGwgYmUgY3JlYXRlZC4gU28gd2UgZG9uJ3QgbmVlZCB0byBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gICAgLy8gMy4gdGhlIGFic29sdXRlIFVSTCBpcyBhdmFpbGFibGUuXG4gICAgLy8gICAgLSBJZiB0aGUgYWJzb2x1dGUgVVJMIGlzIGZhaWxlZCB0byBiZSBjcmVhdGVkLCB0aGUgb3JpZ2luIGNhbm5vdCBiZSBkZXRlcm1pbmVkLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgbm90XG4gICAgLy8gICAgcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAgIC8vIDQuIHRoZSB3b3JrZXIgVVJMIGlzIG5vdCBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAvLyAgICAtIElmIHRoZSB3b3JrZXIgVVJMIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gY3JlYXRlIHRoZSB3b3JrZXIgZGlyZWN0bHkuXG4gICAgY29uc3QgbmVlZFByZWxvYWQgPSAhaXNOb2RlICYmIGlzTXVsdGlUaHJlYWRlZCAmJiB3YXNtTW9kdWxlVXJsICYmICFpc1NhbWVPcmlnaW4od2FzbU1vZHVsZVVybCwgcHJlZml4T3ZlcnJpZGUpO1xuICAgIGNvbnN0IHVybCA9IG5lZWRQcmVsb2FkXG4gICAgICA/IGF3YWl0IHByZWxvYWQod2FzbU1vZHVsZVVybClcbiAgICAgIDogKHdhc21Nb2R1bGVVcmwgPz8gZmFsbGJhY2tVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSkpO1xuICAgIHJldHVybiBbbmVlZFByZWxvYWQgPyB1cmwgOiB1bmRlZmluZWQsIGF3YWl0IGR5bmFtaWNJbXBvcnREZWZhdWx0PEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+Pih1cmwpXTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7IGltcG9ydFdhc21Nb2R1bGUgfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxubGV0IHdhc206IE9ydFdhc21Nb2R1bGUgfCB1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcbmxldCBhYm9ydGVkID0gZmFsc2U7XG5cbmNvbnN0IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIC8vIElmICdTaGFyZWRBcnJheUJ1ZmZlcicgaXMgbm90IGF2YWlsYWJsZSwgV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdCB3b3JrLlxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgdHJhbnNmZXJhYmlsaXR5IG9mIFNBQnMgKGZvciBicm93c2Vycy4gbmVlZGVkIGZvciBGaXJlZm94KVxuICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFtc2cvbW96aWxsYS5kZXYucGxhdGZvcm0vSUhrQlpsSEVUcEEvZHdzTU5jaFdFUUFKXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSk7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgdGhyZWFkcyBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIHRocmVhZGVkIGluc3RydWN0aW9ucy5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUoXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgNCwgMSwgOTYsIDAsIDAsIDMsIDIsIDEsIDAsIDUsIDQsIDEsIDMsIDEsIDEsIDEwLCAxMSwgMSwgOSwgMCwgNjUsIDAsIDI1NCwgMTYsXG4gICAgICAgIDIsIDAsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgU0lNRCBpbnN0cnVjdGlvbnMuXG5cbiAgICAvLyBUaGUgYmluYXJ5IGRhdGEgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGZvbGxvd2luZyBjb2RlIGJ5IHdhdDJ3YXNtOlxuICAgIC8vXG4gICAgLy8gKG1vZHVsZVxuICAgIC8vICAgKHR5cGUgJHQwIChmdW5jKSlcbiAgICAvLyAgIChmdW5jICRmMCAodHlwZSAkdDApXG4gICAgLy8gICAgIChkcm9wXG4gICAgLy8gICAgICAgKGkzMng0LmRvdF9pMTZ4OF9zXG4gICAgLy8gICAgICAgICAoaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcbiAgICAvLyAgICAgICAgICh2MTI4LmNvbnN0IGkzMng0IDB4MDAwMDAwMDAgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDApKSkpKVxuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsIDI4LCAwLCA2NSwgMCwgMjUzLCAxNSwgMjUzLCAxMiwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjUzLCAxODYsIDEsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHkgPSBhc3luYyAoZmxhZ3M6IEVudi5XZWJBc3NlbWJseUZsYWdzKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtcbiAgfVxuXG4gIGluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgLy8gd2FzbSBmbGFncyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFxuICBjb25zdCB0aW1lb3V0ID0gZmxhZ3MuaW5pdFRpbWVvdXQhO1xuICBsZXQgbnVtVGhyZWFkcyA9IGZsYWdzLm51bVRocmVhZHMhO1xuXG4gIC8vIGVuc3VyZSBTSU1EIGlzIHN1cHBvcnRlZFxuICBpZiAoIWlzU2ltZFN1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuJyk7XG4gIH1cblxuICAvLyBjaGVjayBpZiBtdWx0aS10aHJlYWRpbmcgaXMgc3VwcG9ydGVkXG4gIGNvbnN0IG11bHRpVGhyZWFkU3VwcG9ydGVkID0gaXNNdWx0aVRocmVhZFN1cHBvcnRlZCgpO1xuICBpZiAobnVtVGhyZWFkcyA+IDEgJiYgIW11bHRpVGhyZWFkU3VwcG9ydGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArXG4gICAgICAgICAgbnVtVGhyZWFkcyArXG4gICAgICAgICAgJywgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuICcgK1xuICAgICAgICAgICdTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICcgKyAnRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuJyxcbiAgICApO1xuXG4gICAgLy8gc2V0IGZsYWdzLm51bVRocmVhZHMgdG8gMSBzbyB0aGF0IE9ydEluaXQoKSB3aWxsIG5vdCBjcmVhdGUgYSBnbG9iYWwgdGhyZWFkIHBvb2wuXG4gICAgZmxhZ3MubnVtVGhyZWFkcyA9IG51bVRocmVhZHMgPSAxO1xuICB9XG5cbiAgY29uc3Qgd2FzbVBhdGhzID0gZmxhZ3Mud2FzbVBhdGhzO1xuICBjb25zdCB3YXNtUHJlZml4T3ZlcnJpZGUgPSB0eXBlb2Ygd2FzbVBhdGhzID09PSAnc3RyaW5nJyA/IHdhc21QYXRocyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy5tanM7XG4gIGNvbnN0IG1qc1BhdGhPdmVycmlkZSA9IChtanNQYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gbWpzUGF0aE92ZXJyaWRlRmxhZztcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZUZsYWcgPSAod2FzbVBhdGhzIGFzIEVudi5XYXNtRmlsZVBhdGhzKT8ud2FzbTtcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZSA9ICh3YXNtUGF0aE92ZXJyaWRlRmxhZyBhcyBVUkwpPy5ocmVmID8/IHdhc21QYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtQmluYXJ5T3ZlcnJpZGUgPSBmbGFncy53YXNtQmluYXJ5O1xuXG4gIGNvbnN0IFtvYmplY3RVcmwsIG9ydFdhc21GYWN0b3J5XSA9IGF3YWl0IGltcG9ydFdhc21Nb2R1bGUobWpzUGF0aE92ZXJyaWRlLCB3YXNtUHJlZml4T3ZlcnJpZGUsIG51bVRocmVhZHMgPiAxKTtcblxuICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG5cbiAgY29uc3QgdGFza3M6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XG5cbiAgLy8gcHJvbWlzZSBmb3IgdGltZW91dFxuICBpZiAodGltZW91dCA+IDApIHtcbiAgICB0YXNrcy5wdXNoKFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKFxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZzogUGFydGlhbDxPcnRXYXNtTW9kdWxlPiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcbiAgICAgICAgICogY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIG51bVRocmVhZHMsXG4gICAgICB9O1xuXG4gICAgICBpZiAod2FzbUJpbmFyeU92ZXJyaWRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBjdXN0b20gYnVmZmVyIHdoaWNoIGNvbnRhaW5zIHRoZSBXZWJBc3NlbWJseSBiaW5hcnkuIFRoaXMgd2lsbCBza2lwIHRoZSB3YXNtIGZpbGUgZmV0Y2hpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWcud2FzbUJpbmFyeSA9IHdhc21CaW5hcnlPdmVycmlkZTtcbiAgICAgIH0gZWxzZSBpZiAod2FzbVBhdGhPdmVycmlkZSB8fCB3YXNtUHJlZml4T3ZlcnJpZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gbG9jYXRlIHRoZSBXZWJBc3NlbWJseSBmaWxlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWcubG9jYXRlRmlsZSA9IChmaWxlTmFtZSwgc2NyaXB0RGlyZWN0b3J5KSA9PlxuICAgICAgICAgIHdhc21QYXRoT3ZlcnJpZGUgPz8gKHdhc21QcmVmaXhPdmVycmlkZSA/PyBzY3JpcHREaXJlY3RvcnkpICsgZmlsZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIG9ydFdhc21GYWN0b3J5KGNvbmZpZykudGhlbihcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIChtb2R1bGUpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pLFxuICApO1xuXG4gIGF3YWl0IFByb21pc2UucmFjZSh0YXNrcyk7XG5cbiAgaWYgKGlzVGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3RpbWVvdXR9bXNgKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlID0gKCk6IE9ydFdhc21Nb2R1bGUgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xuICAgIHJldHVybiB3YXNtO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc3Bvc2UgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiAhaW5pdGlhbGl6aW5nICYmICFhYm9ydGVkKSB7XG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXG4gICAgLy8gICAgICAgQW5kIHRoaXMgZnVuY3Rpb24gaXMgbm90IHlldCBjYWxsZWQgYnkgYW55IGNvZGUuXG4gICAgLy8gICAgICAgSWYgaXQgaXMgbmVlZGVkIGluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBleHBvc2UgaXQgaW4gdGhlIHdhc20gbW9kdWxlIGFuZCB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lLlxuXG4gICAgLy8gd2FzbT8uUFRocmVhZD8udGVybWluYXRlQWxsVGhyZWFkcygpO1xuICAgIHdhc20gPSB1bmRlZmluZWQ7XG5cbiAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFPcHRpb25zSGFuZGxlciB7XG4gIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUV4dHJhT3B0aW9ucyA9IChcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHByZWZpeDogc3RyaW5nLFxuICBzZWVuOiBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PixcbiAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcixcbik6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9ucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVuLmFkZChvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuYW1lID0gcHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBuYW1lICsgJy4nLCBzZWVuLCBoYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlID8gJzEnIDogJzAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIGNoZWNrIHdlYiBhc3NlbWJseSBBUEkncyBsYXN0IGVycm9yIGFuZCB0aHJvdyBlcnJvciBpZiBhbnkgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgdXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tMYXN0RXJyb3IgPSAobWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJhbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoOCk7XG4gICAgd2FzbS5fT3J0R2V0TGFzdEVycm9yKHBhcmFtc09mZnNldCwgcGFyYW1zT2Zmc2V0ICsgNCk7XG4gICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5IRUFQMzJbcGFyYW1zT2Zmc2V0IC8gNF07XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlUG9pbnRlciA9IHdhc20uSEVBUFUzMltwYXJhbXNPZmZzZXQgLyA0ICsgMV07XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlUG9pbnRlciA/IHdhc20uVVRGOFRvU3RyaW5nKGVycm9yTWVzc2FnZVBvaW50ZXIpIDogJyc7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9IEVSUk9SX0NPREU6ICR7ZXJyb3JDb2RlfSwgRVJST1JfTUVTU0FHRTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQgeyBhbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yLCBpdGVyYXRlRXh0cmFPcHRpb25zIH0gZnJvbSAnLi93YXNtLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IHNldFJ1bk9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHJ1bk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucz8ubG9nU2V2ZXJpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPSAyOyAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCAhPT0gJ251bWJlcicgfHxcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcbiAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHxcbiAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA+IDRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dWZXJib3NpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8udGVybWluYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy50YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhvcHRpb25zLnRhZywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBydW5PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISxcbiAgICAgICEhcnVuT3B0aW9ucy50ZXJtaW5hdGUhLFxuICAgICAgdGFnRGF0YU9mZnNldCxcbiAgICApO1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRSdW5Db25maWdFbnRyeShydW5PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3J1bk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuXG5jb25zdCBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwgPSAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbDogc3RyaW5nIHwgdW5rbm93bik6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkge1xuICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ2V4dGVuZGVkJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2FsbCc6XG4gICAgICByZXR1cm4gOTk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2dyYXBoT3B0aW1pemF0aW9uTGV2ZWx9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRGVmYXVsdE9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQgPT4ge1xuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcbiAgICBvcHRpb25zLmV4dHJhID0ge307XG4gIH1cbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcbiAgICBvcHRpb25zLmV4dHJhLnNlc3Npb24gPSB7fTtcbiAgfVxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGlmICghc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcbiAgfVxuXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXG4gIGlmIChcbiAgICBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyAmJlxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGVwKSA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKVxuICApIHtcbiAgICBvcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4gPSBmYWxzZTtcbiAgfVxufTtcblxuY29uc3Qgc2V0RXhlY3V0aW9uUHJvdmlkZXJzID0gKFxuICBzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLFxuICBleGVjdXRpb25Qcm92aWRlcnM6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXSxcbiAgYWxsb2NzOiBudW1iZXJbXSxcbik6IHZvaWQgPT4ge1xuICBmb3IgKGNvbnN0IGVwIG9mIGV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgIGxldCBlcE5hbWUgPSB0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lO1xuXG4gICAgLy8gY2hlY2sgRVAgbmFtZVxuICAgIHN3aXRjaCAoZXBOYW1lKSB7XG4gICAgICBjYXNlICd3ZWJubic6XG4gICAgICAgIGVwTmFtZSA9ICdXRUJOTic7XG4gICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIC8vIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8uZGV2aWNlVHlwZTtcbiAgICAgICAgICBpZiAoZGV2aWNlVHlwZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygnZGV2aWNlVHlwZScsIGFsbG9jcyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZGV2aWNlVHlwZSwgYWxsb2NzKTtcbiAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke2RldmljZVR5cGV9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlYmdwdSc6XG4gICAgICAgIGVwTmFtZSA9ICdKUyc7XG4gICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2ViZ3B1T3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnM/LnByZWZlcnJlZExheW91dCkge1xuICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0ICE9PSAnTkNIVycgJiYgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOSFdDJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygncHJlZmVycmVkTGF5b3V0JywgYWxsb2NzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCwgYWxsb2NzKTtcbiAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7d2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXR9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dhc20nOlxuICAgICAgY2FzZSAnY3B1JzpcbiAgICAgICAgY29udGludWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBlcE5hbWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGVwTmFtZSwgYWxsb2NzKTtcbiAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGVwTmFtZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9LmApO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNldFNlc3Npb25PcHRpb25zID0gKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBzZXNzaW9uT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGFwcGVuZERlZmF1bHRPcHRpb25zKHNlc3Npb25PcHRpb25zKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPSBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwoc2Vzc2lvbk9wdGlvbnMuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA/PyAnYWxsJyk7XG4gICAgY29uc3QgZXhlY3V0aW9uTW9kZSA9IGdldEV4ZWN1dGlvbk1vZGUoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uTW9kZSA/PyAnc2VxdWVudGlhbCcpO1xuICAgIGNvbnN0IGxvZ0lkRGF0YU9mZnNldCA9XG4gICAgICB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMubG9nSWQgPT09ICdzdHJpbmcnID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLmxvZ0lkLCBhbGxvY3MpIDogMDtcblxuICAgIGNvbnN0IGxvZ1NldmVyaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID8/IDI7IC8vIERlZmF1bHQgdG8gMiAtIHdhcm5pbmdcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9nU2V2ZXJpdHlMZXZlbCkgfHwgbG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHwgbG9nU2V2ZXJpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dWZXJib3NpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID8/IDA7IC8vIERlZmF1bHQgdG8gMCAtIHZlcmJvc2VcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9nVmVyYm9zaXR5TGV2ZWwpIHx8IGxvZ1ZlcmJvc2l0eUxldmVsIDwgMCB8fCBsb2dWZXJib3NpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCA9XG4gICAgICB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCwgYWxsb2NzKVxuICAgICAgICA6IDA7XG5cbiAgICBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKFxuICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCxcbiAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlQ3B1TWVtQXJlbmEsXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4sXG4gICAgICBleGVjdXRpb25Nb2RlLFxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVQcm9maWxpbmcsXG4gICAgICAwLFxuICAgICAgbG9nSWREYXRhT2Zmc2V0LFxuICAgICAgbG9nU2V2ZXJpdHlMZXZlbCxcbiAgICAgIGxvZ1ZlcmJvc2l0eUxldmVsLFxuICAgICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCxcbiAgICApO1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzKSB7XG4gICAgICBzZXRFeGVjdXRpb25Qcm92aWRlcnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygnZW5hYmxlR3JhcGhDYXB0dXJlJywgYWxsb2NzKTtcbiAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSwgYWxsb2NzKTtcbiAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXG4gICAgICAgICAgYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfS5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcobmFtZSwgYWxsb2NzKTtcbiAgICAgICAgaWYgKHdhc20uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShzZXNzaW9uT3B0aW9uc0hhbmRsZSwgbmFtZU9mZnNldCwgdmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke25hbWV9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhzZXNzaW9uT3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaCgoYWxsb2MpID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbmNsdWRlcyBjb21tb24gZGVmaW5pdGlvbnMuIFRoZXkgZG8gTk9UIGhhdmUgZGVwZW5kZW5jeSBvbiB0aGUgV2ViQXNzZW1ibHkgaW5zdGFuY2UuXG5cbi8qKlxuICogQ29waWVkIGZyb20gT05OWCBkZWZpbml0aW9uLiBVc2UgdGhpcyB0byBkcm9wIGRlcGVuZGVuY3kgJ29ubnhfcHJvdG8nIHRvIGRlY3JlYXNlIGNvbXBpbGVkIC5qcyBmaWxlIHNpemUuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIERhdGFUeXBlIHtcbiAgdW5kZWZpbmVkID0gMCxcbiAgZmxvYXQgPSAxLFxuICB1aW50OCA9IDIsXG4gIGludDggPSAzLFxuICB1aW50MTYgPSA0LFxuICBpbnQxNiA9IDUsXG4gIGludDMyID0gNixcbiAgaW50NjQgPSA3LFxuICBzdHJpbmcgPSA4LFxuICBib29sID0gOSxcbiAgZmxvYXQxNiA9IDEwLFxuICBkb3VibGUgPSAxMSxcbiAgdWludDMyID0gMTIsXG4gIHVpbnQ2NCA9IDEzLFxuICBjb21wbGV4NjQgPSAxNCxcbiAgY29tcGxleDEyOCA9IDE1LFxuICBiZmxvYXQxNiA9IDE2LFxuXG4gIC8vIDQtYml0IGRhdGEtdHlwZXNcbiAgdWludDQgPSAyMSxcbiAgaW50NCA9IDIyLFxufVxuXG4vKipcbiAqIE1hcCBzdHJpbmcgdGVuc29yIGRhdGEgdG8gZW51bSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0gPSAodHlwZTogc3RyaW5nKTogRGF0YVR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ4O1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50ODtcbiAgICBjYXNlICdib29sJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5ib29sO1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQxNjtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQxNjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MzI7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MzI7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQxNjtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5mbG9hdDtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5kb3VibGU7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5zdHJpbmc7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDY0O1xuICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDY0O1xuICAgIGNhc2UgJ2ludDQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDQ7XG4gICAgY2FzZSAndWludDQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGVudW0gdmFsdWUgdG8gc3RyaW5nIHRlbnNvciBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IERhdGFUeXBlKTogVGVuc29yLlR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGVQcm90bykge1xuICAgIGNhc2UgRGF0YVR5cGUuaW50ODpcbiAgICAgIHJldHVybiAnaW50OCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50ODpcbiAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQxNjpcbiAgICAgIHJldHVybiAnaW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDE2OlxuICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gJ2ludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcbiAgICAgIHJldHVybiAndWludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gJ2Zsb2F0MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuZG91YmxlOlxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcbiAgICBjYXNlIERhdGFUeXBlLnN0cmluZzpcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgcmV0dXJuICdpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICByZXR1cm4gJ3VpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ0OlxuICAgICAgcmV0dXJuICdpbnQ0JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ0OlxuICAgICAgcmV0dXJuICd1aW50NCc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZVByb3RvfWApO1xuICB9XG59O1xuXG4vKipcbiAqIGdldCB0ZW5zb3Igc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBkaW1lbnNpb25zXG4gKiBAcmV0dXJucyBzaXplIGluIGludGVnZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIHR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMgPSAoXG4gIGRhdGVUeXBlOiBudW1iZXIsXG4gIGRpbXNPclNpemU6IHJlYWRvbmx5IG51bWJlcltdIHwgbnVtYmVyLFxuKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgZWxlbWVudFNpemUgPSBbXG4gICAgLTEsIC8vIHVuZGVmaW5lZCA9IDBcbiAgICA0LCAvLyBmbG9hdCA9IDFcbiAgICAxLCAvLyB1aW50OCA9IDJcbiAgICAxLCAvLyBpbnQ4ID0gM1xuICAgIDIsIC8vIHVpbnQxNiA9IDRcbiAgICAyLCAvLyBpbnQxNiA9IDVcbiAgICA0LCAvLyBpbnQzMiA9IDZcbiAgICA4LCAvLyBpbnQ2NCA9IDdcbiAgICAtMSwgLy8gc3RyaW5nID0gOFxuICAgIDEsIC8vIGJvb2wgPSA5XG4gICAgMiwgLy8gZmxvYXQxNiA9IDEwXG4gICAgOCwgLy8gZG91YmxlID0gMTFcbiAgICA0LCAvLyB1aW50MzIgPSAxMlxuICAgIDgsIC8vIHVpbnQ2NCA9IDEzXG4gICAgLTEsIC8vIGNvbXBsZXg2NCA9IDE0XG4gICAgLTEsIC8vIGNvbXBsZXgxMjggPSAxNVxuICAgIC0xLCAvLyBiZmxvYXQxNiA9IDE2XG4gICAgLTEsIC8vIEZMT0FUOEU0TTNGTiA9IDE3XG4gICAgLTEsIC8vIEZMT0FUOEU0TTNGTlVaID0gMThcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMiA9IDE5XG4gICAgLTEsIC8vIEZMT0FUOEU1TTJGTlVaID0gMjBcbiAgICAwLjUsIC8vIHVpbnQ0ID0gMjFcbiAgICAwLjUsIC8vIGludDQgPSAyMlxuICBdW2RhdGVUeXBlXTtcblxuICBjb25zdCBzaXplID0gdHlwZW9mIGRpbXNPclNpemUgPT09ICdudW1iZXInID8gZGltc09yU2l6ZSA6IGRpbXNPclNpemUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gIHJldHVybiBlbGVtZW50U2l6ZSA+IDAgPyBNYXRoLmNlaWwoc2l6ZSAqIGVsZW1lbnRTaXplKSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogZ2V0IHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIGJ5IHRoZSBnaXZlbiB0ZW5zb3IgdHlwZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gKFxuICB0eXBlOiBUZW5zb3IuVHlwZSxcbik6XG4gIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICAvLyBhbGxvdyBGbG9hdDE2QXJyYXkgcG9seWZpbGwuXG4gICAgICByZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBGbG9hdDE2QXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBGbG9hdDY0QXJyYXk7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICByZXR1cm4gQmlnSW50NjRBcnJheTtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ1VpbnQ2NEFycmF5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgc3RyaW5nIGxvZyBsZXZlbCB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dMZXZlbFN0cmluZ1RvRW51bSA9IChsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7bG9nTGV2ZWx9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdGVuc29yIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IEdQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9PlxuICB0eXBlID09PSAnZmxvYXQzMicgfHxcbiAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8XG4gIHR5cGUgPT09ICdpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ2ludDY0JyB8fFxuICB0eXBlID09PSAndWludDMyJyB8fFxuICB0eXBlID09PSAndWludDgnIHx8XG4gIHR5cGUgPT09ICdib29sJyB8fFxuICB0eXBlID09PSAndWludDQnIHx8XG4gIHR5cGUgPT09ICdpbnQ0JztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgV2ViTk4gTUxUZW5zb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlID0gKHR5cGU6IFRlbnNvci5UeXBlKTogdHlwZSBpcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPT5cbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxuICB0eXBlID09PSAnaW50MzInIHx8XG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ2ludDgnIHx8XG4gIHR5cGUgPT09ICd1aW50OCcgfHxcbiAgdHlwZSA9PT0gJ2Jvb2wnO1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgZGF0YSBsb2NhdGlvbiB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvY2F0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSAnbWwtdGVuc29yJzpcbiAgICAgIHJldHVybiA1O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7bG9jYXRpb259YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGludGVnZXIgZGF0YSBsb2NhdGlvbiB0byBzdHJpbmcgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvbkVudW1Ub1N0cmluZyA9IChsb2NhdGlvbjogbnVtYmVyKTogVGVuc29yLkRhdGFMb2NhdGlvbiB8IHVuZGVmaW5lZCA9PlxuICAoWydub25lJywgJ2NwdScsICdjcHUtcGlubmVkJywgJ3RleHR1cmUnLCAnZ3B1LWJ1ZmZlcicsICdtbC10ZW5zb3InXSBhcyBjb25zdClbbG9jYXRpb25dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIHRoZSBmaWxlIHRvIGxvYWQuIENhbiBiZSBhIFVSTC9wYXRoLCBhIEJsb2IsIGFuIEFycmF5QnVmZmVyLCBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSBhc3luYyAoZmlsZTogc3RyaW5nIHwgQmxvYiB8IEFycmF5QnVmZmVyTGlrZSB8IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIE5vZGUuanNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlYWRGaWxlKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VSUl9GU19GSUxFX1RPT19MQVJHRScpIHtcbiAgICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIGZzLmNyZWF0ZVJlYWRTdHJlYW0gaW5zdGVhZFxuICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUmVhZFN0cmVhbSB9ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgICAgICAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBicm93c2Vyc1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gY29udGVudExlbmd0aEhlYWRlciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKSA6IDA7XG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xuICAgICAgICAvLyB3aGVuIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBub3Qgc2V0LCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBmaWxlIHNpemUuIFdlIGFzc3VtZSBpdCBpcyBzbWFsbCBlbm91Z2ggdG9cbiAgICAgICAgLy8gbG9hZCBpbnRvIG1lbW9yeS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBzdHJlYW0gaW5zdGVhZFxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmaWxlU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHVzZSBXZWJBc3NlbWJseSBNZW1vcnkgdG8gYWxsb2NhdGUgbGFyZ2VyIEFycmF5QnVmZmVyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiBwYWdlcywgbWF4aW11bTogcGFnZXMgfSkuYnVmZmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjaHVuay5zZXQodmFsdWUpO1xuICAgICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgZmlsZVNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImpzZXAvd2Vibm4vd2Vibm4uZC50c1wiIC8+XG5cbmltcG9ydCB7IEVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgVGVuc29yIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXG4gIFRlbnNvck1ldGFkYXRhLFxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7IHNldFJ1bk9wdGlvbnMgfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7IHNldFNlc3Npb25PcHRpb25zIH0gZnJvbSAnLi9zZXNzaW9uLW9wdGlvbnMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsXG4gIGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSxcbiAgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLFxuICBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSxcbiAgbG9nTGV2ZWxTdHJpbmdUb0VudW0sXG4gIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nLFxuICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSxcbiAgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxufSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG4vLyAjcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIFRoZXJlIGFyZSA0IGRpZmZlcmVudCBcImluaXRpYWxpemF0aW9uXCIgc3RlcHMgZm9yIE9SVC4gVGhleSBoYXBwZW4gaW4gZGlmZmVyZW50IHBsYWNlcyBhbmQgZGlmZmVyZW50IHRpbWUuXG4gKlxuICogMS4gSmF2YVNjcmlwdCBpbml0aWFsaXphdGlvbiBmb3Igb25ueHJ1bnRpbWUtY29tbW9uIGFuZCBvbm54cnVudGltZS13ZWIuXG4gKiAgICBUaGlzIGlzIHRoZSBmaXJzdCBpbml0aWFsaXphdGlvbiBzdGVwLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBjYWxscyBvbm54cnVudGltZS1jb21tb24ncyByZWdpc3RlckJhY2tlbmQoKVxuICogZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgYWxsIHRoZSBhdmFpbGFibGUgYmFja2VuZHMuIFRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbiBpcyB2ZXJ5IGZhc3QuIEl0IG9ubHlcbiAqIHJlZ2lzdGVycyB0aGUgYmFja2VuZCBuYW1lIHdpdGggdGhlIHVuaW5pdGlhbGl6ZWQgYmFja2VuZCBvYmplY3QuIE5vIGhlYXZ5IGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgUmVmZXIgdG8gd2ViL2xpYi9pbmRleC50cyBmb3IgdGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uLlxuICpcbiAqIDIuIFdlYkFzc2VtYmx5IGFydGlmYWN0IGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYW55IHJlZ2lzdGVyZWQgd2FzbSBiYWNrZW5kIGlzIHVzZWQgZm9yIHRoZSBmaXJzdCB0aW1lIChpZS4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpc1xuICogY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZC4gVW5saWtlIHRoZSBmaXJzdCAzIHN0ZXBzICh0aGV5IG9ubHkgY2FsbGVkIG9uY2UpLFxuICogdGhpcyBzdGVwIHdpbGwgYmUgZG9uZSBmb3IgZWFjaCBzZXNzaW9uLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBkb2VzIHRoZSBmb2xsb3dpbmdzOlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVSTDpcbiAqICAgIC0gZG93bmxvYWQgdGhlIG1vZGVsIGRhdGEgZnJvbSB0aGUgVVJMLlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGRlcmVmZXJlbmNlIHRoZSBtb2RlbCBidWZmZXIuIFRoaXMgc3RlcCBhbGxvd3MgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVpbnQ4QXJyYXkgb2JqZWN0OlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKlxuICovXG5cbi8qKlxuICogaW5pdGlhbGl6ZSBPUlQgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIG51bVRocmVhZHMgU2V0R2xvYmFsSW50cmFPcE51bVRocmVhZHMobnVtVGhyZWFkcylcbiAqIEBwYXJhbSBsb2dnaW5nTGV2ZWwgQ3JlYXRlRW52KHN0YXRpY19jYXN0PE9ydExvZ2dpbmdMZXZlbD4obG9nZ2luZ19sZXZlbCkpXG4gKi9cbmNvbnN0IGluaXRPcnQgPSAobnVtVGhyZWFkczogbnVtYmVyLCBsb2dnaW5nTGV2ZWw6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBlcnJvckNvZGUgPSBnZXRJbnN0YW5jZSgpLl9PcnRJbml0KG51bVRocmVhZHMsIGxvZ2dpbmdMZXZlbCk7XG4gIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIGluaXRpYWxpemUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSBlbnYgcGFzc2VkIGluIHRoZSBlbnZpcm9ubWVudCBjb25maWcgb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgaW5pdFJ1bnRpbWUgPSBhc3luYyAoZW52OiBFbnYpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgLy8gaW5pdCBPUlRcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIGVudlxuICogQHBhcmFtIGVwTmFtZVxuICovXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMgKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICBjb25zdCBpbml0SnNlcCA9IHJlcXVpcmUoJy4vanNlcC9pbml0JykuaW5pdDtcblxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgICAvLyBwZXJmb3JtIFdlYkdQVSBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdwdSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlciB8IG51bGw7XG4gICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXG4gICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9IGVudi53ZWJncHUucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBwb3dlclByZWZlcmVuY2UgIT09ICdsb3ctcG93ZXInICYmXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSAnaGlnaC1wZXJmb3JtYW5jZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBvd2VyUHJlZmVyZW5jZSBzZXR0aW5nOiBcIiR7cG93ZXJQcmVmZXJlbmNlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9yY2VGYWxsYmFja0FkYXB0ZXIgPSBlbnYud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO1xuICAgICAgICBpZiAoZm9yY2VGYWxsYmFja0FkYXB0ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZm9yY2VGYWxsYmFja0FkYXB0ZXIgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JjZUZhbGxiYWNrQWRhcHRlciBzZXR0aW5nOiBcIiR7Zm9yY2VGYWxsYmFja0FkYXB0ZXJ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcih7IHBvd2VyUHJlZmVyZW5jZSwgZm9yY2VGYWxsYmFja0FkYXB0ZXIgfSk7XG4gICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgbmVlZCB0byBlbmFibGUgZmxhZyBcIi0tZW5hYmxlLXVuc2FmZS13ZWJncHVcIiBpZiB5b3UgYXJlIHVzaW5nIENocm9tZS4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgc2V0LCB2YWxpZGF0ZSBpdC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBhZGFwdGVyLmxpbWl0cyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICB0eXBlb2YgYWRhcHRlci5mZWF0dXJlcyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICB0eXBlb2YgYWRhcHRlci5yZXF1ZXN0RGV2aWNlICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBpbml0SnNlcCgnd2ViZ3B1JywgZ2V0SW5zdGFuY2UoKSwgZW52LCBhZGFwdGVyKTtcbiAgICB9XG4gICAgaWYgKGVwTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgICAgLy8gcGVyZm9ybSBXZWJOTiBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHsgbWw6IHVua25vd24gfSkubWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJOTiBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYm5uJywgZ2V0SW5zdGFuY2UoKSwgZW52KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxuICovXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID0gJ2NwdScgfCAnY3B1LXBpbm5lZCcgfCAnZ3B1LWJ1ZmZlcicgfCAnbWwtdGVuc29yJztcblxudHlwZSBJT0JpbmRpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIHRoZSBoYW5kbGUgb2YgSU8gYmluZGluZy5cbiAgICovXG4gIHJlYWRvbmx5IGhhbmRsZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXG4gICAqXG4gICAqIHZhbHVlIGlzIG9uZSBvZiAnY3B1JywgJ2NwdS1waW5uZWQnLCAnZ3B1LWJ1ZmZlcicsICdtbC10ZW5zb3InLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiByZWFkb25seSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdO1xuXG4gIC8qKlxuICAgKiBlbnVtIHZhbHVlIG9mIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IHJlYWRvbmx5IG51bWJlcltdO1xufTtcblxuLyoqXG4gKiAgdHVwbGUgZWxlbWVudHMgYXJlOiBJbmZlcmVuY2VTZXNzaW9uIElEOyBpbnB1dE5hbWVzVVRGOEVuY29kZWQ7IG91dHB1dE5hbWVzVVRGOEVuY29kZWQ7IGJpbmRpbmdTdGF0ZVxuICovXG50eXBlIFNlc3Npb25NZXRhZGF0YSA9IFtcbiAgaW5mZXJlbmNlU2Vzc2lvbklkOiBudW1iZXIsXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxuICBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlIHwgbnVsbCxcbiAgZW5hYmxlR3JhcGhDYXB0dXJlOiBib29sZWFuLFxuICBpbnB1dE91dHB1dEJvdW5kOiBib29sZWFuLFxuXTtcblxuY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwPG51bWJlciwgU2Vzc2lvbk1ldGFkYXRhPigpO1xuXG4vKipcbiAqIGdldCB0aGUgaW5wdXQvb3V0cHV0IGNvdW50IG9mIHRoZSBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb25IYW5kbGUgdGhlIGhhbmRsZSByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24uIHNob3VsZCBiZSBub24temVyby5cbiAqIEByZXR1cm5zIGEgdHVwbGUgaW5jbHVkaW5nIDIgbnVtYmVycywgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb3VudCBhbmQgb3V0cHV0IGNvdW50LlxuICovXG5jb25zdCBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudCA9IChzZXNzaW9uSGFuZGxlOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIDQpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFt3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNF0sIHdhc20uSEVBUDMyW2RhdGFPZmZzZXQgLyA0ICsgMV1dO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKFxuICBtb2RlbERhdGE6IFVpbnQ4QXJyYXkgfCBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBsZXQgbW9kZWxEYXRhT2Zmc2V0OiBudW1iZXIsIG1vZGVsRGF0YUxlbmd0aDogbnVtYmVyO1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbERhdGEpKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSBpcyBhbiBhcnJheSwgaXQgbXVzdCBiZSBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YVxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBtb2RlbERhdGE7XG4gIH0gZWxzZSBpZiAobW9kZWxEYXRhLmJ1ZmZlciA9PT0gd2FzbS5IRUFQVTguYnVmZmVyKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSB1c2VzIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQuXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IFttb2RlbERhdGEuYnl0ZU9mZnNldCwgbW9kZWxEYXRhLmJ5dGVMZW5ndGhdO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKG1vZGVsRGF0YSk7XG4gIH1cblxuICBsZXQgc2Vzc2lvbkhhbmRsZSA9IDA7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBpb0JpbmRpbmdIYW5kbGUgPSAwO1xuICBsZXQgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xuXG4gIHRyeSB7XG4gICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0ZXJuYWxEYXRhICYmIHdhc20ubW91bnRFeHRlcm5hbERhdGEpIHtcbiAgICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIG9wdGlvbnMuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5wYXRoO1xuICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChcbiAgICAgICAgICBsb2FkRmlsZSh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5kYXRhKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhIShwYXRoLCBkYXRhKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2FpdCBmb3IgYWxsIGV4dGVybmFsIGRhdGEgZmlsZXMgdG8gYmUgbG9hZGVkXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2Ygb3B0aW9ucz8uZXhlY3V0aW9uUHJvdmlkZXJzID8/IFtdKSB7XG4gICAgICBjb25zdCBwcm92aWRlck5hbWUgPSB0eXBlb2YgcHJvdmlkZXIgPT09ICdzdHJpbmcnID8gcHJvdmlkZXIgOiBwcm92aWRlci5uYW1lO1xuICAgICAgaWYgKHByb3ZpZGVyTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IGZhbHNlO1xuICAgICAgICBpZiAod2FzbS5jdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIGlzIGFscmVhZHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gcHJvdmlkZXIgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgZ3B1RGV2aWNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dlYkdwdSk/LmdwdURldmljZTtcbiAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xuICAgICAgICAgIGNvbnN0IG51bVRocmVhZHMgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/Lm51bVRocmVhZHM7XG4gICAgICAgICAgY29uc3QgcG93ZXJQcmVmZXJlbmNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5wb3dlclByZWZlcmVuY2U7XG4gICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBjb250ZXh0IGFzIE1MQ29udGV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdwdURldmljZSkge1xuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KGdwdURldmljZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh7IGRldmljZVR5cGUsIG51bVRocmVhZHMsIHBvd2VyUHJlZmVyZW5jZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2Vzc2lvbkhhbmRsZSA9IGF3YWl0IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBjdXJyZW50IE1MQ29udGV4dCBhZnRlciBzZXNzaW9uIGNyZWF0aW9uXG4gICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcbiAgICAgIHdhc20uanNlcFJlZ2lzdGVyTUxDb250ZXh0IShzZXNzaW9uSGFuZGxlLCB3YXNtLmN1cnJlbnRDb250ZXh0KTtcbiAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgW2lucHV0Q291bnQsIG91dHB1dENvdW50XSA9IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUpO1xuXG4gICAgY29uc3QgZW5hYmxlR3JhcGhDYXB0dXJlID0gISFvcHRpb25zPy5lbmFibGVHcmFwaENhcHR1cmU7XG5cbiAgICBjb25zdCBpbnB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldElucHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICBpbnB1dE5hbWVzLnB1c2god2FzbS5VVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRPdXRwdXROYW1lKHNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcblxuICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaCgnZ3B1LWJ1ZmZlcicpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID1cbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IG9wdGlvbnMucHJlZmVycmVkT3V0cHV0TG9jYXRpb25cbiAgICAgICAgICAgIDogKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bbmFtZVN0cmluZ10gPz8gJ2NwdScpO1xuICAgICAgICBpZiAobG9jYXRpb24gIT09ICdjcHUnICYmIGxvY2F0aW9uICE9PSAnY3B1LXBpbm5lZCcgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJyAmJiBsb2NhdGlvbiAhPT0gJ21sLXRlbnNvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXNlIElPIGJpbmRpbmcgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvdXRwdXQgaXMgcHJlZmVycmVkIHRvIGJlIG9uIEdQVS5cbiAgICBsZXQgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnNvbWUoKGwpID0+IGwgPT09ICdncHUtYnVmZmVyJyB8fCBsID09PSAnbWwtdGVuc29yJykpIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5tYXAoKGwpID0+IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShsKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSGFuZGxlLCBbXG4gICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcbiAgICAgIGJpbmRpbmdTdGF0ZSxcbiAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcbiAgICAgIGZhbHNlLFxuICAgIF0pO1xuICAgIHJldHVybiBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lcywgb3V0cHV0TmFtZXNdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25IYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuXG4gICAgLy8gdW5tb3VudCBleHRlcm5hbCBkYXRhIGlmIG5lY2Vzc2FyeVxuICAgIHdhc20udW5tb3VudEV4dGVybmFsRGF0YT8uKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZV0gPSBzZXNzaW9uO1xuXG4gIGlmIChpb0JpbmRpbmdTdGF0ZSkge1xuICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgfVxuICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcblxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9IChcbiAgdGVuc29yOiBUZW5zb3JNZXRhZGF0YSB8IG51bGwsXG4gIHRlbnNvckhhbmRsZXM6IG51bWJlcltdLFxuICBhbGxvY3M6IG51bWJlcltdLFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXG4pOiB2b2lkID0+IHtcbiAgaWYgKCF0ZW5zb3IpIHtcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gIGNvbnN0IGRpbXMgPSB0ZW5zb3JbMV07XG4gIGNvbnN0IGxvY2F0aW9uID0gdGVuc29yWzNdO1xuXG4gIGxldCByYXdEYXRhOiBudW1iZXI7XG4gIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gIGlmIChkYXRhVHlwZSA9PT0gJ3N0cmluZycgJiYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgfHwgbG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgfVxuXG4gIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7aW5kZXh9IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0ZW5zb3JbMl0uZ3B1QnVmZmVyIGFzIEdQVUJ1ZmZlcjtcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLmpzZXBSZWdpc3RlckJ1ZmZlcjtcbiAgICBpZiAoIXJlZ2lzdGVyQnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgIH1cbiAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkLCBpbmRleCwgZ3B1QnVmZmVyLCBkYXRhQnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSB7XG4gICAgY29uc3QgbWxUZW5zb3IgPSB0ZW5zb3JbMl0ubWxUZW5zb3IgYXMgTUxUZW5zb3I7XG4gICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpITtcblxuICAgIGNvbnN0IHJlZ2lzdGVyTUxUZW5zb3IgPSB3YXNtLmpzZXBSZWdpc3Rlck1MVGVuc29yO1xuICAgIGlmICghcmVnaXN0ZXJNTFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgfVxuICAgIHJhd0RhdGEgPSByZWdpc3Rlck1MVGVuc29yKG1sVGVuc29yLCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgZGF0YUJ5dGVMZW5ndGggPSA0ICogZGF0YS5sZW5ndGg7XG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgbGV0IGRhdGFJbmRleCA9IHJhd0RhdGEgLyA0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK10gPSBhbGxvY1dhc21TdHJpbmcoZGF0YVtpXSwgYWxsb2NzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgcmF3RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBkaW1zLmxlbmd0aCk7XG4gIHRyeSB7XG4gICAgbGV0IGRpbUluZGV4ID0gZGltc09mZnNldCAvIDQ7XG4gICAgZGltcy5mb3JFYWNoKChkKSA9PiAod2FzbS5IRUFQMzJbZGltSW5kZXgrK10gPSBkKSk7XG4gICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLFxuICAgICAgcmF3RGF0YSxcbiAgICAgIGRhdGFCeXRlTGVuZ3RoLFxuICAgICAgZGltc09mZnNldCxcbiAgICAgIGRpbXMubGVuZ3RoLFxuICAgICAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGxvY2F0aW9uKSxcbiAgICApO1xuICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtzZXNzaW9uSWR9LCBpbmRleD0ke2luZGV4fS5gKTtcbiAgICB9XG4gICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gaW5mZXJlbmNlIHJ1blxuICovXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG4gIGNvbnN0IGlucHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMV07XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzJdO1xuICBjb25zdCBpb0JpbmRpbmdTdGF0ZSA9IHNlc3Npb25bM107XG4gIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9IHNlc3Npb25bNF07XG4gIGNvbnN0IGlucHV0T3V0cHV0Qm91bmQgPSBzZXNzaW9uWzVdO1xuXG4gIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEluZGljZXMubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEluZGljZXMubGVuZ3RoO1xuXG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgbGV0IHJ1bk9wdGlvbnNBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgaW5wdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBvdXRwdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE91dHB1dEFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBiZWZvcmVSdW5TdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGlucHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgY29uc3QgaW5wdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gIGNvbnN0IG91dHB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuICBjb25zdCBvdXRwdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuXG4gIHRyeSB7XG4gICAgLy8gV2ViTk4gYmFja2VuZCBuZWVkcyB0aGUgYWN0aXZlIHNlc3Npb24gdG8gY2hlY2sgTUxUZW5zb3JzIHdpdGggdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICB3YXNtLmpzZXBPblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIGlucHV0IHRlbnNvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBpbnB1dFRlbnNvcnNbaV0sXG4gICAgICAgIGlucHV0VGVuc29ySGFuZGxlcyxcbiAgICAgICAgaW5wdXRPdXRwdXRBbGxvY3MsXG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXRWYWx1ZXNJbmRleCA9IGlucHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgaW5wdXROYW1lc0luZGV4ID0gaW5wdXROYW1lc09mZnNldCAvIDQ7XG4gICAgbGV0IG91dHB1dFZhbHVlc0luZGV4ID0gb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0TmFtZXNJbmRleCA9IG91dHB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW2lucHV0VmFsdWVzSW5kZXgrK10gPSBpbnB1dFRlbnNvckhhbmRsZXNbaV07XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXROYW1lc0luZGV4KytdID0gaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc0luZGV4KytdID0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltvdXRwdXROYW1lc0luZGV4KytdID0gb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBpbnB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRCaW5kSW5wdXQoaGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBpbnB1dFRlbnNvckhhbmRsZXNbaV0pO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgaW5wdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgcHJlLWFsbG9jYXRlZCBvdXRwdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG91dHB1dFRlbnNvcnNbaV0/LlszXTsgLy8gdW5kZWZpbmVkIG1lYW5zIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC5cblxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgcHJlLWFsbG9jYXRlZC4gYmluZCB0aGUgdGVuc29yLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KFxuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICB0cnVlLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yQ29kZTogbnVtYmVyO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZS5oYW5kbGUsXG4gICAgICAgIG91dHB1dENvdW50LFxuICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW4oXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICAgIGlucHV0TmFtZXNPZmZzZXQsXG4gICAgICAgIGlucHV0VmFsdWVzT2Zmc2V0LFxuICAgICAgICBpbnB1dENvdW50LFxuICAgICAgICBvdXRwdXROYW1lc09mZnNldCxcbiAgICAgICAgb3V0cHV0Q291bnQsXG4gICAgICAgIG91dHB1dFZhbHVlc09mZnNldCxcbiAgICAgICAgcnVuT3B0aW9uc0hhbmRsZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNCArIGldO1xuICAgICAgaWYgKHRlbnNvciA9PT0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXSkge1xuICAgICAgICAvLyBvdXRwdXQgdGVuc29yIGlzIHByZS1hbGxvY2F0ZWQuIG5vIG5lZWQgdG8gY29weSBkYXRhLlxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3JzW2ldISk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgLy8gc3RhY2sgYWxsb2NhdGUgNCBwb2ludGVyIHZhbHVlXG4gICAgICBjb25zdCB0ZW5zb3JEYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiA0KTtcblxuICAgICAgbGV0IGtlZXBPdXRwdXRUZW5zb3IgPSBmYWxzZTtcbiAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZSB8IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YU9mZnNldCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRUZW5zb3JEYXRhKFxuICAgICAgICAgIHRlbnNvcixcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyA0LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyA4LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyAxMixcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7aX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbnNvckRhdGFJbmRleCA9IHRlbnNvckRhdGFPZmZzZXQgLyA0O1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltc0xlbmd0aCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkaW1zLnB1c2god2FzbS5IRUFQVTMyW2RpbXNPZmZzZXQgLyA0ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX09ydEZyZWUoZGltc09mZnNldCk7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gICAgICAgIHR5cGUgPSB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhkYXRhVHlwZSk7XG5cbiAgICAgICAgY29uc3QgcHJlZmVycmVkTG9jYXRpb24gPSBpb0JpbmRpbmdTdGF0ZT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW291dHB1dEluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInIHx8IHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiB3YXNtLkhFQVBVMzJbZGF0YUluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBzdHJpbmdEYXRhLCAnY3B1J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIGEgY2VydGFpbiBvdXRwdXQncyBwcmVmZXJyZWQgbG9jYXRpb24gaXMgR1BVIGJ1dCB0aGUgdGVuc29yIGlzIGVtcHR5LCB3ZSBzdGlsbCBuZWVkIHRvIGNyZWF0ZSBhIENQVVxuICAgICAgICAgIC8vIHRlbnNvciBmb3IgaXQuIFRoZXJlIGlzIG5vIG1hcHBpbmcgR1BVIGJ1ZmZlciBmb3IgYW4gZW1wdHkgdGVuc29yLlxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRCdWZmZXIgPSB3YXNtLmpzZXBHZXRCdWZmZXI7XG4gICAgICAgICAgICBpZiAoIWdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBncHVCdWZmZXIgPSBnZXRCdWZmZXIoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlciEoZ3B1QnVmZmVyLCBidWZmZXJTaXplLCB0eXBlKSxcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2dwdS1idWZmZXInLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuc3VyZVRlbnNvciA9IHdhc20uanNlcEVuc3VyZVRlbnNvcjtcbiAgICAgICAgICAgIGlmICghZW5zdXJlVGVuc29yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKHRlbnNvclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGdyYXBoIGhhcyBiZWVuIHBhcnRpdGlvbmVkLCB0aGUgb3V0cHV0IHRlbnNvciBtYXkgaGF2ZSBub3QgYmVlbiBjcmVhdGVkLiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZVxuICAgICAgICAgICAgLy8gZW5zdXJlVGVuc29yIHRvIGdldC9jcmVhdGUgdGhlIE1MVGVuc29yLiBJbiB3aGljaCBjYXNlLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgdGhlIGRhdGEgaWYgYSBuZXcgdGVuc29yXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgICAgY29uc3QgbWxUZW5zb3IgPSBhd2FpdCBlbnN1cmVUZW5zb3IoZGF0YU9mZnNldCwgZGF0YVR5cGUsIGRpbXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkaW1zLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWxUZW5zb3IsXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20uanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlciEoZGF0YU9mZnNldCwgdHlwZSksXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgd2FzbS5qc2VwUmVsZWFzZVRlbnNvcklkIShkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnbWwtdGVuc29yJyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzaXplKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkuc2V0KFxuICAgICAgICAgICAgICB3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBPdXRwdXRUZW5zb3IpIHtcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW9CaW5kaW5nU3RhdGUgJiYgIWVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgd2FzbS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKTtcbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICBmYWxzZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZVJ1blN0YWNrKTtcblxuICAgIGlucHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKCh2KSA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcbiAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLmZvckVhY2goKHYpID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIGlucHV0T3V0cHV0QWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xuXG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBydW5PcHRpb25zQWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xuICB9XG59O1xuXG4vKipcbiAqIGVuZCBwcm9maWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vzc2lvbiBpZCcpO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuXG4gIC8vIHByb2ZpbGUgZmlsZSBuYW1lIGlzIG5vdCB1c2VkIHlldCwgYnV0IGl0IG11c3QgYmUgZnJlZWQuXG4gIGNvbnN0IHByb2ZpbGVGaWxlTmFtZSA9IHdhc20uX09ydEVuZFByb2ZpbGluZyhzZXNzaW9uSGFuZGxlKTtcbiAgaWYgKHByb2ZpbGVGaWxlTmFtZSA9PT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKTtcbiAgfVxuICB3YXNtLl9PcnRGcmVlKHByb2ZpbGVGaWxlTmFtZSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMgPSAodGVuc29yczogcmVhZG9ubHkgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSk6IEFycmF5QnVmZmVyTGlrZVtdID0+IHtcbiAgY29uc3QgYnVmZmVyczogQXJyYXlCdWZmZXJMaWtlW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZW5zb3Igb2YgdGVuc29ycykge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpICYmICdidWZmZXInIGluIGRhdGEpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmZXJzO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52LCBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgT3J0V2FzbU1lc3NhZ2UsXG4gIFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsXG4gIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhLFxuICBUZW5zb3JNZXRhZGF0YSxcbn0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vd2FzbS1jb3JlLWltcGwnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5IH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgaW1wb3J0UHJveHlXb3JrZXIgfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxuY29uc3QgaXNQcm94eSA9ICgpOiBib29sZWFuID0+ICEhZW52Lndhc20ucHJveHkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBwcm94eVdvcmtlcjogV29ya2VyIHwgdW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xubGV0IHRlbXBvcmFyeU9iamVjdFVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG50eXBlIFByb21pc2VDYWxsYmFja3M8VCA9IHZvaWQ+ID0gW3Jlc29sdmU6IChyZXN1bHQ6IFQpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZF07XG5sZXQgaW5pdFdhc21DYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M7XG5jb25zdCBxdWV1ZWRDYWxsYmFja3M6IE1hcDxPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBBcnJheTxQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+Pj4gPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGVucXVldWVDYWxsYmFja3MgPSAodHlwZTogT3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgY2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gcXVldWVkQ2FsbGJhY2tzLmdldCh0eXBlKTtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgcXVldWUucHVzaChjYWxsYmFja3MpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlZENhbGxiYWNrcy5zZXQodHlwZSwgW2NhbGxiYWNrc10pO1xuICB9XG59O1xuXG5jb25zdCBlbnN1cmVXb3JrZXIgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXppbmcgfHwgIWluaXRpYWxpemVkIHx8IGFib3J0ZWQgfHwgIXByb3h5V29ya2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZXIgbm90IHJlYWR5Jyk7XG4gIH1cbn07XG5cbmNvbnN0IG9uUHJveHlXb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XG4gICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1sxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcG9yYXJ5T2JqZWN0VXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcG9yYXJ5T2JqZWN0VXJsKTtcbiAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5pdC1lcCc6XG4gICAgY2FzZSAnY29weS1mcm9tJzpcbiAgICBjYXNlICdjcmVhdGUnOlxuICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgIGNhc2UgJ3J1bic6XG4gICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlZENhbGxiYWNrcy5nZXQoZXYuZGF0YS50eXBlKSE7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVswXShldi5kYXRhLm91dCEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwcm94eVdvcmtlcj8udGVybWluYXRlKCk7XG5cbiAgICAgIHZvaWQgaW1wb3J0UHJveHlXb3JrZXIoKS50aGVuKChbb2JqZWN0VXJsLCB3b3JrZXJdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJveHlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25lcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4gcmVqZWN0KGV2KTtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbm1lc3NhZ2UgPSBvblByb3h5V29ya2VyTWVzc2FnZTtcbiAgICAgICAgICBpbml0V2FzbUNhbGxiYWNrcyA9IFtyZXNvbHZlLCByZWplY3RdO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC13YXNtJywgaW46IGVudiB9O1xuICAgICAgICAgIHByb3h5V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IG9iamVjdFVybDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KGVudi53YXNtKTtcbiAgICAgIGF3YWl0IGNvcmUuaW5pdFJ1bnRpbWUoZW52KTtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVPcnRFcCA9IGFzeW5jIChlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdpbml0LWVwJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdpbml0LWVwJywgaW46IHsgZXBOYW1lLCBlbnYgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IGNvcmUuaW5pdEVwKGVudiwgZXBOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSBhc3luYyAoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY29weS1mcm9tJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjb3B5LWZyb20nLCBpbjogeyBidWZmZXIgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtidWZmZXIuYnVmZmVyXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUuY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcbiAgbW9kZWw6IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyIHwgVWludDhBcnJheSxcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIC8vIGNoZWNrIHVuc3VwcG9ydGVkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjcmVhdGUnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NyZWF0ZScsIGluOiB7IG1vZGVsLCBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSB9IH07XG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGU6IFRyYW5zZmVyYWJsZVtdID0gW107XG4gICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKG1vZGVsLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5jcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3JlbGVhc2UnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ3JlbGVhc2UnLCBpbjogc2Vzc2lvbklkIH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5yZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0czogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgLy8gY2hlY2sgaW5wdXRzIGxvY2F0aW9uXG4gICAgaWYgKGlucHV0cy5zb21lKCh0KSA9PiB0WzNdICE9PSAnY3B1JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgb3V0cHV0cyBsb2NhdGlvblxuICAgIGlmIChvdXRwdXRzLnNvbWUoKHQpID0+IHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3J1bicsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZUlucHV0cyA9IGlucHV0cyBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdOyAvLyBldmVyeSBpbnB1dCBpcyBvbiBDUFUuXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ3J1bicsXG4gICAgICAgIGluOiB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHM6IHNlcmlhbGl6YWJsZUlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9LFxuICAgICAgfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBjb3JlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKHNlcmlhbGl6YWJsZUlucHV0cykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLnJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdlbmQtcHJvZmlsaW5nJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdlbmQtcHJvZmlsaW5nJywgaW46IHNlc3Npb25JZCB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUuZW5kUHJvZmlsaW5nKHNlc3Npb25JZCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIEluZmVyZW5jZVNlc3Npb24sXG4gIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLFxuICBTZXNzaW9uSGFuZGxlcixcbiAgVGVuc29yLFxuICBUUkFDRV9GVU5DX0JFR0lOLFxuICBUUkFDRV9GVU5DX0VORCxcbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBjcmVhdGVTZXNzaW9uLCBlbmRQcm9maWxpbmcsIHJlbGVhc2VTZXNzaW9uLCBydW4gfSBmcm9tICcuL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHsgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSB9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3IsIGdldE5hbWU6ICgpID0+IHN0cmluZyk6IFRlbnNvck1ldGFkYXRhID0+IHtcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHRlbnNvci5kYXRhLCAnY3B1J107XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywgeyBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIgfSwgJ2dwdS1idWZmZXInXTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvciB9LCAnbWwtdGVuc29yJ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yWzNdKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGdwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgaWYgKCFpc01MVGVuc29yU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1sVGVuc29yLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gdGVuc29yWzJdO1xuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tTUxUZW5zb3IobWxUZW5zb3IsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XG5cbiAgaW5wdXROYW1lczogc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XG4gICAgLy8gZmV0Y2ggbW9kZWwgZnJvbSB1cmwgYW5kIG1vdmUgdG8gd2FzbSBoZWFwLlxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZyB8IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGxldCBtb2RlbDogUGFyYW1ldGVyczx0eXBlb2YgY3JlYXRlU2Vzc2lvbj5bMF07XG5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cbiAgICAgICAgbW9kZWwgPSBhd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGhPckJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIFt0aGlzLnNlc3Npb25JZCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLm91dHB1dE5hbWVzXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XG4gIH1cblxuICBhc3luYyBydW4oXG4gICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaCgoa3ZwKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBpbnB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBcnJheTogQXJyYXk8VGVuc29yIHwgbnVsbD4gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goKGt2cCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PlxuICAgICAgZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcCgodCwgaSkgPT5cbiAgICAgIHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsLFxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdE1hcFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG91dHB1dEFycmF5W2ldID8/IGRlY29kZVRlbnNvck1ldGFkYXRhKHJlc3VsdHNbaV0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XG5pbXBvcnQgeyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XG5pbXBvcnQgeyBzY3JpcHRTcmMgfSBmcm9tICcuL3dhc20vd2FzbS11dGlscy1pbXBvcnQnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGlmIChlbnYud2FzbS5zaW1kID09PSBmYWxzZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiAnICtcbiAgICAgICAgJ25vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5wcm94eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBhcHBsaWVzIHdoZW4gYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCBpcyBub3Qgc2V0IGJ5IHVzZXIuIFdlIHdpbGwgYWx3YXlzIGhvbm9yIHVzZXInc1xuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG5cbiAgICAvLyBCcm93c2VyOiB3aGVuIGNyb3NzT3JpZ2luSXNvbGF0ZWQgaXMgZmFsc2UsIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUgc28gV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdFxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxuICAgIC8vXG4gICAgLy8gVGhlcmUgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBicm93c2VyIGlzIGNvbmZpZ3VyZWQgdG8gZm9yY2UtZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyIChlLmcuIENocm9tdWltIHdpdGhcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcbiAgICAvLyBudW1UaHJlYWRzIHRvIDEgaGVyZS4gSWYgd2Ugd2FudCB0byBlbmFibGUgbXVsdGktdGhyZWFkaW5nIGluIHRlc3QsIHdlIHNob3VsZCBzZXQgYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCB0byBhXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdub2RlOm9zJykuY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUKSB7XG4gICAgLy8gb3ZlcndyaXRlIHdhc20gcGF0aHMgb3ZlcnJpZGUgaWYgbm90IHNldFxuICAgIGlmIChlbnYud2FzbS53YXNtUGF0aHMgPT09IHVuZGVmaW5lZCAmJiBzY3JpcHRTcmMgJiYgc2NyaXB0U3JjLmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgIGVudi53YXNtLndhc21QYXRocyA9IHNjcmlwdFNyYy5zdWJzdHJpbmcoMCwgc2NyaXB0U3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgV2ViQXNzZW1ibHkgYmFja2VuZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgZm9yIGVhY2ggYmFja2VuZCBuYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSB3aGVuXG4gICAqIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkIHdpdGggYSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIGJhY2tlbmROYW1lIC0gdGhlIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKi9cbiAgYXN5bmMgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gcG9wdWxhdGUgd2FzbSBmbGFnc1xuICAgIGluaXRpYWxpemVGbGFncygpO1xuXG4gICAgLy8gaW5pdCB3YXNtXG4gICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSgpO1xuXG4gICAgLy8gcGVyZm9ybWUgRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0aWFsaXplT3J0RXAoYmFja2VuZE5hbWUpO1xuICB9XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgYXdhaXQgaGFuZGxlci5sb2FkTW9kZWwocGF0aE9yQnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxuLy8gU28gd2UgaW1wb3J0IGNvZGUgaW5zaWRlIHRoZSBpZi1jbGF1c2UgdG8gYWxsb3cgYnVuZGxlciByZW1vdmUgdGhlIGNvZGUgc2FmZWx5LlxuXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5leHBvcnQgZGVmYXVsdCBvcnQ7XG5cbmltcG9ydCB7IHJlZ2lzdGVyQmFja2VuZCwgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHTCkge1xuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XG4gIGNvbnN0IHdhc21CYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20nKS53YXNtQmFja2VuZDtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywgeyB2YWx1ZTogdmVyc2lvbiwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMCc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFnQk0sVUFDQSwwQkFZTyxpQkF3Q1AsZ0NBd0NPO0FBN0diOzs7QUFnQkEsTUFBTSxXQUFxQyxvQkFBSSxJQUFHO0FBQ2xELE1BQU0sMkJBQXFDLENBQUE7QUFZcEMsTUFBTSxrQkFBa0IsQ0FBQ0EsT0FBY0MsVUFBa0IsYUFBMEI7QUFDeEYsWUFBSUEsWUFBVyxPQUFPQSxTQUFRLFNBQVMsY0FBYyxPQUFPQSxTQUFRLGtDQUFrQyxZQUFZO0FBQ2hILGdCQUFNLGlCQUFpQixTQUFTLElBQUlELEtBQUk7QUFDeEMsY0FBSSxtQkFBbUIsUUFBVztBQUNoQyxxQkFBUyxJQUFJQSxPQUFNLEVBQUUsU0FBQUMsVUFBUyxTQUFRLENBQUU7cUJBQy9CLGVBQWUsV0FBVyxVQUFVO0FBRTdDO3FCQUNTLGVBQWUsYUFBYSxVQUFVO0FBQy9DLGdCQUFJLGVBQWUsWUFBWUEsVUFBUztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sNEJBQTRCRCxLQUFJLG9CQUFvQixRQUFRLEVBQUU7OztBQUlsRixjQUFJLFlBQVksR0FBRztBQUNqQixrQkFBTSxJQUFJLHlCQUF5QixRQUFRQSxLQUFJO0FBQy9DLGdCQUFJLE1BQU0sSUFBSTtBQUNaLHVDQUF5QixPQUFPLEdBQUcsQ0FBQzs7QUFHdEMscUJBQVNFLEtBQUksR0FBR0EsS0FBSSx5QkFBeUIsUUFBUUEsTUFBSztBQUN4RCxrQkFBSSxTQUFTLElBQUkseUJBQXlCQSxFQUFDLENBQUMsRUFBRyxZQUFZLFVBQVU7QUFDbkUseUNBQXlCLE9BQU9BLElBQUcsR0FBR0YsS0FBSTtBQUMxQzs7O0FBR0oscUNBQXlCLEtBQUtBLEtBQUk7O0FBRXBDOztBQUdGLGNBQU0sSUFBSSxVQUFVLHFCQUFxQjtN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QVlBLG9CQVlBLFdBWUEsZUFzK0JHO0FBMTdDUDtBQUFBO0FBcUJBLE1BQUksT0FBTztBQUNYLFVBQUk7QUFDRixlQUFPLElBQUksWUFBWSxTQUFTLElBQUksWUFBWSxPQUFPLElBQUksV0FBVztBQUFBLFVBQ3BFO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFH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QjtBQUM3QixVQUFNQyxpQkFBZ0IsOERBQTRCO0FBQ2xELG9CQUFnQixTQUFTQSxnQkFBZSxHQUFHO0FBQUEsRUFDN0M7QUFFQSxNQUFJLE1BQTBCO0FBQzVCLFVBQU1DLGVBQWMsMERBQTBCO0FBQzlDLFFBQUksT0FBMEI7QUFDNUIsc0JBQWdCLFVBQVVBLGNBQWEsQ0FBQztBQUN4QyxzQkFBZ0IsU0FBU0EsY0FBYSxDQUFDO0FBQUEsSUFDekM7QUFDQSxvQkFBZ0IsT0FBT0EsY0FBYSxFQUFFO0FBQ3RDLG9CQUFnQixRQUFRQSxjQUFhLEVBQUU7QUFBQSxFQUN6QztBQUVBLFNBQU8sZUFBZUMsS0FBSSxVQUFVLE9BQU8sRUFBRSxPQUFPQyxVQUFTLFlBQVksS0FBSyxDQUFDOyIsCiAgIm5hbWVzIjogWyJuYW1lIiwgImJhY2tlbmQiLCAiaSIsICJlbnYiLCAiY3JlYXRlQ2FudmFzIiwgIlRlbnNvciIsICJUZW5zb3IiLCAibmFtZSIsICJiYWNrZW5kIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiYmFja2VuZCIsICJUZW5zb3IiLCAibmFtZSIsICJUcmFpbmluZ1Nlc3Npb24iLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJUZW5zb3IiLCAiVHJhaW5pbmdTZXNzaW9uIiwgImVudiIsICJsb2ciLCAiZW52IiwgIm5hbWUiLCAidmVyc2lvbiIsICJleHBvcnRzIiwgIkd1aWQiLCAiY2FjaGUiLCAiZGl2IiwgImxvZzIiLCAib25ueHJ1bnRpbWUiLCAiZXhwZXJpbWVudGFsIiwgImZicyIsICJBdHRyaWJ1dGVUeXBlIiwgIkRpbWVuc2lvblZhbHVlVHlwZSIsICJUZW5zb3JEYXRhVHlwZSIsICJOb2RlVHlwZSIsICJUeXBlSW5mb1ZhbHVlIiwgIk5vZGUiLCAidmVyc2lvbiIsICJUZW5zb3IiLCAiQXR0cmlidXRlIiwgIkdyYXBoIiwgIk1vZGVsIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAicGFyYW1zIiwgIm9mZnNldCIsICJleHBvcnRzIiwgImkiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJzbGljZSIsICJzaXplIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImZyb21OdW1iZXIiLCAidG9OdW1iZXIiLCAiZXhwb3J0cyIsICJCdWZmZXIiLCAibmFtZSIsICJpIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImNyZWF0ZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJjcmVhdGVfYXJyYXkiLCAiY3JlYXRlIiwgImJ1ZmZlciIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJzZWxmIiwgImVyciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAicmVxdWlyZV9taW5pbWFsIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIm9ubngiLCAiVGVuc29yIiwgIk1hcCIsICJpbml0X3RlbnNvciIsICJUZW5zb3IiLCAic2hhcGUiLCAic3BsaXQiLCAiaW1wb3J0X29ubngiLCAiVGVuc29yIiwgImluaXRfdGVuc29yIiwgImNhY2hlIiwgInZlcnNpb24iLCAibmFtZSIsICJzaGFwZSIsICJzaGFwZSIsICJzaGFwZSIsICJpbml0X3RlbnNvciIsICJzaGFwZSIsICJUZW5zb3IiLCAibmFtZSIsICJuYW1lIiwgIm5hbWUiLCAiYWRkIiwgImFuZCIsICJvciIsICJ4b3IiLCAiZ2xzbCIsICJzaGFkZXJTb3VyY2UiLCAidmFsaWRhdGVJbnB1dHMiLCAic2hpZnQiLCAidmFsaWRhdGVJbnB1dHMiLCAibmFtZSIsICJsb2ciLCAibm90IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgIm5hbWUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAic2hhcGUiLCAidmFsaWRhdGVJbnB1dHMiLCAic3VtIiwgInZhbGlkYXRlSW5wdXRzIiwgIm5hbWUiLCAiaW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRpbSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJpbml0X3RlbnNvciIsICJUZW5zb3IiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAic3BsaXQiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHNWMTMiLCAiYWRkIiwgImFuZCIsICJsb2ciLCAibm90IiwgIm9yIiwgInhvciIsICJuYW1lIiwgInNoYXBlIiwgInNoYXBlIiwgIm5hbWUiLCAic291cmNlIiwgInBhY2tlZFNhbXBsZXIiLCAidGV4TnVtUiIsICJ0ZXhOdW1DIiwgInRyYW5zcG9zZSIsICJuYW1lIiwgInNoYXBlIiwgImkiLCAibmFtZSIsICJuYW1lIiwgImVudiIsICJuYW1lIiwgImxvY2F0aW9uIiwgInRleHR1cmUiLCAiYmFja2VuZCIsICJ2ZXJzaW9uIiwgImVudiIsICJlbnYiLCAiY2FjaGUiLCAiYmFja2VuZCIsICJpbml0X2JhY2tlbmQiLCAib3V0cHV0IiwgImltcG9ydF9vbm54IiwgIm9ydEZicyIsICJpbml0X3RlbnNvciIsICJUZW5zb3IiLCAidmFsdWUiLCAiaW1wb3J0X29ubngiLCAib3J0RmJzIiwgImluaXRfdGVuc29yIiwgIm5hbWUiLCAiVGVuc29yIiwgInNoYXBlIiwgIm5vZGVJbmRleCIsICJpbXBvcnRfb25ueCIsICJvcnRGYnMiLCAiaW5pdF9iYWNrZW5kIiwgImJhY2tlbmQiLCAiaW5pdF90ZW5zb3IiLCAibmFtZSIsICJUZW5zb3IiLCAiZW52IiwgIndhc20iLCAibW9kdWxlIiwgIndhc20iLCAibmFtZSIsICJ3YXNtIiwgIndhc20iLCAibmFtZSIsICJsb2NhdGlvbiIsICJlbnYiLCAid2FzbSIsICJuYW1lIiwgImxvY2F0aW9uIiwgInRlbnNvciIsICJlcnJvckNvZGUiLCAiaSIsICJpbml0aWFsaXppbmciLCAiaW5pdGlhbGl6ZWQiLCAiYWJvcnRlZCIsICJjb3B5RnJvbUV4dGVybmFsQnVmZmVyIiwgImNyZWF0ZVNlc3Npb24iLCAicmVsZWFzZVNlc3Npb24iLCAicnVuIiwgImVuZFByb2ZpbGluZyIsICJlbnYiLCAiaW5pdF9zZXNzaW9uX2hhbmRsZXJfaW5mZXJlbmNlIiwgIlRlbnNvciIsICJjb3B5RnJvbUV4dGVybmFsQnVmZmVyIiwgImNyZWF0ZVNlc3Npb24iLCAicmVsZWFzZVNlc3Npb24iLCAibmFtZSIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImluaXRfc2Vzc2lvbl9oYW5kbGVyX2luZmVyZW5jZSIsICJlbnYiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJUZW5zb3IiLCAiVHJhaW5pbmdTZXNzaW9uIiwgImVudiIsICJ2ZXJzaW9uIiwgIm9ubnhqc0JhY2tlbmQiLCAid2FzbUJhY2tlbmQiLCAiZW52IiwgInZlcnNpb24iXQp9Cg==
