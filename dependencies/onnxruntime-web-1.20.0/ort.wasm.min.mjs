/*!
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Ge=Object.defineProperty;var Sr=Object.getOwnPropertyDescriptor;var Ar=Object.getOwnPropertyNames;var Or=Object.prototype.hasOwnProperty;var He=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var w=(t,e)=>()=>(t&&(e=t(t=0)),e);var je=(t,e)=>{for(var n in e)Ge(t,n,{get:e[n],enumerable:!0})},vr=(t,e,n,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Ar(e))!Or.call(t,r)&&r!==n&&Ge(t,r,{get:()=>e[r],enumerable:!(o=Sr(e,r))||o.enumerable});return t};var ut=t=>vr(Ge({},"__esModule",{value:!0}),t);var be,z,oe,xr,ge,Ee=w(()=>{"use strict";be=new Map,z=[],oe=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=be.get(t);if(o===void 0)be.set(t,{backend:e,priority:n});else{if(o.priority>n)return;if(o.priority===n&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let r=z.indexOf(t);r!==-1&&z.splice(r,1);for(let i=0;i<z.length;i++)if(be.get(z[i]).priority<=n){z.splice(i,0,t);return}z.push(t)}return}throw new TypeError("not a valid backend")},xr=async t=>{let e=be.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return n||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},ge=async t=>{let e=t.executionProviders||[],n=e.map(a=>typeof a=="string"?a:a.name),o=n.length===0?z:n,r,i=[],s=new Set;for(let a of o){let u=await xr(a);typeof u=="string"?i.push({name:a,err:u}):(r||(r=u),r===u&&s.add(a))}if(!r)throw new Error(`no available backend found. ERR: ${i.map(a=>`[${a.name}] ${a.err}`).join(", ")}`);for(let{name:a,err:u}of i)n.includes(a)&&console.warn(`removing requested execution provider "${a}" from session options because it is not available: ${u}`);let f=e.filter(a=>s.has(typeof a=="string"?a:a.name));return[r,new Proxy(t,{get:(a,u)=>u==="executionProviders"?f:Reflect.get(a,u)})]}});var ft=w(()=>{"use strict";Ee()});var ct,lt=w(()=>{"use strict";ct="1.20.0"});var dt,U,Ve=w(()=>{"use strict";lt();dt="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:ct},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);dt=t}},get logLevel(){return dt}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var T,pt=w(()=>{"use strict";Ve();T=U});var mt,ht,yt=w(()=>{"use strict";mt=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let o=n.getContext("2d");if(o!=null){let r,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],i=t.dims[3]):(r=t.dims[3],i=t.dims[2]);let s=e?.format!==void 0?e.format:"RGB",f=e?.norm,a,u;f===void 0||f.mean===void 0?a=[255,255,255,255]:typeof f.mean=="number"?a=[f.mean,f.mean,f.mean,f.mean]:(a=[f.mean[0],f.mean[1],f.mean[2],0],f.mean[3]!==void 0&&(a[3]=f.mean[3])),f===void 0||f.bias===void 0?u=[0,0,0,0]:typeof f.bias=="number"?u=[f.bias,f.bias,f.bias,f.bias]:(u=[f.bias[0],f.bias[1],f.bias[2],0],f.bias[3]!==void 0&&(u[3]=f.bias[3]));let d=i*r,l=0,c=d,m=d*2,p=-1;s==="RGBA"?(l=0,c=d,m=d*2,p=d*3):s==="RGB"?(l=0,c=d,m=d*2):s==="RBG"&&(l=0,m=d,c=d*2);for(let h=0;h<i;h++)for(let E=0;E<r;E++){let O=(t.data[l++]-u[0])*a[0],y=(t.data[c++]-u[1])*a[1],b=(t.data[m++]-u[2])*a[2],A=p===-1?255:(t.data[p++]-u[3])*a[3];o.fillStyle="rgba("+O+","+y+","+b+","+A+")",o.fillRect(E,h,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ht=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(n!=null){let r,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],i=t.dims[1],s=t.dims[3]):(r=t.dims[3],i=t.dims[2],s=t.dims[1]);let f=e!==void 0&&e.format!==void 0?e.format:"RGB",a=e?.norm,u,d;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],255],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?d=[0,0,0,0]:typeof a.bias=="number"?d=[a.bias,a.bias,a.bias,a.bias]:(d=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(d[3]=a.bias[3]));let l=i*r;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let c=4,m=0,p=1,h=2,E=3,O=0,y=l,b=l*2,A=-1;f==="RGBA"?(O=0,y=l,b=l*2,A=l*3):f==="RGB"?(O=0,y=l,b=l*2):f==="RBG"&&(O=0,b=l,y=l*2),o=n.createImageData(r,i);for(let M=0;M<i*r;m+=c,p+=c,h+=c,E+=c,M++)o.data[m]=(t.data[O++]-d[0])*u[0],o.data[p]=(t.data[y++]-d[1])*u[1],o.data[h]=(t.data[b++]-d[2])*u[2],o.data[E]=A===-1?255:(t.data[A++]-d[3])*u[3]}else throw new Error("Can not access image data");return o}});var Ye,wt,bt,gt,Et,Tt,St=w(()=>{"use strict";Te();Ye=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:o}=e,r=e.norm??{mean:255,bias:0},i,s;typeof r.mean=="number"?i=[r.mean,r.mean,r.mean,r.mean]:i=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?s=[r.bias,r.bias,r.bias,r.bias]:s=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let f=e.format!==void 0?e.format:"RGBA",a=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",u=n*o,d=a==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),l=4,c=0,m=1,p=2,h=3,E=0,O=u,y=u*2,b=-1;f==="RGB"&&(l=3,c=0,m=1,p=2,h=-1),a==="RGBA"?b=u*3:a==="RBG"?(E=0,y=u,O=u*2):a==="BGR"&&(y=0,O=u,E=u*2);for(let M=0;M<u;M++,c+=l,p+=l,m+=l,h+=l)d[E++]=(t[c]+s[0])/i[0],d[O++]=(t[m]+s[1])/i[1],d[y++]=(t[p]+s[2])/i[2],b!==-1&&h!==-1&&(d[b++]=(t[h]+s[3])/i[3]);return a==="RGBA"?new P("float32",d,[1,4,n,o]):new P("float32",d,[1,3,n,o])},wt=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,r=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,i=typeof t=="string",s,f=e??{},a=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=d=>typeof HTMLCanvasElement<"u"&&d instanceof HTMLCanvasElement||d instanceof OffscreenCanvas?d.getContext("2d"):null;if(n){let d=a();d.width=t.width,d.height=t.height;let l=u(d);if(l!=null){let c=t.height,m=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(c=e.resizedHeight,m=e.resizedWidth),e!==void 0){if(f=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");f.tensorFormat="RGBA",f.height=c,f.width=m}else f.tensorFormat="RGBA",f.height=c,f.width=m;l.drawImage(t,0,0),s=l.getImageData(0,0,m,c).data}else throw new Error("Can not access image data")}else if(o){let d,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(d=e.resizedHeight,l=e.resizedWidth):(d=t.height,l=t.width),e!==void 0&&(f=e),f.format="RGBA",f.height=d,f.width=l,e!==void 0){let c=a();c.width=l,c.height=d;let m=u(c);if(m!=null)m.putImageData(t,0,0),s=m.getImageData(0,0,l,d).data;else throw new Error("Can not access image data")}else s=t.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let d=a();d.width=t.width,d.height=t.height;let l=u(d);if(l!=null){let c=t.height,m=t.width;return l.drawImage(t,0,0,m,c),s=l.getImageData(0,0,m,c).data,f.height=c,f.width=m,Ye(s,f)}else throw new Error("Can not access image data")}else{if(i)return new Promise((d,l)=>{let c=a(),m=u(c);if(!t||!m)return l();let p=new Image;p.crossOrigin="Anonymous",p.src=t,p.onload=()=>{c.width=p.width,c.height=p.height,m.drawImage(p,0,0,c.width,c.height);let h=m.getImageData(0,0,c.width,c.height);f.height=c.height,f.width=c.width,d(Ye(h.data,f))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Ye(s,f);throw new Error("Input data provided is not supported - aborted tensor creation")},bt=(t,e)=>{let{width:n,height:o,download:r,dispose:i}=e,s=[1,o,n,4];return new P({location:"texture",type:"float32",texture:t,dims:s,download:r,dispose:i})},gt=(t,e)=>{let{dataType:n,dims:o,download:r,dispose:i}=e;return new P({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:o,download:r,dispose:i})},Et=(t,e)=>{let{dataType:n,dims:o,download:r,dispose:i}=e;return new P({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:o,download:r,dispose:i})},Tt=(t,e,n)=>new P({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})});var G,se,At,Ot,vt=w(()=>{"use strict";G=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),se=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),At=!1,Ot=()=>{if(!At){At=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;t&&(G.set("int64",BigInt64Array),se.set(BigInt64Array,"int64")),e&&(G.set("uint64",BigUint64Array),se.set(BigUint64Array,"uint64")),n?(G.set("float16",Float16Array),se.set(Float16Array,"float16")):G.set("float16",Uint16Array)}}});var xt,Pt,It=w(()=>{"use strict";Te();xt=t=>{let e=1;for(let n=0;n<t.length;n++){let o=t[n];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${n}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${o}`);e*=o}return e},Pt=(t,e)=>{switch(t.location){case"cpu":return new P(t.type,t.data,e);case"cpu-pinned":return new P({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new P({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new P({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new P({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var P,Te=w(()=>{"use strict";yt();St();vt();It();P=class{constructor(e,n,o){Ot();let r,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,r=e.type,i=e.dims,e.location){case"cpu-pinned":{let f=G.get(r);if(!f)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof f))throw new TypeError(`buffer should be of type ${f.name}`);this.cpuData=e.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let f,a;if(typeof e=="string")if(r=e,a=o,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");f=n}else{let u=G.get(e);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16"&&u===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${u.name} as data.`);e==="uint64"||e==="int64"?f=u.from(n,BigInt):f=u.from(n)}else if(n instanceof u)f=n;else if(n instanceof Uint8ClampedArray)if(e==="uint8")f=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${r} tensor's data must be type of ${u}`)}else if(a=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let u=typeof e[0];if(u==="string")r="string",f=e;else if(u==="boolean")r="bool",f=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else if(e instanceof Uint8ClampedArray)r="uint8",f=Uint8Array.from(e);else{let u=se.get(e.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=u,f=e}if(a===void 0)a=[f.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");i=a,this.cpuData=f,this.dataLocation="cpu"}let s=xt(i);if(this.cpuData&&s!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=i,this.size=s}static async fromImage(e,n){return wt(e,n)}static fromTexture(e,n){return bt(e,n)}static fromGpuBuffer(e,n){return gt(e,n)}static fromMLTensor(e,n){return Et(e,n)}static fromPinnedBuffer(e,n,o){return Tt(e,n,o)}toDataURL(e){return mt(this,e)}toImageData(e){return ht(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Pt(this,e)}}});var I,Se=w(()=>{"use strict";Te();I=P});var Lt,Bt,H,j,qe=w(()=>{"use strict";Ve();Lt=(t,e)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${t}::ORT::${e}`)},Bt=(t,e)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let r=0;r<n.length;r++){if(o&&!n[r].includes("TRACE_FUNC")){let i=`FUNC_${t}::${n[r].trim().split(" ")[1]}`;e&&(i+=`::${e}`),Lt("CPU",i);return}n[r].includes("TRACE_FUNC")&&(o=!0)}},H=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Bt("BEGIN",t)},j=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Bt("END",t)}});var Ae,Ct=w(()=>{"use strict";Ee();Se();qe();Ae=class t{constructor(e){this.handler=e}async run(e,n,o){H();let r={},i={};if(typeof e!="object"||e===null||e instanceof I||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,d=Object.getOwnPropertyNames(n);for(let l of this.outputNames)if(d.indexOf(l)!==-1){let c=n[l];(c===null||c instanceof I)&&(u=!0,s=!1,r[l]=c)}if(u){if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof e[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(s)for(let u of this.outputNames)r[u]=null;let f=await this.handler.run(e,r,i),a={};for(let u in f)if(Object.hasOwnProperty.call(f,u)){let d=f[u];d instanceof I?a[u]=d:a[u]=new I(d.type,d.data,d.dims)}return j(),a}async release(){return this.handler.dispose()}static async create(e,n,o,r){H();let i,s={};if(typeof e=="string"){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let d=e,l=0,c=e.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=d.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${d.byteLength}).`);if(c=e.byteLength-l,typeof o=="number"){if(c=o,!Number.isSafeInteger(c))throw new RangeError("'byteLength' must be an integer.");if(c<=0||l+c>d.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${d.byteLength-l}].`);if(typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(d,l,c)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[f,a]=await ge(s),u=await f.createInferenceSessionHandler(i,a);return j(),new t(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Pr,Mt=w(()=>{"use strict";Ct();Pr=Ae});var Ut=w(()=>{"use strict"});var Dt=w(()=>{"use strict"});var Rt=w(()=>{"use strict"});var _t=w(()=>{"use strict"});var Ir,Oe,kt=w(()=>{"use strict";Ee();Se();Ir="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Oe=class t{constructor(e,n,o){this.handler=e,this.hasOptimizerModel=n,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,n){let o=e.evalModel||"",r=e.optimizerModel||"",i=n||{},[s,f]=await ge(i);if(s.createTrainingSessionHandler){let a=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,o,r,f);return new t(a,!!e.optimizerModel,!!e.evalModel)}else throw new Error(Ir)}typeNarrowingForRunStep(e,n,o,r,i){let s={},f={};if(typeof o!="object"||o===null||o instanceof I||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let u of r){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(n.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);s[u]=null}if(typeof i=="object"&&i!==null)f=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,d=Object.getOwnPropertyNames(r);for(let l of n)if(d.indexOf(l)!==-1){let c=r[l];(c===null||c instanceof I)&&(u=!0,a=!1,s[l]=c)}if(u){if(typeof i=="object"&&i!==null)f=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else f=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of e)if(typeof o[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(a)for(let u of n)s[u]=null;return[s,f]}convertHandlerReturnTypeToMapOfTensors(e){let n={};for(let o in e)if(Object.hasOwnProperty.call(e,o)){let r=e[o];r instanceof I?n[o]=r:n[o]=new I(r.type,r.data,r.dims)}return n}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,n,o){let[r,i]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,n,o),s=await this.handler.runTrainStep(e,r,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,n,o){if(this.hasEvalModel){let[r,i]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,n,o),s=await this.handler.runEvalStep(e,r,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,n=!0){let o=await this.getParametersSize(n);if(e.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,n)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var Lr,Ft=w(()=>{"use strict";kt();Lr=Oe});var Je={};je(Je,{InferenceSession:()=>Pr,TRACE:()=>Lt,TRACE_FUNC_BEGIN:()=>H,TRACE_FUNC_END:()=>j,Tensor:()=>I,TrainingSession:()=>Lr,env:()=>T,registerBackend:()=>oe});var V=w(()=>{"use strict";ft();pt();Mt();Se();Ut();Dt();qe();Rt();_t();Ft()});var ve=w(()=>{"use strict"});var zt={};je(zt,{default:()=>Br});var Wt,$t,Br,Gt=w(()=>{"use strict";Xe();Y();ie();Wt="ort-wasm-proxy-worker",$t=globalThis.self?.name===Wt;$t&&(self.onmessage=t=>{let{type:e,in:n}=t.data;try{switch(e){case"init-wasm":xe(n.wasm).then(()=>{Pe(n).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:r}=n;Ie(r,o).then(()=>{postMessage({type:e})},i=>{postMessage({type:e,err:i})});break}case"copy-from":{let{buffer:o}=n,r=ae(o);postMessage({type:e,out:r});break}case"create":{let{model:o,options:r}=n;Le(o,r).then(i=>{postMessage({type:e,out:i})},i=>{postMessage({type:e,err:i})});break}case"release":Be(n),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:r,inputs:i,outputIndices:s,options:f}=n;Ce(o,r,i,s,new Array(s.length).fill(null),f).then(a=>{a.some(u=>u[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:a},Ue([...i,...a]))},a=>{postMessage({type:e,err:a})});break}case"end-profiling":Me(n),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Br=$t?null:t=>new Worker(t??R,{type:"module",name:Wt})});var R,Cr,jt,Mr,Ur,Vt,Dr,Ht,Yt,qt,ie=w(()=>{"use strict";ve();R=!1?void 0:import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),Cr=!1||typeof location>"u"?void 0:location.origin,jt=(t,e)=>{try{let n=e??R;return(n?new URL(t,n):new URL(t)).origin===Cr}catch{return!1}},Mr=(t,e)=>{let n=e??R;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},Ur=(t,e)=>`${e??"./"}${t}`,Vt=async t=>{let n=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},Dr=async t=>(await import(/*webpackIgnore:true*/t)).default,Ht=(Gt(),ut(zt)).default,Yt=async()=>{if(!R)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(jt(R))return[void 0,Ht()];let t=await Vt(R);return[t,Ht(t)]},qt=async(t,e,n)=>{{let o="ort-wasm-simd-threaded.mjs",r=t??Mr(o,e),i=!!1&&n&&r&&!jt(r,e),s=i?await Vt(r):r??Ur(o,e);return[i?s:void 0,await Dr(s)]}}});var Ke,Qe,De,Jt,Rr,_r,xe,v,Y=w(()=>{"use strict";ie();Qe=!1,De=!1,Jt=!1,Rr=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},_r=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},xe=async t=>{if(Qe)return Promise.resolve();if(De)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Jt)throw new Error("previous call to 'initializeWebAssembly()' failed.");De=!0;let e=t.initTimeout,n=t.numThreads;if(!_r())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=Rr();n>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let r=t.wasmPaths,i=typeof r=="string"?r:void 0,s=r?.mjs,f=s?.href??s,a=r?.wasm,u=a?.href??a,d=t.wasmBinary,[l,c]=await qt(f,i,n>1),m=!1,p=[];if(e>0&&p.push(new Promise(h=>{setTimeout(()=>{m=!0,h()},e)})),p.push(new Promise((h,E)=>{let O={numThreads:n};d?O.wasmBinary=d:(u||i)&&(O.locateFile=(y,b)=>u??(i??b)+y),c(O).then(y=>{De=!1,Qe=!0,Ke=y,h(),l&&URL.revokeObjectURL(l)},y=>{De=!1,Jt=!0,E(y)})})),await Promise.race(p),m)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},v=()=>{if(Qe&&Ke)return Ke;throw new Error("WebAssembly is not initialized yet.")}});var x,ue,S,Re=w(()=>{"use strict";Y();x=(t,e)=>{let n=v(),o=n.lengthBytesUTF8(t)+1,r=n._malloc(o);return n.stringToUTF8(t,r,o),e.push(r),r},ue=(t,e,n,o)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([r,i])=>{let s=e?e+r:r;if(typeof i=="object")ue(i,s+".",n,o);else if(typeof i=="string"||typeof i=="number")o(s,i.toString());else if(typeof i=="boolean")o(s,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},S=t=>{let e=v(),n=e.stackSave();try{let o=e.stackAlloc(8);e._OrtGetLastError(o,o+4);let r=e.HEAP32[o/4],i=e.HEAPU32[o/4+1],s=i?e.UTF8ToString(i):"";throw new Error(`${t} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(n)}}});var Xt,Kt=w(()=>{"use strict";Y();Re();Xt=t=>{let e=v(),n=0,o=[],r=t||{};try{if(t?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(r.terminate=!1);let i=0;return t?.tag!==void 0&&(i=x(t.tag,o)),n=e._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,i),n===0&&S("Can't create run options."),t?.extra!==void 0&&ue(t.extra,"",new WeakSet,(s,f)=>{let a=x(s,o),u=x(f,o);e._OrtAddRunConfigEntry(n,a,u)!==0&&S(`Can't set a run config entry: ${s} - ${f}.`)}),[n,o]}catch(i){throw n!==0&&e._OrtReleaseRunOptions(n),o.forEach(s=>e._free(s)),i}}});var kr,Fr,Nr,Wr,Qt,Zt=w(()=>{"use strict";Y();Re();kr=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},Fr=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},Nr=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},Wr=(t,e,n)=>{for(let o of e){let r=typeof o=="string"?o:o.name;switch(r){case"webnn":if(r="WEBNN",typeof o!="string"){let f=o?.deviceType;if(f){let a=x("deviceType",n),u=x(f,n);v()._OrtAddSessionConfigEntry(t,a,u)!==0&&S(`Can't set a session config entry: 'deviceType' - ${f}.`)}}break;case"webgpu":if(r="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let f=x("preferredLayout",n),a=x(s.preferredLayout,n);v()._OrtAddSessionConfigEntry(t,f,a)!==0&&S(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let i=x(r,n);v()._OrtAppendExecutionProvider(t,i)!==0&&S(`Can't append execution provider: ${r}.`)}},Qt=t=>{let e=v(),n=0,o=[],r=t||{};Nr(r);try{let i=kr(r.graphOptimizationLevel??"all"),s=Fr(r.executionMode??"sequential"),f=typeof r.logId=="string"?x(r.logId,o):0,a=r.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let d=typeof r.optimizedModelFilePath=="string"?x(r.optimizedModelFilePath,o):0;if(n=e._OrtCreateSessionOptions(i,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,f,a,u,d),n===0&&S("Can't create session options."),r.executionProviders&&Wr(n,r.executionProviders,o),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let l=x("enableGraphCapture",o),c=x(r.enableGraphCapture.toString(),o);e._OrtAddSessionConfigEntry(n,l,c)!==0&&S(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[l,c]of Object.entries(r.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof c!="number"||!Number.isInteger(c)||c<0)throw new Error(`free dimension override value must be a non-negative integer: ${c}`);let m=x(l,o);e._OrtAddFreeDimensionOverride(n,m,c)!==0&&S(`Can't set a free dimension override: ${l} - ${c}.`)}return r.extra!==void 0&&ue(r.extra,"",new WeakSet,(l,c)=>{let m=x(l,o),p=x(c,o);e._OrtAddSessionConfigEntry(n,m,p)!==0&&S(`Can't set a session config entry: ${l} - ${c}.`)}),[n,o]}catch(i){throw n!==0&&e._OrtReleaseSessionOptions(n),o.forEach(s=>e._free(s)),i}}});var fe,er,ce,tr,rr,_e,ke,nr,Ze=w(()=>{"use strict";fe=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},er=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},ce=(t,e)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],o=typeof e=="number"?e:e.reduce((r,i)=>r*i,1);return n>0?Math.ceil(o*n):void 0},tr=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},rr=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},_e=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",ke=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool",nr=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}});var le,et=w(()=>{"use strict";ve();le=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=He("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=He("node:fs"),o=n(t),r=[];for await(let i of o)r.push(i);return new Uint8Array(Buffer.concat(r))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let r=e.body.getReader(),i;try{i=new ArrayBuffer(o)}catch(f){if(f instanceof RangeError){let a=Math.ceil(o/65536);i=new WebAssembly.Memory({initial:a,maximum:a}).buffer}else throw f}let s=0;for(;;){let{done:f,value:a}=await r.read();if(f)break;let u=a.byteLength;new Uint8Array(i,s,u).set(a),s+=u}return new Uint8Array(i,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var $r,Pe,Ie,Q,zr,ae,Le,Be,or,Ce,Me,Ue,Xe=w(()=>{"use strict";Kt();Zt();Ze();Y();Re();et();$r=(t,e)=>{v()._OrtInit(t,e)!==0&&S("Can't initialize onnxruntime.")},Pe=async t=>{$r(t.wasm.numThreads,rr(t.logLevel))},Ie=async(t,e)=>{},Q=new Map,zr=t=>{let e=v(),n=e.stackSave();try{let o=e.stackAlloc(8);return e._OrtGetInputOutputCount(t,o,o+4)!==0&&S("Can't get session input/output count."),[e.HEAP32[o/4],e.HEAP32[o/4+1]]}finally{e.stackRestore(n)}},ae=t=>{let e=v(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},Le=async(t,e)=>{let n,o,r=v();Array.isArray(t)?[n,o]=t:t.buffer===r.HEAPU8.buffer?[n,o]=[t.byteOffset,t.byteLength]:[n,o]=ae(t);let i=0,s=0,f=0,a=[],u=[],d=[];try{if([s,a]=Qt(e),e?.externalData&&r.mountExternalData){let y=[];for(let b of e.externalData){let A=typeof b=="string"?b:b.path;y.push(le(typeof b=="string"?b:b.data).then(M=>{r.mountExternalData(A,M)}))}await Promise.all(y)}for(let y of e?.executionProviders??[])if((typeof y=="string"?y:y.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,r.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof y!="string"){let A=y,M=A?.context,te=A?.gpuDevice,pe=A?.deviceType,re=A?.numThreads,me=A?.powerPreference;M?r.currentContext=M:te?r.currentContext=await navigator.ml.createContext(te):r.currentContext=await navigator.ml.createContext({deviceType:pe,numThreads:re,powerPreference:me})}else r.currentContext=await navigator.ml.createContext();break}i=await r._OrtCreateSession(n,o,s),i===0&&S("Can't create a session."),r.currentContext&&(r.jsepRegisterMLContext(i,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[l,c]=zr(i),m=!!e?.enableGraphCapture,p=[],h=[],E=[];for(let y=0;y<l;y++){let b=r._OrtGetInputName(i,y);b===0&&S("Can't get an input name."),u.push(b),p.push(r.UTF8ToString(b))}for(let y=0;y<c;y++){let b=r._OrtGetOutputName(i,y);b===0&&S("Can't get an output name."),d.push(b);let A=r.UTF8ToString(b);h.push(A)}let O=null;return Q.set(i,[i,u,d,O,m,!1]),[i,p,h]}catch(l){throw u.forEach(c=>r._OrtFree(c)),d.forEach(c=>r._OrtFree(c)),f!==0&&r._OrtReleaseBinding(f),i!==0&&r._OrtReleaseSession(i),l}finally{r._free(n),s!==0&&r._OrtReleaseSessionOptions(s),a.forEach(l=>r._free(l)),r.unmountExternalData?.()}},Be=t=>{let e=v(),n=Q.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,r,i,s,f]=n;s&&(f&&e._OrtClearBoundOutputs(s.handle),e._OrtReleaseBinding(s.handle)),e.jsepOnReleaseSession?.(t),r.forEach(a=>e._OrtFree(a)),i.forEach(a=>e._OrtFree(a)),e._OrtReleaseSession(o),Q.delete(t)},or=(t,e,n,o,r,i=!1)=>{if(!t){e.push(0);return}let s=v(),f=t[0],a=t[1],u=t[3],d,l;if(f==="string"&&(u==="gpu-buffer"||u==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(i&&u!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(u==="gpu-buffer"){let p=t[2].gpuBuffer;l=ce(fe(f),a);let h=s.jsepRegisterBuffer;if(!h)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');d=h(o,r,p,l)}else if(u==="ml-tensor"){let p=t[2].mlTensor;l=ce(fe(f),a);let h=s.jsepRegisterMLTensor;if(!h)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');d=h(p,fe(f),a)}else{let p=t[2];if(Array.isArray(p)){l=4*p.length,d=s._malloc(l),n.push(d);let h=d/4;for(let E=0;E<p.length;E++){if(typeof p[E]!="string")throw new TypeError(`tensor data at index ${E} is not a string`);s.HEAPU32[h++]=x(p[E],n)}}else l=p.byteLength,d=s._malloc(l),n.push(d),s.HEAPU8.set(new Uint8Array(p.buffer,p.byteOffset,l),d)}let c=s.stackSave(),m=s.stackAlloc(4*a.length);try{let p=m/4;a.forEach(E=>s.HEAP32[p++]=E);let h=s._OrtCreateTensor(fe(f),d,l,m,a.length,nr(u));h===0&&S(`Can't create tensor for input/output. session=${o}, index=${r}.`),e.push(h)}finally{s.stackRestore(c)}},Ce=async(t,e,n,o,r,i)=>{let s=v(),f=Q.get(t);if(!f)throw new Error(`cannot run inference. invalid session id: ${t}`);let a=f[0],u=f[1],d=f[2],l=f[3],c=f[4],m=f[5],p=e.length,h=o.length,E=0,O=[],y=[],b=[],A=[],M=s.stackSave(),te=s.stackAlloc(p*4),pe=s.stackAlloc(p*4),re=s.stackAlloc(h*4),me=s.stackAlloc(h*4);try{s.jsepOnRunStart?.(a),[E,O]=Xt(i);for(let g=0;g<p;g++)or(n[g],y,A,t,e[g],c);for(let g=0;g<h;g++)or(r[g],b,A,t,p+o[g],c);let k=te/4,wr=pe/4,br=re/4,gr=me/4;for(let g=0;g<p;g++)s.HEAPU32[k++]=y[g],s.HEAPU32[wr++]=u[e[g]];for(let g=0;g<h;g++)s.HEAPU32[br++]=b[g],s.HEAPU32[gr++]=d[o[g]];let ot;ot=await s._OrtRun(a,pe,te,p,me,h,re,E),ot!==0&&S("failed to call OrtRun().");let X=[];for(let g=0;g<h;g++){let K=s.HEAPU32[re/4+g];if(K===b[g]){X.push(r[g]);continue}let st=s.stackSave(),N=s.stackAlloc(4*4),ne=!1,L,D=0;try{s._OrtGetTensorData(K,N,N+4,N+8,N+12)!==0&&S(`Can't access output tensor data on index ${g}.`);let he=N/4,ye=s.HEAPU32[he++];D=s.HEAPU32[he++];let it=s.HEAPU32[he++],Er=s.HEAPU32[he++],W=[];for(let B=0;B<Er;B++)W.push(s.HEAPU32[it/4+B]);s._OrtFree(it);let $=W.reduce((B,C)=>B*C,1);L=er(ye);let we=l?.outputPreferredLocations[o[g]];if(L==="string"){if(we==="gpu-buffer"||we==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let B=[],C=D/4;for(let F=0;F<$;F++){let at=s.HEAPU32[C++],Tr=F===$-1?void 0:s.HEAPU32[C]-at;B.push(s.UTF8ToString(at,Tr))}X.push([L,W,B,"cpu"])}else if(we==="gpu-buffer"&&$>0){let B=s.jsepGetBuffer;if(!B)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let C=B(D),F=ce(ye,$);if(F===void 0||!_e(L))throw new Error(`Unsupported data type: ${L}`);ne=!0,X.push([L,W,{gpuBuffer:C,download:s.jsepCreateDownloader(C,F,L),dispose:()=>{s._OrtReleaseTensor(K)}},"gpu-buffer"])}else if(we==="ml-tensor"&&$>0){let B=s.jsepEnsureTensor;if(!B)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(ce(ye,$)===void 0||!ke(L))throw new Error(`Unsupported data type: ${L}`);let F=await B(D,ye,W,!1);ne=!0,X.push([L,W,{mlTensor:F,download:s.jsepCreateMLTensorDownloader(D,L),dispose:()=>{s.jsepReleaseTensorId(D),s._OrtReleaseTensor(K)}},"ml-tensor"])}else{let B=tr(L),C=new B($);new Uint8Array(C.buffer,C.byteOffset,C.byteLength).set(s.HEAPU8.subarray(D,D+C.byteLength)),X.push([L,W,C,"cpu"])}}finally{s.stackRestore(st),L==="string"&&D&&s._free(D),ne||s._OrtReleaseTensor(K)}}return l&&!c&&(s._OrtClearBoundOutputs(l.handle),Q.set(t,[a,u,d,l,c,!1])),X}finally{s.stackRestore(M),y.forEach(k=>s._OrtReleaseTensor(k)),b.forEach(k=>s._OrtReleaseTensor(k)),A.forEach(k=>s._free(k)),E!==0&&s._OrtReleaseRunOptions(E),O.forEach(k=>s._free(k))}},Me=t=>{let e=v(),n=Q.get(t);if(!n)throw new Error("invalid session id");let o=n[0],r=e._OrtEndProfiling(o);r===0&&S("Can't get an profile file name."),e._OrtFree(r)},Ue=t=>{let e=[];for(let n of t){let o=n[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var J,_,de,Ne,We,Fe,tt,rt,Z,ee,Hr,sr,ir,ar,ur,fr,cr,lr,nt=w(()=>{"use strict";V();Xe();Y();ie();J=()=>!!T.wasm.proxy&&typeof document<"u",de=!1,Ne=!1,We=!1,rt=new Map,Z=(t,e)=>{let n=rt.get(t);n?n.push(e):rt.set(t,[e])},ee=()=>{if(de||!Ne||We||!_)throw new Error("worker not ready")},Hr=t=>{switch(t.data.type){case"init-wasm":de=!1,t.data.err?(We=!0,tt[1](t.data.err)):(Ne=!0,tt[0]()),Fe&&(URL.revokeObjectURL(Fe),Fe=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=rt.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},sr=async()=>{if(!Ne){if(de)throw new Error("multiple calls to 'initWasm()' detected.");if(We)throw new Error("previous call to 'initWasm()' failed.");if(de=!0,J())return new Promise((t,e)=>{_?.terminate(),Yt().then(([n,o])=>{try{_=o,_.onerror=i=>e(i),_.onmessage=Hr,tt=[t,e];let r={type:"init-wasm",in:T};_.postMessage(r),Fe=n}catch(r){e(r)}},e)});try{await xe(T.wasm),await Pe(T),Ne=!0}catch(t){throw We=!0,t}finally{de=!1}}},ir=async t=>{if(J())return ee(),new Promise((e,n)=>{Z("init-ep",[e,n]);let o={type:"init-ep",in:{epName:t,env:T}};_.postMessage(o)});await Ie(T,t)},ar=async t=>J()?(ee(),new Promise((e,n)=>{Z("copy-from",[e,n]);let o={type:"copy-from",in:{buffer:t}};_.postMessage(o,[t.buffer])})):ae(t),ur=async(t,e)=>{if(J()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ee(),new Promise((n,o)=>{Z("create",[n,o]);let r={type:"create",in:{model:t,options:{...e}}},i=[];t instanceof Uint8Array&&i.push(t.buffer),_.postMessage(r,i)})}else return Le(t,e)},fr=async t=>{if(J())return ee(),new Promise((e,n)=>{Z("release",[e,n]);let o={type:"release",in:t};_.postMessage(o)});Be(t)},cr=async(t,e,n,o,r,i)=>{if(J()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return ee(),new Promise((s,f)=>{Z("run",[s,f]);let a=n,u={type:"run",in:{sessionId:t,inputIndices:e,inputs:a,outputIndices:o,options:i}};_.postMessage(u,Ue(a))})}else return Ce(t,e,n,o,r,i)},lr=async t=>{if(J())return ee(),new Promise((e,n)=>{Z("end-profiling",[e,n]);let o={type:"end-profiling",in:t};_.postMessage(o)});Me(t)}});var dr,jr,$e,pr=w(()=>{"use strict";V();nt();Ze();ve();et();dr=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},jr=t=>{switch(t[3]){case"cpu":return new I(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!_e(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:r}=t[2];return I.fromGpuBuffer(n,{dataType:e,dims:t[1],download:o,dispose:r})}case"ml-tensor":{let e=t[0];if(!ke(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:n,download:o,dispose:r}=t[2];return I.fromMLTensor(n,{dataType:e,dims:t[1],download:o,dispose:r})}default:throw new Error(`invalid data location: ${t[3]}`)}},$e=class{async fetchModelAndCopyToWasmMemory(e){return ar(await le(e))}async loadModel(e,n){H();let o;typeof e=="string"?!1?o=await le(e):o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames]=await ur(o,n),j()}async dispose(){return fr(this.sessionId)}async run(e,n,o){H();let r=[],i=[];Object.entries(e).forEach(c=>{let m=c[0],p=c[1],h=this.inputNames.indexOf(m);if(h===-1)throw new Error(`invalid input '${m}'`);r.push(p),i.push(h)});let s=[],f=[];Object.entries(n).forEach(c=>{let m=c[0],p=c[1],h=this.outputNames.indexOf(m);if(h===-1)throw new Error(`invalid output '${m}'`);s.push(p),f.push(h)});let a=r.map((c,m)=>dr(c,()=>`input "${this.inputNames[i[m]]}"`)),u=s.map((c,m)=>c?dr(c,()=>`output "${this.outputNames[f[m]]}"`):null),d=await cr(this.sessionId,i,a,f,u,o),l={};for(let c=0;c<d.length;c++)l[this.outputNames[f[c]]]=s[c]??jr(d[c]);return j(),l}startProfiling(){}endProfiling(){lr(this.sessionId)}}});var hr={};je(hr,{OnnxruntimeWebAssemblyBackend:()=>ze,initializeFlags:()=>mr,wasmBackend:()=>Vr});var mr,ze,Vr,yr=w(()=>{"use strict";V();nt();pr();ie();mr=()=>{if((typeof T.wasm.initTimeout!="number"||T.wasm.initTimeout<0)&&(T.wasm.initTimeout=0),T.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof T.wasm.proxy!="boolean"&&(T.wasm.proxy=!1),typeof T.wasm.trace!="boolean"&&(T.wasm.trace=!1),typeof T.wasm.numThreads!="number"||!Number.isInteger(T.wasm.numThreads)||T.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)T.wasm.numThreads=1;else{let t=typeof navigator>"u"?He("node:os").cpus().length:navigator.hardwareConcurrency;T.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}T.wasm.wasmPaths===void 0&&R&&R.indexOf("blob:")!==0&&(T.wasm.wasmPaths=R.substring(0,R.lastIndexOf("/")+1))},ze=class{async init(e){mr(),await sr(),await ir(e)}async createInferenceSessionHandler(e,n){let o=new $e;return await o.loadModel(e,n),Promise.resolve(o)}},Vr=new ze});V();V();V();var Nt="1.20.0";var Do=Je;{let t=(yr(),ut(hr)).wasmBackend;oe("cpu",t,10),oe("wasm",t,10)}Object.defineProperty(T.versions,"web",{value:Nt,enumerable:!0});export{Pr as InferenceSession,Lt as TRACE,H as TRACE_FUNC_BEGIN,j as TRACE_FUNC_END,I as Tensor,Lr as TrainingSession,Do as default,T as env,oe as registerBackend};
//# sourceMappingURL=ort.wasm.min.mjs.map
